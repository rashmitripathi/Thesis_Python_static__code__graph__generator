digraph tree {
    "tensorflow";
    "/setup.py";
    "Import:setup,";
    "Import:setuptools.command.build_ext";
    "Import:setuptools.command.install";
    "Import:setuptools.command.develop";
    "Import:setuptools.command.build_py";
    "Import:distutils.unixccompiler";
    "Import:distutils.command.build";
    "Import:distutils.command.clean";
    "Import:platform";
    "Import:subprocess";
    "Import:shutil";
    "Import:multiprocessing";
    "Import:sys";
    "Import:import";
    "Import:json";
    "Import:glob";
    "Import:importlib";
    "Import:check_env_flag";
    "Import:WITH_CUDA,";
    "Import:(WITH_CUDNN,";
    "Import:WITH_NCCL,";
    "Import:WITH_NNPACK";
    "Import:NVTOOLEXT_HOME";
    "Import:generate_code";
    "Import:NinjaBuilder,";
    "Import:WITH_DISTRIBUTED,";
    "Import:ninja";
    "Fxn:parallelCCompile";
    "Import:multiprocessing.pool";
    "Fxn:_single_compile";
    "Fxn:patched_link";
    "Import:distutils.sysconfig";
    "Fxn:build_libs";
    "Fxn:check_pydep";
    "class:build_deps(Command):";
    "Fxn:initialize_options";
    "Fxn:finalize_options";
    "Fxn:run";
    "Fxn:check_file";
    "Fxn:os.path.exists(f):";
    "Fxn:{}".format(f))";
    "Fxn:sys.exit(1)";
    "Fxn:check_file(os.path.join(lib_path,";
    "Fxn:check_file(os.path.join(lib_path,";
    "Fxn:check_file(os.path.join(lib_path,";
    "Fxn:check_file(os.path.join('aten',";
    "Fxn:check_file(os.path.join('aten',";
    "Fxn:check_pydep('yaml',";
    "Fxn:check_pydep('typing',";
    "Fxn:sys.platform.startswith('linux'):";
    "Fxn:build_libs(libs)";
    "class:build_dep(build_deps):";
    "Fxn:run";
    "Fxn:build_libs([self.lib])";
    "Fxn:lib.lower()]";
    "class:build_module(Command):";
    "Fxn:initialize_options";
    "Fxn:finalize_options";
    "Fxn:run";
    "Fxn:self.run_command('build_py')";
    "Fxn:self.run_command('build_ext')";
    "class:build_py(setuptools.command.build_py.build_py):";
    "Fxn:run";
    "Fxn:self.create_version_file()";
    "Fxn:setuptools.command.build_py.build_py.run(self)";
    "Fxn:create_version_file";
    "Fxn:os.path.join(cwd,";
    "Fxn:f.write("__version__";
    "Fxn:'{}'\n".format(version))";
    "Fxn:f.write("debug";
    "Fxn:{}\n".format(repr(DEBUG)))";
    "Fxn:f.write("cuda";
    "Fxn:{}\n".format(repr(CUDA_VERSION)))";
    "class:develop(setuptools.command.develop.develop):";
    "Fxn:run";
    "Fxn:build_py.create_version_file()";
    "Fxn:setuptools.command.develop.develop.run(self)";
    "Fxn:self.create_compile_commands()";
    "Fxn:create_compile_commands";
    "Fxn:load";
    "Fxn:json.load(f)";
    "Fxn:glob.glob('build/*_compile_commands.json')";
    "Fxn:glob.glob('torch/lib/build/*/compile_commands.json')";
    "Fxn:load(f)]";
    "Fxn:json.dump(all_commands,";
    "Fxn:monkey_patch_THD_link_flags";
    "Fxn:f.read()";
    "Fxn:thd_deps_.split(';'):";
    "Fxn:thd_deps.append(l)";
    "class:build_ext(build_ext_parent):";
    "Fxn:run";
    "Fxn:monkey_patch_THD_link_flags()";
    "Fxn:generate_code(ninja_global)";
    "Fxn:ninja_global.run()";
    "class:build(distutils.command.build.build):";
    "class:install(setuptools.command.install.install):";
    "Fxn:run";
    "Fxn:self.run_command('build_deps')";
    "Fxn:self.copy_tree('torch/csrc',";
    "Fxn:self.copy_tree('torch/lib/pybind11/include/pybind11/',";
    "Fxn:self.copy_file('torch/torch.h',";
    "Fxn:setuptools.command.install.install.run(self)";
    "class:clean(distutils.command.clean.clean):";
    "Fxn:run";
    "Fxn:f.read()";
    "Fxn:ignores.split('\n')):";
    "Fxn:glob.glob(wildcard):";
    "Fxn:os.remove(filename)";
    "Fxn:shutil.rmtree(filename,";
    "Fxn:make_relative_rpath";
    "Fxn:find_packages(exclude=('tools',";
    "Fxn:Extension("torch._C",";
    "Fxn:[make_relative_rpath('lib')],";
    "Fxn:extensions.append(C)";
    "Fxn:Extension("torch._dl",";
    "Fxn:extensions.append(DL)";
    "Fxn:[make_relative_rpath('lib')]";
    "Fxn:Extension("torch._nvrtc",";
    "Fxn:extensions.append(THNVRTC)";
    "Fxn:os.getenv('PYTORCH_BUILD_VERSION'):";
    "Fxn:os.getenv('PYTORCH_BUILD_NUMBER')";
    "Fxn:os.getenv('PYTORCH_BUILD_VERSION')";
    "Fxn:subprocess.check_output(['git',";
    "Fxn:cwd=cwd).decode('ascii').strip()";
    "Fxn:cmdclass.update(build_dep_cmds)";
    "Fxn:setup(";
    "Fxn:description=("Tensors";
    "Import:glob";
    "Import:numpy";
    "/.jenkins/perf_test/compare_with_baseline.py";
    "Import:sys";
    "Import:json";
    "Import:numpy";
    "Import:argparse";
    "/.jenkins/perf_test/get_stats.py";
    "Import:sys";
    "Import:json";
    "Import:numpy";
    "/.jenkins/perf_test/update_commit_hash.py";
    "Import:sys";
    "Import:json";
    "/aten/src/ATen/code_template.py";
    "Import:match";
    "class:CodeTemplate(object):";
    "Fxn:from_file";
    "Fxn:CodeTemplate(f.read())";
    "Fxn:__init__";
    "Fxn:substitute";
    "Fxn:lookup";
    "Fxn:indent_lines";
    "Fxn:"".join([indent";
    "Fxn:replace";
    "Fxn:match.group(1)";
    "Fxn:match.group(2)";
    "Fxn:lookup(key)";
    "Fxn:indent_lines(indent,";
    "Fxn:'.join([str(x)";
    "Fxn:self.subtitution.sub(replace,";
    "Fxn:CodeTemplate("""\";
    "Fxn:foo($args)";
    "Fxn:commatest(int";
    "Fxn:notest(int";
    "/aten/src/ATen/common_with_cwrap.py";
    "Import:deepcopy";
    "Import:product";
    "Fxn:parse_arguments";
    "Fxn:set_declaration_defaults";
    "Fxn:filter_unique_options";
    "Fxn:exclude_arg";
    "Fxn:exclude_arg_with_self_check";
    "Fxn:signature";
    "Fxn:enumerate_options_due_to_default";
    "Fxn:is_nullable_tensor_arg";
    "Fxn:sort_by_number_of_options";
    "Fxn:num_checked_args";
    "class:Function(object):";
    "Fxn:__init__";
    "Fxn:add_argument";
    "Fxn:self.arguments.append(arg)";
    "Fxn:__repr__";
    "Fxn:'('";
    "Fxn:'.join(map(lambda";
    "Fxn:a.__repr__(),";
    "class:Argument(object):";
    "Fxn:__init__";
    "Fxn:__repr__";
    "Fxn:parse_header";
    "Fxn:f.read().split('\n')";
    "Fxn:l.startswith('#'),";
    "Fxn:l.partition('//'),";
    "Fxn:l[2].strip()),";
    "Fxn:new_lines.append((split,";
    "Fxn:l.startswith('TH_API";
    "Fxn:l.lstrip('TH_API";
    "Fxn:'('";
    "Fxn:generic_functions.append(Function(fn_name))";
    "Fxn:l.split()";
    "Fxn:generic_functions[-1].add_argument(";
    "Fxn:Argument(t,";
    "/aten/src/ATen/copy_wrapper.py";
    "Import:CodeTemplate";
    "Import:nested_dict";
    "Fxn:create_one";
    "Fxn:create";
    "/aten/src/ATen/cwrap_parser.py";
    "Import:yaml";
    "Fxn:parse";
    "/aten/src/ATen/extract_cwrap.py";
    "Import:OptionParser";
    "/aten/src/ATen/function_wrapper.py";
    "Import:code_template";
    "Import:CodeTemplate";
    "Import:typing";
    "Import:`typing`";
    "Import:Union,";
    "Import:Any,";
    "Import:TypedDict";
    "Fxn:TypedDict";
    "Import:sys";
    "class:NYIError(Exception):";
    "Fxn:__init__";
    "Fxn:CodeTemplate(";
    "Fxn:'checked_cast_tensor<${Tensor}>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:CodeTemplate(";
    "Fxn:'checked_cast_tensor<Sparse${Tensor}>(${arg_name}.tref.pImpl,"${arg_name}",${arg_pos},false)'),";
    "Fxn:CodeTemplate(";
    "Fxn:'checked_cast_tensor<${Backend}ByteTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:CodeTemplate(";
    "Fxn:'checked_cast_tensor<${Backend}LongTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:CodeTemplate(";
    "Fxn:'checked_cast_tensor<${Backend}IntTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:CodeTemplate(";
    "Fxn:'checked_cast_tensor<${DenseTensor}>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:CodeTemplate(";
    "Fxn:'checked_cast_tensor<${DenseBackend}LongTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:CodeTemplate('checked_cast_storage<${Storage}>(&${arg_name},"${arg_name}",${arg_pos})'),";
    "Fxn:CodeTemplate(";
    "Fxn:'check_generator<${Backend}Generator>(${arg_name},";
    "Fxn:&context->defaultGenerator(backend()))'),";
    "Fxn:CodeTemplate('THLongStorageView::makeFromSize(${arg_name})'),";
    "Fxn:CodeTemplate('THLongStorageView::makeFromStride(${arg_name},";
    "Fxn:CodeTemplate('${arg_name}.to${ScalarName}()'),";
    "Fxn:CodeTemplate('${arg_name}.to${AccScalarName}()'),";
    "Fxn:CodeTemplate('tensor_list_checked_cast<${Tensor},";
    "Fxn:'${THTensor}>(${arg_name},"${arg_name}",${arg_pos})'),";
    "Fxn:CodeTemplate('check_intlist<${size}>(${arg_name},";
    "Fxn:"{0}_.data(),";
    "Fxn:{0}_.size()",";
    "Fxn:CodeTemplate('${arg_name}_";
    "Fxn:${Tensor}(context${,arguments})',";
    "Fxn:${Backend}ByteTensor(context${,arguments})',";
    "Fxn:${Backend}LongTensor(context${,arguments})',";
    "Fxn:${Backend}IntTensor(context${,arguments})',";
    "Fxn:Sparse${Tensor}(context${,arguments})',";
    "Fxn:${DenseTensor}(context${,arguments})',";
    "Fxn:${DenseBackend}LongTensor(context${,arguments})',";
    "Fxn:'THLongStorageView::makeFromLength(static_cast<int64_t>(storage.size()))'),";
    "Fxn:'self.ndimension()-1'),";
    "class:nested_dict(object):";
    "Fxn:__init__";
    "Fxn:__getitem__";
    "Fxn:self.base.get(x)";
    "Fxn:TypedDict('Environment',";
    "Fxn:TypedDict('TopEnvironment',";
    "Fxn:TypedDict('THFormal',";
    "Fxn:TypedDict('AtFormal',";
    "Fxn:TypedDict('ReturnType',";
    "Fxn:TypedDict('ReturnDecl',";
    "Fxn:TypedDict('NNBuffer',";
    "Fxn:TypedDict('FunctionOption',";
    "Fxn:NamedTuple('OutputDeclaration',";
    "Fxn:is_real_argument_to_wrapper";
    "Fxn:argument.get('output',";
    "Fxn:is_mutable_formal_argument";
    "Fxn:argument.get('output')";
    "Fxn:to_return_type";
    "Fxn:TYPE_RETURN.get(t,";
    "Fxn:arg.get('allocate'):";
    "Fxn:is_mutable_formal_argument(arg,";
    "Fxn:DYNAMIC_TYPE.get(arg['type'],";
    "Fxn:create_generic";
    "Fxn:translate_default";
    "Fxn:re.sub(pattern,";
    "Fxn:default.lower()";
    "Fxn:default.lower()";
    "Fxn:translate_formal";
    "Fxn:TYPE_FORMAL_GENERIC.get(argument['type'],";
    "Fxn:is_mutable_formal_argument(argument,";
    "Fxn:DYNAMIC_TYPE.get(argument['type'],";
    "Fxn:translate_default(argument,";
    "Fxn:argument.get('default_init',";
    "Fxn:translate_default(argument,";
    "Fxn:argument.get('output'):";
    "Fxn:argument.get('size'):";
    "Fxn:argument.get('is_nullable')";
    "Fxn:get_formals";
    "Fxn:insert";
    "Fxn:seen.add(argument['name'])";
    "Fxn:argument.get('kwarg_only',";
    "Fxn:kwd_args.append(argument)";
    "Fxn:pos_args.append(argument)";
    "Fxn:has_output_mask";
    "Fxn:argument.get('allocate',";
    "Fxn:argument.get('mask',";
    "Fxn:argument.get('output')";
    "Fxn:argument.get('allocate',";
    "Fxn:insert(argument)";
    "Fxn:NYIError("Sparse";
    "Fxn:insert(argument)";
    "Fxn:is_real_argument_to_wrapper(argument):";
    "Fxn:insert(argument)";
    "Fxn:insert({";
    "Fxn:'std::array<bool,{}>'.format(mask_size),";
    "Fxn:'.join(['true']";
    "Fxn:[translate_formal(argument,";
    "Fxn:get_return_types";
    "Fxn:[to_return_type(the_arg,";
    "Fxn:[to_return_type(option['arguments'][idx],";
    "Fxn:TYPE_RETURN.get(ret['type'],";
    "Fxn:DYNAMIC_TYPE.get(ret['type'],";
    "Fxn:Exception("format_return_type")";
    "Fxn:format_return_type";
    "Fxn:"std::tuple<{}>".format(','.join(r['type']";
    "Fxn:find_dispatch_tensor";
    "Fxn:format_formal";
    "Fxn:{}'.format(f['type'],";
    "Fxn:formal_with_default";
    "Fxn:format_formal(f)";
    "Fxn:f.get('default')";
    "Fxn:'{}={}'.format(s,";
    "Fxn:get_broadcast_argument";
    "Fxn:argument.get('broadcast'):";
    "Fxn:get_broadcast_actuals";
    "Fxn:{mat1.size(0),mat2.size(1)}"";
    "Fxn:broadcast_arg['broadcast'].split()[0].split(",")";
    "Fxn:broadcast_arg['broadcast'].split()[1].split(':')[1].split(',')";
    "Fxn:'.size('";
    "Fxn:x.split('.')[1].replace('dim',";
    "Fxn:','.join(broadcast_dims)";
    "Fxn:emit_nn_body";
    "Fxn:option['api_name'].replace(base_name,";
    "Fxn:{}({});'.format(fwd_name,";
    "Fxn:'.join(actuals))";
    "Fxn:option['api_name'].endswith('_out'):";
    "Fxn:body.append('Tensor";
    "Fxn:tensor();'.format(buffer['name']))";
    "Fxn:arg.get('output')]";
    "Fxn:arg.get('output')]";
    "Fxn:body.append('return";
    "Fxn:std::get<0>({}({}));'.format(fwd_name,";
    "Fxn:'.join(actuals)))";
    "Fxn:process_option";
    "Fxn:re.search(";
    "Fxn:'(^__i|[^_]_$)',";
    "Fxn:get_formals(option)";
    "Fxn:[format_formal(f)";
    "Fxn:[formal_with_default(f)";
    "Fxn:get_return_types(option)";
    "Fxn:format_return_type(option['returns'])";
    "Fxn:[format_formal(f)";
    "Fxn:[formal_with_default(f)";
    "Fxn:find_dispatch_tensor(formals)";
    "Fxn:get_broadcast_argument(option)";
    "Fxn:nested_dict(option,";
    "Fxn:option.get('cimpls')";
    "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:TYPE_METHOD_DECLARATION_CONCRETE.substitute(env))";
    "Fxn:emit_nn_body(option)";
    "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:TYPE_METHOD_DEFINITION_CONCRETE.substitute(";
    "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:TYPE_METHOD_DECLARATION_ABSTRACT.substitute(env))";
    "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:TYPE_METHOD_DEFINITION_ABSTRACT.substitute(env))";
    "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:TYPE_METHOD_DECLARATION_BROADCAST.substitute(env))";
    "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:TYPE_METHOD_DECLARATION_ABSTRACT.substitute(env))";
    "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:TYPE_METHOD_DEFINITION_ABSTRACT.substitute(env))";
    "Fxn:get_broadcast_actuals(broadcast_arg,";
    "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:TYPE_METHOD_DEFINITION_BROADCAST.substitute(env))";
    "Fxn:top_env['tensor_method_declarations'].append(";
    "Fxn:TENSOR_METHOD_DECLARATION.substitute(env))";
    "Fxn:top_env['tensor_method_definitions'].append(";
    "Fxn:TENSOR_METHOD_DEFINITION.substitute(env))";
    "Fxn:method_of.append('Tensor')";
    "Fxn:'infer_type({})'.format(dispatch_tensor)";
    "Fxn:top_env['function_declarations'].append(";
    "Fxn:FUNCTION_DECLARATION.substitute(env))";
    "Fxn:top_env['function_definitions'].append(";
    "Fxn:FUNCTION_DEFINITION.substitute(env))";
    "Fxn:method_of.append('namespace')";
    "Fxn:option.get('buffers',";
    "Fxn:output_options.append(OutputDeclaration(";
    "Fxn:native_get_formals";
    "Fxn:insert";
    "Fxn:seen.add(argument['name'])";
    "Fxn:argument.get('kwarg_only',";
    "Fxn:kwd_args.append(argument)";
    "Fxn:pos_args.append(argument)";
    "Fxn:insert(argument)";
    "Fxn:add_type_as_dynamic_type";
    "Fxn:[add_type_as_dynamic_type(argument,";
    "Fxn:native_translate_formals";
    "Fxn:translate_map";
    "Fxn:argument.get('output',";
    "Fxn:translate_map(False).get(argument['type'],";
    "Fxn:translate_map(True).get(argument['type'],";
    "Fxn:[native_translate_formals(argument,";
    "Fxn:native_get_return_types";
    "Fxn:'std::vector<Tensor>'}.get(t,";
    "Fxn:option['api_name'].endswith('_out')):";
    "Fxn:return_types.append(rtype)";
    "Fxn:process_native";
    "Fxn:re.search(";
    "Fxn:'(^__i|[^_]_$)',";
    "Fxn:native_get_formals(option)";
    "Fxn:[format_formal(f)";
    "Fxn:[formal_with_default(f)";
    "Fxn:native_get_return_types(option)";
    "Fxn:format_return_type(option['returns'])";
    "Fxn:[format_formal(f)";
    "Fxn:[formal_with_default(f)";
    "Fxn:find_dispatch_type";
    "Fxn:find_dispatch_tensor(formals)";
    "Fxn:find_dispatch_type(formals)";
    "Fxn:[format_formal(f)";
    "Fxn:[formal_with_default(f)";
    "Fxn:nested_dict(option,";
    "Fxn:get_broadcast_argument(option)";
    "Fxn:Exception("broadcasting";
    "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:TYPE_METHOD_DECLARATION_CONCRETE.substitute(env))";
    "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:TYPE_METHOD_DEFINITION_ABSTRACT.substitute(env))";
    "Fxn:TYPE_DEFINITION_BODY_NATIVE.substitute(env)";
    "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:TYPE_METHOD_DEFINITION_CONCRETE.substitute(";
    "Fxn:top_env['native_function_declarations'].append(";
    "Fxn:NATIVE_DECLARATION.substitute(env))";
    "Fxn:generated_native_functions.append(value)";
    "Fxn:top_env['native_function_declarations'].append(";
    "Fxn:NATIVE_DECLARATION.substitute(env))";
    "Fxn:top_env['tensor_method_declarations'].append(";
    "Fxn:TENSOR_METHOD_DECLARATION.substitute(env))";
    "Fxn:top_env['tensor_method_definitions'].append(";
    "Fxn:TENSOR_METHOD_DEFINITION.substitute(env))";
    "Fxn:method_of.append('Tensor')";
    "Fxn:'infer_type({})'.format(dispatch_tensor)";
    "Fxn:top_env['function_declarations'].append(";
    "Fxn:FUNCTION_DECLARATION.substitute(env))";
    "Fxn:top_env['function_definitions'].append(";
    "Fxn:FUNCTION_DEFINITION.substitute(env))";
    "Fxn:method_of.append('namespace')";
    "Fxn:output_options.append(OutputDeclaration(";
    "Fxn:process_option(option,";
    "Fxn:process_native(option,";
    "Fxn:output_declarations.extend(output_options)";
    "Fxn:create_derived";
    "Fxn:replace_with_null";
    "Fxn:requires_checked_cast";
    "Fxn:nullable_argument";
    "Fxn:argument.get('is_nullable',";
    "Fxn:bool_option_is_string";
    "Fxn:get_argument";
    "Fxn:replace_with_null(argument):";
    "Fxn:requires_checked_cast(argument):";
    "Fxn:CHECKED_USE.get(";
    "Fxn:'{}_').format(argument['name'])";
    "Fxn:HALF_CONVERSION.substitute(value=checked_use)";
    "Fxn:nullable_argument(argument):";
    "Fxn:CHECKED_USE_NULLABLE.substitute(";
    "Fxn:bool_option_is_string(argument):";
    "Fxn:'({})";
    "Fxn:'({})";
    "Fxn:tpl.format(argument['name'],";
    "Fxn:bool_option_is_string(argument):";
    "Fxn:'"{}"'.format(argument['name'])";
    "Fxn:re.sub(pattern,";
    "Fxn:CodeTemplate(v).substitute(backend_type_env)";
    "Fxn:get_argument(option['arguments'][index],";
    "Fxn:drop_argument";
    "Fxn:get_arguments";
    "Fxn:[get_argument(argument,";
    "Fxn:drop_argument(argument,";
    "Fxn:is_actual_return_long";
    "Fxn:get_zero_dim_dispatch_when_scalar";
    "Fxn:option.get('zero_dim_dispatch_when_scalar',";
    "Fxn:handle_zero_dim";
    "Fxn:get_zero_dim_dispatch_when_scalar(option)";
    "Fxn:"Scalar({})".format(arg['name'])";
    "Fxn:[ZERO_DIM_CHECK.substitute(env,";
    "Fxn:handle_only_zero_dim";
    "Fxn:option.get('zero_dim_tensor_only',";
    "Fxn:get_zero_dim_dispatch_when_scalar(option)";
    "Fxn:[ZERO_DIM_ONLY.substitute(env,";
    "Fxn:handle_sparse";
    "Fxn:"SparseTensor({})".format(arg['name'])";
    "Fxn:[SPARSE_CHECK.substitute(env,";
    "Fxn:allocate_arg";
    "Fxn:CodeTemplate(ALLOC_WRAP[arg['type']]).substitute(env,";
    "Fxn:'{}_'.format(name)";
    "Fxn:arg.get('mask',";
    "Fxn:nullptr'.format(output_count,";
    "Fxn:.format(name,";
    "Fxn:{};'.format(name,";
    "Fxn:Tensor({},";
    "Fxn:false);'.format(name,";
    "Fxn:resize_arg";
    "Fxn:"{}.resize_({}.sizes());".format(arg['name'],";
    "Fxn:arg.get('resize_scalar',";
    "Fxn:['{}.dim()";
    "Fxn:{}.size({})'.format(name,";
    "Fxn:['{}.size({})'.format(name,";
    "Fxn:"{}.resize_({{";
    "Fxn:}});".format(arg['name'],";
    "Fxn:','.join(dims))";
    "Fxn:handle_call";
    "Fxn:get_arguments(cimpl['arguments'],";
    "Fxn:option.get('sparse',";
    "Fxn:env['THTensor'].replace('TH',";
    "Fxn:'THNN_{}'.format(env['THType'])";
    "Fxn:CALL_TEMPLATE.substitute(actuals=actuals,";
    "Fxn:cimpl.get('condition')";
    "Fxn:{}'.format(cimpl['condition'],";
    "Fxn:emit_body";
    "Fxn:handle_sparse(env,";
    "Fxn:handle_zero_dim(env,";
    "Fxn:handle_only_zero_dim(env,";
    "Fxn:option.get('scalar_check')";
    "Fxn:is_real_argument_to_wrapper(arg):";
    "Fxn:'{}.size()";
    "Fxn:0'.format(arg['name'])";
    "Fxn:seen_tensorlists.add(arg['name'])";
    "Fxn:arg.get('wrap_dim',";
    "Fxn:body.append("{}";
    "Fxn:maybe_wrap_dim({},";
    "Fxn:.format(arg['name'],";
    "Fxn:requires_checked_cast(arg):";
    "Fxn:seen_names.add(arg['name'])";
    "Fxn:arg.get('allocate',";
    "Fxn:allocate_arg(env,";
    "Fxn:nullable_argument(arg)";
    "Fxn:default_init.append(arg['default_init'])";
    "Fxn:'is_noelem_tensor_size(size)'";
    "Fxn:CHECKED_CAST[arg['type']].substitute(";
    "Fxn:size=arg.get('size'),";
    "Fxn:body.append("auto";
    "Fxn:{};".format(";
    "Fxn:drop_argument(arg,";
    "Fxn:replace_with_null(arg):";
    "Fxn:body.append(";
    "Fxn:"(void)";
    "Fxn:warning".format(arg['name']))";
    "Fxn:initializers.append(resize_arg(arg))";
    "Fxn:arg.get('zero',";
    "Fxn:initializers.append("{}.zero_();".format(arg['name']))";
    "Fxn:nullable_argument(arg)";
    "Fxn:body.append(CONDITIONAL_INITIALIZER.substitute({";
    "Fxn:isScalar()";
    "Fxn:isScalar()";
    "Fxn:arg.get('output')";
    "Fxn:'{}->isScalar()'.format(arg['name']";
    "Fxn:nullable_argument(arg):";
    "Fxn:'(!{}";
    "Fxn:{})'.format(arg['name']";
    "Fxn:option.get('cimpls',";
    "Fxn:[handle_call(env,";
    "Fxn:body.append(CodeTemplate(";
    "Fxn:option['aten_custom_call']).substitute(env))";
    "Fxn:body.extend([call";
    "Fxn:body.append("bool";
    "Fxn:{};".format(scalar_check))";
    "Fxn:scalar_check.get(arg['name']))";
    "Fxn:"{}_->maybeScalar({});".format(arg['name'],";
    "Fxn:nullable_argument(arg):";
    "Fxn:{}".format(arg['name'],";
    "Fxn:body.append(stmt)";
    "Fxn:body.append("return";
    "Fxn:{};".format(arg['name']))";
    "Fxn:[to_return_type(arg,";
    "Fxn:body.append(CodeTemplate("return";
    "Fxn:std::tuple<${types}>(${names});").substitute(";
    "Fxn:body.append(CodeTemplate(";
    "Fxn:option['aten_custom_call']).substitute(env))";
    "Fxn:ALLOC_WRAP.keys():";
    "Fxn:"->maybeScalar({})".format(scalar_check)";
    "Fxn:CodeTemplate(ALLOC_WRAP[ret['type']]).substitute(";
    "Fxn:Tensor((${wrapped_tensor})${maybe_scalar},false);"";
    "Fxn:body.append(CodeTemplate(return_tensor).substitute(";
    "Fxn:x.sum(0)";
    "Fxn:x.sum()";
    "Fxn:scalarTensor(convert<${ScalarType}>(${call}));'";
    "Fxn:body.append(CodeTemplate(return_scalar).substitute(env,";
    "Fxn:is_actual_return_long(ret):";
    "Fxn:"static_cast<int64_t>({})".format(call)";
    "Fxn:body.append("return";
    "Fxn:{};".format(call))";
    "Fxn:Exception("NYI";
    "Fxn:process_option";
    "Fxn:nested_dict(option,";
    "Fxn:emit_body(env,";
    "Fxn:type_object_declarations.append(";
    "Fxn:TYPE_DERIVED_DECLARATION.substitute(env))";
    "Fxn:type_object_definitions.append(";
    "Fxn:TYPE_DERIVED_DEFINITION.substitute(env))";
    "Fxn:process_native";
    "Fxn:nested_dict(option,";
    "Fxn:dispatch.get(pair[0])";
    "Fxn:Exception('could";
    "Fxn:.format(pair[0],";
    "Fxn:type_object_declarations.append(";
    "Fxn:TYPE_DERIVED_DECLARATION.substitute(env))";
    "Fxn:type_object_definitions.append(";
    "Fxn:TYPE_DERIVED_DEFINITION_NATIVE.substitute(env))";
    "Fxn:option.get('skip',";
    "Fxn:option.get('cimpls')";
    "Fxn:process_option(option)";
    "Fxn:process_native(option)";
    "/aten/src/ATen/gen.py";
    "Import:argparse";
    "Import:import";
    "Import:yaml";
    "Import:OrderedDict";
    "Import:cwrap_parser";
    "Import:nn_parse";
    "Import:native_parse";
    "Import:preprocess_declarations";
    "Import:function_wrapper";
    "Import:copy_wrapper";
    "Import:CodeTemplate";
    "class:FileManager(object):";
    "Fxn:__init__";
    "Fxn:will_write";
    "Fxn:'{}/{}'.format(options.output_dir,";
    "Fxn:Exception("'will_write'";
    "Fxn:self.filenames.add(filename)";
    "Fxn:_write_if_changed";
    "Fxn:f.read()";
    "Fxn:f.write(contents)";
    "Fxn:write_outputs";
    "Fxn:self._write_if_changed(";
    "Fxn:''.join(name";
    "Fxn:write";
    "Fxn:'{}/{}'.format(options.output_dir,";
    "Fxn:self._write_if_changed(filename,";
    "Fxn:self.undeclared_files.append(filename)";
    "Fxn:self.filenames.remove(filename)";
    "Fxn:check_all_files_written";
    "Fxn:Exception(";
    "Fxn:".format(self.undeclared_files)";
    "Fxn:Exception("Outputs";
    "Fxn:{}".format(self.filenames))";
    "Fxn:CodeTemplate.from_file(";
    "Fxn:CodeTemplate.from_file(";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(";
    "Fxn:CodeTemplate.from_file(";
    "Fxn:CodeTemplate.from_file(";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:FileManager()";
    "Fxn:backends.append('CUDA')";
    "Fxn:dict_representer";
    "Fxn:dumper.represent_dict(data.items())";
    "Fxn:postprocess_output_declarations";
    "Fxn:remove_key_if_none";
    "Fxn:dictionary.keys()";
    "Fxn:[remove_key_if_none(decl._asdict(),";
    "Fxn:format_yaml";
    "Fxn:noalias_dumper.add_representer(OrderedDict,";
    "Fxn:yaml.dump(data,";
    "Fxn:generate_storage_type_and_tensor";
    "Fxn:"{}{}Storage".format(backend,";
    "Fxn:"{}{}{}Type".format(density_tag,";
    "Fxn:"{}{}{}Tensor".format(density_tag,";
    "Fxn:"{}{}Tensor".format(backend,";
    "Fxn:"Sparse{}{}Tensor".format(backend,";
    "Fxn:top_env['type_ids'].append(tag";
    "Fxn:'Cuda{}'.format(sname)";
    "Fxn:'THCuda{}Storage'.format(sname)";
    "Fxn:'THCuda{}Tensor'.format(sname)";
    "Fxn:'THCS{}Tensor'.format(scalar_name)";
    "Fxn:"TH{}Storage".format(scalar_name)";
    "Fxn:'TH{}{}Tensor'.format(th_density_tag,";
    "Fxn:std::runtime_error("CPU";
    "Fxn:function_wrapper.create_derived(";
    "Fxn:file_manager.write(env['Storage']";
    "Fxn:STORAGE_DERIVED_CPP.substitute(env))";
    "Fxn:file_manager.write(env['Storage']";
    "Fxn:STORAGE_DERIVED_H.substitute(env))";
    "Fxn:TENSOR_DENSE_CPP.substitute(env)";
    "Fxn:TENSOR_SPARSE_CPP.substitute(env)";
    "Fxn:file_manager.write(env['Type']";
    "Fxn:TYPE_DERIVED_CPP.substitute(env))";
    "Fxn:file_manager.write(env['Type']";
    "Fxn:TYPE_DERIVED_H.substitute(env))";
    "Fxn:file_manager.write(env['Tensor']";
    "Fxn:TENSOR_DERIVED_CPP.substitute(env))";
    "Fxn:file_manager.write(env['Tensor']";
    "Fxn:TENSOR_DERIVED_H.substitute(env))";
    "Fxn:'[static_cast<int>(ScalarType::{})].reset(new";
    "Fxn:{}(context));')";
    "Fxn:.format(env['Backend'],";
    "Fxn:top_env['type_registrations'].append(type_register)";
    "Fxn:top_env['type_headers'].append(";
    "Fxn:"ATen/{}.h"'.format(env['Type']))";
    "Fxn:iterate_types";
    "Fxn:declare_outputs";
    "Fxn:file_manager.will_write(f)";
    "Fxn:file_manager.will_write(fname)";
    "Fxn:iterate_types():";
    "Fxn:file_manager.will_write("{}{}{}.h".format(full_backend,";
    "Fxn:file_manager.will_write("{}{}{}.cpp".format(full_backend,";
    "Fxn:filter_by_extension";
    "Fxn:file.endswith(extension):";
    "Fxn:filtered_files.append(file)";
    "Fxn:generate_outputs";
    "Fxn:filter_by_extension(options.files,";
    "Fxn:filter_by_extension(options.files,";
    "Fxn:filter_by_extension(options.files,";
    "Fxn:cwrap_parser.parse(file)]";
    "Fxn:nn_parse.run(nn_files)";
    "Fxn:native_parse.run(native_files)";
    "Fxn:preprocess_declarations.run(declarations)";
    "Fxn:generators.items():";
    "Fxn:file_manager.write(fname,";
    "Fxn:GENERATOR_DERIVED.substitute(env))";
    "Fxn:function_wrapper.create_generic(top_env,";
    "Fxn:postprocess_output_declarations(output_declarations)";
    "Fxn:file_manager.write("Declarations.yaml",";
    "Fxn:format_yaml(output_declarations))";
    "Fxn:iterate_types():";
    "Fxn:all_types.append(generate_storage_type_and_tensor(";
    "Fxn:file_manager.write('Type.h',";
    "Fxn:TYPE_H.substitute(top_env))";
    "Fxn:file_manager.write('Type.cpp',";
    "Fxn:TYPE_CPP.substitute(top_env))";
    "Fxn:file_manager.write('Tensor.h',";
    "Fxn:TENSOR_H.substitute(top_env))";
    "Fxn:file_manager.write('TensorMethods.h',";
    "Fxn:TENSOR_METHODS_H.substitute(top_env))";
    "Fxn:file_manager.write('Functions.h',";
    "Fxn:FUNCTIONS_H.substitute(top_env))";
    "Fxn:file_manager.write('Copy.cpp',";
    "Fxn:copy_wrapper.create(all_types))";
    "Fxn:file_manager.write('NativeFunctions.h',";
    "Fxn:NATIVE_FUNCTIONS_H.substitute(top_env))";
    "Fxn:file_manager.check_all_files_written()";
    "Fxn:declare_outputs()";
    "Fxn:file_manager.write_outputs(options.output_dependencies)";
    "Fxn:generate_outputs()";
    "/aten/src/ATen/native_parse.py";
    "Import:import";
    "Import:yaml";
    "Import:CLoader";
    "Import:Loader";
    "Fxn:parse_default";
    "Fxn:sanitize_types";
    "Fxn:parse_arguments";
    "Fxn:has_sparse_dispatches";
    "Fxn:parse_native_yaml";
    "Fxn:run";
    "/aten/src/ATen/nn_parse.py";
    "Import:copy";
    "Import:import";
    "Import:common_with_cwrap";
    "Import:yaml";
    "Import:OrderedDict,";
    "Import:CLoader";
    "Import:Loader";
    "Fxn:argument_to_declaration";
    "Fxn:output_arguments";
    "Fxn:map_to_th_type";
    "Fxn:is_output_arg";
    "Fxn:get_return";
    "Fxn:camel_to_snake";
    "Fxn:get_thnn_args";
    "Fxn:arg_expr";
    "Fxn:remove_unused_args";
    "Fxn:clean_name";
    "Fxn:unique_args";
    "Fxn:function_info";
    "Fxn:base_declaration";
    "Fxn:forward_declaration";
    "Fxn:backward_declaration";
    "Fxn:initialize_output_arg";
    "Fxn:get_condition";
    "Fxn:parse_nn_yaml";
    "Fxn:run";
    "/aten/src/ATen/preprocess_declarations.py";
    "Import:copy";
    "Import:deepcopy";
    "Import:TYPE_FORMAL_GENERIC";
    "Import:common_with_cwrap";
    "Fxn:process_types_and_backends";
    "Fxn:expand";
    "Fxn:exclude";
    "Fxn:add_variants";
    "Fxn:handle_outputs_taken_as_arguments";
    "Fxn:is_nullable";
    "Fxn:should_generate_out_variant";
    "Fxn:sanitize_return";
    "Fxn:set_mode";
    "Fxn:discover_zero_dim_tensor_operations";
    "Fxn:exclude";
    "Fxn:signature";
    "Fxn:discover_sparse_tensor_operations";
    "Fxn:exclude";
    "Fxn:signature";
    "Fxn:run";
    "/docs/source/conf.py";
    "Import:import";
    "Import:sys";
    "Import:torch";
    "Import:torchvision";
    "Import:warnings";
    "Import:sphinx_rtd_theme";
    "Import:nodes";
    "Import:TypedField";
    "Import:addnodes";
    "Fxn:patched_make_field";
    "Fxn:handle_item";
    "/docs/source/scripts/build_activation_images.py";
    "Import:os.path";
    "Import:torch.nn.modules.activation";
    "Import:torch.autograd";
    "Import:matplotlib";
    "Import:pylab";
    "Fxn:plot_function";
    "/test/common.py";
    "Import:sys";
    "Import:import";
    "Import:import";
    "Import:argparse";
    "Import:unittest";
    "Import:warnings";
    "Import:random";
    "Import:contextlib";
    "Import:wraps";
    "Import:product";
    "Import:deepcopy";
    "Import:Number";
    "Import:__main__";
    "Import:errno";
    "Import:torch";
    "Import:torch.cuda";
    "Import:Variable";
    "Import:string_classes";
    "Import:torch.backends.cudnn";
    "Fxn:run_tests";
    "Import:numpy";
    "Import:scipy";
    "Fxn:skipIfNoLapack";
    "Fxn:wrapper";
    "Fxn:suppress_warnings";
    "Fxn:wrapper";
    "Fxn:get_cpu_type";
    "Fxn:get_gpu_type";
    "Fxn:to_gpu";
    "Fxn:set_rng_seed";
    "Fxn:freeze_rng_state";
    "Fxn:iter_indices";
    "Fxn:is_iterable";
    "class:TestCase(unittest.TestCase):";
    "Fxn:setUp";
    "Fxn:set_rng_seed(SEED)";
    "Fxn:assertTensorsSlowEqual";
    "Fxn:self.assertEqual(x.size(),";
    "Fxn:y.size())";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertLessEqual(max_err,";
    "Fxn:safeToDense";
    "Fxn:self.safeCoalesce(t)";
    "Fxn:r.to_dense()";
    "Fxn:safeCoalesce";
    "Fxn:t.coalesce()";
    "Fxn:self.assertEqual(tc.to_dense(),";
    "Fxn:t.to_dense())";
    "Fxn:self.assertTrue(tc.is_coalesced())";
    "Fxn:t._nnz()";
    "Fxn:self.assertEqual(t._indices(),";
    "Fxn:tc._indices())";
    "Fxn:self.assertEqual(t._values(),";
    "Fxn:tc._values())";
    "Fxn:t._values()):";
    "Fxn:val.clone()";
    "Fxn:torch.is_tensor(val)";
    "Fxn:t._values().ndimension()";
    "Fxn:t._values().new(new_values)";
    "Fxn:torch.stack(new_values)";
    "Fxn:t._indices().new(new_indices).t()";
    "Fxn:t.new(new_indices,";
    "Fxn:t.size())";
    "Fxn:self.assertEqual(tc._indices(),";
    "Fxn:tg._indices())";
    "Fxn:self.assertEqual(tc._values(),";
    "Fxn:tg._values())";
    "Fxn:t.is_coalesced():";
    "Fxn:self.assertEqual(tc._indices(),";
    "Fxn:t._indices())";
    "Fxn:self.assertEqual(tc._values(),";
    "Fxn:t._values())";
    "Fxn:unwrapVariables";
    "Fxn:assertEqual";
    "Fxn:self.unwrapVariables(x,";
    "Fxn:self.assertEqual(x.item(),";
    "Fxn:self.assertEqual(x,";
    "Fxn:y.item(),";
    "Fxn:torch.is_tensor(x)";
    "Fxn:torch.is_tensor(y):";
    "Fxn:assertTensorsEqual";
    "Fxn:self).assertEqual(a.size(),";
    "Fxn:b.size(),";
    "Fxn:a.numel()";
    "Fxn:b.type_as(a)";
    "Fxn:b.cuda(device=a.get_device())";
    "Fxn:b.cpu()";
    "Fxn:self.assertTrue(torch.equal(nan_mask,";
    "Fxn:diff.is_signed()";
    "Fxn:diff.type():";
    "Fxn:diff.abs()";
    "Fxn:diff.max()";
    "Fxn:self.assertLessEqual(max_err,";
    "Fxn:self).assertEqual(x.is_sparse,";
    "Fxn:self.safeCoalesce(x)";
    "Fxn:self.safeCoalesce(y)";
    "Fxn:assertTensorsEqual(x._indices(),";
    "Fxn:y._indices())";
    "Fxn:assertTensorsEqual(x._values(),";
    "Fxn:y._values())";
    "Fxn:assertTensorsEqual(x,";
    "Fxn:self).assertEqual(x,";
    "Fxn:self).assertEqual(x,";
    "Fxn:is_iterable(x)";
    "Fxn:is_iterable(y):";
    "Fxn:self).assertEqual(len(x),";
    "Fxn:self.assertEqual(x_,";
    "Fxn:self).assertEqual(x,";
    "Fxn:self).assertEqual(x,";
    "Fxn:self.fail("Expected";
    "Fxn:y={}".format(x,";
    "Fxn:self).assertLessEqual(abs(x";
    "Fxn:self).assertEqual(x,";
    "Fxn:assertAlmostEqual";
    "Fxn:10**(-places)";
    "Fxn:self.assertEqual(x,";
    "Fxn:assertNotEqual";
    "Fxn:self.unwrapVariables(x,";
    "Fxn:torch.is_tensor(x)";
    "Fxn:torch.is_tensor(y):";
    "Fxn:x.size()";
    "Fxn:y.size():";
    "Fxn:self).assertNotEqual(x.size(),";
    "Fxn:y.size())";
    "Fxn:self.assertGreater(x.numel(),";
    "Fxn:y.type_as(x)";
    "Fxn:y.cuda(device=x.get_device())";
    "Fxn:y.cpu()";
    "Fxn:torch.equal(nan_mask,";
    "Fxn:diff.is_signed():";
    "Fxn:diff.abs()";
    "Fxn:diff.max()";
    "Fxn:self.assertGreaterEqual(max_err,";
    "Fxn:self).assertNotEqual(x,";
    "Fxn:is_iterable(x)";
    "Fxn:is_iterable(y):";
    "Fxn:self).assertNotEqual(x,";
    "Fxn:self.assertGreaterEqual(abs(x";
    "Fxn:self).assertNotEqual(x,";
    "Fxn:assertObjectIn";
    "Fxn:AssertionError("object";
    "Fxn:assertExpectedRaises";
    "Fxn:self.assertExpected(str(e),";
    "Fxn:self.fail(msg="Did";
    "Fxn:assertExpected";
    "Fxn:TypeError("assertExpected";
    "Fxn:remove_prefix";
    "Fxn:text.startswith(prefix):";
    "Fxn:text[len(prefix):]";
    "Fxn:remove_prefix(self.id(),";
    "Fxn:os.path.realpath(sys.modules[module_id].__file__)";
    "Fxn:os.path.join(os.path.dirname(test_file),";
    "Fxn:accept_output";
    "Fxn:{}:\n\n{}".format(update_type,";
    "Fxn:f.write(s)";
    "Fxn:f.read()";
    "Fxn:accept_output("output")";
    "Fxn:RuntimeError(";
    "Fxn:--accept").format(munged_id,";
    "Fxn:re.sub(r'CppOp\[(.+?)\]',";
    "Fxn:re.sub(r'CppOp\[(.+?)\]',";
    "Fxn:accept_output("updated";
    "Fxn:self.assertMultiLineEqual(expected,";
    "Fxn:self.assertEqual(s,";
    "Fxn:download_file";
    "Fxn:os.path.basename(urlsplit(url)[2])";
    "Fxn:os.path.join(os.path.dirname(__file__),";
    "Fxn:os.path.join(data_dir,";
    "Fxn:os.path.exists(path):";
    "Fxn:request.urlopen(url,";
    "Fxn:timeout=15).read()";
    "Fxn:f.write(data)";
    "Fxn:'{}'".format(url)";
    "Fxn:warnings.warn(msg,";
    "Fxn:unittest.SkipTest(msg)";
    "Import:urlsplit";
    "Import:urllib2";
    "Import:urlsplit";
    "Import:request,";
    "/test/common_nn.py";
    "Import:sys";
    "Import:tempfile";
    "Import:unittest";
    "Import:deepcopy";
    "Import:product";
    "Import:torch";
    "Import:torch.cuda";
    "Import:Variable";
    "Import:TestCase,";
    "Import:get_numerical_jacobian,";
    "Import:torch.backends.cudnn";
    "Fxn:get_size_average";
    "Fxn:get_weight";
    "Fxn:kldivloss_reference";
    "Fxn:nlllossNd_reference";
    "Fxn:nllloss_reference";
    "Fxn:nll_loss_helper";
    "Fxn:smoothl1loss_reference";
    "Fxn:_multilabelmarginloss_reference";
    "Fxn:multilabelmarginloss_reference";
    "Fxn:hingeembeddingloss_reference";
    "Fxn:softmarginloss_reference";
    "Fxn:_multimarginloss_reference";
    "Fxn:multimarginloss_reference";
    "Fxn:cosineembeddingloss_reference";
    "Fxn:_cos";
    "class:NNTestCase(TestCase):";
    "Fxn:_jacobian";
    "Fxn:[self._jacobian(elem,";
    "Fxn:torch.zeros(input.nelement(),";
    "Fxn:_flatten_tensors";
    "Fxn:torch.is_tensor(x):";
    "Fxn:x.to_dense().view(-1)";
    "Fxn:x.view(-1)";
    "Fxn:self._flatten_tensors(x.data)";
    "Fxn:_zero_grad_input";
    "Fxn:input.grad.data.zero_()";
    "Fxn:input.grad.detach_()";
    "Fxn:torch.is_tensor(input):";
    "Fxn:self._zero_grad_input(i)";
    "Fxn:_analytical_jacobian";
    "Fxn:self._forward(module,";
    "Fxn:output.nelement()";
    "Fxn:self._jacobian(input,";
    "Fxn:self._get_parameters(module)[0])";
    "Fxn:torch.zeros(num_param,";
    "Fxn:self._get_parameters(module)";
    "Fxn:torch.zeros_like(output)";
    "Fxn:d_out.view(-1)";
    "Fxn:self._zero_grad_parameters(module)";
    "Fxn:self._zero_grad_input(input)";
    "Fxn:self._backward(module,";
    "Fxn:iter_tensors(d_input)):";
    "Fxn:d_x.contiguous().view(-1)";
    "Fxn:torch.cat(self._flatten_tensors(d_param),";
    "Fxn:_numerical_jacobian";
    "Fxn:fw";
    "Fxn:self._forward(module,";
    "Fxn:contiguous(input)";
    "Fxn:get_numerical_jacobian(fw,";
    "Fxn:self._get_parameters(module)";
    "Fxn:torch.cat([get_numerical_jacobian(fw,";
    "Fxn:check_jacobian";
    "Fxn:self._analytical_jacobian(module,";
    "Fxn:self._numerical_jacobian(module,";
    "Fxn:self.assertLessEqual(";
    "Fxn:n).abs().max()";
    "Fxn:check_criterion_jacobian";
    "Fxn:self._forward_criterion(criterion,";
    "Fxn:self._backward_criterion(criterion,";
    "Fxn:deepcopy(analytical_d_x)";
    "Fxn:iter_tensors(input)";
    "Fxn:iter_tensors(numerical_d_x)";
    "Fxn:x.view(-1)";
    "Fxn:d_x.view(-1)";
    "Fxn:x[i].item()";
    "Fxn:self._forward_criterion(criterion,";
    "Fxn:self._forward_criterion(criterion,";
    "Fxn:self.assertLessEqual(";
    "Fxn:n).abs().max()";
    "class:TestBase(object):";
    "Fxn:__init__";
    "Fxn:ValueError("{}:";
    "Fxn:.format(self.get_name(),";
    "Fxn:get_name";
    "Fxn:_unpack";
    "Fxn:torch.is_tensor(value):";
    "Fxn:is_iterable(value):";
    "Fxn:constructor_args";
    "Fxn:self._get_arg('constructor_args',";
    "Fxn:_get_arg";
    "Fxn:convert_tensors_to_vars";
    "Fxn:tensor_to_var";
    "Fxn:Variable(t)";
    "Fxn:torch.is_tensor(t)";
    "Fxn:tensor_to_var(args)";
    "Fxn:convert_tensors_to_vars(self._extra_kwargs[name])";
    "Fxn:convert_tensors_to_vars(self._extra_kwargs[fn_name]())";
    "Fxn:map_tensor_sizes";
    "Fxn:[map_tensor_sizes(s)";
    "Fxn:torch.is_tensor(sizes):";
    "Fxn:Variable(sizes.double())";
    "Fxn:torch.randn(sizes)";
    "Fxn:map_tensor_sizes(self._extra_kwargs[size_name])";
    "Fxn:self._unpack(self._arg_cache[name])";
    "Fxn:_get_input";
    "Fxn:self._get_arg('input',";
    "Fxn:__call__";
    "class:ModuleTest(TestBase):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:kwargs.get('jacobian_input',";
    "Fxn:kwargs.get('test_cuda',";
    "Fxn:kwargs.get('pickle',";
    "Fxn:kwargs.get('check_gradgrad',";
    "Fxn:kwargs.get('FIXME_no_cuda_gradgrad_comparison',";
    "Fxn:kwargs.get('precision',";
    "Fxn:__call__";
    "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:self._get_input()";
    "Fxn:test_case._forward(module,";
    "Fxn:deepcopy(input)";
    "Fxn:self.reference_fn(ref_input,";
    "Fxn:test_case._get_parameters(module)[0])";
    "Fxn:test_case.assertEqual(out,";
    "Fxn:self.test_noncontig(test_case,";
    "Fxn:TemporaryFile()";
    "Fxn:test_case._forward(module,";
    "Fxn:torch.save(module,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:test_case.assertEqual(test_case._forward(module,";
    "Fxn:test_case._forward(module_copy,";
    "Fxn:self._do_test(test_case,";
    "Fxn:noncontiguize";
    "Fxn:[self.noncontiguize(o)";
    "Fxn:tensor.dim()";
    "Fxn:torch.stack([tensor.clone().zero_(),";
    "Fxn:ndim).select(ndim,";
    "Fxn:noncontig.numel()";
    "Fxn:noncontig.is_contiguous()";
    "Fxn:Variable(noncontig,";
    "Fxn:test_noncontig";
    "Fxn:input.dim()";
    "Fxn:test_case._zero_grad_parameters(module)";
    "Fxn:test_case._zero_grad_input(input)";
    "Fxn:freeze_rng_state():";
    "Fxn:test_case._forward(module,";
    "Fxn:output.new(output.shape).normal_()";
    "Fxn:output.clone()";
    "Fxn:deepcopy(test_case._backward(module,";
    "Fxn:deepcopy(test_case._get_parameters(module)[1])";
    "Fxn:self.noncontiguize(input)";
    "Fxn:self.noncontiguize(grad_output)";
    "Fxn:product((True,";
    "Fxn:test_case._zero_grad_parameters(module)";
    "Fxn:test_case._zero_grad_input(i)";
    "Fxn:freeze_rng_state():";
    "Fxn:test_case._forward(module,";
    "Fxn:test_case._backward(module,";
    "Fxn:test_case.assertEqual(out,";
    "Fxn:test_case.assertEqual(grad,";
    "Fxn:test_case.assertEqual(test_case._get_parameters(module)[1],";
    "Fxn:test_cuda";
    "Fxn:unittest.SkipTest('Excluded";
    "Fxn:self._get_input()";
    "Fxn:to_gpu(cpu_input,";
    "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:self.constructor(*self.constructor_args).float().cuda()";
    "Fxn:test_case._get_parameters(cpu_module)";
    "Fxn:test_case._get_parameters(gpu_module)";
    "Fxn:gpu_p.copy_(cpu_p)";
    "Fxn:test_case._zero_grad_input(cpu_input)";
    "Fxn:test_case._zero_grad_input(gpu_input)";
    "Fxn:test_case._zero_grad_parameters(cpu_module)";
    "Fxn:test_case._zero_grad_parameters(gpu_module)";
    "Fxn:test_case._forward(cpu_module,";
    "Fxn:test_case._forward(gpu_module,";
    "Fxn:test_case.assertEqual(cpu_output,";
    "Fxn:cpu_output.clone().normal_()";
    "Fxn:cpu_gradOutput.type('torch.cuda.FloatTensor')";
    "Fxn:test_case._backward(cpu_module,";
    "Fxn:test_case._backward(gpu_module,";
    "Fxn:test_case.assertEqual(cpu_gradInput,";
    "Fxn:test_case.assertEqual(cpu_d_p,";
    "Fxn:cpu_module(cpu_input)";
    "Fxn:gpu_module(gpu_input)";
    "Fxn:Variable(cpu_output.data.clone().normal_(),";
    "Fxn:Variable(cpu_gradOutput.data.type_as(gpu_output),";
    "Fxn:torch.autograd.grad(";
    "Fxn:torch.autograd.grad(";
    "Fxn:test_case.assertEqual(cpu_d_i,";
    "Fxn:torch.autograd.grad(";
    "Fxn:cpu_output.sum()";
    "Fxn:x.sum(),";
    "Fxn:torch.autograd.grad(";
    "Fxn:gpu_output.sum()";
    "Fxn:x.sum(),";
    "Fxn:test_case.assertEqual(cpu_gradInput,";
    "Fxn:test_case.assertEqual(cpu_d_p,";
    "Fxn:self.test_noncontig(test_case,";
    "class:CriterionTest(TestBase):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:kwargs.get('test_cuda',";
    "Fxn:_get_target";
    "Fxn:self._get_arg('target',";
    "Fxn:__call__";
    "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:self._get_input()";
    "Fxn:module.__repr__()";
    "Fxn:self._get_target()";
    "Fxn:test_case._forward_criterion(module,";
    "Fxn:self.reference_fn(deepcopy(input),";
    "Fxn:deepcopy(target),";
    "Fxn:expected_out.item()";
    "Fxn:test_case.assertEqual(out,";
    "Fxn:test_case.check_criterion_jacobian(module,";
    "Fxn:self._do_extra_tests(test_case,";
    "Fxn:test_cuda";
    "Fxn:unittest.SkipTest('Excluded";
    "Fxn:self._get_input()";
    "Fxn:to_gpu(cpu_input,";
    "Fxn:self._get_target()";
    "Fxn:to_gpu(cpu_target,";
    "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:self.constructor(*self.constructor_args).float().cuda()";
    "Fxn:test_case._forward_criterion(cpu_module,";
    "Fxn:test_case._forward_criterion(gpu_module,";
    "Fxn:test_case.assertEqual(cpu_output,";
    "Fxn:test_case._backward_criterion(cpu_module,";
    "Fxn:test_case._backward_criterion(gpu_module,";
    "Fxn:test_case.assertEqual(cpu_gradInput,";
    "Fxn:_do_extra_tests";
    "/test/run_test.py";
    "Import:print_function";
    "Import:argparse";
    "Import:import";
    "Import:shlex";
    "Import:shutil";
    "Import:subprocess";
    "Import:sys";
    "Import:tempfile";
    "Import:torch";
    "Fxn:print_to_stderr";
    "Fxn:shell";
    "Fxn:get_shell_output";
    "Fxn:run_test";
    "Fxn:test_cpp_extensions";
    "Fxn:test_distributed";
    "Fxn:parse_args";
    "Fxn:get_python_command";
    "Fxn:get_selected_tests";
    "Fxn:main";
    "/test/test_autograd.py";
    "Import:contextlib";
    "Import:import";
    "Import:sys";
    "Import:math";
    "Import:torch";
    "Import:unittest";
    "Import:warnings";
    "Import:deepcopy";
    "Import:OrderedDict";
    "Import:product";
    "Import:mul";
    "Import:reduce,";
    "Import:gradgradcheck,";
    "Import:once_differentiable";
    "Import:profile";
    "Import:TestCase,";
    "Import:Variable,";
    "Import:InplaceFunction";
    "Import:make_non_contiguous,";
    "Import:cPickle";
    "Import:pickle";
    "class:NoArgsClass(object):";
    "Fxn:__iter__";
    "Fxn:__next__";
    "Fxn:StopIteration()";
    "Fxn:__len__";
    "Fxn:NoArgsClass()";
    "class:non_differentiable(object):";
    "Fxn:__init__";
    "Fxn:backward_engine";
    "Fxn:engine()";
    "Fxn:graph_desc";
    "Fxn:'('";
    "Fxn:graph_desc(next_fn)";
    "class:TestAutograd(TestCase):";
    "Fxn:_function_test";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:cls.apply(x,";
    "Fxn:Variable(torch.ones(1),";
    "Fxn:result.sum().backward(go,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertIsNotNone(x.grad.grad_fn)";
    "Fxn:self.assertIsNotNone(y.grad.grad_fn)";
    "Fxn:test_function";
    "class:MyFunction(Function):";
    "Fxn:forward";
    "Fxn:ctx.save_for_backward(tensor1,";
    "Fxn:backward";
    "Fxn:self.assertIsInstance(var1,";
    "Fxn:self.assertIsInstance(var2,";
    "Fxn:self.assertIsInstance(grad_output,";
    "Fxn:self._function_test(MyFunction)";
    "Fxn:graph_desc(x.grad.grad_fn)";
    "Fxn:graph_desc(y.grad.grad_fn)";
    "Fxn:self.assertEqual(";
    "Fxn:'CloneBackward(AddBackward1(ExpandBackward(AccumulateGrad()),";
    "Fxn:'MulBackward1(ExpandBackward(AccumulateGrad()),";
    "Fxn:AccumulateGrad())))')";
    "Fxn:self.assertEqual(";
    "Fxn:'CloneBackward(AddBackward1(MulBackward0(ExpandBackward(AccumulateGrad())),";
    "Fxn:'MulBackward1(ExpandBackward(AccumulateGrad()),";
    "Fxn:AccumulateGrad())))')";
    "Fxn:test_once_differentiable";
    "class:MyFunction(Function):";
    "Fxn:forward";
    "Fxn:ctx.save_for_backward(tensor1,";
    "Fxn:backward";
    "Fxn:self.assertFalse(torch.is_grad_enabled())";
    "Fxn:self._function_test(MyFunction)";
    "Fxn:self.assertEqual(graph_desc(x.grad.grad_fn),";
    "Fxn:'CloneBackward(Error(AccumulateGrad(),";
    "Fxn:AccumulateGrad()))')";
    "Fxn:self.assertEqual(graph_desc(y.grad.grad_fn),";
    "Fxn:'CloneBackward(Error(AccumulateGrad(),";
    "Fxn:AccumulateGrad()))')";
    "Fxn:test_function_returns_input";
    "class:MyFunction(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:Variable(torch.ones(1),";
    "Fxn:MyFunction.apply(v).backward()";
    "Fxn:self.assertEqual(v.grad.data.tolist(),";
    "Fxn:v.grad.data.zero_()";
    "Fxn:MyFunction.apply(v.clone()).backward()";
    "Fxn:self.assertEqual(v.grad.data.tolist(),";
    "Fxn:test_legacy_function_none_grad";
    "class:MyFunction(Function):";
    "Fxn:forward";
    "Fxn:torch.zeros(2,";
    "Fxn:backward";
    "Fxn:Variable(torch.ones(shape),";
    "Fxn:0].expand(3,";
    "Fxn:5).t().sum()";
    "Fxn:MyFunction()(y).sum().backward()";
    "Fxn:self.assertEqual(v.grad.data,";
    "Fxn:torch.zeros(shape))";
    "Fxn:test_accumulate_grad";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:compute_grad";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:y.backward(grad_output,";
    "Fxn:x.grad.clone()";
    "Fxn:y.backward(grad_output,";
    "Fxn:compute_grad(create_graph=False)";
    "Fxn:self.assertEqual(x_grad,";
    "Fxn:compute_grad(create_graph=True)";
    "Fxn:self.assertEqual(x_grad,";
    "Fxn:test_hessian_vector";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:z.backward(torch.ones(2,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:grad_sum.backward(torch.ones(2,";
    "Fxn:torch.ones(2,";
    "Fxn:torch.ones(2,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_grad";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:z.backward(torch.ones(2,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.autograd.grad(";
    "Fxn:grad_outputs=[torch.ones(2,";
    "Fxn:torch.ones(2,";
    "Fxn:torch.ones(2,";
    "Fxn:self.assertEqual(x_hv[0].data,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_grad_nonleaf";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:torch.ones(2,";
    "Fxn:fn";
    "Fxn:torch.autograd.grad(";
    "Fxn:fn(x),";
    "Fxn:self.assertIsNone(y.grad)";
    "Fxn:self.assertIsNone(x.grad)";
    "Fxn:self.assertEqual(grad_x.data,";
    "Fxn:fn(x_init).data.sum()";
    "Fxn:fn(x).data.sum()";
    "Fxn:self.assertGreater(val_final,";
    "Fxn:x.backward(grad_output)";
    "Fxn:self.assertIsNotNone(y.grad)";
    "Fxn:self.assertIsNotNone(x_init.grad)";
    "Fxn:test_grad_nonleaf_many_outputs";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:x.chunk(2)";
    "Fxn:hook";
    "Fxn:x.register_hook(hook)";
    "Fxn:torch.randn(2,";
    "Fxn:torch.autograd.grad(";
    "Fxn:self.assertEqual(grad_a.data,";
    "Fxn:self.assertEqual(grad_b.data,";
    "Fxn:self.assertFalse(hook_called[0])";
    "Fxn:self.assertIsNone(x.grad)";
    "Fxn:test_sharded_grad";
    "Fxn:[Variable(torch.zeros(5,";
    "Fxn:group";
    "Fxn:group(intermediates,";
    "Fxn:torch.autograd.grad(loss,";
    "Fxn:torch.autograd.backward(intermediates,";
    "Fxn:self.assertEqual(l.grad.data,";
    "Fxn:test_backward_badcalls";
    "Fxn:torch.ones(1)";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:x.backward()";
    "Fxn:test_grad_badcalls";
    "Fxn:torch.ones(1)";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:torch.autograd.grad(x,";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:torch.autograd.grad(y,";
    "Fxn:Variable(torch.ones(1),";
    "Fxn:torch.autograd.grad(y,";
    "Fxn:test_grad_unreachable";
    "Fxn:Variable(torch.ones(1),";
    "Fxn:Variable(torch.ones(1),";
    "Fxn:torch.autograd.grad(x";
    "Fxn:self.assertEqual(grad_x,";
    "Fxn:self.assertIsNone(grad_y)";
    "Fxn:Variable(torch.ones(1),";
    "Fxn:torch.autograd.grad(x";
    "Fxn:self.assertEqual(grad_x,";
    "Fxn:self.assertIsNone(grad_z)";
    "Fxn:test_hooks";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:bw_hook";
    "Fxn:self.assertIsInstance(grad,";
    "Fxn:x.register_hook(lambda";
    "Fxn:bw_hook(0,";
    "Fxn:z.register_hook(lambda";
    "Fxn:bw_hook(1,";
    "Fxn:z.backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter[0],";
    "Fxn:z.register_hook(lambda";
    "Fxn:bw_hook(2,";
    "Fxn:z.backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter[0],";
    "Fxn:test2.remove()";
    "Fxn:z.backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter[0],";
    "Fxn:bw_hook_modify";
    "Fxn:grad.mul(2)";
    "Fxn:test.remove()";
    "Fxn:z.register_hook(bw_hook_modify)";
    "Fxn:y.grad.data.zero_()";
    "Fxn:z.backward(torch.ones(5,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:y.register_hook(bw_hook_modify)";
    "Fxn:y.grad.data.zero_()";
    "Fxn:z.backward(torch.ones(5,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_hooks_cpp";
    "Fxn:torch.nn.BatchNorm1d(5,";
    "Fxn:bn.eval()";
    "Fxn:bw_hook";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:bn(x)";
    "Fxn:z.register_hook(bw_hook)";
    "Fxn:z.sum().backward()";
    "Fxn:self.assertEqual(counter[0],";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:test_hook_none";
    "class:NoneGradientFunction(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:NoneGradientFunction()";
    "Fxn:hook";
    "Fxn:self.assertIsInstance(grad_input,";
    "Fxn:self.assertIsInstance(grad_output,";
    "Fxn:self.assertIsNotNone(grad_input[0])";
    "Fxn:self.assertIsNotNone(grad_input[1])";
    "Fxn:self.assertIsNotNone(grad_output[0])";
    "Fxn:self.assertIsNotNone(grad_output[1])";
    "Fxn:fn.register_hook(hook)";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:y)).sum().backward()";
    "Fxn:self.assertTrue(was_called[0])";
    "Fxn:test_retain_grad";
    "Fxn:Variable(torch.rand(1,";
    "Fxn:h1).sum()";
    "Fxn:retain_grad()";
    "Fxn:h1.retain_grad()";
    "Fxn:h1.retain_grad()";
    "Fxn:out.backward(retain_graph=True)";
    "Fxn:self.assertEqual(h1.data";
    "Fxn:out.backward(retain_graph=True)";
    "Fxn:self.assertEqual(h1.data";
    "Fxn:input.grad.data.zero_()";
    "Fxn:input.retain_grad()";
    "Fxn:input.retain_grad()";
    "Fxn:out.backward()";
    "Fxn:self.assertEqual(input.data";
    "Fxn:test_retain_grad_cycle";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:run_test";
    "Fxn:y.retain_grad()";
    "Fxn:inc";
    "Fxn:weakref.ref(y,";
    "Fxn:run_test()";
    "Fxn:gc.collect()";
    "Fxn:self.assertIsNone(refs[0]())";
    "Fxn:self.assertEqual(counter[0],";
    "Fxn:z.sum().backward()";
    "Fxn:test_backward";
    "Fxn:torch.randn(5,";
    "Fxn:torch.randn(5,";
    "Fxn:torch.rand(5,";
    "Fxn:torch.randn(5,";
    "Fxn:torch.randn(5,";
    "Fxn:Variable(v_t,";
    "Fxn:Variable(x_t,";
    "Fxn:Variable(y_t,";
    "Fxn:Variable(z_t,";
    "Fxn:v.backward(grad_output)";
    "Fxn:self.assertEqual(v.grad.data,";
    "Fxn:a.backward(grad_output)";
    "Fxn:z_t.pow(2)";
    "Fxn:z_t.pow(2)";
    "Fxn:y_t.pow(2)";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:self.assertEqual(z.grad.data,";
    "Fxn:test_sparse_backward";
    "Import:import";
    "Import:weakref";
    "class:FixedGradientFunction(Function):";
    "Fxn:__init__";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:torch.Size([6,";
    "Fxn:torch.LongTensor([";
    "Fxn:torch.DoubleTensor([[1,";
    "Fxn:Variable(torch.sparse.DoubleTensor(i1,";
    "Fxn:torch.LongTensor([";
    "Fxn:torch.DoubleTensor([[1,";
    "Fxn:Variable(torch.sparse.DoubleTensor(i2,";
    "Fxn:Variable(torch.rand(size).double())";
    "Fxn:FixedGradientFunction(sparse_grad1)";
    "Fxn:FixedGradientFunction(sparse_grad2)";
    "Fxn:FixedGradientFunction(dense_grad)";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:dense_fn(x)";
    "Fxn:sparse_fn2(x)).sum().backward()";
    "Fxn:self.assertEqual(x.grad,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:sparse_fn1(x)";
    "Fxn:sparse_fn2(x)).sum().backward()";
    "Fxn:self.assertEqual(x.grad,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:sparse_fn2(x)).sum().backward()";
    "Fxn:self.assertEqual(x.grad,";
    "Fxn:test_multi_backward";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:torch.randn(5,";
    "Fxn:torch.randn(5,";
    "Fxn:torch.autograd.backward([z,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:self.assertEqual(b.grad.data,";
    "Fxn:self.assertEqual(q.grad.data,";
    "Fxn:test_multi_backward_no_grad";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:call_backwards";
    "Fxn:torch.autograd.backward([z,";
    "Fxn:[torch.ones(5,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_dependent_backward";
    "Fxn:Variable(torch.randn(10),";
    "Fxn:torch.randn(10)";
    "Fxn:torch.randn(10)";
    "Fxn:torch.autograd.backward([y,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:xd.pow(5)";
    "Fxn:test_save_output_nr";
    "Fxn:Variable(torch.randn(10),";
    "class:MultiOutputFn(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:torch.cat(grad)";
    "Fxn:MultiOutputFn.apply(x)";
    "Fxn:self.assertEqual(b.output_nr,";
    "class:TestFn(Function):";
    "Fxn:forward";
    "Fxn:ctx.save_for_backward(b)";
    "Fxn:backward";
    "Fxn:self.assertEqual(b.output_nr,";
    "Fxn:TestFn.apply(b).sum().backward()";
    "Fxn:test_no_grad";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:torch.no_grad():";
    "Fxn:self.assertFalse(w.requires_grad)";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:w.backward(torch.ones(5,";
    "Fxn:self.assertIsNone(w.grad_fn)";
    "Fxn:test_no_grad_python_function";
    "Fxn:Variable(torch.ones(5,";
    "class:MyOp(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:torch.no_grad():";
    "Fxn:MyOp.apply(x)";
    "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:test_indexing";
    "Fxn:torch.arange(1,";
    "Fxn:17).view(4,";
    "Fxn:Variable(x,";
    "Fxn:compare";
    "Fxn:torch.is_tensor(indexed_tensor):";
    "Fxn:self.assertEqual(indexed_tensor,";
    "Fxn:indexed_var.sum().backward()";
    "Fxn:torch.Tensor(x.size()).fill_(0)";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:check_index";
    "Fxn:y.grad.data.zero_()";
    "Fxn:compare(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:torch.LongTensor([0,";
    "Fxn:check_index(x,";
    "Fxn:torch.rand(4,";
    "Fxn:4).bernoulli().byte())";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:torch.arange(1,";
    "Fxn:49).view(4,";
    "Fxn:Variable(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:check_index(x,";
    "Fxn:torch.LongTensor([0,";
    "Fxn:Variable(z,";
    "Fxn:y.grad.data.zero_()";
    "Fxn:compare(x,";
    "Fxn:test_indexing_duplicates";
    "Fxn:torch.arange(1,";
    "Fxn:17).view(4,";
    "Fxn:Variable(x,";
    "Fxn:torch.LongTensor([1,";
    "Fxn:y[idx].sum().backward()";
    "Fxn:torch.zeros(4,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.arange(1,";
    "Fxn:17).view(4,";
    "Fxn:Variable(x,";
    "Fxn:y[idx].sum().backward()";
    "Fxn:torch.zeros(4,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.arange(1,";
    "Fxn:17).view(4,";
    "Fxn:Variable(x,";
    "Fxn:y[idx].sum().backward()";
    "Fxn:torch.Tensor([[0,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.arange(1,";
    "Fxn:65).view(4,";
    "Fxn:Variable(x,";
    "Fxn:y[idx].sum().backward()";
    "Fxn:torch.Tensor(4,";
    "Fxn:4).zero_()";
    "Fxn:expected_grad[1].fill_(3)";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_volatile_deprecated";
    "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:self.assertFalse(v.volatile)";
    "Fxn:self.assertIn('volatile',";
    "Fxn:test_requires_grad";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertFalse(a.requires_grad)";
    "Fxn:self.assertTrue(b.requires_grad)";
    "Fxn:error";
    "Fxn:OrderedDict()";
    "Fxn:OrderedDict()";
    "Fxn:OrderedDict()";
    "Fxn:b.backward(torch.ones(5,";
    "Fxn:test_requires_grad_inplace";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertTrue(a.requires_grad)";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertTrue(a.requires_grad)";
    "Fxn:test_no_requires_grad_inplace";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:a.add_(5)";
    "Fxn:a.sum().backward()";
    "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:torch.ones(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:b.add_(5)";
    "Fxn:a.sum().backward()";
    "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:torch.ones(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:a.add_(5)";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:b.add_(5)";
    "Fxn:test_requires_grad_factory";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:fn(x,";
    "Fxn:self.assertEqual(requires_grad,";
    "Fxn:self.assertIs(dtype,";
    "Fxn:torch.cuda.is_available()";
    "Fxn:torch.cuda.device_count()";
    "Fxn:fn(x,";
    "Fxn:self.assertEqual(requires_grad,";
    "Fxn:self.assertIs(dtype,";
    "Fxn:self.assertEqual(1,";
    "Fxn:output.get_device())";
    "Fxn:test_grad_assignment";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).long())";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).long())";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:torch.cuda.is_available():";
    "Fxn:unittest.SkipTest("CUDA";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).cuda())";
    "Fxn:torch.cuda.device_count()";
    "Fxn:unittest.SkipTest("At";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).cuda(0))";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).cuda(1))";
    "Fxn:test_duplicate_backward_root";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:x.data.clone().normal_()";
    "Fxn:torch.autograd.backward([x,";
    "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:self.assertEqual(b.grad.data,";
    "Fxn:test_backward_no_grad";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:torch.autograd.backward([b],";
    "Fxn:test_next_functions";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertIsNotNone(a.grad_fn)";
    "Fxn:self.assertEqual(len(next_functions),";
    "Fxn:self.assertIsInstance(next_functions[0][0],";
    "Fxn:self.assertEqual(next_functions[0][1],";
    "Fxn:self.assertIsInstance(next_functions[1][0],";
    "Fxn:self.assertEqual(next_functions[1][1],";
    "Fxn:self.assertEqual(len(next_functions),";
    "Fxn:self.assertIs(next_functions[0][0],";
    "Fxn:test_inplace";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:z.add_(2)";
    "Fxn:q.backward(torch.ones(5,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:w.backward(torch.ones(5,";
    "Fxn:z.add_(y)";
    "Fxn:w.backward(torch.ones(5,";
    "Fxn:r.backward(torch.ones(5,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:q.backward(torch.ones(5,";
    "Fxn:x.grad.data.zero_()";
    "Fxn:z.exp_()";
    "Fxn:self.assertNotEqual(z._version,";
    "Fxn:r.backward(torch.ones(5,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:w.backward(torch.ones(5,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.Tensor(5,";
    "Fxn:5).fill_((1";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:q.backward(torch.ones(5,";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:leaf.clone()";
    "Fxn:x.add_(10)";
    "Fxn:self.assertEqual(x.data,";
    "Fxn:torch.ones(5,";
    "Fxn:y.backward(torch.ones(5,";
    "Fxn:self.assertEqual(leaf.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:x.add_(2)";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:z.backward(torch.ones(5,";
    "Fxn:test_mark_non_differentiable";
    "class:MyFunction(Function):";
    "Fxn:forward";
    "Fxn:ctx.mark_non_differentiable(output)";
    "Fxn:backward";
    "Fxn:0).type(torch.DoubleTensor)";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:MyFunction.apply(x)";
    "Fxn:self.assertFalse(mask.requires_grad)";
    "Fxn:x.masked_fill(mask,";
    "Fxn:y.sum().backward()";
    "Fxn:test_mark_non_differentiable_mixed";
    "class:MyFunction(Function):";
    "Fxn:forward";
    "Fxn:ctx.mark_non_differentiable(a)";
    "Fxn:backward";
    "Fxn:self.assertTrue((grad_a";
    "Fxn:0).all())";
    "Fxn:self.assertTrue((grad_b";
    "Fxn:1).all())";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:MyFunction.apply(x)";
    "Fxn:self.assertFalse(a.requires_grad)";
    "Fxn:self.assertTrue(b.requires_grad)";
    "Fxn:b.sum().backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:test_mark_non_differentiable_none";
    "class:MyFunction(Function):";
    "Fxn:forward";
    "Fxn:input.clone()";
    "Fxn:ctx.mark_non_differentiable(output)";
    "Fxn:backward";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:MyFunction.apply(x";
    "Fxn:x).sum().backward()";
    "Fxn:test_return_duplicate";
    "class:DoubleDuplicate(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:fn";
    "Fxn:DoubleDuplicate.apply(x)";
    "Fxn:self.assertIs(a,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:gradcheck(fn,";
    "Fxn:gradgradcheck(fn,";
    "Fxn:test_return_duplicate_inplace";
    "class:DoubleInplace(Function):";
    "Fxn:forward";
    "Fxn:x.mul_(2)";
    "Fxn:ctx.mark_dirty(x)";
    "Fxn:backward";
    "Fxn:inplace_fn";
    "Fxn:DoubleInplace.apply(x.clone())";
    "Fxn:self.assertIs(a,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:gradcheck(inplace_fn,";
    "Fxn:gradgradcheck(inplace_fn,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:InplaceFunction.apply(x))";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:InplaceFunction.apply(x.clone()[0]))";
    "Fxn:test_resize";
    "Fxn:Variable(torch.ones(2,";
    "Fxn:self.assertTrue(x.resize(3,";
    "Fxn:2).size()";
    "Fxn:_test_setitem";
    "Fxn:Variable(torch.ones(*size),";
    "Fxn:self.assertNotEqual(y._version,";
    "Fxn:y.backward(torch.ones(*size))";
    "Fxn:torch.ones(*size)";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:_test_setitem_tensor";
    "Fxn:Variable(torch.ones(*size),";
    "Fxn:x.new(x[index].size()).fill_(7)";
    "Fxn:self.assertNotEqual(y._version,";
    "Fxn:y.backward(torch.ones(*size))";
    "Fxn:torch.ones(*size)";
    "Fxn:novars.append(i.data)";
    "Fxn:novars.append(i)";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(value.grad.data,";
    "Fxn:torch.ones(value.data.size()))";
    "Fxn:Variable(torch.randn(4),";
    "Fxn:Variable(torch.zeros(2,";
    "Fxn:y.backward(torch.randn(2,";
    "Fxn:self.assertEqual(x.size(),";
    "Fxn:x.grad.size())";
    "Fxn:test_setitem";
    "Fxn:self._test_setitem((5,";
    "Fxn:self._test_setitem((5,),";
    "Fxn:self._test_setitem((1,),";
    "Fxn:self._test_setitem((10,),";
    "Fxn:self._test_setitem((5,";
    "Fxn:self._test_setitem((5,";
    "Fxn:[slice(None),";
    "Fxn:self._test_setitem((5,";
    "Fxn:[slice(None),";
    "Fxn:self._test_setitem((5,";
    "Fxn:self._test_setitem((5,";
    "Fxn:[slice(None),";
    "Fxn:self._test_setitem((5,";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:Variable(torch.LongTensor([3]),";
    "Fxn:requires_grad=False).sum())";
    "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:[slice(None),";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:[slice(None),";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:[slice(None),";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:[Variable(torch.LongTensor([1,";
    "Fxn:test_setitem_mask";
    "Fxn:torch.ByteTensor(5,";
    "Fxn:5).bernoulli_()";
    "Fxn:self._test_setitem((5,";
    "Fxn:Variable(mask))";
    "Fxn:self._test_setitem((5,),";
    "Fxn:Variable(mask[0]))";
    "Fxn:self._test_setitem((1,),";
    "Fxn:Variable(mask[0,";
    "Fxn:self._test_setitem_tensor((5,";
    "Fxn:Variable(mask))";
    "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:Variable(mask[0]))";
    "Fxn:test_select_sum";
    "Fxn:Variable(torch.randn(10),";
    "Fxn:func";
    "Fxn:x.select(0,";
    "Fxn:1).sum()";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_stack";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:torch.stack([x,";
    "Fxn:torch.randn(3,";
    "Fxn:stacked.backward(grad)";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:self.assertEqual(z.grad.data,";
    "Fxn:test_put";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(6),";
    "Fxn:Variable(torch.LongTensor([1,";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:x.put_(idx,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_put_accumulate";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(6),";
    "Fxn:Variable(torch.LongTensor([1,";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:x.put_(idx,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_fill";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:x.fill_(2)";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_unused_output";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:x.chunk(5)";
    "Fxn:o.sum().backward()";
    "Fxn:torch.zeros(10,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:x.grad.data.zero_()";
    "Fxn:torch.randn(2,";
    "Fxn:x.chunk(5)";
    "Fxn:outputs[0].backward(grad_output)";
    "Fxn:torch.zeros(10,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_gc_in_destructor";
    "class:CollectOnDelete(Function):";
    "Fxn:__del__";
    "Fxn:gc.collect()";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:_grad_fn=CollectOnDelete())";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_unused_output_gpu";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).float().cuda(),";
    "Fxn:Broadcast.apply(list(range(torch.cuda.device_count())),";
    "Fxn:y.sum().backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_backward_device";
    "Import:Broadcast";
    "class:Identity(torch.autograd.Function):";
    "Fxn:forward";
    "Fxn:x.clone()";
    "Fxn:backward";
    "Fxn:torch.cuda.current_device()";
    "Fxn:grad_output.clone()";
    "Fxn:Variable(torch.randn(1).cuda(1),";
    "Fxn:Identity.apply(v).backward()";
    "Fxn:self.assertEqual(device[0],";
    "Fxn:test_detach";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:y.detach()";
    "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:self.assertFalse(z.requires_grad)";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:y.detach()";
    "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:self.assertIsNone(y.grad_fn)";
    "Fxn:z.sum().backward()";
    "Fxn:detach()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(10,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:a).sum().backward(retain_graph=True)";
    "Fxn:a.detach_()";
    "Fxn:self.assertFalse(a.requires_grad)";
    "Fxn:a).sum().backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(10,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.ones(10,";
    "Fxn:x.narrow(0,";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:view.detach_())";
    "Fxn:test_detach_base";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:x.narrow(0,";
    "Fxn:x.detach_()";
    "Fxn:self.assertFalse(x.requires_grad)";
    "Fxn:self.assertTrue(view.requires_grad)";
    "Fxn:self.assertIsNotNone(view.grad_fn)";
    "Fxn:self.assertIs(view._base,";
    "Fxn:_test_type_conversion_backward";
    "Fxn:Variable(t(torch.randn(5,";
    "Fxn:5).float()),";
    "Fxn:fvar.double().sum().backward()";
    "Fxn:self.assertEqual(fvar.grad,";
    "Fxn:torch.ones_like(fvar))";
    "Fxn:self.assertEqual(type(fvar.grad.data),";
    "Fxn:Variable(t(torch.randn(5,";
    "Fxn:5).double()),";
    "Fxn:dvar.float().sum().backward()";
    "Fxn:self.assertEqual(dvar.grad,";
    "Fxn:torch.ones_like(dvar))";
    "Fxn:self.assertEqual(type(dvar.grad.data),";
    "Fxn:test_type_conversions";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertIsInstance(x.float().data,";
    "Fxn:self.assertIsInstance(x.int().data,";
    "Fxn:torch.cuda.is_available():";
    "Fxn:self.assertIsInstance(x.float().cuda().data,";
    "Fxn:self.assertIsInstance(x.int().cuda().data,";
    "Fxn:self.assertIsInstance(x.int().cuda().cpu().data,";
    "Fxn:torch.cuda.device_count()";
    "Fxn:x.float().cuda(1)";
    "Fxn:self.assertIsInstance(x2.data,";
    "Fxn:self.assertIs(x2.get_device(),";
    "Fxn:x.float().cuda()";
    "Fxn:self.assertIsInstance(x2.data,";
    "Fxn:self.assertIs(x2.get_device(),";
    "Fxn:x2.cuda(1)";
    "Fxn:self.assertIsInstance(x2.data,";
    "Fxn:self.assertIs(x2.get_device(),";
    "Fxn:Variable(torch.randn(5).cuda(1),";
    "Fxn:y.cpu().sum().backward()";
    "Fxn:self.assertIs(y.grad.get_device(),";
    "Fxn:self.assertIs(y.long().data.get_device(),";
    "Fxn:torch.randn(5,";
    "Fxn:5).type(t)";
    "Fxn:Variable(y)";
    "Fxn:self.assertIsInstance(x.type(t).data,";
    "Fxn:self.assertIsInstance(x.type_as(y).data,";
    "Fxn:self.assertIsInstance(x.type(t_dtype).data,";
    "Fxn:self.assertIs(t_dtype,";
    "Fxn:x.type(t_dtype).dtype)";
    "Fxn:self.assertEqual(y.data_ptr(),";
    "Fxn:y.type(t).data_ptr())";
    "Fxn:torch.cuda.is_available():";
    "Fxn:x.cuda()";
    "Fxn:y.cuda()";
    "Fxn:y_c.type().rsplit('.',";
    "Fxn:self.assertEqual(y_c.type(),";
    "Fxn:x_c.type(y_typestr).type())";
    "Fxn:self.assertIs(y_c.dtype,";
    "Fxn:x_c.type(y_c.dtype).dtype)";
    "Fxn:self.assertEqual(y_c.data_ptr(),";
    "Fxn:y_c.cuda().data_ptr()";
    "Fxn:y_c.data_ptr())";
    "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:torch.cuda.is_available():";
    "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:x.cuda())";
    "Fxn:torch.cuda.device_count()";
    "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:x.cuda(0))";
    "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:x.cuda(1))";
    "Fxn:_test_pyscalar_conversions";
    "Fxn:Variable(t(torch.zeros(1,";
    "Fxn:1).long()))";
    "Fxn:self.assertEqual(integral_conv(l),";
    "Fxn:Variable(t(torch.randn(1,";
    "Fxn:self.assertEqual(float(f),";
    "Fxn:self.assertTrue(math.isnan(float(f)))";
    "Fxn:self.assertEqual(float(f),";
    "Fxn:self.assertEqual(float(f),";
    "Fxn:self.assertNotEqual(pyscalar,";
    "Fxn:integral_conv(float(pyscalar)))";
    "Fxn:self.assertEqual(float(l),";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:integral_conv(f[0]))";
    "Fxn:self.assertRaises(OverflowError,";
    "Fxn:integral_conv(f[0]))";
    "Fxn:self.assertRaises(OverflowError,";
    "Fxn:integral_conv(f[0]))";
    "Fxn:self.assertEqual(integral_conv(f),";
    "Fxn:test_nonzero";
    "Fxn:self.assertEqual(expected,";
    "Fxn:self.assertEqual(expected,";
    "Fxn:test_nonzero(l,";
    "Fxn:test_nonzero(l,";
    "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero(f,";
    "Fxn:test_pyscalar_conversions";
    "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:long(x))";
    "Fxn:torch.cuda.is_available():";
    "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:x.cuda(),";
    "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:x.cuda(),";
    "Fxn:long(x))";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_pin_memory";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:self.assertEqual(x,";
    "Fxn:x.pin_memory())";
    "Fxn:self.assertIsNot(x,";
    "Fxn:x.pin_memory())";
    "Fxn:self.assertTrue(x.pin_memory().requires_grad)";
    "Fxn:gradcheck(lambda";
    "Fxn:x.pin_memory(),";
    "Fxn:gradgradcheck(lambda";
    "Fxn:x.pin_memory(),";
    "Fxn:test_isolated_node";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:torch.max(a,";
    "Fxn:True)[1].repeat(1,";
    "Fxn:5).double()";
    "Fxn:a).sum()";
    "Fxn:o.backward()";
    "Fxn:test_shape";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:self.assertEqual(2,";
    "Fxn:self.assertEqual(x.shape[0],";
    "Fxn:self.assertEqual(x.shape[1],";
    "Fxn:test_numpy_requires_grad";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:x.numpy())";
    "Fxn:test_return_leaf";
    "class:Identity(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Identity()(x,";
    "Fxn:hook";
    "Fxn:self.assertEqual(grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:q.register_hook(hook)";
    "Fxn:x).sum().backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertTrue(hook_called[0])";
    "Fxn:test_return_leaf_inplace";
    "class:Inplace(InplaceFunction):";
    "Fxn:forward";
    "Fxn:self.mark_dirty(a)";
    "Fxn:a.add_(b),";
    "Fxn:backward";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Inplace(True)";
    "Fxn:fn(x,";
    "Fxn:self.assertIs(q,";
    "Fxn:self.assertIs(q.grad_fn,";
    "Fxn:self.assertTrue(q.requires_grad)";
    "Fxn:q.sum().backward()";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:test_leaf_assignment";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5),";
    "Fxn:Variable(torch.randn(5),";
    "Fxn:self.assertTrue(x.requires_grad)";
    "Fxn:self.assertIsNot(x.grad_fn,";
    "Fxn:x.sum().backward()";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.ones(5))";
    "Fxn:self.assertEqual(z.grad.data,";
    "Fxn:torch.ones(5)";
    "Fxn:test_no_grad_assignment";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5))";
    "Fxn:torch.no_grad():";
    "Fxn:self.assertTrue(x.requires_grad)";
    "Fxn:self.assertIsNone(x.grad_fn)";
    "Fxn:test_no_grad_modifies_version";
    "Fxn:Variable(torch.randn(5),";
    "Fxn:Variable(torch.randn(5),";
    "Fxn:y).sum()";
    "Fxn:torch.no_grad():";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:z.backward())";
    "Fxn:test_backward_copy";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:torch.ones(5,";
    "Fxn:out.backward(grad_output)";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:test_functional_blas";
    "Fxn:compare";
    "Fxn:fn(*unpacked_args)";
    "Fxn:fn(*args).data";
    "Fxn:torch.is_tensor(unpacked_result):";
    "Fxn:packed_result.dim()";
    "Fxn:packed_result.nelement()";
    "Fxn:self.assertEqual(packed_result,";
    "Fxn:test_blas_add";
    "Fxn:compare(fn,";
    "Fxn:compare(fn,";
    "Fxn:compare(fn,";
    "Fxn:test_blas";
    "Fxn:compare(fn,";
    "Fxn:test_blas(torch.mm,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:test_blas_add(torch.addmm,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:test_blas(torch.bmm,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas_add(torch.addbmm,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas_add(torch.baddbmm,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas(torch.mv,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(10)))";
    "Fxn:test_blas_add(torch.addmv,";
    "Fxn:Variable(torch.randn(2)),";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(10)))";
    "Fxn:test_blas(torch.ger,";
    "Fxn:Variable(torch.randn(5)),";
    "Fxn:Variable(torch.randn(6)))";
    "Fxn:test_blas_add(torch.addr,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5)),";
    "Fxn:Variable(torch.randn(6)))";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(6)),";
    "Fxn:Variable(torch.randn(6)))";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:Variable(torch.randn(4)))";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(5)),";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(10)))";
    "Fxn:test_blas(torch.matmul,";
    "Fxn:Variable(torch.randn(10)),";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:test_save_none_for_backward";
    "class:MyFn(Function):";
    "Fxn:forward";
    "Fxn:self.save_for_backward(None,";
    "Fxn:backward";
    "Fxn:test_case.assertIsNone(n1)";
    "Fxn:test_case.assertIsNone(n2)";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:MyFn()(x)";
    "Fxn:y.sum().backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_too_many_grads";
    "class:MyFn(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:MyFn()(x)";
    "Fxn:y.sum().backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:x.data.clone().fill_(1))";
    "Fxn:test_pickle";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:assert_strict_equal";
    "Fxn:self.assertEqual(var1.data,";
    "Fxn:self.assertEqual(var1.requires_grad,";
    "Fxn:[pickle.dumps([x,";
    "Fxn:pickle.loads(dump)";
    "Fxn:assert_strict_equal(xc,";
    "Fxn:assert_strict_equal(yc,";
    "Fxn:test_dep_nograd";
    "class:F1(Function):";
    "Fxn:forward";
    "Fxn:Variable(torch.randn(input.size()))";
    "Fxn:self.mark_non_differentiable(out)";
    "Fxn:backward";
    "class:F2(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:Variable(torch.randn(5),";
    "Fxn:F1()(x)";
    "Fxn:self.assertTrue(a.requires_grad)";
    "Fxn:self.assertFalse(b.requires_grad)";
    "Fxn:F2()(a,";
    "Fxn:c.backward(torch.ones(c.size()))";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:torch.ones(x.size()))";
    "Fxn:test_set_grad_enabled";
    "Fxn:torch.tensor([1],";
    "Fxn:torch.set_grad_enabled(False):";
    "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:torch.set_grad_enabled(True):";
    "Fxn:self.assertTrue(y.requires_grad)";
    "Fxn:torch.set_grad_enabled(False):";
    "Fxn:torch.set_grad_enabled(True)";
    "Fxn:self.assertTrue(y.requires_grad)";
    "Fxn:test_reentrant";
    "Fxn:torch.randn(2,";
    "class:Reenter(Function):";
    "Fxn:forward";
    "Fxn:torch.enable_grad():";
    "Fxn:Variable(x.data,";
    "Fxn:Variable(y_data,";
    "Fxn:ctx.output_var.detach()";
    "Fxn:backward";
    "Fxn:torch.enable_grad():";
    "Fxn:ctx.output_var.sum().backward()";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Reenter.apply(x)";
    "Fxn:out.sum().backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_cat";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:run_functional_checks(self,";
    "Fxn:torch.cat((a,";
    "Fxn:test_cat_negdim_1";
    "Fxn:Variable(torch.randn(S,";
    "Fxn:Variable(torch.randn(S,";
    "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:run_functional_checks(self,";
    "Fxn:torch.cat((a,";
    "Fxn:test_cat_negdim_2";
    "Fxn:Variable(torch.randn(S,";
    "Fxn:Variable(torch.randn(S,";
    "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:run_functional_checks(self,";
    "Fxn:torch.cat((a,";
    "Fxn:test_cat_empty";
    "Fxn:Variable(torch.randn(S,";
    "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:run_functional_checks(self,";
    "Fxn:torch.cat((a,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:torch.cat((a,";
    "Fxn:test_potrf";
    "Fxn:Variable(torch.tril(torch.rand(S,";
    "Fxn:run_test";
    "Fxn:func";
    "Fxn:torch.mm(root,";
    "Fxn:root.t())";
    "Fxn:torch.potrf(x,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:run_test(upper=True)";
    "Fxn:run_test(upper=False)";
    "Fxn:test_trtrs";
    "Fxn:_test_with_size";
    "Fxn:Variable(torch.rand(N,";
    "Fxn:Variable(torch.rand(N,";
    "Fxn:product((True,";
    "Fxn:func";
    "Fxn:torch.trtrs(b,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:_test_with_size(S,";
    "Fxn:_test_with_size(S,";
    "Fxn:test_variable_traverse";
    "Fxn:get_out_and_unrefed_cycle";
    "Fxn:Variable(torch.randn(10),";
    "Fxn:inp.view(10,";
    "Fxn:tmp.view(10)";
    "Fxn:my_list.append(tmp)";
    "Fxn:my_list.append(my_list)";
    "Fxn:get_out_and_unrefed_cycle()";
    "Fxn:gc.collect()";
    "Fxn:out.backward(torch.randn(out.size()))";
    "Fxn:test_norm_subgradient";
    "Fxn:run_test";
    "Fxn:Variable(torch.zeros(*input_size),";
    "Fxn:input.norm(norm_deg).backward()";
    "Fxn:self.assertEqual(input.grad.data.abs().sum(),";
    "Fxn:run_test((10,),";
    "Fxn:run_test((10,";
    "Fxn:run_test((10,),";
    "Fxn:run_test((10,),";
    "Fxn:run_test((10,),";
    "Fxn:test_profiler";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:profile()";
    "Fxn:self.assertEqual(len(p.function_events),";
    "Fxn:self.assertGreater(info.cpu_interval.start,";
    "Fxn:self.assertEqual(info.name,";
    "Fxn:test_dir";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:self.assertIn('shape',";
    "Fxn:self.assertTrue(hasattr(x,";
    "Fxn:test_as_strided";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:25).view(5,";
    "Fxn:as_strided";
    "Fxn:x.as_strided([3,";
    "Fxn:gradcheck(as_strided,";
    "Fxn:gradgradcheck(as_strided,";
    "Fxn:[Variable(torch.randn(3,";
    "Fxn:_test_where_functional";
    "Fxn:Variable(t(torch.randn(5,";
    "Fxn:Variable(t(torch.randn(5,";
    "Fxn:Variable(t(mask_not_all_zeros((5,";
    "Fxn:where";
    "Fxn:torch.where(cond,";
    "Fxn:gradcheck(where,";
    "Fxn:gradgradcheck(where,";
    "Fxn:[Variable(t(torch.randn(5,";
    "Fxn:Variable(t(torch.randn(5,";
    "Fxn:Variable(t(torch.randn(5,";
    "Fxn:gradcheck(where,";
    "Fxn:gradgradcheck(where,";
    "Fxn:[Variable(t(torch.randn(5,";
    "Fxn:test_where_functional";
    "Fxn:self._test_where_functional(lambda";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_where_functional_cuda";
    "Fxn:self._test_where_functional(lambda";
    "Fxn:t.cuda())";
    "Fxn:test_inplace_view_backprop_base";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:root.clone()";
    "Fxn:x.narrow(0,";
    "Fxn:v1.mul_(2)";
    "Fxn:x.sum().backward()";
    "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "Fxn:test_inplace_view_backprop_view_of_view";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:root.clone()";
    "Fxn:x.narrow(0,";
    "Fxn:x.narrow(0,";
    "Fxn:v1.mul_(2)";
    "Fxn:v2.sum().backward()";
    "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "Fxn:test_inplace_view_of_view";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:root.clone()";
    "Fxn:x.narrow(0,";
    "Fxn:v1.narrow(1,";
    "Fxn:v2.mul_(2)";
    "Fxn:x.sum().backward()";
    "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "Fxn:test_inplace_view_gradcheck";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:x.narrow(1,";
    "Fxn:2).narrow(0,";
    "Fxn:2).mul_(b)";
    "Fxn:x.narrow(1,";
    "Fxn:2).narrow(0,";
    "Fxn:2).mul_(b)";
    "Fxn:gradcheck(func,";
    "Fxn:Variable(torch.randn(a.size()),";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_inplace_view_makes_base_require_grad";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:self.assertFalse(x.requires_grad)";
    "Fxn:x.narrow(1,";
    "Fxn:2).mul_(b)";
    "Fxn:self.assertTrue(x.requires_grad)";
    "Fxn:gradcheck(func,";
    "Fxn:Variable(torch.randn(a.size()),";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_inplace_view_backprop_view";
    "Fxn:Variable(torch.Tensor([2,";
    "Fxn:Variable(torch.Tensor([3]),";
    "Fxn:a.narrow(0,";
    "Fxn:1).mul_(b)";
    "Fxn:res.sum().backward()";
    "Fxn:self.assertEqual(b.grad.data.tolist(),";
    "Fxn:self.assertIsNone(a.grad)";
    "Fxn:test_inplace_view_modify_base";
    "Fxn:Variable(torch.ones(1),";
    "Fxn:fn";
    "Fxn:Variable(torch.ones(5))";
    "Fxn:x.select(0,";
    "Fxn:self.assertFalse(v.requires_grad)";
    "Fxn:self.assertIsNone(v.grad_fn)";
    "Fxn:x.add_(r)";
    "Fxn:self.assertTrue(v.requires_grad)";
    "Fxn:gradcheck(fn,";
    "Fxn:gradgradcheck(fn,";
    "Fxn:test_inplace_view_python";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(2,";
    "class:PyAdd(torch.autograd.Function):";
    "Fxn:forward";
    "Fxn:ctx.mark_dirty(x)";
    "Fxn:x.add_(y)";
    "Fxn:backward";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:PyAdd.apply(x.narrow(1,";
    "Fxn:2).narrow(0,";
    "Fxn:PyAdd.apply(x.narrow(1,";
    "Fxn:2).narrow(0,";
    "Fxn:gradcheck(func,";
    "Fxn:Variable(torch.randn(a.size()),";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_inplace_view_non_contig";
    "Fxn:torch.ones(2,";
    "Fxn:2).select(2,";
    "Fxn:1).t()";
    "Fxn:Variable(data,";
    "Fxn:root.clone()";
    "Fxn:x.narrow(0,";
    "Fxn:v1.narrow(1,";
    "Fxn:v2.mul_(2)";
    "Fxn:x.sum().backward()";
    "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "Fxn:test_inplace_view_saved_output";
    "class:IncrementOnDelete(object):";
    "Fxn:__del__";
    "Fxn:test";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:root.clone()";
    "Fxn:copy.grad_fn.register_hook(IncrementOnDelete())";
    "Fxn:copy.view(9)";
    "Fxn:torch.nn.functional.relu(view,";
    "Fxn:test()";
    "Fxn:self.assertEqual(dealloc[0],";
    "Fxn:test_mul_out";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:torch.zeros_like(a)";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:torch.mul(a,";
    "Fxn:no_grad()";
    "Fxn:torch.no_grad():";
    "Fxn:torch.mul(a,";
    "Fxn:self.assertEqual(x,";
    "Fxn:test_mul_out_result_requires_grad";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.zeros(2,";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:torch.mul(a,";
    "Fxn:index_variable";
    "Fxn:torch.rand(*shape).mul_(max_indices).floor_().long()";
    "Fxn:index_perm_variable";
    "Fxn:torch.randperm(max_indices).narrow(0,";
    "Fxn:reduce(mul,";
    "Fxn:shape)).view(shape)";
    "Fxn:gather_variable";
    "Fxn:torch.LongTensor(*shape)";
    "Fxn:index.select(index_dim,";
    "Fxn:i).copy_(";
    "Fxn:torch.randperm(max_indices)[:shape[batch_dim]])";
    "Fxn:index.select(batch_dim,";
    "Fxn:0).copy_(index.select(batch_dim,";
    "Fxn:mask_not_all_zeros";
    "Fxn:torch.randn(shape).gt(0)";
    "Fxn:result.sum()";
    "Fxn:prod_zeros";
    "Fxn:torch.randn(dim_size,";
    "Fxn:result.narrow(dim_select[0],";
    "Fxn:1).narrow(dim_select[1],";
    "Fxn:1).zero_()";
    "Fxn:result.narrow(dim_select[0],";
    "Fxn:1).narrow(dim_select[1],";
    "Fxn:1).zero_()";
    "Fxn:result.narrow(dim_select[0],";
    "Fxn:1).narrow(dim_select[1],";
    "Fxn:1).zero_()";
    "Fxn:prod_single_zero";
    "Fxn:torch.randn(dim_size,";
    "Fxn:random_square_matrix_of_rank";
    "Fxn:torch.randn(l,";
    "Fxn:A.svd()";
    "Fxn:u.mm(torch.diag(s)).mm(v.transpose(0,";
    "Fxn:random_symmetric_matrix";
    "Fxn:torch.randn(l,";
    "Fxn:random_symmetric_psd_matrix";
    "Fxn:torch.randn(l,";
    "Fxn:A.mm(A.transpose(0,";
    "Fxn:random_symmetric_pd_matrix";
    "Fxn:torch.randn(l,";
    "Fxn:A.mm(A.transpose(0,";
    "Fxn:torch.eye(l)";
    "Fxn:make_nonzero_det";
    "Fxn:A.svd()";
    "Fxn:u.mm(torch.diag(s)).mm(v.t())";
    "Fxn:A.det().item()";
    "Fxn::].neg_()";
    "Fxn:random_fullrank_matrix_distinct_singular_value";
    "Fxn:torch.randn(l,";
    "Fxn:A.svd()";
    "Fxn:torch.arange(1,";
    "Fxn:1).mul_(1.0";
    "Fxn:u.mm(torch.diag(s)).mm(v.t())";
    "Fxn:uniform_scalar";
    "Fxn:torch.tensor(0).uniform_(0,";
    "Fxn:normal_scalar_clamp";
    "Fxn:torch.tensor(0).normal_().clamp(amin,";
    "Fxn:bernoulli_scalar";
    "Fxn:torch.tensor(0,";
    "Fxn:dtype=torch.uint8).bernoulli_()";
    "class:dont_convert(tuple):";
    "Fxn:create_input";
    "Fxn:map_arg";
    "Fxn:maybe_non_contig";
    "Fxn:make_non_contiguous(tensor)";
    "Fxn:torch.tensor(1).double().normal_()";
    "Fxn:torch.is_tensor(arg[0])";
    "Fxn:Variable(maybe_non_contig(torch.randn(*arg).double()),";
    "Fxn:maybe_non_contig(arg.tensor)";
    "Fxn:Variable(maybe_non_contig(arg.tensor))";
    "Fxn:arg.double()";
    "Fxn:maybe_non_contig(arg).detach()";
    "Fxn:v.is_floating_point()";
    "Fxn:map_arg(arg())";
    "Fxn:unpack_variables";
    "Fxn:exclude_tensor_method";
    "Fxn:gradgradcheck_method_precision_override";
    "Fxn:test_name.split("_broadcast")[0]";
    "Fxn:gradgradcheck_precision_override.get(non_broadcasted_test_name)";
    "Fxn:run_grad_and_gradgrad_checks";
    "Fxn:test_case.assertTrue(gradcheck(apply_method,";
    "Fxn:gradgradcheck_method_precision_override(test_name)";
    "Fxn:test_case.assertTrue(gradgradcheck(apply_method,";
    "Fxn:test_case.assertTrue(gradgradcheck(apply_method,";
    "Fxn:run_functional_checks";
    "Fxn:apply_fn(*f_args_variable)";
    "Fxn:run_grad_and_gradgrad_checks(test_case,";
    "Fxn:output_variable.backward(randn_like(output_variable))";
    "Fxn:test_case.assertEqual(self_variable.type(),";
    "Fxn:self_variable.grad.type())";
    "Fxn:test_case.assertEqual(self_variable.size(),";
    "Fxn:self_variable.grad.size())";
    "Fxn:product([-1,";
    "Fxn:repeat=len(dim_args_idx)):";
    "Fxn:dim_perm[dim_args_idx.index(i)]";
    "Fxn:''.join('_neg'";
    "Fxn:do_test";
    "Fxn:check";
    "Fxn:create_input((self_size,))[0]";
    "Fxn:create_input(args,";
    "Fxn:deepcopy(self_variable.data)";
    "Fxn:deepcopy(unpack_variables(args_variable))";
    "Fxn:name)(*args_variable)";
    "Fxn:exclude_tensor_method(name,";
    "Fxn:name)(*args_tensor)";
    "Fxn:torch.is_tensor(output_tensor)";
    "Fxn:torch.DoubleTensor((output_tensor,))";
    "Fxn:self.assertEqual(unpack_variables(output_variable),";
    "Fxn:fn";
    "Fxn:name)(*inputs[1:])";
    "Fxn:run_grad_and_gradgrad_checks(self,";
    "Fxn:fn";
    "Fxn:name)(*inputs)";
    "Fxn:run_functional_checks(self,";
    "Fxn:create_input((self_size,),";
    "Fxn:create_input(args,";
    "Fxn:name)(*args_variable)";
    "Fxn:output_variable.backward(randn_like(output_variable))";
    "Fxn:self.assertTrue(type(self_variable.data)";
    "Fxn:self.assertTrue(self_variable.size()";
    "Fxn:self_variable.grad.size())";
    "Fxn:name)(*args_variable)";
    "Fxn:deepcopy(self_variable)";
    "Fxn:deepcopy(args_variable)";
    "Fxn:inplace_name)(*inplace_args_variable_copy))";
    "Fxn:self.assertEqual(inplace_output_variable,";
    "Fxn:inp_i.grad.data.zero_()";
    "Fxn:i.grad.data.zero_()";
    "Fxn:randn_like(io).double()";
    "Fxn:io.backward(grad)";
    "Fxn:o.backward(grad)";
    "Fxn:self.assertEqual(inp_i.grad,";
    "Fxn:check(name)";
    "Fxn:check(inplace_name)";
    "Fxn:skip(do_test)";
    "Fxn:run_tests()";
    "/test/test_cpp_extensions.py";
    "Import:unittest";
    "Import:torch";
    "Import:torch.utils.cpp_extension";
    "Import:torch_test_cpp_extension";
    "Import:common";
    "class:TestCppExtension(common.TestCase):";
    "Fxn:test_extension_function";
    "Fxn:torch.randn(4,";
    "Fxn:torch.randn(4,";
    "Fxn:cpp_extension.sigmoid_add(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:x.sigmoid()";
    "Fxn:y.sigmoid())";
    "Fxn:test_extension_module";
    "Fxn:cpp_extension.MatrixMultiplier(4,";
    "Fxn:torch.rand(8,";
    "Fxn:mm.get().mm(weights)";
    "Fxn:mm.forward(weights)";
    "Fxn:self.assertEqual(expected,";
    "Fxn:test_backward";
    "Fxn:cpp_extension.MatrixMultiplier(4,";
    "Fxn:torch.rand(8,";
    "Fxn:mm.forward(weights)";
    "Fxn:result.sum().backward()";
    "Fxn:mm.get()";
    "Fxn:tensor.t().mm(torch.ones([4,";
    "Fxn:self.assertEqual(weights.grad,";
    "Fxn:torch.ones([4,";
    "Fxn:4]).mm(weights.t())";
    "Fxn:self.assertEqual(tensor.grad,";
    "Fxn:test_jit_compile_extension";
    "Fxn:torch.utils.cpp_extension.load(";
    "Fxn:torch.randn(4,";
    "Fxn:torch.randn(4,";
    "Fxn:module.tanh_add(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:x.tanh()";
    "Fxn:y.tanh())";
    "Fxn:module.exp_add(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:x.exp()";
    "Fxn:y.exp())";
    "Fxn:module.Doubler(2,";
    "Fxn:self.assertIsNone(doubler.get().grad)";
    "Fxn:self.assertEqual(doubler.get().sum(),";
    "Fxn:self.assertEqual(doubler.forward().sum(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_extension";
    "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:cuda_extension.sigmoid_add(x,";
    "Fxn:y).cpu()";
    "Fxn:sigmoid(0)";
    "Fxn:self.assertEqual(z,";
    "Fxn:torch.ones_like(z))";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_jit_cuda_extension";
    "Fxn:torch.utils.cpp_extension.load(";
    "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:module.sigmoid_add(x,";
    "Fxn:y).cpu()";
    "Fxn:sigmoid(0)";
    "Fxn:self.assertEqual(z,";
    "Fxn:torch.ones_like(z))";
    "Fxn:common.run_tests()";
    "Import:torch_test_cuda_extension";
    "/test/test_cuda.py";
    "Import:math";
    "Import:tempfile";
    "Import:import";
    "Import:unittest";
    "Import:repeat";
    "Import:torch";
    "Import:torch.cuda";
    "Import:torch.cuda.comm";
    "Import:TestTorch";
    "Import:TestCase,";
    "Fxn:is_floating";
    "Fxn:is_half";
    "Fxn:number";
    "Fxn:make_tensor";
    "Fxn:make_sparse_tensor";
    "Fxn:tensor_clamp";
    "Fxn:tensor_mul";
    "Fxn:tensor_abs_";
    "Fxn:constant_tensor_sub";
    "Fxn:constant_tensor_add";
    "Fxn:small_2d";
    "Fxn:small_2d_scaled";
    "Fxn:small_2d_oneish";
    "Fxn:small_3d";
    "Fxn:medium_1d";
    "Fxn:medium_2d";
    "Fxn:medium_2d_expanded";
    "Fxn:medium_2d_scaled";
    "Fxn:small_3d_ones";
    "Fxn:small_3d_positive";
    "Fxn:small_3d_unique";
    "Fxn:small_1d_lapack";
    "Fxn:small_2d_lapack";
    "Fxn:small_2d_lapack_skinny";
    "Fxn:small_2d_lapack_fat";
    "Fxn:large_2d_lapack";
    "Fxn:long_type";
    "Fxn:new_t";
    "Fxn:tmp";
    "Fxn:get_cycles_per_ms";
    "Fxn:compare_cpu_gpu";
    "Fxn:tmp";
    "class:TestCuda(TestCase):";
    "Fxn:_test_memory_stats_generator";
    "Fxn:torch.cuda.current_device()";
    "Fxn:torch.cuda.memory_allocated(device)";
    "Fxn:[torch.cuda.memory_allocated(device)]";
    "Fxn:[torch.cuda.max_memory_allocated(device)]";
    "Fxn:[torch.cuda.memory_cached(device)]";
    "Fxn:[torch.cuda.max_memory_cached(device)]";
    "Fxn:alloc";
    "Fxn:torch.cuda.device(device):";
    "Fxn:torch.cuda.FloatTensor(*size)";
    "Fxn:assert_change";
    "Fxn:torch.cuda.memory_allocated(device)";
    "Fxn:torch.cuda.max_memory_allocated(device)";
    "Fxn:self.assertGreater(new_m,";
    "Fxn:self.assertLess(new_m,";
    "Fxn:self.assertEqual(new_m,";
    "Fxn:self.assertLessEqual(new_m,";
    "Fxn:self.assertGreaterEqual(new_max_m,";
    "Fxn:torch.cuda.memory_cached(device)";
    "Fxn:torch.cuda.max_memory_cached(device)";
    "Fxn:self.assertLessEqual(new_c,";
    "Fxn:self.assertGreaterEqual(new_max_c,";
    "Fxn:torch.cuda.empty_cache()";
    "Fxn:torch.cuda.memory_cached(device)";
    "Fxn:torch.cuda.max_memory_cached(device)";
    "Fxn:self.assertLessEqual(new_c,";
    "Fxn:self.assertLessEqual(new_c,";
    "Fxn:self.assertEqual(new_max_c,";
    "Fxn:assert_change(0)";
    "Fxn:assert_change(0)";
    "Fxn:[alloc(1),";
    "Fxn:alloc(10,";
    "Fxn:alloc(200,";
    "Fxn:torch.cuda.memory_allocated(device)";
    "Fxn:assert_change(1)";
    "Fxn:tensors2.append(alloc(i,";
    "Fxn:assert_change(1)";
    "Fxn:tensors2.append(alloc(i,";
    "Fxn:assert_change(1)";
    "Fxn:tensors2.append(alloc(0,";
    "Fxn:assert_change(0)";
    "Fxn:torch.randperm(len(tensors2)):";
    "Fxn:permute.append(tensors2[i])";
    "Fxn:assert_change(0)";
    "Fxn:assert_change(0)";
    "Fxn:assert_change(0)";
    "Fxn:assert_change(0)";
    "Fxn:tensors2[i].numel()";
    "Fxn:assert_change(-x)";
    "Fxn:tensors2.append(alloc(i,";
    "Fxn:assert_change(1)";
    "Fxn:assert_change(-1)";
    "Fxn:assert_change(0)";
    "Fxn:self.assertEqual(torch.cuda.memory_allocated(device),";
    "Fxn:assert_change(-1)";
    "Fxn:self.assertEqual(torch.cuda.memory_allocated(device),";
    "Fxn:assert_change(0,";
    "Fxn:test_memory_stats";
    "Fxn:torch.cuda.empty_cache()";
    "Fxn:self._test_memory_stats_generator(self):";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_memory_stats_multigpu";
    "Fxn:advance";
    "Fxn:torch.cuda.empty_cache()";
    "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:advance(gen0,";
    "Fxn:advance(gen1,";
    "Fxn:torch.cuda.empty_cache()";
    "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:advance(gen0,";
    "Fxn:torch.LongTensor(1).random_(0,";
    "Fxn:advance(gen1,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_autogpu";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda()";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda()";
    "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:torch.cuda.device(1):";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda()";
    "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:x.add(y)";
    "Fxn:self.assertEqual(q.get_device(),";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda()";
    "Fxn:self.assertEqual(w.get_device(),";
    "Fxn:self.assertEqual(y.cuda().get_device(),";
    "Fxn:self.assertEqual(y.cuda(-1).get_device(),";
    "Fxn:z.cuda()";
    "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_new";
    "Fxn:torch.randn(3,";
    "Fxn:3).cuda()";
    "Fxn:self.assertEqual(x.new([0,";
    "Fxn:2]).get_device(),";
    "Fxn:self.assertEqual(x.new([0,";
    "Fxn:device=1).get_device(),";
    "Fxn:x.new(dtype=torch.cuda.int64,";
    "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:self.assertIs(y.dtype,";
    "Fxn:x.new(dtype=torch.int64)";
    "Fxn:self.assertIs(y.dtype,";
    "Fxn:x.new(1,";
    "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:self.assertIs(y.dtype,";
    "Fxn:x.new(1,";
    "Fxn:self.assertIs(y.dtype,";
    "Fxn:x.new([0,";
    "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:self.assertIs(y.dtype,";
    "Fxn:x.new([0,";
    "Fxn:self.assertIs(y.dtype,";
    "Fxn:torch.cuda.device(1):";
    "Fxn:self.assertEqual(x.new([0,";
    "Fxn:2]).get_device(),";
    "Fxn:self.assertEqual(x.new([0,";
    "Fxn:device=1).get_device(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_copy_device";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda()";
    "Fxn:torch.cuda.device(1):";
    "Fxn:x.cuda()";
    "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:self.assertIs(y.cuda(),";
    "Fxn:y.cuda(0)";
    "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:self.assertIs(z.cuda(0),";
    "Fxn:torch.randn(5,";
    "Fxn:torch.cuda.device(1):";
    "Fxn:x.cuda()";
    "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:self.assertIs(y.cuda(),";
    "Fxn:y.cuda(0)";
    "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:self.assertIs(z.cuda(0),";
    "Fxn:test_serialization_array_with_storage";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda()";
    "Fxn:torch.IntTensor(2,";
    "Fxn:5).fill_(0).cuda()";
    "Fxn:y.storage()]";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(q,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertEqual(q_copy,";
    "Fxn:q_copy[0].fill_(5)";
    "Fxn:self.assertEqual(q_copy[0],";
    "Fxn:self.assertTrue(isinstance(q_copy[0],";
    "Fxn:self.assertTrue(isinstance(q_copy[1],";
    "Fxn:self.assertTrue(isinstance(q_copy[2],";
    "Fxn:self.assertTrue(isinstance(q_copy[3],";
    "Fxn:q_copy[1].fill_(10)";
    "Fxn:self.assertTrue(q_copy[3],";
    "Fxn:torch.cuda.IntStorage(10).fill_(10))";
    "Fxn:test_type_conversions";
    "Fxn:torch.randn(5,";
    "Fxn:self.assertIsInstance(x.float(),";
    "Fxn:self.assertIsInstance(x.cuda(),";
    "Fxn:self.assertIsInstance(x.cuda().float(),";
    "Fxn:self.assertIsInstance(x.cuda().float().cpu(),";
    "Fxn:self.assertIsInstance(x.cuda().float().cpu().int(),";
    "Fxn:x.storage()";
    "Fxn:self.assertIsInstance(y.float(),";
    "Fxn:self.assertIsInstance(y.cuda(),";
    "Fxn:self.assertIsInstance(y.cuda().float(),";
    "Fxn:self.assertIsInstance(y.cuda().float().cpu(),";
    "Fxn:self.assertIsInstance(y.cuda().float().cpu().int(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_type_conversions_same_gpu";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda(1)";
    "Fxn:self.assertEqual(x.int().get_device(),";
    "Fxn:test_neg";
    "Fxn:TestTorch._test_neg(self,";
    "Fxn:t.cuda())";
    "Fxn:_test_broadcast";
    "Fxn:torch.cuda.device_count()";
    "Fxn:unittest.SkipTest("only";
    "Fxn:comm.broadcast(input,";
    "Fxn:self.assertEqual(t.get_device(),";
    "Fxn:self.assertEqual(t,";
    "Fxn:test_broadcast_cpu";
    "Fxn:self._test_broadcast(torch.randn(5,";
    "Fxn:test_broadcast_gpu";
    "Fxn:self._test_broadcast(torch.randn(5,";
    "Fxn:5).cuda())";
    "Fxn:_test_broadcast_coalesced";
    "Fxn:[comm.broadcast(t,";
    "Fxn:self.assertEqual(bt.get_device(),";
    "Fxn:self.assertEqual(bt,";
    "Fxn:self.assertIsInstance(bt,";
    "Fxn:comm.broadcast_coalesced(tensors,";
    "Fxn:self.assertEqual(b_tensors,";
    "Fxn:self.assertEqual(bt.get_device(),";
    "Fxn:bct.get_device())";
    "Fxn:self.assertIsInstance(bct,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_broadcast_coalesced";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.FloatTensor,";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:torch.randn(numel";
    "Fxn:2).int().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:self._test_broadcast_coalesced(self,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_broadcast_coalesced_dense_only";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel";
    "Fxn:2).int().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:self._test_broadcast_coalesced(self,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_reduce_add";
    "Fxn:torch.randn(5,";
    "Fxn:torch.randn(5,";
    "Fxn:x.cuda(0)";
    "Fxn:y.cuda(1)";
    "Fxn:comm.reduce_add((x_cuda,";
    "Fxn:self.assertEqual(result.get_device(),";
    "Fxn:self.assertEqual(result.cpu(),";
    "Fxn:_test_reduce_add_coalesced";
    "Fxn:t.cuda(1),";
    "Fxn:self.assertEqual(r.get_device(),";
    "Fxn:t.get_device())";
    "Fxn:self.assertEqual(r,";
    "Fxn:self.assertEqual(r.type(),";
    "Fxn:t.type())";
    "Fxn:comm.reduce_add_coalesced(dup_tensors,";
    "Fxn:self.assertEqual(r_tensors,";
    "Fxn:self.assertEqual(rc.get_device(),";
    "Fxn:r.get_device())";
    "Fxn:self.assertEqual(rc.type(),";
    "Fxn:r.type())";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_reduce_add_coalesced";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.FloatTensor,";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:torch.randn(numel";
    "Fxn:2).int().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:self._test_reduce_add_coalesced(self,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_reduce_add_coalesced_dense_only";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:torch.randn(numel";
    "Fxn:2).int().cuda(),";
    "Fxn:torch.randn(numel).cuda(),";
    "Fxn:self._test_reduce_add_coalesced(self,";
    "Fxn:_test_scatter";
    "Fxn:torch.cuda.device_count()";
    "Fxn:unittest.SkipTest("only";
    "Fxn:comm.scatter(input,";
    "Fxn:self.assertEqual(len(result),";
    "Fxn:[slice(None,";
    "Fxn:self.assertEqual(r,";
    "Fxn:input[tuple(index)],";
    "Fxn:test_scatter_cpu";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_cpu_dim";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_cpu_neg_dim";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_cpu_sizes";
    "Fxn:self._test_scatter(torch.randn(6,";
    "Fxn:chunk_sizes=(2,";
    "Fxn:test_scatter_gpu";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:4).cuda(),";
    "Fxn:test_scatter_gpu_dim";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:4).cuda(),";
    "Fxn:test_scatter_gpu_neg_dim";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:4).cuda(),";
    "Fxn:test_scatter_gpu_sizes";
    "Fxn:self._test_scatter(torch.randn(6,";
    "Fxn:4).cuda(),";
    "Fxn:chunk_sizes=(2,";
    "Fxn:_test_gather";
    "Fxn:torch.cuda.device_count()";
    "Fxn:unittest.SkipTest("only";
    "Fxn:torch.randn(2,";
    "Fxn:5).cuda(0)";
    "Fxn:torch.randn(2,";
    "Fxn:5).cuda(1)";
    "Fxn:comm.gather((x,";
    "Fxn:y.size(dim)";
    "Fxn:torch.Size(expected_size)";
    "Fxn:self.assertEqual(result.get_device(),";
    "Fxn:self.assertEqual(result.size(),";
    "Fxn:[slice(None,";
    "Fxn:x.size(dim))";
    "Fxn:self.assertEqual(result[tuple(index)],";
    "Fxn:x.size(dim)";
    "Fxn:y.size(dim))";
    "Fxn:self.assertEqual(result[tuple(index)],";
    "Fxn:test_gather";
    "Fxn:self._test_gather(0)";
    "Fxn:test_gather_dim";
    "Fxn:self._test_gather(1)";
    "Fxn:test_from_sequence";
    "Fxn:[list(range(i";
    "Fxn:torch.arange(0,";
    "Fxn:20).resize_(5,";
    "Fxn:get_gpu_type(t)";
    "Fxn:self.assertEqual(cuda_type(seq),";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices";
    "Fxn:freeze_rng_state():";
    "Fxn:torch.zeros(4,";
    "Fxn:4).float().cuda()";
    "Fxn:torch.manual_seed(2)";
    "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:x.uniform_()";
    "Fxn:torch.manual_seed(2)";
    "Fxn:x.clone().uniform_()";
    "Fxn:self.assertEqual(x,";
    "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:test_manual_seed";
    "Fxn:freeze_rng_state():";
    "Fxn:torch.zeros(4,";
    "Fxn:4).float().cuda()";
    "Fxn:torch.cuda.manual_seed(2)";
    "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:x.uniform_()";
    "Fxn:torch.cuda.manual_seed(2)";
    "Fxn:x.clone().uniform_()";
    "Fxn:self.assertEqual(x,";
    "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_cat_autogpu";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda(1)";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda(1)";
    "Fxn:torch.cat([x,";
    "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:x.get_device())";
    "Fxn:test_cat";
    "Fxn:torch.rand(13,";
    "Fxn:SIZE).transpose(0,";
    "Fxn:pos_dim).cuda()";
    "Fxn:torch.rand(17,";
    "Fxn:SIZE).transpose(0,";
    "Fxn:pos_dim).cuda()";
    "Fxn:torch.rand(19,";
    "Fxn:SIZE).transpose(0,";
    "Fxn:pos_dim).cuda()";
    "Fxn:torch.cat((x,";
    "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:torch.randn(20,";
    "Fxn:SIZE).cuda()";
    "Fxn:self.assertEqual(torch.cat(torch.split(x,";
    "Fxn:self.assertEqual(torch.cat(torch.chunk(x,";
    "Fxn:torch.randn(1,";
    "Fxn:SIZE).cuda()";
    "Fxn:torch.cat([x,";
    "Fxn:self.assertEqual(z.size(),";
    "Fxn:test_bernoulli";
    "Fxn:torch.tensor([0,";
    "Fxn:self.assertEqual(x.bernoulli().tolist(),";
    "Fxn:test_cat_bad_input_sizes";
    "Fxn:torch.randn(2,";
    "Fxn:1).cuda()";
    "Fxn:torch.randn(2,";
    "Fxn:1).cuda()";
    "Fxn:torch.randn(2,";
    "Fxn:1).cuda()";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.cat([x,";
    "Fxn:torch.randn(2,";
    "Fxn:2).cuda()";
    "Fxn:torch.randn(2,";
    "Fxn:1).cuda()";
    "Fxn:torch.randn(2,";
    "Fxn:1).cuda()";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.cat([x,";
    "Fxn:test_serialization";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda()";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(x,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertEqual(x_copy,";
    "Fxn:self.assertIs(type(x_copy),";
    "Fxn:self.assertEqual(x_copy.get_device(),";
    "Fxn:x.get_device())";
    "Fxn:test_serialization_array_with_empty";
    "Fxn:[torch.randn(4,";
    "Fxn:4).cuda(),";
    "Fxn:torch.cuda.FloatTensor()]";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(x,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertEqual(copy,";
    "Fxn:self.assertIs(type(copy),";
    "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:original.get_device())";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_multigpu_serialization";
    "Fxn:[torch.randn(4,";
    "Fxn:4).cuda(0),";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda(1)]";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(x,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertEqual(copy,";
    "Fxn:self.assertIs(type(copy),";
    "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:original.get_device())";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_multigpu_serialization_remap";
    "Fxn:[torch.randn(4,";
    "Fxn:4).cuda(0),";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda(1)]";
    "Fxn:gpu_remap";
    "Fxn:storage.cuda(0)";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(x,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f,";
    "Fxn:self.assertEqual(copy,";
    "Fxn:self.assertIs(type(copy),";
    "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_multigpu_serialization_remap_dict";
    "Fxn:[torch.randn(4,";
    "Fxn:4).cuda(0),";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda(1)]";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(x,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f,";
    "Fxn:self.assertEqual(copy,";
    "Fxn:self.assertIs(type(copy),";
    "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_cuda_set_device";
    "Fxn:torch.randn(5,";
    "Fxn:torch.cuda.device(1):";
    "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:torch.cuda.set_device(0)";
    "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:torch.cuda.device(1):";
    "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:torch.cuda.set_device(1)";
    "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:test_is_tensor";
    "Fxn:get_gpu_type(t)()";
    "Fxn:self.assertTrue(torch.is_tensor(tensor))";
    "Fxn:self.assertTrue(torch.is_tensor(torch.cuda.HalfTensor()))";
    "Fxn:test_cuda_synchronize";
    "Fxn:torch.cuda.synchronize()";
    "Fxn:test_streams";
    "Fxn:torch.cuda.current_stream()";
    "Fxn:torch.cuda.Stream()";
    "Fxn:self.assertEqual(torch.cuda.current_stream(),";
    "Fxn:self.assertNotEqual(default_stream,";
    "Fxn:self.assertEqual(default_stream.cuda_stream,";
    "Fxn:self.assertNotEqual(user_stream.cuda_stream,";
    "Fxn:torch.cuda.stream(user_stream):";
    "Fxn:self.assertEqual(torch.cuda.current_stream(),";
    "Fxn:self.assertTrue(user_stream.query())";
    "Fxn:torch.ByteTensor(10000000).pin_memory()";
    "Fxn:tensor1.cuda(non_blocking=True)";
    "Fxn:self.assertFalse(default_stream.query())";
    "Fxn:default_stream.synchronize()";
    "Fxn:self.assertTrue(default_stream.query())";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_streams_multi_gpu";
    "Fxn:torch.cuda.current_stream()";
    "Fxn:self.assertEqual(default_stream.device,";
    "Fxn:torch.cuda.Stream(device=1)";
    "Fxn:self.assertEqual(stream.device,";
    "Fxn:torch.cuda.device(1):";
    "Fxn:self.assertEqual(torch.cuda.current_stream().device,";
    "Fxn:self.assertNotEqual(torch.cuda.current_stream(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_tensor_device";
    "Fxn:self.assertEqual(torch.cuda.FloatTensor(1).get_device(),";
    "Fxn:self.assertEqual(torch.cuda.FloatTensor(1,";
    "Fxn:device=1).get_device(),";
    "Fxn:torch.cuda.device(1):";
    "Fxn:self.assertEqual(torch.cuda.FloatTensor(1).get_device(),";
    "Fxn:self.assertEqual(torch.cuda.FloatTensor(1,";
    "Fxn:device=0).get_device(),";
    "Fxn:self.assertEqual(torch.cuda.FloatTensor(1,";
    "Fxn:device=None).get_device(),";
    "Fxn:test_events";
    "Fxn:torch.cuda.current_stream()";
    "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:self.assertTrue(event.query())";
    "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:stream.record_event(start_event)";
    "Fxn:torch.cuda._sleep(int(50";
    "Fxn:get_cycles_per_ms()))";
    "Fxn:stream.record_event(event)";
    "Fxn:self.assertFalse(event.query())";
    "Fxn:event.synchronize()";
    "Fxn:self.assertTrue(event.query())";
    "Fxn:self.assertGreater(start_event.elapsed_time(event),";
    "Fxn:test_record_stream";
    "Fxn:get_cycles_per_ms()";
    "Fxn:torch.FloatTensor([1,";
    "Fxn:4]).pin_memory()";
    "Fxn:torch.cuda.FloatTensor(t.size())";
    "Fxn:torch.cuda.Stream()";
    "Fxn:perform_copy";
    "Fxn:torch.cuda.stream(stream):";
    "Fxn:t.cuda(non_blocking=True)";
    "Fxn:tmp.data_ptr()";
    "Fxn:torch.cuda.current_stream().wait_stream(stream)";
    "Fxn:tmp.record_stream(torch.cuda.current_stream())";
    "Fxn:torch.cuda._sleep(int(50";
    "Fxn:result.copy_(tmp)";
    "Fxn:perform_copy()";
    "Fxn:torch.cuda.stream(stream):";
    "Fxn:torch.cuda.FloatTensor(t.size())";
    "Fxn:tmp2.zero_()";
    "Fxn:self.assertNotEqual(tmp2.data_ptr(),";
    "Fxn:self.assertEqual(result.tolist(),";
    "Fxn:torch.cuda.current_stream().synchronize()";
    "Fxn:torch.cuda.stream(stream):";
    "Fxn:torch.cuda.FloatTensor(t.size())";
    "Fxn:self.assertEqual(tmp3.data_ptr(),";
    "Fxn:test_noncontiguous_pinned_memory";
    "Fxn:torch.arange(0,";
    "Fxn:10).view((2,";
    "Fxn:self.assertEqual(x.t(),";
    "Fxn:x.t().pin_memory())";
    "Fxn:test_caching_pinned_memory";
    "Fxn:get_cycles_per_ms()";
    "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:t.data_ptr()";
    "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:self.assertEqual(t.data_ptr(),";
    "Fxn:torch.cuda.FloatTensor([0])";
    "Fxn:torch.cuda._sleep(int(50";
    "Fxn:gpu_tensor.copy_(t,";
    "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:self.assertNotEqual(t.data_ptr(),";
    "Fxn:self.assertEqual(list(gpu_tensor),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_caching_pinned_memory_multi_gpu";
    "Fxn:get_cycles_per_ms()";
    "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:t.data_ptr()";
    "Fxn:torch.cuda.FloatTensor([0],";
    "Fxn:torch.cuda.FloatTensor([0],";
    "Fxn:torch.cuda.device(1):";
    "Fxn:torch.cuda._sleep(int(50";
    "Fxn:gpu_tensor1.copy_(t,";
    "Fxn:torch.FloatTensor([2]).pin_memory()";
    "Fxn:self.assertNotEqual(t.data_ptr(),";
    "Fxn:torch.cuda.device(0):";
    "Fxn:gpu_tensor0.copy_(t,";
    "Fxn:self.assertEqual(gpu_tensor1[0],";
    "Fxn:self.assertEqual(gpu_tensor0[0],";
    "Fxn:_select_broadcastable_dims";
    "Fxn:TestTorch._select_broadcastable_dims(dims_full)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_det_logdet_slogdet";
    "Fxn:TestTorch._test_det_logdet_slogdet(self,";
    "Fxn:t.cuda())";
    "Fxn:test_view";
    "Fxn:TestTorch._test_view(self,";
    "Fxn:t.cuda())";
    "Fxn:test_stft";
    "Fxn:TestTorch._test_stft(self,";
    "Fxn:t.cuda())";
    "Fxn:test_multinomial";
    "Fxn:TestTorch._test_multinomial(self,";
    "Fxn:test_broadcast";
    "Fxn:TestTorch._test_broadcast(self,";
    "Fxn:t.cuda())";
    "Fxn:test_contiguous";
    "Fxn:TestTorch._test_contiguous(self,";
    "Fxn:t.cuda())";
    "Fxn:test_broadcast_fused_matmul";
    "Fxn:TestTorch._test_broadcast_fused_matmul(self,";
    "Fxn:t.cuda())";
    "Fxn:test_broadcast_batched_matmul";
    "Fxn:TestTorch._test_broadcast_batched_matmul(self,";
    "Fxn:t.cuda())";
    "Fxn:test_index";
    "Fxn:TestTorch._test_index(self,";
    "Fxn:t.cuda())";
    "Fxn:test_advancedindex";
    "Fxn:TestTorch._test_advancedindex(self,";
    "Fxn:t.cuda())";
    "Fxn:test_advancedindex_mixed_cpu_cuda";
    "Fxn:test";
    "Fxn:self.assertEqual(x[:,";
    "Fxn:0].cpu(),";
    "Fxn:x.cpu()[:,";
    "Fxn:ia.cpu(),";
    "Fxn:ib.cpu(),";
    "Fxn:self.assertEqual(x[ia],";
    "Fxn:x.cpu()[ia.cpu()])";
    "Fxn:torch.randn(3,";
    "Fxn:torch.cuda.LongTensor([0,";
    "Fxn:torch.cuda.LongTensor([0,";
    "Fxn:test(x,";
    "Fxn:x.cuda()";
    "Fxn:ia.cpu()";
    "Fxn:ib.cpu()";
    "Fxn:test(x,";
    "Fxn:x.cpu()";
    "Fxn:ia.cpu()";
    "Fxn:ib.cuda()";
    "Fxn:test(x,";
    "Fxn:x.cuda()";
    "Fxn:ia.cpu()";
    "Fxn:ib.cuda()";
    "Fxn:test(x,";
    "Fxn:test_advancedindex_big";
    "Fxn:TestTorch._test_advancedindex_big(self,";
    "Fxn:t.cuda())";
    "Fxn:test_btrifact";
    "Fxn:TestTorch._test_btrifact(self,";
    "Fxn:t.cuda())";
    "Fxn:test_btrisolve";
    "Fxn:TestTorch._test_btrisolve(self,";
    "Fxn:t.cuda())";
    "Fxn:test_dim_reduction";
    "Fxn:TestTorch._test_dim_reduction(self,";
    "Fxn:t.cuda())";
    "Fxn:test_tensor_gather";
    "Fxn:TestTorch._test_gather(self,";
    "Fxn:t.cuda(),";
    "Fxn:test_tensor_scatter";
    "Fxn:TestTorch._test_scatter_base(self,";
    "Fxn:t.cuda(),";
    "Fxn:test_tensor_scatterAdd";
    "Fxn:TestTorch._test_scatter_base(self,";
    "Fxn:t.cuda(),";
    "Fxn:test_tensor_scatterFill";
    "Fxn:TestTorch._test_scatter_base(self,";
    "Fxn:t.cuda(),";
    "Fxn:test_min_max_inits";
    "Fxn:torch.cuda.ByteTensor([0])";
    "Fxn:torch.cuda.ByteTensor([255])";
    "Fxn:torch.cuda.LongTensor([0])[0]";
    "Fxn:x.max(dim=0)";
    "Fxn:self.assertEqual(v,";
    "Fxn:y.min(dim=0)";
    "Fxn:self.assertEqual(v,";
    "Fxn:test_int_pow";
    "Fxn:TestTorch._test_int_pow(self,";
    "Fxn:x.cuda())";
    "Fxn:test_var";
    "Fxn:torch.randn(2,";
    "Fxn:cpu_tensor.cuda()";
    "Fxn:self.assertEqual(gpu_tensor.var(),";
    "Fxn:cpu_tensor.var())";
    "Fxn:self.assertEqual(gpu_tensor.var(1),";
    "Fxn:cpu_tensor.var(1))";
    "Fxn:self.assertEqual(gpu_tensor.var(2),";
    "Fxn:cpu_tensor.var(2))";
    "Fxn:self.assertEqual(gpu_tensor.std(),";
    "Fxn:cpu_tensor.std())";
    "Fxn:self.assertEqual(gpu_tensor.std(1),";
    "Fxn:cpu_tensor.std(1))";
    "Fxn:self.assertEqual(gpu_tensor.var(2),";
    "Fxn:cpu_tensor.var(2))";
    "Fxn:torch.randn(100)";
    "Fxn:cpu_tensor.cuda()";
    "Fxn:self.assertEqual(gpu_tensor.var(),";
    "Fxn:cpu_tensor.var())";
    "Fxn:test_var_unbiased";
    "Fxn:torch.randn(100).cuda()";
    "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:tensor.var(0,";
    "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:tensor.var(unbiased=True))";
    "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:tensor.var(0,";
    "Fxn:torch.FloatTensor([1.0,";
    "Fxn:2.0]).cuda()";
    "Fxn:self.assertEqual(tensor.var(unbiased=True),";
    "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:torch.randn(100).cuda()";
    "Fxn:self.assertEqual(tensor.std(0),";
    "Fxn:tensor.std(0,";
    "Fxn:self.assertEqual(tensor.std(),";
    "Fxn:tensor.std(unbiased=True))";
    "Fxn:self.assertEqual(tensor.std(unbiased=False),";
    "Fxn:tensor.std(0,";
    "Fxn:test_var_large_input";
    "Fxn:torch.randn(2";
    "Fxn:tensor_cpu.cuda()";
    "Fxn:self.assertEqual(tensor_cpu.var(2),";
    "Fxn:tensor_cuda.var(2).cpu())";
    "Fxn:test_var_stability";
    "Fxn:torch.FloatTensor([2281.5,";
    "Fxn:2281.25]).cuda()";
    "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:tensor.unsqueeze(1)";
    "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:test_digamma";
    "Fxn:test";
    "Fxn:torch.randn(10,";
    "Fxn:cpu_tensor.cuda()";
    "Fxn:torch.zeros(10,";
    "Fxn:cpu_tensor.double()";
    "Fxn:gpu_tensor.double()";
    "Fxn:zeros.double()";
    "Fxn:cpu_tensor.digamma()";
    "Fxn:gpu_tensor.digamma()";
    "Fxn:cpu_out.cuda())";
    "Fxn:self.assertEqual(norm_errors,";
    "Fxn:test(True)";
    "Fxn:test(False)";
    "Fxn:test_polygamma";
    "Fxn:test";
    "Fxn:torch.randn(10,";
    "Fxn:cpu_tensor.cuda()";
    "Fxn:torch.zeros(10,";
    "Fxn:cpu_tensor.double()";
    "Fxn:gpu_tensor.double()";
    "Fxn:zeros.double()";
    "Fxn:cpu_tensor.polygamma(n)";
    "Fxn:gpu_tensor.polygamma(n)";
    "Fxn:cpu_out.cuda())";
    "Fxn:self.assertEqual(norm_errors,";
    "Fxn:test(True)";
    "Fxn:test(False)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_symeig";
    "Fxn:torch.randn(3,";
    "Fxn:3).cuda()";
    "Fxn:torch.mm(tensor,";
    "Fxn:tensor.t())";
    "Fxn:torch.symeig(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:torch.mm(torch.mm(eigvec,";
    "Fxn:eigval.diag()),";
    "Fxn:eigvec.t()))";
    "Fxn:torch.randn(257,";
    "Fxn:257).cuda()";
    "Fxn:torch.mm(tensor,";
    "Fxn:tensor.t())";
    "Fxn:torch.symeig(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:torch.mm(torch.mm(eigvec,";
    "Fxn:eigval.diag()),";
    "Fxn:eigvec.t()))";
    "Fxn:test_arange";
    "Fxn:torch.cuda.__dict__[t]()";
    "Fxn:torch.arange(0,";
    "Fxn:torch.__dict__[t]()";
    "Fxn:torch.arange(0,";
    "Fxn:self.assertEqual(a,";
    "Fxn:b.cuda())";
    "Fxn:test_diagonal";
    "Fxn:TestTorch._test_diagonal(self,";
    "Fxn:test_diagflat";
    "Fxn:TestTorch._test_diagflat(self,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_get_set_rng_state_all";
    "Fxn:torch.cuda.get_rng_state_all()";
    "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:device=0).normal_()";
    "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:device=1).normal_()";
    "Fxn:torch.cuda.set_rng_state_all(states)";
    "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:device=0).normal_()";
    "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:device=1).normal_()";
    "Fxn:self.assertEqual(before0,";
    "Fxn:self.assertEqual(before1,";
    "Fxn:test_nvtx";
    "Fxn:torch.cuda.nvtx.range_push("foo")";
    "Fxn:torch.cuda.nvtx.mark("bar")";
    "Fxn:torch.cuda.nvtx.range_pop()";
    "Fxn:load_ignore_file";
    "Fxn:join(dirname(__file__),";
    "Fxn:f.read().splitlines()";
    "Fxn:l.startswith('#')}";
    "Fxn:generate_tests";
    "Fxn:custom_precision.get(name,";
    "Fxn:custom_half_precision.get(name,";
    "Fxn:'{}.{}'.format(tensor.type(),";
    "Fxn:compare_cpu_gpu(constr,";
    "Fxn:load_ignore_file()";
    "Fxn:generate_tests()";
    "Fxn:run_tests()";
    "Import:join,";
    "/test/test_dataloader.py";
    "Import:math";
    "Import:sys";
    "Import:errno";
    "Import:import";
    "Import:ctypes";
    "Import:signal";
    "Import:torch";
    "Import:time";
    "Import:traceback";
    "Import:unittest";
    "Import:multiprocessing";
    "Import:Dataset,";
    "Import:random_split";
    "Import:default_collate,";
    "Import:TestCase,";
    "Import:TEST_CUDA";
    "class:TestDatasetRandomSplit(TestCase):";
    "Fxn:test_lengths_must_equal_datset_size";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:random_split([1,";
    "Fxn:test_splits_have_correct_size";
    "Fxn:random_split([1,";
    "Fxn:self.assertEqual(len(splits),";
    "Fxn:self.assertEqual(len(splits[0]),";
    "Fxn:self.assertEqual(len(splits[1]),";
    "Fxn:test_splits_are_mutually_exclusive";
    "Fxn:random_split(data,";
    "Fxn:all_values.extend(list(splits[0]))";
    "Fxn:all_values.extend(list(splits[1]))";
    "Fxn:data.sort()";
    "Fxn:all_values.sort()";
    "Fxn:self.assertListEqual(data,";
    "class:TestTensorDataset(TestCase):";
    "Fxn:test_len";
    "Fxn:TensorDataset(torch.randn(15,";
    "Fxn:torch.randperm(15))";
    "Fxn:self.assertEqual(len(source),";
    "Fxn:test_getitem";
    "Fxn:torch.randn(15,";
    "Fxn:torch.randn(15,";
    "Fxn:TensorDataset(t,";
    "Fxn:self.assertEqual(t[i],";
    "Fxn:self.assertEqual(l[i],";
    "Fxn:test_getitem_1d";
    "Fxn:torch.randn(15)";
    "Fxn:torch.randn(15)";
    "Fxn:TensorDataset(t,";
    "Fxn:self.assertEqual(t[i],";
    "Fxn:self.assertEqual(l[i],";
    "class:TestConcatDataset(TestCase):";
    "Fxn:test_concat_two_singletons";
    "Fxn:ConcatDataset([[0],";
    "Fxn:self.assertEqual(2,";
    "Fxn:self.assertEqual(0,";
    "Fxn:self.assertEqual(1,";
    "Fxn:test_concat_two_non_singletons";
    "Fxn:ConcatDataset([[0,";
    "Fxn:self.assertEqual(10,";
    "Fxn:self.assertEqual(0,";
    "Fxn:self.assertEqual(5,";
    "Fxn:test_concat_two_non_singletons_with_empty";
    "Fxn:ConcatDataset([[0,";
    "Fxn:self.assertEqual(10,";
    "Fxn:self.assertEqual(0,";
    "Fxn:self.assertEqual(5,";
    "Fxn:test_concat_raises_index_error";
    "Fxn:ConcatDataset([[0,";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:test_add_dataset";
    "Fxn:TensorDataset(torch.rand(7,";
    "Fxn:torch.rand(7))";
    "Fxn:TensorDataset(torch.rand(7,";
    "Fxn:torch.rand(7))";
    "Fxn:TensorDataset(torch.rand(7,";
    "Fxn:torch.rand(7))";
    "Fxn:self.assertEqual(21,";
    "Fxn:self.assertEqual(0,";
    "Fxn:result[0][0]).abs().sum())";
    "Fxn:self.assertEqual(0,";
    "Fxn:result[7][0]).abs().sum())";
    "Fxn:self.assertEqual(0,";
    "Fxn:result[14][0]).abs().sum())";
    "class:ErrorTrackingProcess(multiprocessing.Process):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:multiprocessing.Pipe()";
    "Fxn:run";
    "Fxn:os.close(sys.stderr.fileno())";
    "Fxn:self).run()";
    "Fxn:self._cconn.send(None)";
    "Fxn:self._cconn.send(ExceptionWrapper(sys.exc_info()))";
    "Fxn:exception";
    "Fxn:self._pconn.poll():";
    "Fxn:self._pconn.recv()";
    "Fxn:self._exception.exc_type(self._exception.exc_msg)";
    "Fxn:send_signal";
    "Fxn:os.kill(self.pid,";
    "class:ErrorDataset(Dataset):";
    "Fxn:__init__";
    "Fxn:__len__";
    "class:SegfaultDataset(Dataset):";
    "Fxn:__init__";
    "Fxn:__getitem__";
    "Fxn:ctypes.string_at(0)";
    "Fxn:__len__";
    "class:SleepDataset(Dataset):";
    "Fxn:__init__";
    "Fxn:__getitem__";
    "Fxn:time.sleep(self.sleep_sec)";
    "Fxn:__len__";
    "class:SeedDataset(Dataset):";
    "Fxn:__init__";
    "Fxn:__getitem__";
    "Fxn:torch.initial_seed()";
    "Fxn:__len__";
    "class:SynchronizedSeedDataset(Dataset):";
    "Fxn:__init__";
    "Fxn:multiprocessing.Value('i',";
    "Fxn:multiprocessing.Semaphore(0)";
    "Fxn:__getitem__";
    "Fxn:self.count.get_lock():";
    "Fxn:self.barrier.release()";
    "Fxn:self.barrier.acquire()";
    "Fxn:self.barrier.release()";
    "Fxn:torch.initial_seed()";
    "Fxn:__len__";
    "Fxn:_test_timeout";
    "Fxn:SleepDataset(10,";
    "Fxn:DataLoader(dataset,";
    "Fxn:_test_segfault";
    "Fxn:SegfaultDataset(10)";
    "Fxn:DataLoader(dataset,";
    "Fxn:init_fn";
    "Fxn:torch.manual_seed(12345)";
    "class:TestDataLoader(TestCase):";
    "Fxn:setUp";
    "Fxn:torch.randn(100,";
    "Fxn:torch.randperm(50).repeat(2)";
    "Fxn:TensorDataset(self.data,";
    "Fxn:_test_sequential";
    "Fxn:self.assertEqual(sample,";
    "Fxn:self.assertEqual(target,";
    "Fxn:self.assertEqual(i,";
    "Fxn:math.floor((len(self.dataset)";
    "Fxn:_test_shuffle";
    "Fxn:data_point.eq(sample).all():";
    "Fxn:self.assertFalse(found_data[data_point_idx])";
    "Fxn:self.assertEqual(target,";
    "Fxn:self.assertEqual(sum(found_data.values()),";
    "Fxn:self.assertEqual(sum(found_labels.values()),";
    "Fxn:self.assertEqual(i,";
    "Fxn:math.floor((len(self.dataset)";
    "Fxn:_test_error";
    "Fxn:self.assertEqual(errors,";
    "Fxn:math.ceil(float(len(loader.dataset))";
    "Fxn:test_sequential";
    "Fxn:self._test_sequential(DataLoader(self.dataset))";
    "Fxn:test_sequential_batch";
    "Fxn:self._test_sequential(DataLoader(self.dataset,";
    "Fxn:test_growing_dataset";
    "Fxn:[torch.ones(4)";
    "Fxn:DataLoader(dataset,";
    "Fxn:DataLoader(dataset,";
    "Fxn:dataset.append(torch.ones(4))";
    "Fxn:self.assertEqual(len(dataloader_seq),";
    "Fxn:self.assertEqual(len(dataloader_shuffle),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_sequential_pin_memory";
    "Fxn:DataLoader(self.dataset,";
    "Fxn:self.assertTrue(input.is_pinned())";
    "Fxn:self.assertTrue(target.is_pinned())";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_multiple_dataloaders";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skip("temporarily";
    "Fxn:test_segfault";
    "Fxn:ErrorTrackingProcess(target=_test_segfault)";
    "Fxn:p.start()";
    "Fxn:p.join(JOIN_TIMEOUT)";
    "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:self.assertNotEqual(p.exitcode,";
    "Fxn:self.assertIsInstance(p.exception,";
    "Fxn:self.assertRegex(str(p.exception),";
    "Fxn:self.assertIsInstance(p.exception,";
    "Fxn:self.assertRegex(str(p.exception),";
    "Fxn:\(pid";
    "Fxn:p.terminate()";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_timeout";
    "Fxn:ErrorTrackingProcess(target=_test_timeout)";
    "Fxn:p.start()";
    "Fxn:p.join(JOIN_TIMEOUT)";
    "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:self.assertNotEqual(p.exitcode,";
    "Fxn:self.assertIsInstance(p.exception,";
    "Fxn:self.assertRegex(str(p.exception),";
    "Fxn:p.terminate()";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_worker_seed";
    "Fxn:SynchronizedSeedDataset(num_workers,";
    "Fxn:DataLoader(dataset,";
    "Fxn:seeds.add(batch[0])";
    "Fxn:self.assertEqual(len(seeds),";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_worker_init_fn";
    "Fxn:SeedDataset(4)";
    "Fxn:DataLoader(dataset,";
    "Fxn:self.assertEqual(12345,";
    "Fxn:self.assertEqual(12345,";
    "Fxn:test_shuffle";
    "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:test_shuffle_batch";
    "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_sequential_workers";
    "Fxn:self._test_sequential(DataLoader(self.dataset,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_seqential_batch_workers";
    "Fxn:self._test_sequential(DataLoader(self.dataset,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_shuffle_workers";
    "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_shuffle_batch_workers";
    "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:_test_batch_sampler";
    "Fxn:[(0,";
    "Fxn:batches.append(tuple(range(i,";
    "Fxn:batches.append(tuple(range(i";
    "Fxn:DataLoader(self.dataset,";
    "Fxn:self.assertEqual(len(dl),";
    "Fxn:self.assertEqual(len(input),";
    "Fxn:self.assertEqual(input,";
    "Fxn:self.assertEqual(len(input),";
    "Fxn:self.assertEqual(input,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_batch_sampler";
    "Fxn:self._test_batch_sampler()";
    "Fxn:self._test_batch_sampler(num_workers=4)";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_shuffle_pin_memory";
    "Fxn:DataLoader(self.dataset,";
    "Fxn:self.assertTrue(input.is_pinned())";
    "Fxn:self.assertTrue(target.is_pinned())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy";
    "Import:numpy";
    "class:TestDataset(torch.utils.data.Dataset):";
    "Fxn:__getitem__";
    "Fxn:np.ones((2,";
    "Fxn:__len__";
    "Fxn:DataLoader(TestDataset(),";
    "Fxn:self.assertIsInstance(batch,";
    "Fxn:self.assertEqual(batch.size(),";
    "Fxn:torch.Size([12,";
    "Fxn:test_error";
    "Fxn:self._test_error(DataLoader(ErrorDataset(100),";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_error_workers";
    "Fxn:self._test_error(DataLoader(ErrorDataset(41),";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_partial_workers";
    "Fxn:w.join(JOIN_TIMEOUT)";
    "Fxn:self.assertFalse(w.is_alive(),";
    "Fxn:self.assertEqual(w.exitcode,";
    "Fxn:worker_manager_thread.join(JOIN_TIMEOUT)";
    "Fxn:self.assertFalse(worker_manager_thread.is_alive())";
    "Fxn:test_len";
    "Fxn:check_len";
    "Fxn:self.assertEqual(len(dl),";
    "Fxn:self.assertEqual(n,";
    "Fxn:check_len(self.dataset,";
    "Fxn:check_len(DataLoader(self.dataset,";
    "Fxn:check_len(DataLoader(self.dataset,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy_scalars";
    "Import:numpy";
    "class:ScalarDataset(torch.utils.data.Dataset):";
    "Fxn:__init__";
    "Fxn:__getitem__";
    "Fxn:self.dtype()";
    "Fxn:__len__";
    "Fxn:dtypes.items():";
    "Fxn:ScalarDataset(dt)";
    "Fxn:DataLoader(dset,";
    "Fxn:self.assertIsInstance(batch,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_default_colate_bad_numpy_types";
    "Fxn:np.array(['a',";
    "Fxn:default_collate(arr)";
    "Fxn:np.array([[['a',";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:default_collate(arr))";
    "Fxn:np.array([object(),";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:default_collate(arr))";
    "Fxn:np.array([[[object(),";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:default_collate(arr))";
    "Import:numpy";
    "class:StringDataset(Dataset):";
    "Fxn:__init__";
    "Fxn:__len__";
    "Fxn:__getitem__";
    "class:TestStringDataLoader(TestCase):";
    "Fxn:setUp";
    "Fxn:StringDataset()";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_shuffle_pin_memory";
    "Fxn:DataLoader(self.dataset,";
    "Fxn:self.assertIsInstance(s[0],";
    "Fxn:self.assertTrue(n.is_pinned())";
    "class:DictDataset(Dataset):";
    "Fxn:__len__";
    "Fxn:__getitem__";
    "Fxn:torch.Tensor(4,";
    "Fxn:2).fill_(ndx),";
    "class:TestDictDataLoader(TestCase):";
    "Fxn:setUp";
    "Fxn:DictDataset()";
    "Fxn:test_sequential_batch";
    "Fxn:DataLoader(self.dataset,";
    "Fxn:self.assertEqual(set(sample.keys()),";
    "Fxn:self.assertEqual(set(sample['another_dict'].keys()),";
    "Fxn:self.assertEqual(t.size(),";
    "Fxn:torch.Size([batch_size,";
    "Fxn:self.assertTrue((t[0]";
    "Fxn:idx).all())";
    "Fxn:self.assertTrue((t[1]";
    "Fxn:1).all())";
    "Fxn:self.assertEqual(n.size(),";
    "Fxn:torch.Size([batch_size]))";
    "Fxn:self.assertEqual(n[0],";
    "Fxn:self.assertEqual(n[1],";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_pin_memory";
    "Fxn:DataLoader(self.dataset,";
    "Fxn:self.assertTrue(sample['a_tensor'].is_pinned())";
    "Fxn:self.assertTrue(sample['another_dict']['a_number'].is_pinned())";
    "Fxn:run_tests()";
    "/test/test_distributed.py";
    "Import:fcntl";
    "Import:multiprocessing";
    "Import:import";
    "Import:sys";
    "Import:copy";
    "Import:time";
    "Import:unittest";
    "Import:wraps,";
    "Import:contextmanager";
    "Import:torch";
    "Import:torch.cuda";
    "Import:torch.nn";
    "Import:torch.distributed";
    "Import:torch.optim";
    "Import:torch.nn.functional";
    "Import:Variable";
    "Import:TestCase";
    "Fxn:get_timeout";
    "Fxn:skip_if_no_cuda_distributed";
    "Fxn:wrapper";
    "Fxn:skip_if_no_multigpu";
    "Fxn:wrapper";
    "Fxn:skip_if_small_worldsize";
    "Fxn:wrapper";
    "Fxn:apply_hack_for_nccl";
    "Fxn:_lock";
    "Fxn:_build_tensor";
    "class:Barrier(object):";
    "Fxn:init";
    "Fxn:os.path.join(TEMP_DIR,";
    "Fxn:os.listdir(barrier_dir):";
    "Fxn:os.unlink(os.path.join(barrier_dir,";
    "Fxn:sync";
    "Fxn:os.path.join(TEMP_DIR,";
    "Fxn:os.path.join(barrier_dir,";
    "Fxn:_lock():";
    "Fxn:f.write(str(cls.barrier_id))";
    "Fxn:time.time()";
    "Fxn:_lock():";
    "Fxn:os.listdir(barrier_dir):";
    "Fxn:f.read()";
    "Fxn:dist.get_world_size():";
    "Fxn:time.time()";
    "Fxn:RuntimeError("barrier";
    "Fxn:time.sleep(0.1)";
    "class:_DistTestBase(object):";
    "Fxn:_barrier";
    "Fxn:Barrier.sync(*args,";
    "Fxn:_init_group_test";
    "Fxn:dist.new_group(group)";
    "Fxn:dist.get_rank()";
    "Fxn:_init_global_test";
    "Fxn:dist.get_world_size())]";
    "Fxn:dist.get_rank()";
    "Fxn:test_get_rank";
    "Fxn:os.path.join(TEMP_DIR,";
    "Fxn:dist.get_world_size()";
    "Fxn:f.write(str(dist.get_rank()))";
    "Fxn:self._barrier()";
    "Fxn:os.listdir(test_dir):";
    "Fxn:all_ranks.add(int(f.read()))";
    "Fxn:self.assertEqual(len(all_ranks),";
    "Fxn:self._barrier()";
    "Fxn:dist.get_rank()";
    "Fxn:os.listdir(test_dir):";
    "Fxn:os.unlink(os.path.join(test_dir,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_send_recv";
    "Fxn:dist.get_rank()";
    "Fxn:_build_tensor(rank";
    "Fxn:dist.get_world_size()):";
    "Fxn:dist.send(tensor,";
    "Fxn:dist.get_world_size()):";
    "Fxn:_build_tensor(src";
    "Fxn:_build_tensor(src";
    "Fxn:dist.recv(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_send_recv_any_source";
    "Fxn:dist.get_rank()";
    "Fxn:_build_tensor(10,";
    "Fxn:dist.get_world_size()):";
    "Fxn:dist.send(tensor,";
    "Fxn:dist.get_world_size()):";
    "Fxn:_build_tensor(10,";
    "Fxn:dist.recv(tensor)";
    "Fxn:self.assertTrue(tensor.eq(sender).all())";
    "Fxn:recv_ranks.add(sender)";
    "Fxn:self.assertEqual(len(recv_ranks),";
    "Fxn:dist.get_world_size()";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_isend";
    "Fxn:dist.get_rank()";
    "Fxn:dist.get_world_size()";
    "Fxn:dist.isend(_build_tensor(dest,";
    "Fxn:request.wait()";
    "Fxn:self.assertTrue(request.is_completed())";
    "Fxn:_build_tensor(rank,";
    "Fxn:dist.recv(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:_build_tensor(rank,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_irecv";
    "Fxn:dist.get_rank()";
    "Fxn:dist.get_world_size()";
    "Fxn:[_build_tensor(src,";
    "Fxn:dist.irecv(expected_tensors[src";
    "Fxn:1].wait()";
    "Fxn:self.assertTrue(requests[src";
    "Fxn:1].is_completed())";
    "Fxn:self.assertEqual(expected_tensors[src";
    "Fxn:_build_tensor(src,";
    "Fxn:_build_tensor(rank,";
    "Fxn:dist.send(tensor,";
    "Fxn:self._barrier()";
    "Fxn:_test_broadcast_helper";
    "Fxn:_build_tensor(src";
    "Fxn:value).type(ttype)";
    "Fxn:expected_tensor.cuda()";
    "Fxn:dist.broadcast(expected_tensor,";
    "Fxn:_build_tensor(src";
    "Fxn:-1).type(ttype)";
    "Fxn:tensor.cuda()";
    "Fxn:dist.broadcast(tensor,";
    "Fxn:self.assertEqual(tensor.size(),";
    "Fxn:expected_tensor.size())";
    "Fxn:self.assertEqual(tensor.ne(expected_tensor).max(),";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_broadcast_helper(group,";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast_cuda";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_broadcast_helper(group,";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast_group";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_broadcast_helper(group,";
    "Fxn:_test_reduce_helper";
    "Fxn:_build_tensor(src";
    "Fxn:1).fill_(master_value)";
    "Fxn:tensor.cuda()";
    "Fxn:dist.reduce(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:_build_tensor(src";
    "Fxn:_build_tensor(src";
    "Fxn:1).fill_(worker_value)";
    "Fxn:tensor.cuda()";
    "Fxn:dist.reduce(tensor,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_sum";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_sum_cuda";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_product";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:reduce((lambda";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_min";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_max";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_sum";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_product";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:reduce((lambda";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_min";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_max";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_reduce_helper(";
    "Fxn:_test_all_reduce_helper";
    "Fxn:_build_tensor(src";
    "Fxn:1).fill_(master_value)";
    "Fxn:tensor.cuda()";
    "Fxn:dist.all_reduce(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:_build_tensor(src";
    "Fxn:_build_tensor(src";
    "Fxn:1).fill_(worker_value)";
    "Fxn:tensor.cuda()";
    "Fxn:dist.all_reduce(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:_build_tensor(src";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_sum";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_sum_cuda";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_product";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:reduce((lambda";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_min";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_max";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_sum";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_product";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:reduce((lambda";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_min";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_max";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_all_reduce_helper(";
    "Fxn:_test_scatter_helper";
    "Fxn:_build_tensor(dest";
    "Fxn:_build_tensor(dest";
    "Fxn:[_build_tensor(dest";
    "Fxn:dist.scatter(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_scatter";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_scatter_helper(group,";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_scatter_group";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_scatter_helper(group,";
    "Fxn:_test_gather_helper";
    "Fxn:_build_tensor(dest";
    "Fxn:[_build_tensor(dest";
    "Fxn:dist.gather(tensor,";
    "Fxn:[_build_tensor(dest";
    "Fxn:self.assertEqual(t1,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_gather";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_gather_helper(group,";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_gather_group";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_gather_helper(group,";
    "Fxn:_test_all_gather_helper";
    "Fxn:_build_tensor(dest";
    "Fxn:[_build_tensor(dest";
    "Fxn:tensor.cuda()";
    "Fxn:[t.cuda()";
    "Fxn:dist.all_gather(tensors,";
    "Fxn:[_build_tensor(dest";
    "Fxn:self.assertEqual(t1,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_all_gather_helper(group,";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather_cuda";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_all_gather_helper(group,";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather_group";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_all_gather_helper(group,";
    "Fxn:_test_barrier_helper";
    "Fxn:torch.DoubleTensor(1).fill_(0.0)";
    "Fxn:expected_time.fill_(time.time()";
    "Fxn:dist.broadcast(expected_time,";
    "Fxn:time.sleep(WAIT_TIME";
    "Fxn:dist.barrier(group_id)";
    "Fxn:dist.broadcast(expected_time,";
    "Fxn:dist.barrier(group_id)";
    "Fxn:self.assertGreaterEqual(time.time(),";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_barrier";
    "Fxn:self._init_global_test()";
    "Fxn:self._test_barrier_helper(group,";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_barrier_group";
    "Fxn:self._init_group_test()";
    "Fxn:self._test_barrier_helper(group,";
    "Fxn:_init_multigpu_helper";
    "Fxn:torch.cuda.device_count()";
    "Fxn:dist.get_world_size()";
    "Fxn:apply_hack_for_nccl()";
    "Fxn:_test_broadcast_multigpu_helper";
    "Fxn:_build_tensor(src";
    "Fxn:[_build_tensor(src";
    "Fxn:-1).cuda(device=i)";
    "Fxn:expected_tensor.cuda(";
    "Fxn:dist.broadcast_multigpu(tensors,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast_multigpu";
    "Fxn:self._init_global_test()";
    "Fxn:self._init_multigpu_helper()";
    "Fxn:self._test_broadcast_multigpu_helper(group,";
    "Fxn:_test_all_reduce_multigpu_helper";
    "Fxn:[_build_tensor(src";
    "Fxn:master_value).cuda(device=i)";
    "Fxn:[_build_tensor(src";
    "Fxn:worker_value).cuda(device=i)";
    "Fxn:dist.all_reduce_multigpu(tensors,";
    "Fxn:_build_tensor(src";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_multigpu";
    "Fxn:self._init_global_test()";
    "Fxn:self._init_multigpu_helper()";
    "Fxn:self._test_all_reduce_multigpu_helper(";
    "Fxn:_test_reduce_multigpu_helper";
    "Fxn:[_build_tensor(src";
    "Fxn:master_value).cuda(device=i)";
    "Fxn:dist.reduce_multigpu(tensors,";
    "Fxn:_build_tensor(src";
    "Fxn:self.assertEqual(tensors[0],";
    "Fxn:[_build_tensor(src";
    "Fxn:worker_value).cuda(device=i)";
    "Fxn:dist.reduce_multigpu(tensors,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_multigpu";
    "Fxn:self._init_global_test()";
    "Fxn:self._init_multigpu_helper()";
    "Fxn:self._test_reduce_multigpu_helper(";
    "Fxn:_test_all_gather_multigpu_helper";
    "Fxn:[_build_tensor(dest";
    "Fxn:1).cuda(device=i)";
    "Fxn:[_build_tensor(dest";
    "Fxn:[_build_tensor(dest";
    "Fxn:output_tensors.append([t.cuda(device=gpu)";
    "Fxn:expected_output.append([t.cuda(device=gpu)";
    "Fxn:dist.all_gather_multigpu(output_tensors,";
    "Fxn:self.assertEqual(output_tensors,";
    "Fxn:self._barrier()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather_multigpu";
    "Fxn:self._init_global_test()";
    "Fxn:self._init_multigpu_helper()";
    "Fxn:self._test_all_gather_multigpu_helper(group,";
    "Fxn:_test_DDP_helper";
    "Fxn:model.train()";
    "Fxn:model(input_var)";
    "Fxn:loss(output,";
    "Fxn:l.backward()";
    "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_DistributedDataParallel";
    "Fxn:self._init_global_test()";
    "Fxn:self._init_multigpu_helper()";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(50,";
    "Fxn:nn.ReLU()";
    "Fxn:forward";
    "Fxn:self.relu(self.fc1(x))";
    "Fxn:self.relu(self.fc2(x))";
    "Fxn:self.fc3(x)";
    "Fxn:F.softmax(x,";
    "Fxn:Net()";
    "Fxn:copy.deepcopy(model)";
    "Fxn:model_gpu.cuda(gpu_subset[0])";
    "Fxn:copy.deepcopy(model)";
    "Fxn:model_DDP.cuda(gpu_subset[0])";
    "Fxn:nn.parallel.DistributedDataParallel(model_DDP,";
    "Fxn:optim.SGD(model_DDP.parameters(),";
    "Fxn:optimizer.zero_grad()";
    "Fxn:torch.randn(batch_size,";
    "Fxn:torch.randn(batch_size,";
    "Fxn:nn.MSELoss()";
    "Fxn:self._test_DDP_helper(model_gpu,";
    "Fxn:input_cpu.cuda(gpu_subset[0]),";
    "Fxn:target.cuda(gpu_subset[0]),";
    "Fxn:self._test_DDP_helper(model_DDP,";
    "Fxn:model_DDP.module.modules()):";
    "Fxn:self.assertEqual(layer_gpu.weight.grad,";
    "Fxn:optimizer.step()";
    "Fxn:self._test_DDP_helper(model_DDP,";
    "Fxn:target.cuda(gpu_subset[0]),";
    "Fxn:self._barrier()";
    "class:TestDistBackend(TestCase,";
    "Fxn:manager_join";
    "Fxn:@wraps(fn)";
    "Fxn:wrapper";
    "Fxn:self._join_and_reduce(fn)";
    "Fxn:fn(self)";
    "Fxn:setUpClass";
    "Fxn:attr.startswith('test'):";
    "Fxn:cls.manager_join(fn))";
    "Fxn:setUp";
    "Fxn:Barrier.init()";
    "Fxn:self.processes.append(self._spawn_process(rank))";
    "Fxn:tearDown";
    "Fxn:p.terminate()";
    "Fxn:_spawn_process";
    "Fxn:multiprocessing.Process(target=self._run,";
    "Fxn:args=(rank,))";
    "Fxn:process.start()";
    "Fxn:_run";
    "Fxn:dist.init_process_group(init_method=INIT_METHOD,";
    "Fxn:world_size=int(WORLD_SIZE))";
    "Fxn:sys.exit(0)";
    "Fxn:self.id()";
    "Fxn:self.id().split(".")[2])()";
    "Fxn:sys.exit(0)";
    "Fxn:_join_and_reduce";
    "Fxn:get_timeout(self.id())";
    "Fxn:p.join(self.JOIN_TIMEOUT)";
    "Fxn:self.assertEqual(p.exitcode,";
    "Fxn:self.assertEqual(p.exitcode,";
    "Fxn:unittest.SkipTest("cuda";
    "Fxn:unittest.SkipTest("multigpu";
    "Fxn:unittest.SkipTest("worldsize";
    "Fxn:dist.init_process_group(init_method=INIT_METHOD,";
    "class:TestMPI(TestCase,";
    "/test/test_distributions.py";
    "Import:math";
    "Import:numbers";
    "Import:unittest";
    "Import:namedtuple";
    "Import:product";
    "Import:shuffle";
    "Import:torch";
    "Import:TestCase,";
    "Import:Variable,";
    "Import:(Bernoulli,";
    "Import:_kl_expfamily_expfamily";
    "Import:biject_to,";
    "Import:Constraint,";
    "Import:_Dirichlet_backward";
    "Import:(AbsTransform,";
    "Import:_finfo,";
    "Import:numpy";
    "Import:scipy.stats";
    "Import:scipy.special";
    "Fxn:pairwise";
    "Fxn:is_all_nan";
    "Fxn:unwrap";
    "class:TestDistributions(TestCase):";
    "Fxn:_gradcheck_log_prob";
    "Fxn:dist_ctor(*ctor_params)";
    "Fxn:distribution.sample()";
    "Fxn:self.assertEqual(s.size(),";
    "Fxn:apply_fn";
    "Fxn:dist_ctor(*params).log_prob(s)";
    "Fxn:gradcheck(apply_fn,";
    "Fxn:_check_log_prob";
    "Fxn:dist.sample()";
    "Fxn:dist.log_prob(s)";
    "Fxn:log_probs.data.view(-1))):";
    "Fxn:asset_fn(i,";
    "Fxn:_check_sampler_sampler";
    "Fxn:.sample()";
    "Fxn:torch_dist.sample((num_samples,)).squeeze()";
    "Fxn:torch_samples.cpu().numpy()";
    "Fxn:ref_dist.rvs(num_samples).astype(np.float64)";
    "Fxn:np.random.normal(size=torch_samples.shape[-1])";
    "Fxn:np.linalg.norm(axis)";
    "Fxn:np.dot(torch_samples,";
    "Fxn:np.dot(ref_samples,";
    "Fxn:[(x,";
    "Fxn:[(x,";
    "Fxn:shuffle(samples)";
    "Fxn:samples.sort(key=lambda";
    "Fxn:np.array(samples)[:,";
    "Fxn:samples.reshape((num_bins,";
    "Fxn:samples_per_bin)).mean(axis=1)";
    "Fxn:scipy.special.erfinv(1";
    "Fxn:'{}.sample()";
    "Fxn:biased:\n{}'.format(message,";
    "Fxn:self.assertLess(-threshold,";
    "Fxn:self.assertLess(bias,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:_check_sampler_discrete";
    "Fxn:torch_dist.sample((num_samples,)).squeeze()";
    "Fxn:torch_samples.cpu().numpy()";
    "Fxn:np.unique(torch_samples,";
    "Fxn:ref_dist.pmf(unique)";
    "Fxn:self.assertGreater(pmf[msk].sum(),";
    "Fxn:scipy.stats.chisquare(counts[msk],";
    "Fxn:self.assertGreater(p,";
    "Fxn:_check_enumerate_support";
    "Fxn:torch.Tensor(param)";
    "Fxn:torch.Tensor(expected)";
    "Fxn:dist(param).enumerate_support()";
    "Fxn:self.assertEqual(actual,";
    "Fxn:variable(param)";
    "Fxn:variable(expected)";
    "Fxn:dist(param).enumerate_support()";
    "Fxn:self.assertEqual(actual,";
    "Fxn:test_sample_detached";
    "Fxn:param.values()";
    "Fxn:Dist(**param)";
    "Fxn:dist.sample()";
    "Fxn:self.assertFalse(sample.requires_grad,";
    "Fxn:.sample()";
    "Fxn:detached'.format(";
    "Fxn:test_rsample_requires_grad";
    "Fxn:param.values()):";
    "Fxn:Dist(**param)";
    "Fxn:dist.rsample()";
    "Fxn:self.assertTrue(sample.requires_grad,";
    "Fxn:.rsample()";
    "Fxn:grad'.format(";
    "Fxn:test_enumerate_support_type";
    "Fxn:Dist(**param)";
    "Fxn:self.assertTrue(type(unwrap(dist.sample()))";
    "Fxn:msg=('{}";
    "Fxn:enumerate_support.').format(Dist.__name__,";
    "Fxn:test_has_examples";
    "Fxn:self.assertIn(Dist,";
    "Fxn:test_distributions.py".format(Dist.__name__))";
    "Fxn:test_bernoulli";
    "Fxn:torch.tensor([0.7,";
    "Fxn:torch.tensor(0.3,";
    "Fxn:self.assertEqual(Bernoulli(p).sample((8,)).size(),";
    "Fxn:self.assertTrue(isinstance(Bernoulli(p).sample().data,";
    "Fxn:self.assertEqual(Bernoulli(r).sample((8,)).size(),";
    "Fxn:self.assertEqual(Bernoulli(r).sample().size(),";
    "Fxn:self.assertEqual(Bernoulli(r).sample((3,";
    "Fxn:2)).size(),";
    "Fxn:self.assertEqual(Bernoulli(s).sample().size(),";
    "Fxn:self._gradcheck_log_prob(Bernoulli,";
    "Fxn:ref_log_prob";
    "Fxn:self.assertEqual(log_prob,";
    "Fxn:math.log(prob";
    "Fxn:self._check_log_prob(Bernoulli(p),";
    "Fxn:self._check_log_prob(Bernoulli(logits=p.log()";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:Bernoulli(r).rsample)";
    "Fxn:self.assertEqual(Bernoulli(p).entropy().data,";
    "Fxn:torch.Tensor([0.6108,";
    "Fxn:self.assertEqual(Bernoulli(torch.Tensor([0.0])).entropy(),";
    "Fxn:torch.Tensor([0.0]))";
    "Fxn:self.assertEqual(Bernoulli(s).entropy(),";
    "Fxn:torch.tensor(0.6108),";
    "Fxn:test_bernoulli_enumerate_support";
    "Fxn:self._check_enumerate_support(Bernoulli,";
    "Fxn:test_bernoulli_3d";
    "Fxn:variable(torch.Tensor(2,";
    "Fxn:5).fill_(0.5),";
    "Fxn:self.assertEqual(Bernoulli(p).sample().size(),";
    "Fxn:self.assertEqual(Bernoulli(p).sample(sample_shape=(2,";
    "Fxn:5)).size(),";
    "Fxn:self.assertEqual(Bernoulli(p).sample((2,)).size(),";
    "Fxn:test_geometric";
    "Fxn:variable([0.7,";
    "Fxn:variable(0.3,";
    "Fxn:self.assertEqual(Geometric(p).sample((8,)).size(),";
    "Fxn:self.assertEqual(Geometric(1).sample(),";
    "Fxn:self.assertEqual(Geometric(1).log_prob(torch.tensor(1)),";
    "Fxn:-float('inf'),";
    "Fxn:self.assertEqual(Geometric(1).log_prob(torch.tensor(0)),";
    "Fxn:self.assertTrue(isinstance(Geometric(p).sample().data,";
    "Fxn:self.assertEqual(Geometric(r).sample((8,)).size(),";
    "Fxn:self.assertEqual(Geometric(r).sample().size(),";
    "Fxn:self.assertEqual(Geometric(r).sample((3,";
    "Fxn:2)).size(),";
    "Fxn:self.assertEqual(Geometric(s).sample().size(),";
    "Fxn:self._gradcheck_log_prob(Geometric,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:Geometric(0))";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:Geometric(r).rsample)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_geometric_log_prob_and_entropy";
    "Fxn:variable([0.7,";
    "Fxn:ref_log_prob";
    "Fxn:self.assertEqual(log_prob,";
    "Fxn:scipy.stats.geom(prob,";
    "Fxn:loc=-1).logpmf(val))";
    "Fxn:self._check_log_prob(Geometric(p),";
    "Fxn:self._check_log_prob(Geometric(logits=p.log()";
    "Fxn:self.assertEqual(Geometric(p).entropy().data,";
    "Fxn:scipy.stats.geom(p.data.numpy(),";
    "Fxn:loc=-1).entropy(),";
    "Fxn:self.assertEqual(float(Geometric(s).entropy()),";
    "Fxn:scipy.stats.geom(s,";
    "Fxn:loc=-1).entropy().item(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_geometric_sample";
    "Fxn:set_rng_seed(0)";
    "Fxn:self._check_sampler_discrete(Geometric(prob),";
    "Fxn:scipy.stats.geom(p=prob,";
    "Fxn:'Geometric(prob={})'.format(prob))";
    "Fxn:test_binomial";
    "Fxn:variable(torch.arange(0.05,";
    "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:Binomial(total_count,";
    "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:Binomial(total_count,";
    "Fxn:p.log()),";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:Binomial(10,";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:Binomial(10,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_binomial_log_prob";
    "Fxn:variable(torch.arange(0.05,";
    "Fxn:ref_log_prob";
    "Fxn:probs.data.view(-1)[idx].item()";
    "Fxn:scipy.stats.binom(total_count,";
    "Fxn:p).logpmf(x)";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(Binomial(total_count,";
    "Fxn:probs_to_logits(probs,";
    "Fxn:self._check_log_prob(Binomial(total_count,";
    "Fxn:test_binomial_extreme_vals";
    "Fxn:Binomial(total_count,";
    "Fxn:self.assertEqual(bin0.sample(),";
    "Fxn:self.assertAlmostEqual(bin0.log_prob(torch.tensor([0]))[0],";
    "Fxn:self.assertEqual(float(bin0.log_prob(torch.tensor([1])).exp()),";
    "Fxn:Binomial(total_count,";
    "Fxn:self.assertEqual(bin1.sample(),";
    "Fxn:self.assertAlmostEqual(bin1.log_prob(torch.tensor([total_count]))[0],";
    "Fxn:self.assertEqual(float(bin1.log_prob(torch.tensor([total_count";
    "Fxn:1])).exp()),";
    "Fxn:test_multinomial_1d";
    "Fxn:variable([0.1,";
    "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:p).sample().size(),";
    "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:p).sample((2,";
    "Fxn:2)).size(),";
    "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:p).sample((1,)).size(),";
    "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:Multinomial(total_count,";
    "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:Multinomial(total_count,";
    "Fxn:p.log()),";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:Multinomial(10,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_multinomial_1d_log_prob";
    "Fxn:variable([0.1,";
    "Fxn:Multinomial(total_count,";
    "Fxn:dist.sample()";
    "Fxn:dist.log_prob(x)";
    "Fxn:torch.Tensor(scipy.stats.multinomial.logpmf(x.numpy(),";
    "Fxn:p=dist.probs.detach().numpy()))";
    "Fxn:self.assertEqual(log_prob.data,";
    "Fxn:Multinomial(total_count,";
    "Fxn:logits=p.log())";
    "Fxn:dist.sample()";
    "Fxn:dist.log_prob(x)";
    "Fxn:torch.Tensor(scipy.stats.multinomial.logpmf(x.numpy(),";
    "Fxn:p=dist.probs.detach().numpy()))";
    "Fxn:self.assertEqual(log_prob.data,";
    "Fxn:test_multinomial_2d";
    "Fxn:variable(probabilities,";
    "Fxn:variable(probabilities_1,";
    "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:p).sample().size(),";
    "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:p).sample(sample_shape=(3,";
    "Fxn:4)).size(),";
    "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:p).sample((6,)).size(),";
    "Fxn:set_rng_seed(0)";
    "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:Multinomial(total_count,";
    "Fxn:p.grad.zero_()";
    "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:Multinomial(total_count,";
    "Fxn:p.log()),";
    "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:s).sample().data,";
    "Fxn:torch.Tensor([[total_count,";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:Multinomial(10,";
    "Fxn:test_categorical_1d";
    "Fxn:variable([0.1,";
    "Fxn:self.assertTrue(is_all_nan(Categorical(p).mean))";
    "Fxn:self.assertTrue(is_all_nan(Categorical(p).variance))";
    "Fxn:self.assertEqual(Categorical(p).sample().size(),";
    "Fxn:self.assertTrue(isinstance(Categorical(p).sample().data,";
    "Fxn:self.assertEqual(Categorical(p).sample((2,";
    "Fxn:2)).size(),";
    "Fxn:self.assertEqual(Categorical(p).sample((1,)).size(),";
    "Fxn:self._gradcheck_log_prob(Categorical,";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:Categorical(p).rsample)";
    "Fxn:test_categorical_2d";
    "Fxn:variable(probabilities,";
    "Fxn:variable(probabilities_1,";
    "Fxn:self.assertEqual(Categorical(p).mean.size(),";
    "Fxn:self.assertEqual(Categorical(p).variance.size(),";
    "Fxn:self.assertTrue(is_all_nan(Categorical(p).mean))";
    "Fxn:self.assertTrue(is_all_nan(Categorical(p).variance))";
    "Fxn:self.assertEqual(Categorical(p).sample().size(),";
    "Fxn:self.assertEqual(Categorical(p).sample(sample_shape=(3,";
    "Fxn:4)).size(),";
    "Fxn:self.assertEqual(Categorical(p).sample((6,)).size(),";
    "Fxn:self._gradcheck_log_prob(Categorical,";
    "Fxn:set_rng_seed(0)";
    "Fxn:self.assertEqual(Categorical(s).sample(sample_shape=(2,)).data,";
    "Fxn:torch.Tensor([[0,";
    "Fxn:ref_log_prob";
    "Fxn:p.data[idx].sum()";
    "Fxn:self.assertEqual(log_prob,";
    "Fxn:math.log(sample_prob))";
    "Fxn:self._check_log_prob(Categorical(p),";
    "Fxn:self._check_log_prob(Categorical(logits=p.log()),";
    "Fxn:self.assertEqual(Categorical(p).entropy().data,";
    "Fxn:torch.Tensor([1.0114,";
    "Fxn:self.assertEqual(Categorical(s).entropy().data,";
    "Fxn:torch.Tensor([0.0,";
    "Fxn:test_categorical_enumerate_support";
    "Fxn:self._check_enumerate_support(Categorical,";
    "Fxn:test_one_hot_categorical_1d";
    "Fxn:variable([0.1,";
    "Fxn:self.assertEqual(OneHotCategorical(p).sample().size(),";
    "Fxn:self.assertTrue(isinstance(OneHotCategorical(p).sample().data,";
    "Fxn:self.assertEqual(OneHotCategorical(p).sample((2,";
    "Fxn:2)).size(),";
    "Fxn:self.assertEqual(OneHotCategorical(p).sample((1,)).size(),";
    "Fxn:self._gradcheck_log_prob(OneHotCategorical,";
    "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:OneHotCategorical(p).rsample)";
    "Fxn:test_one_hot_categorical_2d";
    "Fxn:variable(probabilities,";
    "Fxn:variable(probabilities_1,";
    "Fxn:self.assertEqual(OneHotCategorical(p).sample().size(),";
    "Fxn:self.assertEqual(OneHotCategorical(p).sample(sample_shape=(3,";
    "Fxn:4)).size(),";
    "Fxn:self.assertEqual(OneHotCategorical(p).sample((6,)).size(),";
    "Fxn:self._gradcheck_log_prob(OneHotCategorical,";
    "Fxn:OneHotCategorical(p)";
    "Fxn:dist.sample()";
    "Fxn:self.assertEqual(dist.log_prob(x),";
    "Fxn:Categorical(p).log_prob(x.max(-1)[1]))";
    "Fxn:test_one_hot_categorical_enumerate_support";
    "Fxn:self._check_enumerate_support(OneHotCategorical,";
    "Fxn:test_poisson_shape";
    "Fxn:variable(torch.randn(2,";
    "Fxn:3).abs(),";
    "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:self.assertEqual(Poisson(rate).sample().size(),";
    "Fxn:self.assertEqual(Poisson(rate).sample((7,)).size(),";
    "Fxn:self.assertEqual(Poisson(rate_1d).sample().size(),";
    "Fxn:self.assertEqual(Poisson(rate_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Poisson(2.0).sample((2,)).size(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_poisson_log_prob";
    "Fxn:variable(torch.randn(2,";
    "Fxn:3).abs(),";
    "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:ref_log_prob";
    "Fxn:rate.data.view(-1)[idx]";
    "Fxn:scipy.stats.poisson.logpmf(x,";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:set_rng_seed(0)";
    "Fxn:self._check_log_prob(Poisson(rate),";
    "Fxn:self._gradcheck_log_prob(Poisson,";
    "Fxn:self._gradcheck_log_prob(Poisson,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_poisson_sample";
    "Fxn:set_rng_seed(1)";
    "Fxn:self._check_sampler_discrete(Poisson(rate),";
    "Fxn:scipy.stats.poisson(rate),";
    "Fxn:'Poisson(lambda={})'.format(rate),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_poisson_gpu_sample";
    "Fxn:set_rng_seed(0)";
    "Fxn:self._check_sampler_discrete(Poisson(torch.Tensor([rate]).cuda()),";
    "Fxn:scipy.stats.poisson(rate),";
    "Fxn:'Poisson(lambda={},";
    "Fxn:cuda)'.format(rate),";
    "Fxn:test_relaxed_bernoulli";
    "Fxn:torch.tensor([0.7,";
    "Fxn:torch.tensor(0.3,";
    "Fxn:torch.tensor(0.67,";
    "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:p).sample((8,)).size(),";
    "Fxn:self.assertTrue(isinstance(RelaxedBernoulli(temp,";
    "Fxn:p).sample().data,";
    "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:r).sample((8,)).size(),";
    "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:r).sample().size(),";
    "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:r).sample((3,";
    "Fxn:2)).size(),";
    "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:s).sample().size(),";
    "Fxn:self._gradcheck_log_prob(RelaxedBernoulli,";
    "Fxn:self._gradcheck_log_prob(RelaxedBernoulli,";
    "Fxn:RelaxedBernoulli(temp,";
    "Fxn:p).rsample()";
    "Fxn:s.backward(torch.ones_like(s))";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_rounded_relaxed_bernoulli";
    "Fxn:set_rng_seed(0)";
    "class:Rounded(object):";
    "Fxn:__init__";
    "Fxn:sample";
    "Fxn:torch.round(self.dist.sample(*args,";
    "Fxn:product([0.1,";
    "Fxn:self._check_sampler_discrete(Rounded(RelaxedBernoulli(temp,";
    "Fxn:scipy.stats.bernoulli(probs),";
    "Fxn:'Rounded(RelaxedBernoulli(temp={},";
    "Fxn:probs={}))'.format(temp,";
    "Fxn:torch.tensor(0.5)";
    "Fxn:RelaxedBernoulli(1e10,";
    "Fxn:dist.rsample()";
    "Fxn:self.assertEqual(equal_probs,";
    "Fxn:test_relaxed_one_hot_categorical_1d";
    "Fxn:variable([0.1,";
    "Fxn:torch.tensor(0.67,";
    "Fxn:self.assertEqual(RelaxedOneHotCategorical(probs=p,";
    "Fxn:temperature=temp).sample().size(),";
    "Fxn:self.assertTrue(isinstance(RelaxedOneHotCategorical(probs=p,";
    "Fxn:temperature=temp).sample().data,";
    "Fxn:self.assertEqual(RelaxedOneHotCategorical(probs=p,";
    "Fxn:temperature=temp).sample((2,";
    "Fxn:2)).size(),";
    "Fxn:self.assertEqual(RelaxedOneHotCategorical(probs=p,";
    "Fxn:temperature=temp).sample_n(1).size(),";
    "Fxn:self._gradcheck_log_prob(RelaxedOneHotCategorical,";
    "Fxn:test_relaxed_one_hot_categorical_2d";
    "Fxn:variable([3.00],";
    "Fxn:variable([0.2],";
    "Fxn:variable(probabilities,";
    "Fxn:variable(probabilities_1,";
    "Fxn:self.assertEqual(RelaxedOneHotCategorical(temp,";
    "Fxn:p).sample().size(),";
    "Fxn:self.assertEqual(RelaxedOneHotCategorical(temp,";
    "Fxn:p).sample(sample_shape=(3,";
    "Fxn:4)).size(),";
    "Fxn:self.assertEqual(RelaxedOneHotCategorical(temp,";
    "Fxn:p).sample_n(6).size(),";
    "Fxn:self._gradcheck_log_prob(RelaxedOneHotCategorical,";
    "Fxn:self._gradcheck_log_prob(RelaxedOneHotCategorical,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_argmax_relaxed_categorical";
    "Fxn:set_rng_seed(0)";
    "class:ArgMax(object):";
    "Fxn:__init__";
    "Fxn:sample";
    "Fxn:self.dist.sample(*args,";
    "Fxn:torch.max(s,";
    "class:ScipyCategorical(object):";
    "Fxn:__init__";
    "Fxn:pmf";
    "Fxn:np.zeros(samples.shape";
    "Fxn:new_samples[np.arange(samples.shape[0]),";
    "Fxn:self.dist.pmf(new_samples)";
    "Fxn:product([torch.Tensor([0.1,";
    "Fxn:torch.Tensor([0.2,";
    "Fxn:self._check_sampler_discrete(ArgMax(RelaxedOneHotCategorical(temp,";
    "Fxn:ScipyCategorical(scipy.stats.multinomial(1,";
    "Fxn:'Rounded(RelaxedOneHotCategorical(temp={},";
    "Fxn:probs={}))'.format(temp,";
    "Fxn:[torch.Tensor([0.1,";
    "Fxn:torch.Tensor([0.2,";
    "Fxn:torch.ones(probs.size())";
    "Fxn:probs.size()[0]";
    "Fxn:RelaxedOneHotCategorical(1e10,";
    "Fxn:dist.rsample()";
    "Fxn:self.assertEqual(equal_probs,";
    "Fxn:test_uniform";
    "Fxn:variable(torch.zeros(5,";
    "Fxn:variable(torch.ones(5,";
    "Fxn:variable(torch.zeros(1),";
    "Fxn:variable(torch.ones(1)";
    "Fxn:self.assertEqual(Uniform(low,";
    "Fxn:high).sample().size(),";
    "Fxn:self.assertEqual(Uniform(low,";
    "Fxn:high).sample((7,)).size(),";
    "Fxn:self.assertEqual(Uniform(low_1d,";
    "Fxn:high_1d).sample().size(),";
    "Fxn:self.assertEqual(Uniform(low_1d,";
    "Fxn:high_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Uniform(0.0,";
    "Fxn:1.0).sample((1,)).size(),";
    "Fxn:Uniform(low_1d,";
    "Fxn:variable([4.0])";
    "Fxn:variable([-1.0])";
    "Fxn:self.assertEqual(uniform.log_prob(above_high).item(),";
    "Fxn:-float('inf'),";
    "Fxn:self.assertEqual(uniform.log_prob(below_low).item(),";
    "Fxn:-float('inf'),";
    "Fxn:set_rng_seed(1)";
    "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:torch.get_rng_state()";
    "Fxn:low.new(low.size()).uniform_()";
    "Fxn:torch.set_rng_state(state)";
    "Fxn:Uniform(low,";
    "Fxn:high).rsample()";
    "Fxn:u.backward(torch.ones_like(u))";
    "Fxn:self.assertEqual(low.grad,";
    "Fxn:self.assertEqual(high.grad,";
    "Fxn:low.grad.zero_()";
    "Fxn:high.grad.zero_()";
    "Fxn:test_cauchy";
    "Fxn:variable(torch.zeros(5,";
    "Fxn:variable(torch.ones(5,";
    "Fxn:variable(torch.zeros(1),";
    "Fxn:variable(torch.ones(1),";
    "Fxn:self.assertTrue(is_all_nan(Cauchy(loc_1d,";
    "Fxn:self.assertEqual(Cauchy(loc_1d,";
    "Fxn:self.assertEqual(Cauchy(loc,";
    "Fxn:scale).sample().size(),";
    "Fxn:self.assertEqual(Cauchy(loc,";
    "Fxn:scale).sample((7,)).size(),";
    "Fxn:self.assertEqual(Cauchy(loc_1d,";
    "Fxn:scale_1d).sample().size(),";
    "Fxn:self.assertEqual(Cauchy(loc_1d,";
    "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Cauchy(0.0,";
    "Fxn:1.0).sample((1,)).size(),";
    "Fxn:set_rng_seed(1)";
    "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:torch.get_rng_state()";
    "Fxn:loc.new(loc.size()).cauchy_()";
    "Fxn:torch.set_rng_state(state)";
    "Fxn:Cauchy(loc,";
    "Fxn:scale).rsample()";
    "Fxn:c.backward(torch.ones_like(c))";
    "Fxn:self.assertEqual(loc.grad,";
    "Fxn:torch.ones_like(scale))";
    "Fxn:self.assertEqual(scale.grad,";
    "Fxn:loc.grad.zero_()";
    "Fxn:scale.grad.zero_()";
    "Fxn:test_lognormal";
    "Fxn:variable(torch.randn(5,";
    "Fxn:variable(torch.randn(5,";
    "Fxn:5).abs(),";
    "Fxn:variable(torch.randn(1),";
    "Fxn:variable(torch.randn(1),";
    "Fxn:variable([1.0,";
    "Fxn:variable([1e-5,";
    "Fxn:self.assertEqual(LogNormal(mean,";
    "Fxn:std).sample().size(),";
    "Fxn:self.assertEqual(LogNormal(mean,";
    "Fxn:std).sample((7,)).size(),";
    "Fxn:self.assertEqual(LogNormal(mean_1d,";
    "Fxn:std_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(LogNormal(mean_1d,";
    "Fxn:std_1d).sample().size(),";
    "Fxn:self.assertEqual(LogNormal(0.2,";
    "Fxn:.6).sample((1,)).size(),";
    "Fxn:self.assertEqual(LogNormal(-0.7,";
    "Fxn:50.0).sample((1,)).size(),";
    "Fxn:set_rng_seed(1)";
    "Fxn:self.assertEqual(LogNormal(mean_delta,";
    "Fxn:std_delta).sample(sample_shape=(1,";
    "Fxn:torch.Tensor([[[math.exp(1),";
    "Fxn:[math.exp(1),";
    "Fxn:self._gradcheck_log_prob(LogNormal,";
    "Fxn:self._gradcheck_log_prob(LogNormal,";
    "Fxn:self._gradcheck_log_prob(LogNormal,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_lognormal_logprob";
    "Fxn:variable(torch.randn(5,";
    "Fxn:variable(torch.randn(5,";
    "Fxn:1).abs(),";
    "Fxn:ref_log_prob";
    "Fxn:mean.data.view(-1)[idx]";
    "Fxn:std.data.view(-1)[idx]";
    "Fxn:scipy.stats.lognorm(s=s,";
    "Fxn:scale=math.exp(m)).logpdf(x)";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(LogNormal(mean,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_lognormal_sample";
    "Fxn:set_rng_seed(0)";
    "Fxn:product([-1.0,";
    "Fxn:self._check_sampler_sampler(LogNormal(mean,";
    "Fxn:scipy.stats.lognorm(scale=math.exp(mean),";
    "Fxn:'LogNormal(loc={},";
    "Fxn:scale={})'.format(mean,";
    "Fxn:test_normal";
    "Fxn:variable(torch.randn(5,";
    "Fxn:variable(torch.randn(5,";
    "Fxn:5).abs(),";
    "Fxn:variable(torch.randn(1),";
    "Fxn:variable(torch.randn(1),";
    "Fxn:variable([1.0,";
    "Fxn:variable([1e-5,";
    "Fxn:self.assertEqual(Normal(loc,";
    "Fxn:scale).sample().size(),";
    "Fxn:self.assertEqual(Normal(loc,";
    "Fxn:scale).sample((7,)).size(),";
    "Fxn:self.assertEqual(Normal(loc_1d,";
    "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Normal(loc_1d,";
    "Fxn:scale_1d).sample().size(),";
    "Fxn:self.assertEqual(Normal(0.2,";
    "Fxn:.6).sample((1,)).size(),";
    "Fxn:self.assertEqual(Normal(-0.7,";
    "Fxn:50.0).sample((1,)).size(),";
    "Fxn:set_rng_seed(1)";
    "Fxn:self.assertEqual(Normal(loc_delta,";
    "Fxn:scale_delta).sample(sample_shape=(1,";
    "Fxn:torch.Tensor([[[1.0,";
    "Fxn:self._gradcheck_log_prob(Normal,";
    "Fxn:self._gradcheck_log_prob(Normal,";
    "Fxn:self._gradcheck_log_prob(Normal,";
    "Fxn:torch.get_rng_state()";
    "Fxn:torch.normal(torch.zeros_like(loc),";
    "Fxn:torch.ones_like(scale))";
    "Fxn:torch.set_rng_state(state)";
    "Fxn:Normal(loc,";
    "Fxn:scale).rsample()";
    "Fxn:z.backward(torch.ones_like(z))";
    "Fxn:self.assertEqual(loc.grad,";
    "Fxn:torch.ones_like(loc))";
    "Fxn:self.assertEqual(scale.grad,";
    "Fxn:loc.grad.zero_()";
    "Fxn:scale.grad.zero_()";
    "Fxn:self.assertEqual(z.size(),";
    "Fxn:ref_log_prob";
    "Fxn:loc.data.view(-1)[idx]";
    "Fxn:scale.data.view(-1)[idx]";
    "Fxn:math.sqrt(2";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:math.log(expected),";
    "Fxn:self._check_log_prob(Normal(loc,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_normal_sample";
    "Fxn:set_rng_seed(0)";
    "Fxn:product([-1.0,";
    "Fxn:self._check_sampler_sampler(Normal(loc,";
    "Fxn:scipy.stats.norm(loc=loc,";
    "Fxn:'Normal(mean={},";
    "Fxn:std={})'.format(loc,";
    "Fxn:test_exponential";
    "Fxn:variable(torch.randn(5,";
    "Fxn:5).abs(),";
    "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:self.assertEqual(Exponential(rate).sample().size(),";
    "Fxn:self.assertEqual(Exponential(rate).sample((7,)).size(),";
    "Fxn:self.assertEqual(Exponential(rate_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Exponential(rate_1d).sample().size(),";
    "Fxn:self.assertEqual(Exponential(0.2).sample((1,)).size(),";
    "Fxn:self.assertEqual(Exponential(50.0).sample((1,)).size(),";
    "Fxn:self._gradcheck_log_prob(Exponential,";
    "Fxn:torch.get_rng_state()";
    "Fxn:rate.new(rate.size()).exponential_()";
    "Fxn:torch.set_rng_state(state)";
    "Fxn:Exponential(rate).rsample()";
    "Fxn:z.backward(torch.ones_like(z))";
    "Fxn:self.assertEqual(rate.grad,";
    "Fxn:rate.grad.zero_()";
    "Fxn:self.assertEqual(z.size(),";
    "Fxn:ref_log_prob";
    "Fxn:rate.data.view(-1)[idx]";
    "Fxn:math.log(m)";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(Exponential(rate),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_exponential_sample";
    "Fxn:set_rng_seed(1)";
    "Fxn:self._check_sampler_sampler(Exponential(rate),";
    "Fxn:scipy.stats.expon(scale=1.";
    "Fxn:'Exponential(rate={})'.format(rate))";
    "Fxn:test_laplace";
    "Fxn:variable(torch.randn(5,";
    "Fxn:variable(torch.randn(5,";
    "Fxn:5).abs(),";
    "Fxn:variable(torch.randn(1),";
    "Fxn:variable(torch.randn(1),";
    "Fxn:torch.Tensor([1.0,";
    "Fxn:torch.Tensor([1e-5,";
    "Fxn:self.assertEqual(Laplace(loc,";
    "Fxn:scale).sample().size(),";
    "Fxn:self.assertEqual(Laplace(loc,";
    "Fxn:scale).sample((7,)).size(),";
    "Fxn:self.assertEqual(Laplace(loc_1d,";
    "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Laplace(loc_1d,";
    "Fxn:scale_1d).sample().size(),";
    "Fxn:self.assertEqual(Laplace(0.2,";
    "Fxn:.6).sample((1,)).size(),";
    "Fxn:self.assertEqual(Laplace(-0.7,";
    "Fxn:50.0).sample((1,)).size(),";
    "Fxn:set_rng_seed(0)";
    "Fxn:self.assertEqual(Laplace(loc_delta,";
    "Fxn:scale_delta).sample(sample_shape=(1,";
    "Fxn:torch.Tensor([[[1.0,";
    "Fxn:self._gradcheck_log_prob(Laplace,";
    "Fxn:self._gradcheck_log_prob(Laplace,";
    "Fxn:self._gradcheck_log_prob(Laplace,";
    "Fxn:torch.get_rng_state()";
    "Fxn:torch.ones_like(loc).uniform_(-.5,";
    "Fxn:torch.set_rng_state(state)";
    "Fxn:Laplace(loc,";
    "Fxn:scale).rsample()";
    "Fxn:z.backward(torch.ones_like(z))";
    "Fxn:self.assertEqual(loc.grad,";
    "Fxn:torch.ones_like(loc))";
    "Fxn:self.assertEqual(scale.grad,";
    "Fxn:-eps.sign()";
    "Fxn:torch.log1p(-2";
    "Fxn:eps.abs()))";
    "Fxn:loc.grad.zero_()";
    "Fxn:scale.grad.zero_()";
    "Fxn:self.assertEqual(z.size(),";
    "Fxn:ref_log_prob";
    "Fxn:loc.data.view(-1)[idx]";
    "Fxn:scale.data.view(-1)[idx]";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(Laplace(loc,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_laplace_sample";
    "Fxn:set_rng_seed(1)";
    "Fxn:product([-1.0,";
    "Fxn:self._check_sampler_sampler(Laplace(loc,";
    "Fxn:scipy.stats.laplace(loc=loc,";
    "Fxn:'Laplace(loc={},";
    "Fxn:scale={})'.format(loc,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gamma_shape";
    "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:self.assertEqual(Gamma(alpha,";
    "Fxn:beta).sample().size(),";
    "Fxn:self.assertEqual(Gamma(alpha,";
    "Fxn:beta).sample((5,)).size(),";
    "Fxn:self.assertEqual(Gamma(alpha_1d,";
    "Fxn:beta_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Gamma(alpha_1d,";
    "Fxn:beta_1d).sample().size(),";
    "Fxn:self.assertEqual(Gamma(0.5,";
    "Fxn:0.5).sample().size(),";
    "Fxn:self.assertEqual(Gamma(0.5,";
    "Fxn:0.5).sample((1,)).size(),";
    "Fxn:ref_log_prob";
    "Fxn:alpha.data.view(-1)[idx]";
    "Fxn:beta.data.view(-1)[idx]";
    "Fxn:scipy.stats.gamma.logpdf(x,";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(Gamma(alpha,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gamma_sample";
    "Fxn:set_rng_seed(0)";
    "Fxn:product([0.1,";
    "Fxn:self._check_sampler_sampler(Gamma(alpha,";
    "Fxn:scipy.stats.gamma(alpha,";
    "Fxn:'Gamma(concentration={},";
    "Fxn:rate={})'.format(alpha,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_pareto";
    "Fxn:variable(torch.randn(2,";
    "Fxn:3).abs(),";
    "Fxn:variable(torch.randn(2,";
    "Fxn:3).abs(),";
    "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:self.assertEqual(Pareto(scale,";
    "Fxn:alpha).sample().size(),";
    "Fxn:self.assertEqual(Pareto(scale,";
    "Fxn:alpha).sample((5,)).size(),";
    "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:alpha_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:alpha_1d).sample().size(),";
    "Fxn:self.assertEqual(Pareto(1.0,";
    "Fxn:1.0).sample().size(),";
    "Fxn:self.assertEqual(Pareto(1.0,";
    "Fxn:1.0).sample((1,)).size(),";
    "Fxn:ref_log_prob";
    "Fxn:scale.data.view(-1)[idx]";
    "Fxn:alpha.data.view(-1)[idx]";
    "Fxn:scipy.stats.pareto.logpdf(x,";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(Pareto(scale,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_pareto_sample";
    "Fxn:set_rng_seed(1)";
    "Fxn:product([0.1,";
    "Fxn:self._check_sampler_sampler(Pareto(scale,";
    "Fxn:scipy.stats.pareto(alpha,";
    "Fxn:'Pareto(scale={},";
    "Fxn:alpha={})'.format(scale,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gumbel";
    "Fxn:variable(torch.randn(2,";
    "Fxn:variable(torch.randn(2,";
    "Fxn:3).abs(),";
    "Fxn:variable(torch.randn(1),";
    "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:self.assertEqual(Gumbel(loc,";
    "Fxn:scale).sample().size(),";
    "Fxn:self.assertEqual(Gumbel(loc,";
    "Fxn:scale).sample((5,)).size(),";
    "Fxn:self.assertEqual(Gumbel(loc_1d,";
    "Fxn:scale_1d).sample().size(),";
    "Fxn:self.assertEqual(Gumbel(loc_1d,";
    "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Gumbel(1.0,";
    "Fxn:1.0).sample().size(),";
    "Fxn:self.assertEqual(Gumbel(1.0,";
    "Fxn:1.0).sample((1,)).size(),";
    "Fxn:ref_log_prob";
    "Fxn:loc.data.view(-1)[idx]";
    "Fxn:scale.data.view(-1)[idx]";
    "Fxn:scipy.stats.gumbel_r.logpdf(x,";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(Gumbel(loc,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gumbel_sample";
    "Fxn:set_rng_seed(1)";
    "Fxn:product([-5.0,";
    "Fxn:self._check_sampler_sampler(Gumbel(loc,";
    "Fxn:scipy.stats.gumbel_r(loc=loc,";
    "Fxn:'Gumbel(loc={},";
    "Fxn:scale={})'.format(loc,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_fishersnedecor";
    "Fxn:variable(torch.randn(2,";
    "Fxn:3).abs(),";
    "Fxn:variable(torch.randn(2,";
    "Fxn:3).abs(),";
    "Fxn:torch.randn(1).abs()";
    "Fxn:torch.randn(1).abs()";
    "Fxn:self.assertTrue(is_all_nan(FisherSnedecor(1,";
    "Fxn:self.assertTrue(is_all_nan(FisherSnedecor(1,";
    "Fxn:self.assertEqual(FisherSnedecor(df1,";
    "Fxn:df2).sample().size(),";
    "Fxn:self.assertEqual(FisherSnedecor(df1,";
    "Fxn:df2).sample((5,)).size(),";
    "Fxn:self.assertEqual(FisherSnedecor(df1_1d,";
    "Fxn:df2_1d).sample().size(),";
    "Fxn:self.assertEqual(FisherSnedecor(df1_1d,";
    "Fxn:df2_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(FisherSnedecor(1.0,";
    "Fxn:1.0).sample().size(),";
    "Fxn:self.assertEqual(FisherSnedecor(1.0,";
    "Fxn:1.0).sample((1,)).size(),";
    "Fxn:ref_log_prob";
    "Fxn:df1.data.view(-1)[idx]";
    "Fxn:df2.data.view(-1)[idx]";
    "Fxn:scipy.stats.f.logpdf(x,";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(FisherSnedecor(df1,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_fishersnedecor_sample";
    "Fxn:set_rng_seed(1)";
    "Fxn:product([0.1,";
    "Fxn:self._check_sampler_sampler(FisherSnedecor(df1,";
    "Fxn:scipy.stats.f(df1,";
    "Fxn:'FisherSnedecor(loc={},";
    "Fxn:scale={})'.format(df1,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_chi2_shape";
    "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:self.assertEqual(Chi2(df).sample().size(),";
    "Fxn:self.assertEqual(Chi2(df).sample((5,)).size(),";
    "Fxn:self.assertEqual(Chi2(df_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Chi2(df_1d).sample().size(),";
    "Fxn:self.assertEqual(Chi2(torch.tensor(0.5,";
    "Fxn:requires_grad=True)).sample().size(),";
    "Fxn:self.assertEqual(Chi2(0.5).sample().size(),";
    "Fxn:self.assertEqual(Chi2(0.5).sample((1,)).size(),";
    "Fxn:ref_log_prob";
    "Fxn:df.data.view(-1)[idx]";
    "Fxn:scipy.stats.chi2.logpdf(x,";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(Chi2(df),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_chi2_sample";
    "Fxn:set_rng_seed(0)";
    "Fxn:self._check_sampler_sampler(Chi2(df),";
    "Fxn:scipy.stats.chi2(df),";
    "Fxn:'Chi2(df={})'.format(df))";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_studentT";
    "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:self.assertTrue(is_all_nan(StudentT(1).mean))";
    "Fxn:self.assertTrue(is_all_nan(StudentT(1).variance))";
    "Fxn:self.assertEqual(StudentT(2).variance,";
    "Fxn:self.assertEqual(StudentT(df).sample().size(),";
    "Fxn:self.assertEqual(StudentT(df).sample((5,)).size(),";
    "Fxn:self.assertEqual(StudentT(df_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(StudentT(df_1d).sample().size(),";
    "Fxn:self.assertEqual(StudentT(torch.tensor(0.5,";
    "Fxn:requires_grad=True)).sample().size(),";
    "Fxn:self.assertEqual(StudentT(0.5).sample().size(),";
    "Fxn:self.assertEqual(StudentT(0.5).sample((1,)).size(),";
    "Fxn:ref_log_prob";
    "Fxn:df.data.view(-1)[idx]";
    "Fxn:scipy.stats.t.logpdf(x,";
    "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:self._check_log_prob(StudentT(df),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_studentT_sample";
    "Fxn:set_rng_seed(11)";
    "Fxn:product([0.1,";
    "Fxn:self._check_sampler_sampler(StudentT(df=df,";
    "Fxn:scipy.stats.t(df=df,";
    "Fxn:'StudentT(df={},";
    "Fxn:scale={})'.format(df,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_studentT_log_prob";
    "Fxn:set_rng_seed(0)";
    "Fxn:product([0.1,";
    "Fxn:StudentT(df=df,";
    "Fxn:dist.sample((num_samples,))";
    "Fxn:dist.log_prob(x)";
    "Fxn:scipy.stats.t.logpdf(x[i],";
    "Fxn:self.assertAlmostEqual(float(actual_log_prob[i]),";
    "Fxn:test_dirichlet_shape";
    "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:variable(torch.exp(torch.randn(4)),";
    "Fxn:self.assertEqual(Dirichlet(alpha).sample().size(),";
    "Fxn:self.assertEqual(Dirichlet(alpha).sample((5,)).size(),";
    "Fxn:self.assertEqual(Dirichlet(alpha_1d).sample().size(),";
    "Fxn:self.assertEqual(Dirichlet(alpha_1d).sample((1,)).size(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_dirichlet_log_prob";
    "Fxn:torch.exp(torch.randn(5))";
    "Fxn:Dirichlet(alpha)";
    "Fxn:dist.sample((num_samples,))";
    "Fxn:dist.log_prob(x)";
    "Fxn:scipy.stats.dirichlet.logpdf(x[i].numpy(),";
    "Fxn:alpha.numpy())";
    "Fxn:self.assertAlmostEqual(actual_log_prob[i],";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_dirichlet_sample";
    "Fxn:set_rng_seed(0)";
    "Fxn:torch.exp(torch.randn(3))";
    "Fxn:self._check_sampler_sampler(Dirichlet(alpha),";
    "Fxn:scipy.stats.dirichlet(alpha.numpy()),";
    "Fxn:'Dirichlet(alpha={})'.format(list(alpha)),";
    "Fxn:test_beta_shape";
    "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:variable(torch.exp(torch.randn(4)),";
    "Fxn:variable(torch.exp(torch.randn(4)),";
    "Fxn:self.assertEqual(Beta(con1,";
    "Fxn:con0).sample().size(),";
    "Fxn:self.assertEqual(Beta(con1,";
    "Fxn:con0).sample((5,)).size(),";
    "Fxn:self.assertEqual(Beta(con1_1d,";
    "Fxn:con0_1d).sample().size(),";
    "Fxn:self.assertEqual(Beta(con1_1d,";
    "Fxn:con0_1d).sample((1,)).size(),";
    "Fxn:self.assertEqual(Beta(0.1,";
    "Fxn:0.3).sample().size(),";
    "Fxn:self.assertEqual(Beta(0.1,";
    "Fxn:0.3).sample((5,)).size(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_log_prob";
    "Fxn:np.exp(np.random.normal())";
    "Fxn:np.exp(np.random.normal())";
    "Fxn:Beta(con1,";
    "Fxn:dist.sample()";
    "Fxn:dist.log_prob(x).sum()";
    "Fxn:scipy.stats.beta.logpdf(x,";
    "Fxn:self.assertAlmostEqual(float(actual_log_prob),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_sample";
    "Fxn:set_rng_seed(1)";
    "Fxn:product([0.1,";
    "Fxn:self._check_sampler_sampler(Beta(con1,";
    "Fxn:scipy.stats.beta(con1,";
    "Fxn:'Beta(alpha={},";
    "Fxn:beta={})'.format(con1,";
    "Fxn:Beta(Tensor([1e-6]),";
    "Fxn:Tensor([1e-6])).sample()[0]";
    "Fxn:self.assertTrue(np.isfinite(x)";
    "Fxn:Beta.sample():";
    "Fxn:{}'.format(x))";
    "Fxn:test_cdf_icdf_inverse";
    "Fxn:Dist(**param)";
    "Fxn:dist.sample(sample_shape=(20,))";
    "Fxn:dist.cdf(samples)";
    "Fxn:dist.icdf(cdf)";
    "Fxn:torch.abs(actual";
    "Fxn:torch.abs(samples))";
    "Fxn:self.assertLess(rel_error.max(),";
    "Fxn:msg='\n'.join([";
    "Fxn:icdf(cdf(x))";
    "Fxn:x'.format(Dist.__name__,";
    "Fxn:{}'.format(samples),";
    "Fxn:'cdf(x)";
    "Fxn:{}'.format(cdf),";
    "Fxn:'icdf(cdf(x))";
    "Fxn:{}'.format(actual),";
    "Fxn:test_cdf_log_prob";
    "Fxn:Dist(**param)";
    "Fxn:variable(dist.sample().data,";
    "Fxn:dist.cdf(samples)";
    "Fxn:dist.log_prob(samples).exp()";
    "Fxn:grad(cdfs.sum(),";
    "Fxn:torch.abs()";
    "Fxn:self.assertEqual(cdfs_derivative,";
    "Fxn:message='\n'.join([";
    "Fxn:pdf(x)'.format(Dist.__name__,";
    "Fxn:{}'.format(samples),";
    "Fxn:{}'.format(cdfs),";
    "Fxn:{}'.format(pdfs),";
    "Fxn:'grad(cdf)";
    "Fxn:{}'.format(cdfs_derivative),";
    "Fxn:test_valid_parameter_broadcasting";
    "Fxn:scale=torch.tensor([1,";
    "Fxn:scale=torch.tensor([1])),";
    "Fxn:scale=torch.tensor([[1],";
    "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:df2=torch.tensor([1,";
    "Fxn:df2=torch.tensor([1])),";
    "Fxn:df2=torch.tensor([[1],";
    "Fxn:df2=torch.tensor([[1]])),";
    "Fxn:df2=torch.tensor([[1]])),";
    "Fxn:rate=torch.tensor([1,";
    "Fxn:rate=torch.tensor([[1],";
    "Fxn:rate=torch.tensor([[1],";
    "Fxn:rate=torch.tensor([[1]])),";
    "Fxn:rate=torch.tensor([[1]])),";
    "Fxn:scale=torch.tensor([1,";
    "Fxn:scale=torch.tensor([1])),";
    "Fxn:scale=torch.tensor([[1],";
    "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:scale=torch.tensor([1,";
    "Fxn:scale=torch.tensor([1])),";
    "Fxn:scale=torch.tensor([[1],";
    "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:alpha=torch.tensor([1,";
    "Fxn:alpha=torch.tensor([1])),";
    "Fxn:alpha=torch.tensor([[1],";
    "Fxn:alpha=torch.tensor([[1]])),";
    "Fxn:alpha=torch.tensor([[1]])),";
    "Fxn:scale=torch.tensor([1,";
    "Fxn:loc=torch.tensor([1])),";
    "Fxn:scale=torch.tensor([[1],";
    "Fxn:loc=torch.tensor([[1]])),";
    "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:dist.sample().size()";
    "Fxn:self.assertEqual(dist_sample_size,";
    "Fxn:{}'.format(dist_sample_size,";
    "Fxn:test_invalid_parameter_broadcasting";
    "Fxn:torch.tensor([[0,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([[[0,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([[0,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([[[0,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([0,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([0,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:.rsample()";
    "class:TestRsample(TestCase):";
    "Fxn:test_gamma";
    "Fxn:variable(torch.FloatTensor([alpha]";
    "Fxn:variable(torch.ones(num_samples).type_as(alphas))";
    "Fxn:Gamma(alphas,";
    "Fxn:betas).rsample()";
    "Fxn:x.sum().backward()";
    "Fxn:x.data.sort()";
    "Fxn:x.numpy()";
    "Fxn:alphas.grad.data[ind].numpy()";
    "Fxn:cdf(x,alpha).";
    "Fxn:cdf(x,";
    "Fxn:pdf(x,";
    "Fxn:np.abs(actual_grad";
    "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:'\n'.join([";
    "Fxn:Gamma({},";
    "Fxn:1)'.format(alpha),";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(expected_grad),";
    "Fxn:{}'.format(actual_grad),";
    "Fxn:{}'.format(rel_error),";
    "Fxn:{}'.format(rel_error.max()),";
    "Fxn:x={}'.format(alpha,";
    "Fxn:x[rel_error.argmax()]),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_chi2";
    "Fxn:variable(torch.FloatTensor([df]";
    "Fxn:Chi2(dfs).rsample()";
    "Fxn:x.sum().backward()";
    "Fxn:x.data.sort()";
    "Fxn:x.numpy()";
    "Fxn:dfs.grad.data[ind].numpy()";
    "Fxn:cdf(x,df).";
    "Fxn:cdf(x,";
    "Fxn:pdf(x,";
    "Fxn:np.abs(actual_grad";
    "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:'\n'.join([";
    "Fxn:Chi2({})'.format(df),";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(expected_grad),";
    "Fxn:{}'.format(actual_grad),";
    "Fxn:{}'.format(rel_error),";
    "Fxn:{}'.format(rel_error.max()),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_dirichlet_on_diagonal";
    "Fxn:product(grid,";
    "Fxn:variable(torch.FloatTensor([[a0,";
    "Fxn:Dirichlet(alphas).rsample()[:,";
    "Fxn:x.sum().backward()";
    "Fxn:x.data.sort()";
    "Fxn:x.numpy()";
    "Fxn:alphas.grad.data[ind].numpy()[:,";
    "Fxn:cdf(x,alpha).";
    "Fxn:Beta(alpha[0],";
    "Fxn:np.sqrt(alpha))";
    "Fxn:cdf(x,";
    "Fxn:pdf(x,";
    "Fxn:np.abs(actual_grad";
    "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:'\n'.join([";
    "Fxn:Dirichlet([{},";
    "Fxn:{}])'.format(a0,";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(expected_grad),";
    "Fxn:{}'.format(actual_grad),";
    "Fxn:{}'.format(rel_error),";
    "Fxn:{}'.format(rel_error.max()),";
    "Fxn:x={}'.format(x[rel_error.argmax()]),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_wrt_alpha";
    "Fxn:product(grid,";
    "Fxn:variable(torch.FloatTensor([con1]";
    "Fxn:variable(torch.FloatTensor([con0]";
    "Fxn:num_samples).type_as(con1s))";
    "Fxn:Beta(con1s,";
    "Fxn:con0s).rsample()";
    "Fxn:x.sum().backward()";
    "Fxn:x.data.sort()";
    "Fxn:x.numpy()";
    "Fxn:con1s.grad.data[ind].numpy()";
    "Fxn:cdf(x,con1,con0).";
    "Fxn:np.sqrt(con1))";
    "Fxn:cdf(x,";
    "Fxn:pdf(x,";
    "Fxn:np.abs(actual_grad";
    "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:'\n'.join([";
    "Fxn:Beta({},";
    "Fxn:{})'.format(con1,";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(expected_grad),";
    "Fxn:{}'.format(actual_grad),";
    "Fxn:{}'.format(rel_error),";
    "Fxn:{}'.format(rel_error.max()),";
    "Fxn:{}'.format(x[rel_error.argmax()]),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_wrt_beta";
    "Fxn:product(grid,";
    "Fxn:variable(torch.FloatTensor([con0]";
    "Fxn:variable(torch.FloatTensor([con1]";
    "Fxn:num_samples).type_as(con0s))";
    "Fxn:Beta(con1s,";
    "Fxn:con0s).rsample()";
    "Fxn:x.sum().backward()";
    "Fxn:x.data.sort()";
    "Fxn:x.numpy()";
    "Fxn:con0s.grad.data[ind].numpy()";
    "Fxn:cdf(x,con1,con0).";
    "Fxn:np.sqrt(con0))";
    "Fxn:cdf(x,";
    "Fxn:pdf(x,";
    "Fxn:np.abs(actual_grad";
    "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:'\n'.join([";
    "Fxn:Beta({},";
    "Fxn:{})'.format(con1,";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(expected_grad),";
    "Fxn:{}'.format(actual_grad),";
    "Fxn:{}'.format(rel_error),";
    "Fxn:{}'.format(rel_error.max()),";
    "Fxn:{!r}'.format(x[rel_error.argmax()]),";
    "Fxn:test_dirichlet_multivariate";
    "Fxn:variable(torch.FloatTensor([alpha]),";
    "Fxn:torch.cat([alpha,";
    "Fxn:alpha.new([1])])";
    "Fxn:Dirichlet(alpha_vec.expand(num_samples,";
    "Fxn:3)).rsample()";
    "Fxn:torch.pow(z[:,";
    "Fxn:2.0).mean()";
    "Fxn:grad(loss,";
    "Fxn:self.assertEqual(actual_grad,";
    "Fxn:'\n'.join([";
    "Fxn:torch.abs(expected_grad";
    "Fxn:actual_grad).max(),";
    "Fxn:test_dirichlet_tangent_field";
    "Fxn:compute_v";
    "Fxn:torch.stack([";
    "Fxn:_Dirichlet_backward(x,";
    "Fxn:torch.eye(3,";
    "Fxn:3)[i].expand_as(x))[:,";
    "Fxn:product(alpha_grid,";
    "Fxn:variable([a1,";
    "Fxn:requires_grad=True).expand(num_samples,";
    "Fxn:Dirichlet(alpha).rsample()";
    "Fxn:grad([Dirichlet(alpha).log_prob(x.detach()).sum()],";
    "Fxn:grad([Dirichlet(alpha.detach()).log_prob(x).sum()],";
    "Fxn:torch.stack([grad([x[:,";
    "Fxn:i].sum()],";
    "Fxn:self.assertEqual(compute_v(x,";
    "Fxn:compute_v()";
    "Fxn:torch.Tensor([[2,";
    "Fxn:dx.norm(2,";
    "Fxn:x.min(-1,";
    "Fxn:compute_v(x";
    "Fxn:compute_v(x";
    "Fxn:dx[1]).sum(-1)";
    "Fxn:log_prob.exp().";
    "Fxn:v).sum(-1)";
    "Fxn:self.assertLess(torch.abs(error).max(),";
    "Fxn:'\n'.join([";
    "Fxn:'Dirichlet([{},";
    "Fxn:equation:'.format(a1,";
    "Fxn:{}'.format(error),";
    "class:TestDistributionShapes(TestCase):";
    "Fxn:setUp";
    "Fxn:self).setUp()";
    "Fxn:variable(torch.ones(3,";
    "Fxn:variable(torch.ones(3,";
    "Fxn:Distribution.set_default_validate_args(True)";
    "Fxn:tearDown";
    "Fxn:self).tearDown()";
    "Fxn:Distribution.set_default_validate_args(False)";
    "Fxn:test_entropy_shape";
    "Fxn:Dist(validate_args=False,";
    "Fxn:dist.entropy().size()";
    "Fxn:torch.Size()";
    "Fxn:{}'.format(";
    "Fxn:self.assertEqual(actual_shape,";
    "Fxn:test_bernoulli_shape_scalar_params";
    "Fxn:Bernoulli(0.3)";
    "Fxn:self.assertEqual(bernoulli._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(bernoulli._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(bernoulli.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(bernoulli.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(bernoulli.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(bernoulli.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_tensor_params";
    "Fxn:Bernoulli(torch.tensor([[0.6,";
    "Fxn:self.assertEqual(bernoulli._batch_shape,";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(bernoulli._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(bernoulli.sample().size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(bernoulli.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(bernoulli.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(bernoulli.log_prob(variable(torch.ones(3,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_scalar_params";
    "Fxn:Geometric(0.3)";
    "Fxn:self.assertEqual(geometric._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(geometric._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(geometric.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(geometric.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(geometric.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(geometric.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_tensor_params";
    "Fxn:Geometric(torch.tensor([[0.6,";
    "Fxn:self.assertEqual(geometric._batch_shape,";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(geometric._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(geometric.sample().size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(geometric.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(geometric.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(geometric.log_prob(variable(torch.ones(3,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_scalar_params";
    "Fxn:Beta(0.1,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_tensor_params";
    "Fxn:Beta(torch.tensor([[0.1,";
    "Fxn:torch.tensor([[0.1,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_binomial_shape";
    "Fxn:Binomial(10,";
    "Fxn:torch.tensor([0.6,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_multinomial_shape";
    "Fxn:Multinomial(10,";
    "Fxn:torch.tensor([[0.6,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:2))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape";
    "Fxn:Categorical(torch.tensor([0.6,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:Categorical(torch.tensor([[0.6,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_one_hot_categorical_shape";
    "Fxn:OneHotCategorical(torch.tensor([0.6,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.tensor_sample_2.sum(-1,";
    "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.log_prob(dist.enumerate_support()).size(),";
    "Fxn:torch.Size((3,)))";
    "Fxn:variable(torch.ones(3,";
    "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:torch.Size((3,)))";
    "Fxn:OneHotCategorical(torch.tensor([[0.6,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.tensor_sample_1.sum(-1,";
    "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(dist.log_prob(dist.enumerate_support()).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:variable(torch.ones(3,";
    "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_scalar_params";
    "Fxn:Cauchy(0,";
    "Fxn:self.assertEqual(cauchy._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(cauchy._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(cauchy.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(cauchy.sample(torch.Size((3,";
    "Fxn:2))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(cauchy.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(cauchy.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_tensor_params";
    "Fxn:Cauchy(torch.tensor([0,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertEqual(cauchy._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(cauchy._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(cauchy.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(cauchy.sample(torch.Size((3,";
    "Fxn:2))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(cauchy.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(cauchy.log_prob(variable(torch.ones(2,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:test_dirichlet_shape";
    "Fxn:Dirichlet(torch.tensor([[0.6,";
    "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(dist.sample((5,";
    "Fxn:4)).size(),";
    "Fxn:torch.Size((5,";
    "Fxn:self.tensor_sample_1.sum(-1,";
    "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:torch.Size((3,)))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:torch.ones((3,";
    "Fxn:simplex_sample.sum(-1).unsqueeze(-1)";
    "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_scalar_params";
    "Fxn:Gamma(1,";
    "Fxn:self.assertEqual(gamma._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(gamma._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(gamma.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(gamma.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(gamma.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(gamma.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_tensor_params";
    "Fxn:Gamma(torch.tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertEqual(gamma._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(gamma._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(gamma.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(gamma.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(gamma.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(gamma.log_prob(variable(torch.ones(2,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:test_chi2_shape_scalar_params";
    "Fxn:Chi2(1)";
    "Fxn:self.assertEqual(chi2._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(chi2._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(chi2.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(chi2.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(chi2.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(chi2.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_chi2_shape_tensor_params";
    "Fxn:Chi2(torch.tensor([1,";
    "Fxn:self.assertEqual(chi2._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(chi2._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(chi2.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(chi2.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(chi2.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(chi2.log_prob(variable(torch.ones(2,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:test_studentT_shape_scalar_params";
    "Fxn:StudentT(1)";
    "Fxn:self.assertEqual(st._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(st._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(st.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(st.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(st.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(st.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_studentT_shape_tensor_params";
    "Fxn:StudentT(torch.tensor([1,";
    "Fxn:self.assertEqual(st._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(st._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(st.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(st.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(st.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(st.log_prob(variable(torch.ones(2,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:test_pareto_shape_scalar_params";
    "Fxn:Pareto(1,";
    "Fxn:self.assertEqual(pareto._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(pareto._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(pareto.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(pareto.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(pareto.log_prob(self.tensor_sample_1";
    "Fxn:1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(pareto.log_prob(self.tensor_sample_2";
    "Fxn:1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_gumbel_shape_scalar_params";
    "Fxn:Gumbel(1,";
    "Fxn:self.assertEqual(gumbel._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(gumbel._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(gumbel.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(gumbel.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(gumbel.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(gumbel.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_scalar_params";
    "Fxn:Normal(0,";
    "Fxn:self.assertEqual(normal._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(normal._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(normal.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(normal.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(normal.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(normal.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_tensor_params";
    "Fxn:Normal(torch.tensor([0,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertEqual(normal._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(normal._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(normal.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(normal.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(normal.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(normal.log_prob(variable(torch.ones(2,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:test_uniform_shape_scalar_params";
    "Fxn:Uniform(0,";
    "Fxn:self.assertEqual(uniform._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(uniform._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(uniform.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(uniform.sample(torch.Size((3,";
    "Fxn:2))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(uniform.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(uniform.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_uniform_shape_tensor_params";
    "Fxn:Uniform(torch.tensor([0,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertEqual(uniform._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(uniform._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(uniform.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(uniform.sample(torch.Size((3,";
    "Fxn:2))).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(uniform.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(uniform.log_prob(variable(torch.ones(2,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:test_exponential_shape_scalar_param";
    "Fxn:Exponential(1.)";
    "Fxn:self.assertEqual(expon._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(expon._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(expon.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(expon.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(expon.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(expon.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_exponential_shape_tensor_param";
    "Fxn:Exponential(torch.tensor([1,";
    "Fxn:self.assertEqual(expon._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(expon._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(expon.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(expon.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(expon.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(expon.log_prob(variable(torch.ones(2,";
    "Fxn:2))).size(),";
    "Fxn:torch.Size((2,";
    "Fxn:test_laplace_shape_scalar_params";
    "Fxn:Laplace(0,";
    "Fxn:self.assertEqual(laplace._batch_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(laplace._event_shape,";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(laplace.sample().size(),";
    "Fxn:torch.Size())";
    "Fxn:self.assertEqual(laplace.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(laplace.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(laplace.log_prob(self.tensor_sample_2).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:test_laplace_shape_tensor_params";
    "Fxn:Laplace(torch.tensor([0,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertEqual(laplace._batch_shape,";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(laplace._event_shape,";
    "Fxn:torch.Size(()))";
    "Fxn:self.assertEqual(laplace.sample().size(),";
    "Fxn:torch.Size((2,)))";
    "Fxn:self.assertEqual(laplace.sample((3,";
    "Fxn:2)).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertEqual(laplace.log_prob(self.tensor_sample_1).size(),";
    "Fxn:torch.Size((3,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertEqual(laplace.log_prob(variable(torch.ones(2,";
    "Fxn:1))).size(),";
    "Fxn:torch.Size((2,";
    "class:TestKL(TestCase):";
    "Fxn:setUp";
    "class:Binomial30(Binomial):";
    "Fxn:__init__";
    "Fxn:self).__init__(30,";
    "Fxn:pairwise(Bernoulli,";
    "Fxn:pairwise(Binomial30,";
    "Fxn:pairwise(Beta,";
    "Fxn:pairwise(Categorical,";
    "Fxn:pairwise(Chi2,";
    "Fxn:pairwise(Dirichlet,";
    "Fxn:pairwise(Exponential,";
    "Fxn:pairwise(Gamma,";
    "Fxn:pairwise(Gumbel,";
    "Fxn:pairwise(Laplace,";
    "Fxn:pairwise(LogNormal,";
    "Fxn:pairwise(Normal,";
    "Fxn:pairwise(OneHotCategorical,";
    "Fxn:pairwise(Pareto,";
    "Fxn:pairwise(Poisson,";
    "Fxn:pairwise(Uniform,";
    "Fxn:pairwise(Uniform,";
    "Fxn:pairwise(Uniform,";
    "Fxn:pairwise(Uniform,";
    "Fxn:Bernoulli(1)),";
    "Fxn:Bernoulli(0)),";
    "Fxn:Categorical(torch.tensor([1,";
    "Fxn:Uniform(0.25,";
    "Fxn:Uniform(0,";
    "Fxn:Uniform(0.25,";
    "Fxn:Pareto(1,";
    "Fxn:Binomial(30,";
    "Fxn:Beta(2,";
    "Fxn:Pareto(2,";
    "Fxn:Uniform(-2,";
    "Fxn:Beta(2,";
    "Fxn:Pareto(2,";
    "Fxn:Uniform(-2,";
    "Fxn:Beta(3,";
    "Fxn:Pareto(3,";
    "Fxn:Uniform(-3,";
    "Fxn:Beta(3,";
    "Fxn:Chi2(3)),";
    "Fxn:Exponential(3)),";
    "Fxn:Gamma(3,";
    "Fxn:Pareto(3,";
    "Fxn:Uniform(-3,";
    "Fxn:Beta(3,";
    "Fxn:Chi2(3)),";
    "Fxn:Exponential(3)),";
    "Fxn:Gamma(3,";
    "Fxn:Pareto(3,";
    "Fxn:Uniform(-3,";
    "Fxn:Beta(3,";
    "Fxn:Chi2(3)),";
    "Fxn:Exponential(3)),";
    "Fxn:Gamma(3,";
    "Fxn:Pareto(3,";
    "Fxn:Uniform(-3,";
    "Fxn:Chi2(3)),";
    "Fxn:Exponential(3)),";
    "Fxn:Gamma(3,";
    "Fxn:Normal(-3,";
    "Fxn:Pareto(3,";
    "Fxn:Bernoulli(0.5)),";
    "Fxn:Binomial(10,";
    "Fxn:Beta(2,";
    "Fxn:Beta(3,";
    "Fxn:Beta(3,";
    "Fxn:Chi2(3)),";
    "Fxn:Exponential(3)),";
    "Fxn:Gamma(3,";
    "Fxn:Pareto(3,";
    "Fxn:test_kl_monte_carlo";
    "Fxn:set_rng_seed(0)";
    "Fxn:KL({},";
    "Fxn:Carlo'.format(type(p).__name__,";
    "Fxn:kl_divergence(p,";
    "Fxn:p.sample(sample_shape=(self.samples_per_batch,))";
    "Fxn:q.log_prob(x)).sum(0)";
    "Fxn:x.size(0)";
    "Fxn:torch.abs(expected";
    "Fxn:error].max()";
    "Fxn:self.assertLess(error[error";
    "Fxn:error].max(),";
    "Fxn:'\n'.join([";
    "Fxn:KL({},";
    "Fxn:{}).'.format(type(p).__name__,";
    "Fxn:{}'.format(denominator,";
    "Fxn:{}'.format(actual),";
    "Fxn:test_kl_exponential_family";
    "Fxn:KL({},";
    "Fxn:Divergence'.format(type(p).__name__,";
    "Fxn:kl_divergence(p,";
    "Fxn:_kl_expfamily_expfamily(p,";
    "Fxn:self.assertEqual(actual,";
    "Fxn:message='\n'.join([";
    "Fxn:KL({},";
    "Fxn:{}).'.format(type(p).__name__,";
    "Fxn:{}'.format(expected),";
    "Fxn:{}'.format(actual),";
    "Fxn:{}'.format(torch.abs(actual";
    "Fxn:expected).max())";
    "Fxn:test_kl_infinite";
    "Fxn:self.assertTrue((kl_divergence(p,";
    "Fxn:KL({},";
    "Fxn:{})'.format(type(p).__name__,";
    "Fxn:test_kl_edgecases";
    "Fxn:self.assertEqual(kl_divergence(Bernoulli(0),";
    "Fxn:Bernoulli(0)),";
    "Fxn:self.assertEqual(kl_divergence(Bernoulli(1),";
    "Fxn:Bernoulli(1)),";
    "Fxn:self.assertEqual(kl_divergence(Categorical(torch.tensor([0,";
    "Fxn:Categorical(torch.tensor([0,";
    "Fxn:test_kl_shape";
    "Fxn:Dist(**param)";
    "Fxn:kl_divergence(dist,";
    "Fxn:torch.Size()";
    "Fxn:self.assertEqual(kl.shape,";
    "Fxn:message='\n'.join([";
    "Fxn:{}/{}'.format(Dist.__name__,";
    "Fxn:{}'.format(expected_shape),";
    "Fxn:{}'.format(kl.shape),";
    "Fxn:test_entropy_monte_carlo";
    "Fxn:set_rng_seed(0)";
    "Fxn:Dist(**param)";
    "Fxn:dist.entropy()";
    "Fxn:dist.sample(sample_shape=(50000,))";
    "Fxn:-dist.log_prob(x).mean(0)";
    "Fxn:self.assertEqual(actual,";
    "Fxn:message='\n'.join([";
    "Fxn:.entropy().'.format(Dist.__name__,";
    "Fxn:{}'.format(expected),";
    "Fxn:{}'.format(actual),";
    "Fxn:{}'.format(torch.abs(actual";
    "Fxn:expected).max()),";
    "Fxn:test_entropy_exponential_family";
    "Fxn:Dist(**param)";
    "Fxn:dist.entropy()";
    "Fxn:ExponentialFamily.entropy(dist)";
    "Fxn:self.assertEqual(actual,";
    "Fxn:message='\n'.join([";
    "Fxn:.entropy().'.format(Dist.__name__,";
    "Fxn:{}'.format(expected),";
    "Fxn:{}'.format(actual),";
    "Fxn:{}'.format(torch.abs(actual";
    "Fxn:expected).max())";
    "class:TestConstraints(TestCase):";
    "Fxn:test_params_contains";
    "Fxn:Dist(**param)";
    "Fxn:param.items():";
    "Fxn:torch.Tensor([value])";
    "Fxn:value.sum(-1,";
    "Fxn:is_dependent(constraint):";
    "Fxn:{}'.format(";
    "Fxn:self.assertTrue(constraint.check(value).all(),";
    "Fxn:test_support_contains";
    "Fxn:self.assertIsInstance(Dist.support,";
    "Fxn:Dist(**param)";
    "Fxn:dist.sample()";
    "Fxn:{}'.format(";
    "Fxn:self.assertTrue(constraint.check(value).all(),";
    "class:TestNumericalStability(TestCase):";
    "Fxn:_test_pdf_score";
    "Fxn:Variable(probs,";
    "Fxn:dist_class(p)";
    "Fxn:Variable(logits,";
    "Fxn:dist_class(logits=p)";
    "Fxn:dist.log_prob(Variable(x))";
    "Fxn:log_pdf.sum().backward()";
    "Fxn:self.assertEqual(log_pdf.data,";
    "Fxn:.format(type(x),";
    "Fxn:self.assertEqual(p.grad.data,";
    "Fxn:.format(type(x),";
    "Fxn:test_bernoulli_gradient";
    "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:probs=tensor_type([0]),";
    "Fxn:x=tensor_type([0]),";
    "Fxn:expected_value=tensor_type([0]),";
    "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:probs=tensor_type([0]),";
    "Fxn:x=tensor_type([1]),";
    "Fxn:expected_value=tensor_type([_finfo(tensor_type([])).eps]).log(),";
    "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:probs=tensor_type([1e-4]),";
    "Fxn:x=tensor_type([1]),";
    "Fxn:expected_value=tensor_type([math.log(1e-4)]),";
    "Fxn:expected_gradient=tensor_type([10000]))";
    "Fxn:torch.FloatTensor([0.9999]))";
    "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:probs=tensor_type([1";
    "Fxn:x=tensor_type([0]),";
    "Fxn:expected_value=tensor_type([math.log(1e-4)]),";
    "Fxn:expected_gradient=tensor_type([-10000]),";
    "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:logits=tensor_type([math.log(9999)]),";
    "Fxn:x=tensor_type([0]),";
    "Fxn:expected_value=tensor_type([math.log(1e-4)]),";
    "Fxn:expected_gradient=tensor_type([-1]),";
    "Fxn:test_bernoulli_with_logits_underflow";
    "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:logits=tensor_type([lim]),";
    "Fxn:x=tensor_type([0]),";
    "Fxn:expected_value=tensor_type([0]),";
    "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:test_bernoulli_with_logits_overflow";
    "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:logits=tensor_type([lim]),";
    "Fxn:x=tensor_type([1]),";
    "Fxn:expected_value=tensor_type([0]),";
    "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:test_categorical_log_prob";
    "Fxn:variable(tensor_type([0,";
    "Fxn:OneHotCategorical(p)";
    "Fxn:categorical.log_prob(variable(tensor_type([0,";
    "Fxn:self.assertEqual(log_pdf.item(),";
    "Fxn:test_categorical_log_prob_with_logits";
    "Fxn:variable(tensor_type([-float('inf'),";
    "Fxn:OneHotCategorical(logits=p)";
    "Fxn:categorical.log_prob(variable(tensor_type([0,";
    "Fxn:self.assertEqual(log_pdf_prob_1.item(),";
    "Fxn:categorical.log_prob(variable(tensor_type([1,";
    "Fxn:self.assertEqual(log_pdf_prob_0.item(),";
    "Fxn:-float('inf'),";
    "Fxn:test_multinomial_log_prob";
    "Fxn:variable(tensor_type([0,";
    "Fxn:variable(tensor_type([0,";
    "Fxn:Multinomial(10,";
    "Fxn:multinomial.log_prob(s)";
    "Fxn:self.assertEqual(log_pdf.item(),";
    "Fxn:test_multinomial_log_prob_with_logits";
    "Fxn:variable(tensor_type([-float('inf'),";
    "Fxn:Multinomial(10,";
    "Fxn:multinomial.log_prob(variable(tensor_type([0,";
    "Fxn:self.assertEqual(log_pdf_prob_1.item(),";
    "Fxn:multinomial.log_prob(variable(tensor_type([10,";
    "Fxn:self.assertEqual(log_pdf_prob_0.item(),";
    "Fxn:-float('inf'),";
    "class:TestLazyLogitsInitialization(TestCase):";
    "Fxn:setUp";
    "Fxn:test_lazy_logits_initialization";
    "Fxn:param.pop('probs')";
    "Fxn:probs_to_logits(probs)";
    "Fxn:Dist(**param)";
    "Fxn:dist.log_prob(variable(torch.ones(shape)))";
    "Fxn:0/{}'.format(Dist.__name__,";
    "Fxn:self.assertFalse('probs'";
    "Fxn:dist.enumerate_support()";
    "Fxn:self.assertFalse('probs'";
    "Fxn:self.assertFalse('probs'";
    "Fxn:test_lazy_probs_initialization";
    "Fxn:Dist(**param)";
    "Fxn:dist.sample()";
    "Fxn:0/{}'.format(Dist.__name__,";
    "Fxn:self.assertFalse('logits'";
    "Fxn:dist.enumerate_support()";
    "Fxn:self.assertFalse('logits'";
    "Fxn:self.assertFalse('logits'";
    "Fxn:@unittest.skipIf(not";
    "class:TestAgainstScipy(TestCase):";
    "Fxn:setUp";
    "Fxn:variable(torch.Tensor(20,).normal_()).exp()";
    "Fxn:variable(torch.Tensor(20,).normal_()).exp()";
    "Fxn:variable(torch.Tensor(20,).normal_())";
    "Fxn:torch.Tensor(20,).normal_()";
    "Fxn:softmax(random_tensor)";
    "Fxn:Bernoulli(simplex_tensor),";
    "Fxn:scipy.stats.bernoulli(simplex_tensor)";
    "Fxn:Beta(positive_var,";
    "Fxn:scipy.stats.beta(positive_var,";
    "Fxn:Binomial(10,";
    "Fxn:scipy.stats.binom(10";
    "Fxn:np.ones(simplex_tensor.shape),";
    "Fxn:Cauchy(random_var,";
    "Fxn:scipy.stats.cauchy(loc=random_var,";
    "Fxn:Dirichlet(positive_var),";
    "Fxn:scipy.stats.dirichlet(positive_var)";
    "Fxn:Exponential(positive_var),";
    "Fxn:scipy.stats.expon(scale=positive_var.reciprocal())";
    "Fxn:FisherSnedecor(positive_var,";
    "Fxn:scipy.stats.f(positive_var,";
    "Fxn:Gamma(positive_var,";
    "Fxn:scipy.stats.gamma(positive_var,";
    "Fxn:scale=positive_var2.reciprocal())";
    "Fxn:Geometric(simplex_tensor),";
    "Fxn:scipy.stats.geom(simplex_tensor,";
    "Fxn:Gumbel(random_var,";
    "Fxn:scipy.stats.gumbel_r(random_var,";
    "Fxn:Laplace(random_var,";
    "Fxn:scipy.stats.laplace(random_var,";
    "Fxn:LogNormal(random_var,";
    "Fxn:positive_var.clamp(max=3)),";
    "Fxn:scipy.stats.lognorm(s=positive_var.clamp(max=3),";
    "Fxn:scale=random_var.exp())";
    "Fxn:Multinomial(10,";
    "Fxn:scipy.stats.multinomial(10,";
    "Fxn:Normal(random_var,";
    "Fxn:scipy.stats.norm(random_var,";
    "Fxn:OneHotCategorical(simplex_tensor),";
    "Fxn:scipy.stats.multinomial(1,";
    "Fxn:Pareto(positive_var,";
    "Fxn:scipy.stats.pareto(2";
    "Fxn:Poisson(positive_var),";
    "Fxn:scipy.stats.poisson(positive_var)";
    "Fxn:StudentT(2";
    "Fxn:scipy.stats.t(2";
    "Fxn:Uniform(random_var,";
    "Fxn:scipy.stats.uniform(random_var,";
    "Fxn:test_mean";
    "Fxn:self.assertEqual(pytorch_dist.mean,";
    "Fxn:scipy_dist.mean(),";
    "Fxn:test_variance_stddev";
    "Fxn:self.assertEqual(pytorch_dist.variance,";
    "Fxn:np.diag(scipy_dist.cov()),";
    "Fxn:self.assertEqual(pytorch_dist.stddev,";
    "Fxn:np.diag(scipy_dist.cov())";
    "Fxn:self.assertEqual(pytorch_dist.variance,";
    "Fxn:scipy_dist.var(),";
    "Fxn:self.assertEqual(pytorch_dist.stddev,";
    "Fxn:scipy_dist.var()";
    "Fxn:test_cdf";
    "Fxn:pytorch_dist.sample((5,))";
    "Fxn:pytorch_dist.cdf(samples)";
    "Fxn:self.assertEqual(cdf,";
    "Fxn:scipy_dist.cdf(samples),";
    "Fxn:test_icdf";
    "Fxn:variable(torch.rand((5,)";
    "Fxn:pytorch_dist.icdf(samples)";
    "Fxn:self.assertEqual(icdf,";
    "Fxn:scipy_dist.ppf(samples),";
    "class:TestTransforms(TestCase):";
    "Fxn:setUp";
    "Fxn:AbsTransform(cache_size=cache_size),";
    "Fxn:ExpTransform(cache_size=cache_size),";
    "Fxn:SigmoidTransform(cache_size=cache_size),";
    "Fxn:AffineTransform(variable(torch.Tensor(5).normal_()),";
    "Fxn:variable(torch.Tensor(5).normal_()),";
    "Fxn:AffineTransform(variable(torch.Tensor(4,";
    "Fxn:5).normal_()),";
    "Fxn:variable(torch.Tensor(4,";
    "Fxn:5).normal_()),";
    "Fxn:BoltzmannTransform(cache_size=cache_size),";
    "Fxn:StickBreakingTransform(cache_size=cache_size),";
    "Fxn:LowerCholeskyTransform(cache_size=cache_size),";
    "Fxn:ComposeTransform([";
    "Fxn:AffineTransform(variable(torch.Tensor(4,";
    "Fxn:5).normal_()),";
    "Fxn:variable(torch.Tensor(4,";
    "Fxn:5).normal_()),";
    "Fxn:ComposeTransform([";
    "Fxn:AffineTransform(variable(torch.Tensor(4,";
    "Fxn:5).normal_()),";
    "Fxn:variable(torch.Tensor(4,";
    "Fxn:5).normal_()),";
    "Fxn:ExpTransform(cache_size=cache_size),";
    "Fxn:transforms.append(t.inv)";
    "Fxn:transforms.append(identity_transform)";
    "Fxn:_generate_data";
    "Fxn:torch.Tensor(4,";
    "Fxn:torch.Tensor(6,";
    "Fxn:x.normal_()";
    "Fxn:x.normal_()";
    "Fxn:x.normal_().exp()";
    "Fxn:x.uniform_()";
    "Fxn:x.normal_().exp()";
    "Fxn:x.sum(-1,";
    "Fxn:ValueError('Unsupported";
    "Fxn:{}'.format(domain))";
    "Fxn:test_inv_inv";
    "Fxn:self.assertTrue(t.inv.inv";
    "Fxn:test_equality";
    "Fxn:product(transforms,";
    "Fxn:self.assertTrue(x";
    "Fxn:self.assertFalse(x";
    "Fxn:self.assertFalse(x";
    "Fxn:self.assertTrue(x";
    "Fxn:self.assertTrue(identity_transform";
    "Fxn:self.assertFalse(identity_transform";
    "Fxn:test_forward_inverse_cache";
    "Fxn:variable(self._generate_data(transform),";
    "Fxn:transform(x)";
    "Fxn:transform.inv(y)";
    "Fxn:transform(x2)";
    "Fxn:self.assertEqual(x2,";
    "Fxn:message='\n'.join([";
    "Fxn:t.inv(t(-))";
    "Fxn:error'.format(transform),";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(y),";
    "Fxn:t.inv(y)";
    "Fxn:{}'.format(x2),";
    "Fxn:self.assertEqual(y2,";
    "Fxn:message='\n'.join([";
    "Fxn:error'.format(transform),";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(y),";
    "Fxn:t.inv(y)";
    "Fxn:{}'.format(x2),";
    "Fxn:{}'.format(y2),";
    "Fxn:test_forward_inverse_no_cache";
    "Fxn:variable(self._generate_data(transform),";
    "Fxn:transform(x)";
    "Fxn:transform.inv(y.clone())";
    "Fxn:transform(x2)";
    "Fxn:self.assertEqual(x2,";
    "Fxn:message='\n'.join([";
    "Fxn:t.inv(t(-))";
    "Fxn:error'.format(transform),";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(y),";
    "Fxn:t.inv(y)";
    "Fxn:{}'.format(x2),";
    "Fxn:self.assertEqual(y2,";
    "Fxn:message='\n'.join([";
    "Fxn:error'.format(transform),";
    "Fxn:{}'.format(x),";
    "Fxn:{}'.format(y),";
    "Fxn:t.inv(y)";
    "Fxn:{}'.format(x2),";
    "Fxn:{}'.format(y2),";
    "Fxn:test_univariate_forward_jacobian";
    "Fxn:variable(self._generate_data(transform),";
    "Fxn:transform(x)";
    "Fxn:transform.log_abs_det_jacobian(x,";
    "Fxn:torch.abs(grad([y.sum()],";
    "Fxn:[x])[0]).log()";
    "Fxn:self.assertEqual(actual,";
    "Fxn:message='\n'.join([";
    "Fxn:{}.log_abs_det_jacobian()";
    "Fxn:{}'.format(expected),";
    "Fxn:{}'.format(actual),";
    "Fxn:test_univariate_inverse_jacobian";
    "Fxn:variable(self._generate_data(transform.inv),";
    "Fxn:transform.inv(y)";
    "Fxn:transform.log_abs_det_jacobian(x,";
    "Fxn:-torch.abs(grad([x.sum()],";
    "Fxn:[y])[0]).log()";
    "Fxn:self.assertEqual(actual,";
    "Fxn:message='\n'.join([";
    "Fxn:'{}.log_abs_det_jacobian()";
    "Fxn:.inv()'.format(transform),";
    "Fxn:{}'.format(expected),";
    "Fxn:{}'.format(actual),";
    "Fxn:test_transform_shapes";
    "Fxn:ExpTransform()";
    "Fxn:BoltzmannTransform()";
    "Fxn:LowerCholeskyTransform()";
    "Fxn:self.assertEqual(transform0.event_dim,";
    "Fxn:self.assertEqual(transform1.event_dim,";
    "Fxn:self.assertEqual(transform2.event_dim,";
    "Fxn:self.assertEqual(ComposeTransform([transform0,";
    "Fxn:self.assertEqual(ComposeTransform([transform0,";
    "Fxn:self.assertEqual(ComposeTransform([transform1,";
    "Fxn:test_transformed_distribution_shapes";
    "Fxn:ExpTransform()";
    "Fxn:BoltzmannTransform()";
    "Fxn:LowerCholeskyTransform()";
    "Fxn:Normal(variable(torch.zeros(4,";
    "Fxn:variable(torch.ones(4,";
    "Fxn:Dirichlet(variable(torch.ones(4,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:self.assertEqual(dist.batch_shape,";
    "Fxn:self.assertEqual(dist.event_shape,";
    "Fxn:dist.rsample()";
    "Fxn:dist.log_prob(x)";
    "class:TestConstraintRegistry(TestCase):";
    "Fxn:setUp";
    "Fxn:constraints.greater_than(torch.tensor([-10,";
    "Fxn:constraints.less_than(torch.tensor([-10,";
    "Fxn:constraints.interval(torch.tensor([-4,";
    "Fxn:torch.tensor([-3,";
    "Fxn:test_biject_to";
    "Fxn:biject_to(constraint)";
    "Fxn:self.assertTrue(t.bijective,";
    "Fxn:"biject_to({})";
    "Fxn:bijective".format(constraint))";
    "Fxn:variable(torch.Tensor(5,";
    "Fxn:5)).normal_()";
    "Fxn:self.assertTrue(constraint.check(y).all(),";
    "Fxn:'\n'.join([";
    "Fxn:biject_to({})".format(constraint),";
    "Fxn:{}".format(x),";
    "Fxn:"biject_to(...)(x)";
    "Fxn:{}".format(y),";
    "Fxn:t.inv(y)";
    "Fxn:self.assertEqual(x,";
    "Fxn:biject_to({})";
    "Fxn:inverse".format(constraint))";
    "Fxn:test_transform_to";
    "Fxn:transform_to(constraint)";
    "Fxn:variable(torch.Tensor(5,";
    "Fxn:5)).normal_()";
    "Fxn:self.assertTrue(constraint.check(y).all(),";
    "Fxn:transform_to({})".format(constraint))";
    "Fxn:t.inv(y)";
    "Fxn:self.assertEqual(y,";
    "Fxn:transform_to({})";
    "Fxn:pseudoinverse".format(constraint))";
    "class:TestValidation(TestCase):";
    "Fxn:setUp";
    "Fxn:self).setUp()";
    "Fxn:Distribution.set_default_validate_args(True)";
    "Fxn:test_valid";
    "Fxn:constraints.is_dependent(Dist.params):";
    "Fxn:Dist(validate_args=True,";
    "Fxn:test_invalid";
    "Fxn:constraints.is_dependent(Dist.params):";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:Dist(validate_args=True,";
    "Fxn:AssertionError(fail_string.format(Dist.__name__,";
    "Fxn:tearDown";
    "Fxn:self).tearDown()";
    "Fxn:Distribution.set_default_validate_args(False)";
    "Fxn:run_tests()";
    "/test/test_indexing.py";
    "Import:TestCase,";
    "Import:unittest";
    "Import:torch";
    "Import:warnings";
    "Import:Variable";
    "class:TestIndexing(TestCase):";
    "Fxn:test_single_int";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertEqual(v[4].shape,";
    "Fxn:test_multiple_int";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertEqual(v[4].shape,";
    "Fxn:self.assertEqual(v[4,";
    "Fxn:test_none";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertEqual(v[None].shape,";
    "Fxn:self.assertEqual(v[:,";
    "Fxn:self.assertEqual(v[:,";
    "Fxn:self.assertEqual(v[...,";
    "Fxn:test_step";
    "Fxn:Variable(torch.arange(10))";
    "Fxn:self.assertEqual(v[::1],";
    "Fxn:self.assertEqual(v[::2].data.tolist(),";
    "Fxn:self.assertEqual(v[::3].data.tolist(),";
    "Fxn:self.assertEqual(v[::11].data.tolist(),";
    "Fxn:self.assertEqual(v[1:6:2].data.tolist(),";
    "Fxn:test_step_assignment";
    "Fxn:Variable(torch.zeros(4,";
    "Fxn:Variable(torch.Tensor([3,";
    "Fxn:self.assertEqual(v[0].data.tolist(),";
    "Fxn:self.assertEqual(v[1:].data.sum(),";
    "Fxn:test_byte_mask";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.ByteTensor([1,";
    "Fxn:self.assertEqual(v[mask].shape,";
    "Fxn:self.assertEqual(v[mask],";
    "Fxn:torch.stack([v[0],";
    "Fxn:Variable(torch.Tensor([1]))";
    "Fxn:self.assertEqual(v[v";
    "Fxn:Variable(torch.Tensor()))";
    "Fxn:test_multiple_byte_mask";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.ByteTensor([1,";
    "Fxn:Variable(torch.ByteTensor([1,";
    "Fxn:self.assertEqual(v[mask1,";
    "Fxn:test_byte_mask2d";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:0).data.sum()";
    "Fxn:self.assertEqual(r.shape,";
    "Fxn:test_int_indices";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertEqual(v[[0,";
    "Fxn:self.assertEqual(v[:,";
    "Fxn:self.assertEqual(v[:,";
    "Fxn:test_int_indices2d";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:12).view(4,";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:self.assertEqual(x[rows,";
    "Fxn:columns].data.tolist(),";
    "Fxn:test_int_indices_broadcast";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:12).view(4,";
    "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:self.assertEqual(result.data.tolist(),";
    "Fxn:test_empty_index";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:12).view(4,";
    "Fxn:Variable(torch.LongTensor())";
    "Fxn:self.assertEqual(x[idx].numel(),";
    "Fxn:x.clone()";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.zeros(4,";
    "Fxn:3).byte()";
    "Fxn:self.assertEqual(x,";
    "Fxn:test_index_getitem_copy_bools_slices";
    "Fxn:torch.tensor(1,";
    "Fxn:torch.tensor(0,";
    "Fxn:[Variable(torch.randn(2,";
    "Fxn:torch.tensor(3)]";
    "Fxn:self.assertNotEqual(a.data_ptr(),";
    "Fxn:a[True].data_ptr())";
    "Fxn:self.assertEqual(torch.tensor([]),";
    "Fxn:self.assertNotEqual(a.data_ptr(),";
    "Fxn:a[true].data_ptr())";
    "Fxn:self.assertEqual(torch.tensor([]),";
    "Fxn:self.assertEqual(a.data_ptr(),";
    "Fxn:a[None].data_ptr())";
    "Fxn:self.assertEqual(a.data_ptr(),";
    "Fxn:a[...].data_ptr())";
    "Fxn:test_index_setitem_bools_slices";
    "Fxn:torch.tensor(1,";
    "Fxn:torch.tensor(0,";
    "Fxn:[Variable(torch.randn(2,";
    "Fxn:torch.tensor(3)]";
    "Fxn:torch.ones_like(a)";
    "Fxn:neg_ones.unsqueeze(0).unsqueeze(0)";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(a,";
    "Fxn:a.dim()";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_setitem_expansion_error";
    "Fxn:torch.tensor(1,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:a.expand(torch.Size([5,";
    "Fxn:a.size())";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:torch.autograd.Variable(a_expanded)";
    "Fxn:test_getitem_scalars";
    "Fxn:torch.tensor(0,";
    "Fxn:torch.tensor(1,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:self.assertEqual(a[0],";
    "Fxn:self.assertEqual(a[0][1],";
    "Fxn:self.assertEqual(a[0,";
    "Fxn:self.assertEqual(a[0,";
    "Fxn:torch.tensor(0).normal_()";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertEqual(r,";
    "Fxn:test_setitem_scalars";
    "Fxn:torch.tensor(0,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:a.clone()";
    "Fxn:a.clone()";
    "Fxn:Variable(torch.randn(3))";
    "Fxn:self.assertEqual(a_set_with_number,";
    "Fxn:self.assertEqual(7.7,";
    "Fxn:torch.tensor(0).normal_()";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertEqual(9.9,";
    "Fxn:test_basic_advanced_combined";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:12).view(4,";
    "Fxn:self.assertEqual(x[1:2,";
    "Fxn:self.assertEqual(x[1:2,";
    "Fxn:1:3].data.tolist(),";
    "Fxn:x.clone()";
    "Fxn:2]].zero_()";
    "Fxn:self.assertEqual(x,";
    "Fxn:x.clone()";
    "Fxn:self.assertNotEqual(x,";
    "Fxn:test_int_assignment";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:4).view(2,";
    "Fxn:self.assertEqual(x.data.tolist(),";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:4).view(2,";
    "Fxn:Variable(torch.arange(5,";
    "Fxn:self.assertEqual(x.data.tolist(),";
    "Fxn:test_byte_tensor_assignment";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:16).view(4,";
    "Fxn:Variable(torch.ByteTensor([True,";
    "Fxn:Variable(torch.Tensor([3,";
    "Fxn:self.assertEqual(x[0],";
    "Fxn:self.assertEqual(x[1].data,";
    "Fxn:torch.arange(4,";
    "Fxn:self.assertEqual(x[2],";
    "Fxn:self.assertEqual(x[3].data,";
    "Fxn:torch.arange(12,";
    "Fxn:test_variable_slicing";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:16).view(4,";
    "Fxn:Variable(torch.IntTensor([0,";
    "Fxn:self.assertEqual(x[i:j],";
    "Fxn:test_ellipsis_tensor";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:9).view(3,";
    "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:self.assertEqual(x[...,";
    "Fxn:idx].tolist(),";
    "Fxn:self.assertEqual(x[idx,";
    "Fxn:...].tolist(),";
    "Fxn:test_invalid_index";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:16).view(4,";
    "Fxn:self.assertRaisesRegex(TypeError,";
    "Fxn:test_zero_dim_index";
    "Fxn:torch.tensor(10)";
    "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:self.assertEqual(x,";
    "Fxn:self.assertEqual(len(w),";
    "Fxn:tensor";
    "Fxn:Variable(torch.Tensor(*args,";
    "Fxn:byteTensor";
    "Fxn:Variable(torch.ByteTensor(data))";
    "Fxn:ones";
    "Fxn:Variable(torch.ones(*args))";
    "Fxn:zeros";
    "Fxn:Variable(torch.zeros(*args))";
    "class:NumpyTests(TestCase):";
    "Fxn:test_index_no_floats";
    "Fxn:Variable(torch.Tensor([[[5]]]))";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_none_index";
    "Fxn:tensor([1,";
    "Fxn:self.assertEqual(a[None].dim(),";
    "Fxn:a.dim()";
    "Fxn:test_empty_tuple_index";
    "Fxn:tensor([1,";
    "Fxn:self.assertEqual(a[()],";
    "Fxn:self.assertEqual(a[()].data_ptr(),";
    "Fxn:a.data_ptr())";
    "Fxn:test_empty_fancy_index";
    "Fxn:tensor([1,";
    "Fxn:self.assertEqual(a[[]],";
    "Fxn:Variable(torch.Tensor()))";
    "Fxn:tensor([]).long()";
    "Fxn:self.assertEqual(a[[]],";
    "Fxn:Variable(torch.LongTensor()))";
    "Fxn:tensor([]).float()";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_ellipsis_index";
    "Fxn:tensor([[1,";
    "Fxn:self.assertIsNot(a[...],";
    "Fxn:self.assertEqual(a[...],";
    "Fxn:self.assertEqual(a[...].data_ptr(),";
    "Fxn:a.data_ptr())";
    "Fxn:self.assertEqual(a[0,";
    "Fxn:self.assertEqual(a[0,";
    "Fxn:self.assertEqual(a[...,";
    "Fxn:self.assertEqual(a[0,";
    "Fxn:torch.tensor(2))";
    "Fxn:`(Ellipsis,)`";
    "Fxn:torch.tensor(1)";
    "Fxn:b[(Ellipsis,)]";
    "Fxn:self.assertEqual(b,";
    "Fxn:test_single_int_index";
    "Fxn:tensor([[1,";
    "Fxn:self.assertEqual(a[0].data,";
    "Fxn:self.assertEqual(a[-1].data,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(Exception,";
    "Fxn:test_single_bool_index";
    "Fxn:tensor([[1,";
    "Fxn:self.assertEqual(a[True],";
    "Fxn:self.assertEqual(a[False],";
    "Fxn:test_boolean_shape_mismatch";
    "Fxn:ones((5,";
    "Fxn:byteTensor([True])";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:byteTensor([False]";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:Variable(torch.ByteTensor(4,";
    "Fxn:4)).zero_()";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:arr[(slice(None),";
    "Fxn:test_boolean_indexing_onedim";
    "Fxn:tensor([[0.,";
    "Fxn:byteTensor([True])";
    "Fxn:self.assertEqual(a[b],";
    "Fxn:self.assertEqual(a,";
    "Fxn:tensor([[1.,";
    "Fxn:test_boolean_assignment_value_mismatch";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:f";
    "Fxn:tensor(v)";
    "Fxn:self.assertRaisesRegex(Exception,";
    "Fxn:self.assertRaisesRegex(Exception,";
    "Fxn:self.assertRaisesRegex(Exception,";
    "Fxn:test_boolean_indexing_twodim";
    "Fxn:tensor([[1,";
    "Fxn:byteTensor([[True,";
    "Fxn:self.assertEqual(a[b],";
    "Fxn:tensor([1,";
    "Fxn:self.assertEqual(a[b[1]],";
    "Fxn:tensor([[4,";
    "Fxn:self.assertEqual(a[b[0]],";
    "Fxn:self.assertEqual(a,";
    "Fxn:tensor([[0,";
    "Fxn:test_everything_returns_views";
    "Fxn:tensor(5)";
    "Fxn:self.assertIsNot(a,";
    "Fxn:a[()])";
    "Fxn:self.assertIsNot(a,";
    "Fxn:self.assertIsNot(a,";
    "Fxn:test_broaderrors_indexing";
    "Fxn:zeros(5,";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_trivial_fancy_out_of_bounds";
    "Fxn:zeros(5)";
    "Fxn:ones(20).long()";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:ones(20).long()";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_index_is_larger";
    "Fxn:zeros((5,";
    "Fxn:tensor([2,";
    "Fxn:self.assertTrue((a[:3,";
    "Fxn:tensor([2,";
    "Fxn:4])).all())";
    "Fxn:test_broadcast_subspace";
    "Fxn:zeros((100,";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:Variable(torch.arange(99,";
    "Fxn:-1).long())";
    "Fxn:b.double().unsqueeze(1).expand(100,";
    "Fxn:self.assertEqual(a,";
    "Fxn:run_tests()";
    "/test/test_jit.py";
    "Import:torch";
    "Import:torch.jit";
    "Import:torch.nn";
    "Import:torch.nn.functional";
    "Import:unittest";
    "Import:contextmanager";
    "Import:product,";
    "Import:torch.jit.frontend";
    "Import:Variable,";
    "Import:traceable";
    "Import:TestCase,";
    "Import:import";
    "Import:sys";
    "Import:numpy";
    "Import:torchvision";
    "Fxn:capture_stdout";
    "Import:import";
    "Import:fcntl";
    "Import:errno";
    "Fxn:LSTMCell";
    "Fxn:LSTMCellC";
    "class:TestJit(TestCase):";
    "Fxn:assertCompiled";
    "Fxn:self.assertIsInstance(compiled_fn,";
    "Fxn:self.assertLess(hits,";
    "Fxn:self.assertEqual(misses,";
    "Fxn:assertExpectedTrace";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_canonicalize(trace)";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:self.assertExpected(str(trace),";
    "Fxn:test_simple";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:f";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_matmul_native";
    "Fxn:Variable(torch.Tensor([[0.4]]),";
    "Fxn:Variable(torch.Tensor([[0.7]]),";
    "Fxn:torch.jit.get_trace_graph(lambda";
    "Fxn:x.matmul(y),";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_matmul_native_run";
    "Fxn:Variable(torch.Tensor([[0.4]]),";
    "Fxn:Variable(torch.Tensor([[0.7]]),";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn";
    "Fxn:x.matmul(y)";
    "Fxn:fn(x,";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:test_index";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.LongTensor([0]),";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn";
    "Fxn:fn(x,";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:test_index_constant";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn";
    "Fxn:fn(x)";
    "Fxn:z.backward()";
    "Fxn:x.grad.clone()";
    "Fxn:x.grad.zero_()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(x)";
    "Fxn:z2.backward()";
    "Fxn:x.grad.clone()";
    "Fxn:self.assertEqual(z,";
    "Fxn:self.assertEqual(grad,";
    "Fxn:test_scopes";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:f";
    "Fxn:torch.jit.scope('Foo',";
    "Fxn:torch.jit.scope('Bar',";
    "Fxn:torch.tanh(out)";
    "Fxn:torch.sigmoid(out)";
    "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_scopes_intermediate_node";
    "class:Net(nn.Module):";
    "Fxn:forward";
    "Fxn:F.log_softmax(x,";
    "Fxn:Net()";
    "Fxn:Variable(torch.ones(2),";
    "Fxn:torch.jit.get_trace_graph(net,";
    "Fxn:torch.onnx._optimize_trace(trace,";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_scopes_identity_node";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Sequential(";
    "Fxn:nn.Conv2d(3,";
    "Fxn:nn.ReLU(inplace=True),";
    "Fxn:nn.MaxPool2d(kernel_size=3,";
    "Fxn:forward";
    "Fxn:self.features(x)";
    "Fxn:Net()";
    "Fxn:Variable(torch.ones(1,";
    "Fxn:torch.onnx.set_training(model,";
    "Fxn:torch.jit.get_trace_graph(model,";
    "Fxn:torch.onnx._optimize_trace(trace,";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_lstm_fusion";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:10).float().cuda())";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:20).float().cuda())";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:20).float().cuda())";
    "Fxn:nn.LSTMCell(10,";
    "Fxn:20).float().cuda()";
    "Fxn:torch.jit.get_trace_graph(LSTMCell,";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_fuse(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:run_lstm_fusion";
    "Fxn:to_type";
    "Fxn:x.float()";
    "Fxn:x.cuda()";
    "Fxn:rand_v";
    "Fxn:Variable(to_type(torch.randn(a,";
    "Fxn:rand_v(3,";
    "Fxn:rand_v(3,";
    "Fxn:rand_v(3,";
    "Fxn:to_type(nn.LSTMCell(10,";
    "Fxn:torch.jit.compile(nderivs=0)(LSTMCell)";
    "Fxn:CompiledLSTMCell(input,";
    "Fxn:*module.parameters())";
    "Fxn:self.assertCompiled(CompiledLSTMCell):";
    "Fxn:CompiledLSTMCell(input,";
    "Fxn:*module.parameters())";
    "Fxn:self.assertEqual(z,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_run_lstm_fusion_cuda";
    "Fxn:self.run_lstm_fusion(True)";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_run_lstm_fusion_cpu";
    "Fxn:self.run_lstm_fusion(False)";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_run_lstm_fusion_concat";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:10).float().cuda())";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:20).float().cuda())";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:20).float().cuda())";
    "Fxn:nn.LSTMCell(10,";
    "Fxn:20).float().cuda()";
    "Fxn:torch.jit.compile(nderivs=0)(LSTMCellC)";
    "Fxn:CompiledLSTMCell(input,";
    "Fxn:*module.parameters())";
    "Fxn:self.assertCompiled(CompiledLSTMCell):";
    "Fxn:CompiledLSTMCell(input,";
    "Fxn:*module.parameters())";
    "Fxn:self.assertEqual(z,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_concat_fusion";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:20).float().cuda())";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:20).float().cuda())";
    "Fxn:Foo";
    "Fxn:torch.cat((hx";
    "Fxn:torch.jit.get_trace_graph(Foo,";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_fuse(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_fusion_distribute";
    "Fxn:f";
    "Fxn:y).chunk(2,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:4).float().cuda())";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:4).float().cuda())";
    "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:self.assertExpectedTrace(trace,";
    "Fxn:torch._C._jit_pass_fuse(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_arg_configurations";
    "Fxn:Variable(torch.FloatTensor(4,";
    "Fxn:4).uniform_())";
    "Fxn:Variable(x.data.double())";
    "Fxn:Variable(x.data.clone(),";
    "Fxn:Variable(torch.randn(4))";
    "Fxn:torch.cuda.is_available():";
    "Fxn:Variable(x.data.cuda())";
    "Fxn:torch.cuda.device_count()";
    "Fxn:Variable(x.data.cuda(1))";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn";
    "Fxn:torch._C._jit_flatten(args)";
    "Fxn:self.assertFalse(fn.has_trace_for(*config))";
    "Fxn:fn(*config)";
    "Fxn:self.assertTrue(fn.has_trace_for(*config))";
    "Fxn:self.assertFalse(fn.has_trace_for(*unk_config))";
    "Fxn:self.assertEqual(fn.hits,";
    "Fxn:test_cse";
    "Fxn:Variable(torch.Tensor([0.4,";
    "Fxn:Variable(torch.Tensor([0.7,";
    "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn";
    "Fxn:torch.tanh(w)";
    "Fxn:torch.tanh(w)";
    "Fxn:fn(*inputs)";
    "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_cse(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_compile_run_twice";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:@torch.jit.compile(nderivs=0,";
    "Fxn:doit";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit(x,";
    "Fxn:self.assertCompiled(doit):";
    "Fxn:doit(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:self.assertEqual(z,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_compile_addc";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:requires_grad=True).float().cuda()";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:requires_grad=True).float().cuda()";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:doit";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit(x,";
    "Fxn:self.assertCompiled(doit):";
    "Fxn:doit(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:self.assertEqual(z,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_compile_fuse_last_device";
    "Fxn:torch.cuda.device_count()";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:requires_grad=True).float().cuda(max_device)";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:requires_grad=True).float().cuda(max_device)";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:doit";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit(x,";
    "Fxn:self.assertCompiled(doit):";
    "Fxn:doit(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:self.assertEqual(z,";
    "Fxn:test_traced_function";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:doit";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit(x,";
    "Fxn:self.assertCompiled(doit):";
    "Fxn:doit(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:self.assertEqual(z,";
    "Fxn:test_disabled_traced_function";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:@torch.jit.compile(enabled=False)";
    "Fxn:doit";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit(x,";
    "Fxn:doit(x,";
    "Fxn:self.assertEqual(z,";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:self.assertEqual(z,";
    "Fxn:test_assign_traces";
    "class:MyFn(Function):";
    "Fxn:forward";
    "Fxn:ctx.save_for_backward(out)";
    "Fxn:backward";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:torch.jit.get_trace_graph(MyFn.apply,";
    "Fxn:out.sum().backward()";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_legacy_traced_module";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "class:MyLSTMCell(nn.LSTMCell):";
    "Fxn:test_autograd_closure";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn";
    "Fxn:torch.sigmoid(x";
    "Fxn:torch.abs(x";
    "Fxn:Variable(torch.ones(1))";
    "Fxn:fn(*inputs)";
    "Fxn:torch._C._tracer_exit((z,";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:w).backward()";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:x.grad.data.clone()";
    "Fxn:x.grad.data.zero_()";
    "Fxn:torch._C._jit_createInterpreterFactory(trace)";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:function()(x,";
    "Fxn:w2).backward()";
    "Fxn:self.assertEqual(z,";
    "Fxn:self.assertEqual(w,";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_verify";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:f";
    "Fxn:torch.sigmoid(x";
    "Fxn:torch.abs(x";
    "Fxn:Variable(torch.ones(1))";
    "Fxn:torch.jit.verify(f,";
    "Fxn:test_constant";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:Variable(torch.diag(torch.Tensor([2,";
    "Fxn:tx.matmul(y)";
    "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:torch._C._jit_createInterpreterFactory(trace)";
    "Fxn:function()(x)";
    "Fxn:self.assertEqual(z,";
    "Fxn:y.data.fill_(1000)";
    "Fxn:Variable(torch.ones(2,";
    "Fxn:function()(x2)";
    "Fxn:self.assertEqual(z3.data,";
    "Fxn:torch.ones(2,";
    "Fxn:test_c_function";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:nn.Conv2d(3,";
    "Fxn:torch._C._tracer_enter((x,)";
    "Fxn:torch._C._tracer_exit((y,))";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_legacy_fail";
    "class:MyLegacyFn(Function):";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:Variable(torch.Tensor([0]),";
    "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:MyLegacyFn()(*inputs))";
    "Fxn:torch._C._tracer_exit(inputs)";
    "Fxn:test_inplace_transplant";
    "Fxn:Variable(torch.Tensor([0]),";
    "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:fn";
    "Fxn:x.clone()";
    "Fxn:y.add_(2)";
    "Fxn:y.add_(3)";
    "Fxn:fn(*inputs)";
    "Fxn:torch._C._tracer_exit((y,))";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_inplace_flags";
    "class:InplaceFn(Function):";
    "Fxn:forward";
    "Fxn:ctx.mark_dirty(x)";
    "Fxn:x.add_(1)";
    "Fxn:backward";
    "class:RegularFn(Function):";
    "Fxn:forward";
    "Fxn:x.add(1)";
    "Fxn:backward";
    "Fxn:Variable(torch.Tensor([0]),";
    "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:fn";
    "Fxn:RegularFn.apply(x)";
    "Fxn:InplaceFn.apply(y)";
    "Fxn:InplaceFn.apply(y)";
    "Fxn:RegularFn.apply(y)";
    "Fxn:fn(*inputs)";
    "Fxn:torch._C._tracer_exit((y,))";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:trace.graph().nodes()]";
    "Fxn:self.assertTrue(op.hasAttribute('inplace'))";
    "Fxn:self.assertEqual(op.i('inplace'),";
    "Fxn:test_inplace_check";
    "class:MyInplaceFn(Function):";
    "Fxn:forward";
    "Fxn:x.add_(1)";
    "Fxn:self.mark_dirty(x)";
    "Fxn:backward";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn";
    "Fxn:MyInplaceFn.apply(x)";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:fn(x)";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:fn(x)";
    "Fxn:test_backward";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn";
    "Fxn:fn(*inputs)";
    "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch.autograd.grad(z,";
    "Fxn:Variable(torch.ones(2,";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:grad.sum().backward(create_graph=True)";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:self.skipTest("output";
    "Fxn:test_backward_opaque";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn";
    "Fxn:x.cross(y)";
    "Fxn:fn(*inputs)";
    "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch.autograd.grad(z,";
    "Fxn:Variable(torch.ones(3,";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:self.skipTest("output";
    "Fxn:test_backward_closure";
    "Fxn:Variable(torch.randn(1),";
    "Fxn:@torch.jit.compile(nderivs=2)";
    "Fxn:fn";
    "Fxn:torch.autograd.grad(fn(x),";
    "Fxn:self.assertFalse(fn.has_trace_for(x))";
    "Fxn:grad_x.backward()";
    "Fxn:self.assertTrue(fn.has_trace_for(x))";
    "Fxn:x.grad.data.clone()";
    "Fxn:x.grad.data.zero_()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(x)";
    "Fxn:torch.autograd.grad(output,";
    "Fxn:grad_x.backward()";
    "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_trace_expire";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:record_trace";
    "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn";
    "Fxn:fn(*inputs)";
    "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:check";
    "Fxn:self.assertEqual(trace.is_expired,";
    "Fxn:self.assertEqual(trace.is_complete,";
    "Fxn:record_trace(0)";
    "Fxn:check(False,";
    "Fxn:check(False,";
    "Fxn:record_trace(1)";
    "Fxn:check(False,";
    "Fxn:check(True,";
    "Fxn:record_trace(1)";
    "Fxn:check(False,";
    "Fxn:z.sum().backward()";
    "Fxn:check(False,";
    "Fxn:check(False,";
    "Fxn:test_multiuse_fn";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:cell";
    "Fxn:cell(cell(cell(x,";
    "Fxn:self.assertFalse(cell.has_trace_for(x,";
    "Fxn:out.sum().backward()";
    "Fxn:self.assertTrue(cell.has_trace_for(x,";
    "Fxn:torch.jit.verify(cell,";
    "Fxn:test_output_unflatten";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:fn";
    "Fxn:fn(x)";
    "Fxn:torch.jit.compile(fn)";
    "Fxn:recursive_sum";
    "Fxn:obj.sum()";
    "Fxn:recursive_sum(fn(x)).backward()";
    "Fxn:self.assertTrue(fn.has_trace_for(x))";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:self.assertEqual(fn(x),";
    "Fxn:test_input_flatten";
    "Fxn:make_var";
    "Fxn:Variable(torch.randn(1),";
    "Fxn:make_var()))";
    "Fxn:fn";
    "Fxn:fn(*x)";
    "Fxn:torch.jit.compile(fn)";
    "Fxn:fn(*x).backward()";
    "Fxn:self.assertTrue(fn.has_trace_for(*x))";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:self.assertEqual(fn(*x),";
    "Fxn:test_flags";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:fn";
    "Fxn:y).sum()";
    "Fxn:product((True,";
    "Fxn:self.assertFalse(fn.has_trace_for(x,";
    "Fxn:fn(x,";
    "Fxn:self.assertFalse(fn.has_trace_for(x,";
    "Fxn:[(x,";
    "Fxn:torch.autograd.grad(out,";
    "Fxn:grads.setdefault(name,";
    "Fxn:self.assertEqual(grad_v,";
    "Fxn:self.assertEqual(fn.has_trace_for(x,";
    "Fxn:test_no_grad_fallback";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:fn";
    "Fxn:fn(x,";
    "Fxn:self.assertFalse(fn.has_trace_for(x,";
    "Fxn:torch.no_grad():";
    "Fxn:fn(x,";
    "Fxn:self.assertTrue(fn.has_trace_for(x,";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(x,";
    "Fxn:self.assertEqual(out,";
    "Fxn:test_backward_flag_checks";
    "Fxn:Variable(torch.randn(1),";
    "Fxn:@torch.jit.compile(nderivs=2)";
    "Fxn:fn";
    "Fxn:torch.autograd.grad(fn(x),";
    "Fxn:self.assertFalse(fn.has_trace_for(x))";
    "Fxn:grad_x.backward()";
    "Fxn:self.assertTrue(fn.has_trace_for(x))";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:fn(x).backward(Variable(torch.ones(1),";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:torch.autograd.grad(fn(x),";
    "Fxn:grad_x.backward(Variable(torch.ones(1),";
    "Fxn:test_python_ir";
    "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:doit";
    "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:torch.jit.get_trace_graph(doit,";
    "Fxn:torch._C._jit_get_graph(traced)";
    "Fxn:torch._C.Graph()";
    "Fxn:g.inputs():";
    "Fxn:g2.addInput()";
    "Fxn:g.nodes():";
    "Fxn:g2.createClone(node,";
    "Fxn:g2.appendNode(n_)";
    "Fxn:n_.outputs()):";
    "Fxn:g.outputs():";
    "Fxn:g2.registerOutput(g_to_g2[node])";
    "Fxn:g2.create("TensorTest").t_("a",";
    "Fxn:torch.ones([2,";
    "Fxn:assert(t_node.attributeNames()";
    "Fxn:g2.appendNode(t_node)";
    "Fxn:assert(torch.equal(torch.ones([2,";
    "Fxn:t_node.t("a")))";
    "Fxn:self.assertExpected(str(g2))";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cpp";
    "Fxn:self.assertExpected(torch._C._jit_run_cpp_tests())";
    "Fxn:test_batchnorm";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:2).fill_(1.0),";
    "Fxn:torch.jit.get_trace_graph(nn.BatchNorm2d(2),";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_dropout";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:2).fill_(1.0),";
    "Fxn:torch.jit.get_trace_graph(nn.Dropout(0.6),";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_batchnorm_run_twice";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "class:MyBatchNorm2d(nn.BatchNorm2d):";
    "Fxn:test_non_decorator_use_fails";
    "Fxn:torch.jit.compile(nn.LSTM)";
    "Fxn:self.assertRaisesRegex(TypeError,";
    "Fxn:MyLSTM(2,";
    "Fxn:test_conv";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:40).fill_(1.0),";
    "Fxn:torch.jit.get_trace_graph(nn.Conv2d(16,";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_reuse_function";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:clinear";
    "Fxn:F.linear(*args)";
    "Fxn:cast";
    "Fxn:Variable(cast(torch.randn(1,";
    "Fxn:Variable(cast(torch.randn(1,";
    "Fxn:Variable(cast(torch.randn(1,";
    "Fxn:clinear(input,";
    "Fxn:self.assertCompiled(clinear):";
    "Fxn:clinear(r1_,";
    "Fxn:F.linear(F.linear(input,";
    "Fxn:self.assertEqual(r1,";
    "Fxn:test_unused_input";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn";
    "Fxn:[Variable(torch.randn(2,";
    "Fxn:fn(a,";
    "Fxn:c).sum().backward()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(a,";
    "Fxn:c).sum().backward()";
    "Fxn:test_repeated_input";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn";
    "Fxn:[Variable(torch.randn(2,";
    "Fxn:fn(a,";
    "Fxn:a).sum().backward()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(a,";
    "Fxn:a).sum().backward()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(a,";
    "Fxn:b).sum().backward()";
    "Fxn:self.assertExpected(str(fn.graph_for(a,";
    "Fxn:test_repeated_output";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn";
    "Fxn:[Variable(torch.randn(2,";
    "Fxn:b)).sum().backward()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:b)).sum().backward()";
    "Fxn:self.assertExpected(str(fn.graph_for(a,";
    "Fxn:test_re_enter";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn2";
    "Fxn:fn(a,";
    "Fxn:[Variable(torch.randn(2,";
    "Fxn:fn(a,";
    "Fxn:b).sum().backward()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(a,";
    "Fxn:b).sum().backward()";
    "Fxn:fn2(a,";
    "Fxn:c).sum().backward()";
    "Fxn:self.assertCompiled(fn2):";
    "Fxn:fn2(a,";
    "Fxn:c).sum().backward()";
    "Fxn:test_mini_wlm";
    "class:MyModel(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Embedding(2,";
    "Fxn:forward";
    "Fxn:self.encoder(input)";
    "Fxn:hidden.clone()";
    "Fxn:MyModel()";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:Variable(torch.FloatTensor([0]))";
    "Fxn:model(x,";
    "Fxn:z.sum().backward()";
    "Fxn:self.assertTrue(model.has_trace_for(x,";
    "Fxn:self.assertCompiled(model):";
    "Fxn:model(x,";
    "Fxn:z.sum().backward()";
    "Fxn:test_module_cast";
    "Fxn:@torch.jit.compile(nderivs=0)";
    "class:Adder(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Parameter(torch.randn(2,";
    "Fxn:forward";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:2).float())";
    "Fxn:nn.Sequential(Adder()).float()";
    "Fxn:check_type";
    "Fxn:caster(a)";
    "Fxn:self.assertCompiled(a[0]):";
    "Fxn:check_type(lambda";
    "Fxn:check_type(lambda";
    "Fxn:x.double())";
    "Fxn:torch.cuda.is_available():";
    "Fxn:check_type(lambda";
    "Fxn:x.float().cuda())";
    "Fxn:check_type(lambda";
    "Fxn:x.double().cuda())";
    "Fxn:self.assertEqual(a[0].hits,";
    "Fxn:torch.cuda.is_available()";
    "Fxn:@unittest.skip("Broken";
    "Fxn:test_repeated_grad";
    "Fxn:fn";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:test_input_pruning";
    "Fxn:fn";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:fn(x,";
    "Fxn:out[1]).sum().backward()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(x,";
    "Fxn:self.assertExpected(str(fn.graph_for(x,";
    "Fxn:test_output_pruning";
    "Fxn:fn";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:fn(x,";
    "Fxn:out[1]).sum().backward()";
    "Fxn:self.assertCompiled(fn):";
    "Fxn:fn(x,";
    "Fxn:self.assertExpected(str(fn.graph_for(x,";
    "Fxn:test_alexnet";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:224).fill_(1.0),";
    "Fxn:torch.jit.get_trace_graph(torchvision.models.AlexNet(),";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_debug_info";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:fn(x,";
    "Fxn:out.sum().backward()";
    "Fxn:fn(x,";
    "Fxn:fn.jit_debug_info()";
    "Fxn:self.assertTrue("hits:";
    "Fxn:self.assertTrue("stage";
    "Fxn:test_inplace_copy";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:f";
    "Fxn:Variable(torch.zeros(x.size()))";
    "Fxn:out.copy_(x)";
    "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_index_trace";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:torch.jit.get_trace_graph(lambda";
    "Fxn:z.sum().backward()";
    "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_saved_output";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn";
    "Fxn:x.sigmoid()";
    "Fxn:fn(x).sum().backward()";
    "Fxn:self.assertExpected(str(fn.graph_for(x)))";
    "Fxn:test_shared_param";
    "class:MyModule(torch.nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Parameter(torch.randn(2,";
    "Fxn:forward";
    "Fxn:MyModule()";
    "Fxn:torch.jit.get_trace_graph(m,";
    "Fxn:self.assertEqual(len(list(trace.graph().inputs())),";
    "Fxn:self.assertExpected(str(trace))";
    "Fxn:test_nested_inplace";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:torch.jit.get_trace_graph(lambda";
    "Fxn:F.threshold(x,";
    "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:checkGraphExecutor";
    "Fxn:allSum";
    "Fxn:v.sum()";
    "Fxn:[Variable(t)";
    "Fxn:[Variable(t,";
    "Fxn:torch._C.GraphExecutor(func,";
    "Fxn:[Variable(t)";
    "Fxn:func(*nograd_inputs)";
    "Fxn:ge(*nograd_inputs)";
    "Fxn:self.assertEqual(outputs,";
    "Fxn:func(*recording_inputs)";
    "Fxn:torch.autograd.grad(allSum(outputs),";
    "Fxn:ge(*recording_inputs)";
    "Fxn:torch.autograd.grad(allSum(outputs_ge),";
    "Fxn:self.assertEqual(outputs,";
    "Fxn:self.assertEqual(grads,";
    "Fxn:func(*recording_inputs)";
    "Fxn:allSum(outputs)";
    "Fxn:torch.autograd.grad(l1,";
    "Fxn:torch.autograd.grad(l2,";
    "Fxn:[Variable(t,";
    "Fxn:ge(*recording_inputs)";
    "Fxn:allSum(outputs_ge)";
    "Fxn:torch.autograd.grad(";
    "Fxn:torch.autograd.grad(l2_ge,";
    "Fxn:self.assertEqual(outputs,";
    "Fxn:self.assertEqual(grads,";
    "Fxn:self.assertEqual(grads2,";
    "Fxn:run_ge_tests";
    "Fxn:rand";
    "Fxn:torch.rand(*args).float()";
    "Fxn:t.cuda()";
    "Fxn:self.checkGraphExecutor(lambda";
    "Fxn:[rand(1),";
    "Fxn:rand(1)],";
    "Fxn:[rand(2,";
    "Fxn:rand(2,";
    "Fxn:self.checkGraphExecutor(lambda";
    "Fxn:[rand(1),";
    "Fxn:rand(1)],";
    "Fxn:foo";
    "Fxn:self.checkGraphExecutor(foo,";
    "Fxn:[rand(1)],";
    "Fxn:self.checkGraphExecutor(";
    "Fxn:[rand(1),";
    "Fxn:rand(1)],";
    "Fxn:self.checkGraphExecutor(foo,";
    "Fxn:[rand(1)],";
    "Fxn:self.checkGraphExecutor(lambda";
    "Fxn:[rand(1),";
    "Fxn:rand(1)],";
    "Fxn:test_ge_unoptimized";
    "Fxn:self.run_ge_tests(False,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_ge_optimized";
    "Fxn:self.run_ge_tests(True,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_ge_cuda";
    "Fxn:self.run_ge_tests(True,";
    "Fxn:test_ge";
    "Fxn:foo";
    "Fxn:V(torch.rand(1)),";
    "Fxn:V(torch.rand(1))";
    "Fxn:torch._C.GraphExecutor(foo,";
    "Fxn:V(torch.rand(1),";
    "Fxn:torch.rand(1),";
    "Fxn:ge(a,";
    "Fxn:torch.autograd.grad(r";
    "Fxn:torch.autograd.grad(l2,";
    "Fxn:foo(a,";
    "Fxn:torch.autograd.grad(r";
    "Fxn:self.assertEqual(da,";
    "Fxn:self.assertEqual(db,";
    "Fxn:torch.autograd.grad(l3,";
    "Fxn:self.assertEqual(g2result,";
    "Fxn:checkScript";
    "Fxn:torch.jit.CompilationUnit(script,";
    "Fxn:torch.jit.script(script)";
    "Fxn:capture_stdout()";
    "Fxn:ge(*inputs)";
    "Fxn:self.assertExpected(captured[0],";
    "Fxn:ge(*inputs)";
    "Fxn:self.assertEqual(outputs,";
    "Fxn:test_script_add";
    "Fxn:func";
    "Fxn:Variable(torch.rand(1),";
    "Fxn:Variable(torch.rand(1),";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_mul";
    "Fxn:func";
    "Fxn:Variable(torch.rand(1),";
    "Fxn:Variable(torch.rand(1),";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_triple";
    "Fxn:func";
    "Fxn:Variable(torch.rand(1).float(),";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_slice";
    "Fxn:func";
    "Fxn:Variable(torch.rand(10).float(),";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_gather";
    "Fxn:func";
    "Fxn:Variable(torch.rand(10).float(),";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_func_call";
    "Fxn:add";
    "Fxn:mul";
    "Fxn:func";
    "Fxn:add(mul(alpha,";
    "Fxn:mul(beta,";
    "Fxn:Variable(torch.rand(1).float(),";
    "Fxn:Variable(torch.rand(1).float(),";
    "Fxn:Variable(torch.rand(3).float(),";
    "Fxn:Variable(torch.rand(3).float(),";
    "Fxn:self.checkScript(script,";
    "Fxn:@unittest.skip("RuntimeError:";
    "Fxn:VariableType::ID()";
    "Fxn:test_script_cast";
    "Fxn:to_int";
    "Fxn:Variable(torch.FloatTensor([1.1,";
    "Fxn:Variable(torch.IntTensor([1,";
    "Fxn:self.checkScript(script,";
    "Fxn:test_python_frontend";
    "Fxn:fn";
    "Fxn:z.sigmoid()";
    "Fxn:torch.jit.frontend.get_jit_ast(fn)";
    "Fxn:self.assertExpected(str(ast))";
    "Fxn:_make_scalar_vars";
    "Fxn:out.append(torch.from_numpy(np.array(inp,";
    "Fxn:test_script_while";
    "Fxn:test_while";
    "Fxn:self._make_scalar_vars([1,";
    "Fxn:self._make_scalar_vars([20],";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_fibb";
    "Fxn:test_while";
    "Fxn:self._make_scalar_vars([10],";
    "Fxn:self._make_scalar_vars([2,";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_if";
    "Fxn:test_if";
    "Fxn:self._make_scalar_vars([1,";
    "Fxn:self._make_scalar_vars([7],";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_if_noelse";
    "Fxn:test_if_noelse";
    "Fxn:self._make_scalar_vars([-1,";
    "Fxn:self._make_scalar_vars([0],";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_while_nonexistant_value";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_while";
    "Fxn:test_script_while_nonexistant_cond_value";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_while";
    "Fxn:test_script_while_write_outer_then_read";
    "Fxn:test_while";
    "Fxn:self._make_scalar_vars([42,";
    "Fxn:self._make_scalar_vars([1379],";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_while_nest_if";
    "Fxn:test_while_if";
    "Fxn:self._make_scalar_vars([-1234,";
    "Fxn:self._make_scalar_vars([-5564],";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_if_nest_while";
    "Fxn:test_if_while";
    "Fxn:self._make_scalar_vars([4321,";
    "Fxn:self._make_scalar_vars([-4321],";
    "Fxn:self.checkScript(script,";
    "Fxn:test_script_ternary";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_ternary_control";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_ternary";
    "Fxn:self.assertEqual(";
    "Fxn:test_python_frontend_run";
    "Fxn:func";
    "Fxn:y).sigmoid()";
    "Fxn:Variable(torch.arange(4),";
    "Fxn:Variable(torch.arange(4)";
    "Fxn:y).sigmoid().pow(2)";
    "Fxn:self.checkScript(func,";
    "Fxn:test_multiple_assignment";
    "Fxn:outer_func";
    "Fxn:func";
    "Fxn:outer_func(x)";
    "Fxn:torch.arange(4)";
    "Fxn:self.assertEqual(func(x),";
    "Fxn:test_trace_annotation";
    "Fxn:@torch.jit.trace(Variable(torch.rand(1)))";
    "Fxn:foo";
    "Fxn:Variable(torch.rand(2))";
    "Fxn:self.assertEqual(s";
    "Fxn:foo(s))";
    "Fxn:test_script_cu";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:foo";
    "Fxn:Variable(torch.rand(1))";
    "Fxn:self.assertEqual(a,";
    "Fxn:cu.foo(a))";
    "Fxn:test_script_annotation";
    "Fxn:foo";
    "Fxn:Variable(torch.rand(2))";
    "Fxn:self.assertEqual(s";
    "Fxn:foo(s))";
    "Fxn:test_script_error";
    "Fxn:foo";
    "Fxn:a.t()";
    "Fxn:Variable(torch.rand(10))";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:foo(s)";
    "Fxn:bar";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:bar(Variable(torch.rand(10),";
    "Fxn:Variable(torch.rand(9),";
    "Fxn:test_script_python_call";
    "Fxn:pyfunc";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:other_func";
    "Fxn:test_call_python";
    "Fxn:pyfunc(a)";
    "Fxn:other_func(b)";
    "Fxn:pyfunc(b)";
    "Fxn:pyfunc(b)";
    "Fxn:self._make_scalar_vars([1],";
    "Fxn:self._make_scalar_vars([54],";
    "Fxn:self.assertEqual(cu.test_call_python(*inputs),";
    "Fxn:test_script_python_call_failure";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:pyfunc";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:other_func";
    "Fxn:test_call_python";
    "Fxn:pyfunc(a)";
    "Fxn:other_func(b)";
    "Fxn:pyfunc2(b)";
    "Fxn:pyfunc(b)";
    "Fxn:self._make_scalar_vars([1],";
    "Fxn:self._make_scalar_vars([54],";
    "Fxn:self.assertEqual(cu.test_call_python(*inputs),";
    "Fxn:test_script_python_call_annotation";
    "Fxn:pyfunc";
    "Fxn:foo";
    "Fxn:self.test(a)";
    "Fxn:pyfunc(a)";
    "Fxn:pyfunc(a)";
    "Fxn:self._make_scalar_vars([1],";
    "Fxn:self._make_scalar_vars([6],";
    "Fxn:self.assertEqual(foo(*inputs),";
    "Fxn:test_script_python_call_annotation_failure";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:pyfunc";
    "Fxn:foo";
    "Fxn:self.test(a)";
    "Fxn:pyfunc2(a)";
    "Fxn:pyfunc(a)";
    "Fxn:self._make_scalar_vars([1],";
    "Fxn:self._make_scalar_vars([6],";
    "Fxn:self.assertEqual(foo(*inputs),";
    "Fxn:test_desugar_module";
    "Fxn:fn";
    "Fxn:torch.abs(x)";
    "Fxn:torch.nn.functional.prelu(x,";
    "Fxn:F.prelu(x,";
    "Fxn:torch.arange(-3,";
    "Fxn:torch.tensor([0.5])";
    "Fxn:fn(x,";
    "Fxn:self.checkScript(fn,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:.cuda()")";
    "Fxn:test_traced_module";
    "Import:torch.nn.functional";
    "class:Model(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[[nn.Linear(num_features,";
    "Fxn:nn.Sigmoid()]";
    "Fxn:nn.Sequential(*chain(*layers))";
    "Fxn:forward";
    "Fxn:self.submodule[i](x)";
    "Fxn:Model(5,";
    "Fxn:torch.randn(2,";
    "Fxn:torch.jit.trace(x)(model)";
    "Fxn:__repr__()";
    "Fxn:model.__repr__()";
    "Fxn:self.assertRaises(AttributeError):";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:nn.Parameter(torch.randn(linear_submodule.weight.shape))";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:linear_submodule(x)";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:linear_submodule.cuda()";
    "Fxn:traced_model.float().cuda()";
    "Fxn:traced_model(x.float().cuda())";
    "Fxn:traced_model.cpu()";
    "Fxn:traced_model(x.float())";
    "Fxn:self.assertEqual(cpu_out,";
    "Fxn:traced_model.double()";
    "Fxn:v.clone()";
    "Fxn:traced_model.state_dict().items()}";
    "Fxn:v.clone().fill_(1)";
    "Fxn:state.items()}";
    "Fxn:traced_model(x)";
    "Fxn:traced_model.load_state_dict(new_state)";
    "Fxn:traced_model(x)";
    "Fxn:traced_model.load_state_dict(state)";
    "Fxn:traced_model(x)";
    "Fxn:self.assertEqual(out,";
    "Fxn:self.assertNotEqual(out,";
    "Fxn:test_shape_prop_mismatch_output";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_shape_prop_mismatch_output";
    "Fxn:topk(a,";
    "Fxn:[torch.zeros(10)]";
    "Fxn:[torch.zeros(2),";
    "Fxn:torch.from_numpy(np.array([1,";
    "Fxn:5])).long()]";
    "Fxn:cu.test_shape_prop_mismatch_output(*inputs)";
    "Fxn:self.assertEqual(real_outs,";
    "Fxn:test_view_shape_prop";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_view_shape_prop";
    "Fxn:view(a,";
    "Fxn:[torch.zeros(10,";
    "Fxn:torch.zeros(100)";
    "Fxn:cu.test_view_shape_prop(*inputs)";
    "Fxn:self.assertEqual(real_outs,";
    "Fxn:test_integral_shape_inference";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_integral_shape_inference";
    "Fxn:[torch.ones(10,";
    "Fxn:10).type(torch.LongTensor)]";
    "Fxn:torch.ones(10,";
    "Fxn:self.assertEqual(cu.test_integral_shape_inference(*inputs),";
    "Fxn:test_fuser_multiple_blocks";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_fuser_multiple_blocks";
    "Fxn:cat(this,";
    "Fxn:cat(that,";
    "Fxn:cat(theother,";
    "Fxn:[torch.ones(0,";
    "Fxn:[torch.ones(1,";
    "Fxn:[torch.ones(20,";
    "Fxn:self.assertEqual(cu.test_fuser_multiple_blocks(*inputs),";
    "Fxn:test_print_graph_executor";
    "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_print_graph_executor";
    "Fxn:[torch.ones(5,";
    "Fxn:capture_stdout()";
    "Fxn:cu.test_print_graph_executor(*inputs)";
    "Fxn:self.assertExpected(captured[0])";
    "Fxn:test_script_module";
    "class:M1(torch.jit.ScriptModule):";
    "Fxn:__init__";
    "Fxn:self).__init__(False)";
    "Fxn:nn.Parameter(torch.randn(2))";
    "Fxn:forward";
    "class:M2(torch.jit.ScriptModule):";
    "Fxn:__init__";
    "Fxn:self).__init__(False)";
    "Fxn:M1()";
    "Fxn:nn.Parameter(torch.randn(2,";
    "Fxn:nn.Parameter(torch.randn(2))";
    "Fxn:self.define("""";
    "Fxn:hi";
    "Fxn:self.weight.mm(a)";
    "Fxn:doit";
    "Fxn:self.weight.mm(input)";
    "Fxn:doit2";
    "Fxn:self.weight.mm(input)";
    "Fxn:forward";
    "Fxn:self.doit(input)";
    "Fxn:self.doit2(input)";
    "Fxn:self.hi(input)";
    "Fxn:self.sub(a)";
    "Fxn:M2()";
    "Fxn:torch.randn(3,";
    "Fxn:m2.weight.mm(input)";
    "Fxn:m2.weight.mm(input)";
    "Fxn:m2.weight.mm(input)";
    "Fxn:self.assertEqual(ref,";
    "Fxn:m2.forward(input))";
    "Fxn:nn.Parameter(torch.zeros_like(m2.weight))";
    "Fxn:nn.Parameter(torch.zeros_like(m2.bias))";
    "Fxn:nn.Parameter(torch.zeros_like(m2.sub.weight))";
    "Fxn:self.assertEqual(torch.zeros(2,";
    "Fxn:m2.forward(torch.randn(3,";
    "Fxn:run_tests()";
    "/test/test_legacy_nn.py";
    "Import:math";
    "Import:random";
    "Import:unittest";
    "Import:collections";
    "Import:deepcopy";
    "Import:torch";
    "Import:torch.legacy.nn";
    "Import:NNTestCase,";
    "Import:get_numerical_jacobian,";
    "Import:to_gpu,";
    "Import:Variable";
    "class:OldModuleTest(ModuleTest):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:kwargs.get('check_inplace',";
    "Fxn:_do_test";
    "Fxn:module.training()";
    "Fxn:torch.no_grad():";
    "Fxn:test_case.check_jacobian(module,";
    "Fxn:module.evaluate()";
    "Fxn:torch.no_grad():";
    "Fxn:test_case.check_jacobian(module,";
    "Fxn:.type()";
    "Fxn:module.float().double().forward(input)";
    "Fxn:.clearState()";
    "Fxn:module.clearState()";
    "Fxn:module.__repr__()";
    "Fxn:deepcopy(input)";
    "Fxn:self.constructor(*self.constructor_args,";
    "Fxn:freeze_rng_state():";
    "Fxn:module.forward(input)";
    "Fxn:test_case.assertEqual(input,";
    "Fxn:freeze_rng_state():";
    "Fxn:module_ip.forward(input2)";
    "Fxn:torch.equal(output,";
    "Fxn:test_case.assertNotEqual(input,";
    "Fxn:test_case.assertEqual(output,";
    "Fxn:OldModuleTest(nn.Add,";
    "Fxn:constructor_args=(torch.Size([5,";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.Add,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.AddConstant,";
    "Fxn:constructor_args=(3.5,),";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.BatchNormalization,";
    "Fxn:constructor_args=(10,),";
    "Fxn:input_size=(4,";
    "Fxn:OldModuleTest(nn.BatchNormalization,";
    "Fxn:constructor_args=(10,";
    "Fxn:input_size=(4,";
    "Fxn:OldModuleTest(nn.SpatialBatchNormalization,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialBatchNormalization,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialBatchNormalization,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricBatchNormalization,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricBatchNormalization,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricBatchNormalization,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.CMul,";
    "Fxn:constructor_args=(5,";
    "Fxn:input_size=(10,";
    "Fxn:OldModuleTest(nn.CMul,";
    "Fxn:constructor_args=(50,";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.CMul,";
    "Fxn:constructor_args=(1,";
    "Fxn:torch.randn(10,";
    "Fxn:OldModuleTest(nn.Exp,";
    "Fxn:input_size=(2,";
    "Fxn:i.exp()),";
    "Fxn:OldModuleTest(nn.Log,";
    "Fxn:torch.rand(2,";
    "Fxn:i.log()),";
    "Fxn:OldModuleTest(nn.Clamp,";
    "Fxn:constructor_args=(-2.,";
    "Fxn:torch.randn(3,";
    "Fxn:i.clamp(-2,";
    "Fxn:OldModuleTest(nn.Abs,";
    "Fxn:input_size=(3,";
    "Fxn:i.abs()),";
    "Fxn:OldModuleTest(nn.Bilinear,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=[(4,";
    "Fxn:OldModuleTest(nn.Bilinear,";
    "Fxn:constructor_args=(5,";
    "Fxn:input_size=[(2,";
    "Fxn:OldModuleTest(nn.Euclidean,";
    "Fxn:constructor_args=(5,";
    "Fxn:input_size=(10,";
    "Fxn:OldModuleTest(nn.WeightedEuclidean,";
    "Fxn:constructor_args=(5,";
    "Fxn:input_size=(10,";
    "Fxn:OldModuleTest(nn.Cosine,";
    "Fxn:constructor_args=(5,";
    "Fxn:input_size=(10,";
    "Fxn:OldModuleTest(nn.CAddTable,";
    "Fxn:input_size=[(5,";
    "Fxn:OldModuleTest(nn.CSubTable,";
    "Fxn:input_size=[(5,";
    "Fxn:OldModuleTest(nn.CDivTable,";
    "Fxn:[torch.randn(1,";
    "Fxn:torch.rand(1,";
    "Fxn:OldModuleTest(nn.CMulTable,";
    "Fxn:input_size=[(5,";
    "Fxn:OldModuleTest(nn.Square,";
    "Fxn:input_size=(10,";
    "Fxn:i.mul(i)),";
    "Fxn:OldModuleTest(nn.Sqrt,";
    "Fxn:torch.rand(10,";
    "Fxn:i.sqrt()),";
    "Fxn:OldModuleTest(nn.Squeeze,";
    "Fxn:input_size=(2,";
    "Fxn:i.squeeze()),";
    "Fxn:OldModuleTest(nn.Squeeze,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(2,";
    "Fxn:i.squeeze(1),";
    "Fxn:OldModuleTest(nn.Unsqueeze,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(2,";
    "Fxn:i.view(2,";
    "Fxn:OldModuleTest(nn.Unsqueeze,";
    "Fxn:constructor_args=(0,),";
    "Fxn:input_size=(2,";
    "Fxn:i.view(1,";
    "Fxn:OldModuleTest(nn.Unsqueeze,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(2,";
    "Fxn:i.view(2,";
    "Fxn:OldModuleTest(nn.View,";
    "Fxn:constructor_args=(-1,";
    "Fxn:input_size=(2,";
    "Fxn:i.view(-1,";
    "Fxn:OldModuleTest(nn.View,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:i.view(2,";
    "Fxn:OldModuleTest(nn.View,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:i.view(2,";
    "Fxn:OldModuleTest(nn.Sum,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(2,";
    "Fxn:i.sum(1,";
    "Fxn:OldModuleTest(nn.Sum,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(2,";
    "Fxn:i.sum(1,";
    "Fxn:keepdim=False).div(i.size(1)),";
    "Fxn:OldModuleTest(nn.Mean,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(2,";
    "Fxn:torch.mean(i,";
    "Fxn:OldModuleTest(lambda:";
    "Fxn:nn.Sequential().add(nn.GradientReversal()).add(nn.GradientReversal()),";
    "Fxn:input_size=(4,";
    "Fxn:OldModuleTest(nn.Identity,";
    "Fxn:input_size=(4,";
    "Fxn:OldModuleTest(nn.DotProduct,";
    "Fxn:input_size=[(10,";
    "Fxn:torch.Tensor(list(";
    "Fxn:a.dot(b)";
    "Fxn:OldModuleTest(nn.CosineDistance,";
    "Fxn:input_size=[(10,";
    "Fxn:torch.Tensor(list(";
    "Fxn:a.dot(b)";
    "Fxn:b.norm(2))";
    "Fxn:OldModuleTest(nn.JoinTable,";
    "Fxn:constructor_args=(0,),";
    "Fxn:input_size=[(10,";
    "Fxn:torch.cat(i,";
    "Fxn:OldModuleTest(nn.JoinTable,";
    "Fxn:constructor_args=(2,),";
    "Fxn:input_size=[(2,";
    "Fxn:torch.cat(i,";
    "Fxn:OldModuleTest(nn.JoinTable,";
    "Fxn:constructor_args=(-1,),";
    "Fxn:input_size=[(2,";
    "Fxn:torch.cat(i,";
    "Fxn:OldModuleTest(nn.MM,";
    "Fxn:input_size=[(4,";
    "Fxn:torch.bmm(*i)),";
    "Fxn:OldModuleTest(nn.MV,";
    "Fxn:input_size=[(4,";
    "Fxn:torch.bmm(i[0],";
    "Fxn:i[1].view(i[1].size(0),";
    "Fxn:i[1].size(1),";
    "Fxn:1)).squeeze()),";
    "Fxn:OldModuleTest(nn.Max,";
    "Fxn:input_size=(4,";
    "Fxn:torch.max(i,";
    "Fxn:OldModuleTest(nn.Max,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(4,";
    "Fxn:torch.max(i,";
    "Fxn:OldModuleTest(nn.Min,";
    "Fxn:input_size=(4,";
    "Fxn:torch.min(i,";
    "Fxn:OldModuleTest(nn.Min,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(4,";
    "Fxn:torch.min(i,";
    "Fxn:OldModuleTest(nn.MixtureTable,";
    "Fxn:input_size=[(5,";
    "Fxn:OldModuleTest(nn.LookupTable,";
    "Fxn:constructor_args=(4,";
    "Fxn:torch.randperm(2).repeat(1,";
    "Fxn:OldModuleTest(nn.Mul,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.MulConstant,";
    "Fxn:constructor_args=(4,),";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.Narrow,";
    "Fxn:constructor_args=(0,";
    "Fxn:input_size=(2,";
    "Fxn:i.narrow(0,";
    "Fxn:OldModuleTest(nn.Narrow,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(2,";
    "Fxn:i.narrow(1,";
    "Fxn:OldModuleTest(nn.Transpose,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:i.transpose(1,";
    "Fxn:2).transpose(1,";
    "Fxn:OldModuleTest(nn.Transpose,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:i.transpose(1,";
    "Fxn:OldModuleTest(nn.Replicate,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(10,";
    "Fxn:i.view(10,";
    "Fxn:5).expand(10,";
    "Fxn:OldModuleTest(nn.Padding,";
    "Fxn:constructor_args=(0,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.Padding,";
    "Fxn:constructor_args=(0,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.Padding,";
    "Fxn:constructor_args=(0,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.PartialLinear,";
    "Fxn:constructor_args=(5,";
    "Fxn:input_size=(4,";
    "Fxn:OldModuleTest(lambda:";
    "Fxn:nn.PartialLinear(5,";
    "Fxn:6).setPartition(torch.Tensor((2,";
    "Fxn:input_size=(4,";
    "Fxn:OldModuleTest(nn.Power,";
    "Fxn:constructor_args=(2,),";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.Power,";
    "Fxn:constructor_args=(1.5,),";
    "Fxn:torch.rand(3,";
    "Fxn:OldModuleTest(nn.Reshape,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.Reshape,";
    "Fxn:constructor_args=(4";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.Select,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(3,";
    "Fxn:i.select(1,";
    "Fxn:OldModuleTest(nn.SelectTable,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=[(1,),";
    "Fxn:OldModuleTest(nn.SpatialAveragePooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialAveragePooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialAveragePooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialAdaptiveMaxPooling,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:nn.SpatialMaxPooling(2,";
    "Fxn:2).forward(i)),";
    "Fxn:OldModuleTest(nn.SpatialAdaptiveMaxPooling,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialConvolutionLocal,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialConvolutionLocal,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialConvolutionLocal,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialDivisiveNormalization,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialContrastiveNormalization,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialDilatedConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialDilatedConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialMaxPooling,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialReflectionPadding,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialReplicationPadding,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialZeroPadding,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.SpatialConvolutionMap,";
    "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.SpatialConvolutionMap,";
    "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.SpatialConvolutionMap,";
    "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.full(3,";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.SpatialFullConvolutionMap,";
    "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.SpatialFullConvolutionMap,";
    "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(nn.SpatialFullConvolutionMap,";
    "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.full(3,";
    "Fxn:input_size=(3,";
    "Fxn:OldModuleTest(lambda:";
    "Fxn:nn.SpatialFractionalMaxPooling(2,";
    "Fxn:0.5).fixPoolingRegions(),";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(lambda:";
    "Fxn:nn.SpatialFractionalMaxPooling(2,";
    "Fxn:4).fixPoolingRegions(),";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialFullConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialLPPooling,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialSubSampling,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialSubtractiveNormalization,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialSubtractiveNormalization,";
    "Fxn:constructor_args=(3,";
    "Fxn:torch.rand(3)),";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.SpatialUpSamplingNearest,";
    "Fxn:constructor_args=(2,),";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.TemporalConvolution,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.TemporalConvolution,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.TemporalSubSampling,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(10,";
    "Fxn:OldModuleTest(nn.TemporalSubSampling,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(10,";
    "Fxn:OldModuleTest(nn.VolumetricAveragePooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricAveragePooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricAveragePooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricConvolution,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:OldModuleTest(nn.VolumetricFullConvolution,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(1,";
    "Fxn:OldModuleTest(nn.VolumetricMaxPooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:OldModuleTest(nn.VolumetricMaxPooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:OldModuleTest(nn.VolumetricMaxPooling,";
    "Fxn:constructor_args=(2,";
    "Fxn:OldModuleTest(nn.VolumetricReplicationPadding,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(2,";
    "Fxn:CriterionTest(nn.L1Cost,";
    "Fxn:input_size=(2,";
    "Fxn:CriterionTest(nn.L1HingeEmbeddingCriterion,";
    "Fxn:input_size=[(2,";
    "Fxn:CriterionTest(nn.L1HingeEmbeddingCriterion,";
    "Fxn:constructor_args=(2,),";
    "Fxn:input_size=[(2,";
    "Fxn:CriterionTest(nn.WeightedMSECriterion,";
    "Fxn:input_size=(2,";
    "Fxn:target_size=(2,";
    "Fxn:CriterionTest(nn.MarginCriterion,";
    "Fxn:input_size=(5,";
    "Fxn:torch.randn(5,";
    "Fxn:10).sign()),";
    "Fxn:CriterionTest(nn.ClassSimplexCriterion,";
    "Fxn:constructor_args=(30,),";
    "Fxn:torch.randn(5,";
    "Fxn:30).mul(10).renorm(2,";
    "Fxn:torch.rand(5).mul(30).floor().long(),";
    "Fxn:tests.append(";
    "Fxn:OldModuleTest(nn.Normalize,";
    "Fxn:constructor_args=(p,),";
    "Fxn:input_size=(4,";
    "Fxn:i.div(i.norm(p,";
    "Fxn:True).expand_as(i)),";
    "Fxn:desc=str(p)),";
    "Fxn:tests.append(";
    "Fxn:OldModuleTest(nn.PairwiseDistance,";
    "Fxn:constructor_args=(p,),";
    "Fxn:input_size=[(4,";
    "Fxn:desc=str(p))";
    "Fxn:build_spatial_unpooling_net";
    "Fxn:nn.SpatialMaxPooling(2,";
    "Fxn:nn.SpatialMaxUnpooling(pool)";
    "Fxn:nn.Sequential().add(pool).add(unpool)";
    "Fxn:tests.append(";
    "Fxn:OldModuleTest(build_spatial_unpooling_net,";
    "Fxn:input_size=(1,";
    "Fxn:build_volumetric_unpooling_net";
    "Fxn:nn.VolumetricMaxPooling(2,";
    "Fxn:nn.VolumetricMaxUnpooling(pool)";
    "Fxn:nn.Sequential().add(pool).add(unpool)";
    "Fxn:tests.append(";
    "Fxn:OldModuleTest(build_volumetric_unpooling_net,";
    "Fxn:input_size=(1,";
    "Fxn:prepare_tests";
    "Fxn:add_test";
    "Fxn:test.get_name()";
    "Fxn:RuntimeError('Found";
    "Fxn:RuntimeError('Found";
    "Fxn:test(self))";
    "Fxn:test.test_cuda(self))";
    "Fxn:add_test(test)";
    "Fxn:deepcopy(test_params)";
    "Fxn:test_params.pop('module_name')";
    "Fxn:name_remap.get(name,";
    "Fxn:OldModuleTest(**test_params)";
    "Fxn:add_test(test)";
    "Fxn:deepcopy(test_params)";
    "Fxn:test_params.pop('module_name')";
    "Fxn:name_remap.get(name,";
    "Fxn:name.replace('Loss',";
    "Fxn:test_params.keys()";
    "Fxn:test_params.pop('legacy_constructor_args',";
    "Fxn:CriterionTest(**test_params)";
    "Fxn:add_test(test)";
    "Fxn:require_grad";
    "Fxn:input.detach()";
    "class:TestNN(NNTestCase):";
    "Fxn:_numerical_jacobian";
    "Fxn:fw";
    "Fxn:self._forward(module,";
    "Fxn:contiguous(input)";
    "Fxn:require_grad(input)";
    "Fxn:get_numerical_jacobian(fw,";
    "Fxn:self._get_parameters(module)";
    "Fxn:p.detach()";
    "Fxn:jacobians.append(get_numerical_jacobian(fw,";
    "Fxn:torch.cat(jacobians,";
    "Fxn:_forward";
    "Fxn:freeze_rng_state():";
    "Fxn:torch.no_grad():";
    "Fxn:module.forward(input)";
    "Fxn:_backward";
    "Fxn:module.backward(input,";
    "Fxn:_forward_criterion";
    "Fxn:torch.no_grad():";
    "Fxn:criterion.forward(input,";
    "Fxn:_backward_criterion";
    "Fxn:torch.no_grad():";
    "Fxn:criterion.backward(input,";
    "Fxn:_zero_grad_parameters";
    "Fxn:module.zeroGradParameters()";
    "Fxn:_get_parameters";
    "Fxn:module.parameters()";
    "Fxn:test_Dropout";
    "Fxn:torch.Tensor(1000).fill_(1";
    "Fxn:nn.Dropout(p)";
    "Fxn:module.forward(input)";
    "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:module.backward(input,";
    "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:nn.Dropout(p,";
    "Fxn:module.forward(input.clone())";
    "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:module.backward(input.clone(),";
    "Fxn:input.clone())";
    "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:module.__repr__()";
    "Fxn:test_SpatialDropout";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:torch.Tensor(b,";
    "Fxn:h).fill_(1)";
    "Fxn:nn.SpatialDropout(p)";
    "Fxn:module.training()";
    "Fxn:module.forward(input)";
    "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:module.backward(input,";
    "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:module.__repr__()";
    "Fxn:test_VolumetricDropout";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:torch.Tensor(bsz,";
    "Fxn:h).fill_(1)";
    "Fxn:nn.VolumetricDropout(p)";
    "Fxn:module.training()";
    "Fxn:module.forward(input)";
    "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:module.backward(input,";
    "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:module.__repr__()";
    "Fxn:test_ReLU_reference";
    "Fxn:torch.randn(10,";
    "Fxn:nn.ReLU()";
    "Fxn:module.forward(input)";
    "Fxn:self.assertTrue(output[input.ge(0)].eq(input[input.gt(0)]).all())";
    "Fxn:self.assertTrue(output[input.lt(0)].eq(0).all())";
    "Fxn:test_ReLU6_reference";
    "Fxn:torch.randn(10,";
    "Fxn:20).mul(10)";
    "Fxn:nn.ReLU6()";
    "Fxn:module.forward(input)";
    "Fxn:self.assertTrue(output[input.ge(6)].eq(6).all())";
    "Fxn:self.assertTrue(output[input.lt(0)].eq(0).all())";
    "Fxn:test_Copy";
    "Fxn:torch.randn(3,";
    "Fxn:4).double()";
    "Fxn:nn.Copy(torch.DoubleTensor,";
    "Fxn:c.forward(input)";
    "Fxn:self.assertIsInstance(output,";
    "Fxn:self.assertEqual(output,";
    "Fxn:input.float(),";
    "Fxn:c.backward(input,";
    "Fxn:output.fill_(1))";
    "Fxn:self.assertIsInstance(gradInput,";
    "Fxn:self.assertEqual(gradInput,";
    "Fxn:output.double(),";
    "Fxn:c.double()";
    "Fxn:self.assertIsInstance(output,";
    "Fxn:c.__repr__()";
    "Fxn:test_FlattenTable";
    "Fxn:torch.rand(1),";
    "Fxn:torch.rand(2),";
    "Fxn:torch.rand(3)";
    "Fxn:torch.rand(4)";
    "Fxn:torch.rand(1),";
    "Fxn:torch.rand(2),";
    "Fxn:torch.rand(3),";
    "Fxn:torch.rand(4)";
    "Fxn:nn.FlattenTable()";
    "Fxn:m.forward(input)";
    "Fxn:self.assertEqual(len(output),";
    "Fxn:self.assertEqual(output[0],";
    "Fxn:self.assertEqual(output[1],";
    "Fxn:self.assertEqual(output[2],";
    "Fxn:self.assertEqual(output[3],";
    "Fxn:m.backward(input,";
    "Fxn:self.assertEqual(gradOutput[0],";
    "Fxn:self.assertEqual(gradOutput[1],";
    "Fxn:self.assertEqual(gradOutput[2],";
    "Fxn:self.assertEqual(gradOutput[3],";
    "Fxn:m.__repr__()";
    "Fxn:m.forward(input)";
    "Fxn:self.assertEqual(old_input_map,";
    "Fxn:self.assertEqual(old_output,";
    "Fxn:input[1].append(torch.rand(5))";
    "Fxn:m.forward(input)";
    "Fxn:self.assertNotEqual(old_input_map,";
    "Fxn:self.assertNotEqual(old_output,";
    "Fxn:input.pop()";
    "Fxn:m.forward(input)";
    "Fxn:self.assertNotEqual(old_input_map,";
    "Fxn:self.assertNotEqual(old_output,";
    "Fxn:test_Concat";
    "Fxn:torch.randn(4,";
    "Fxn:random.randint(2,";
    "Fxn:[nn.Linear(2,";
    "Fxn:nn.Concat(0)";
    "Fxn:m.add(l)";
    "Fxn:l.zeroGradParameters()";
    "Fxn:l.weight.fill_(1)";
    "Fxn:l.bias.fill_(0)";
    "Fxn:m.__repr__()";
    "Fxn:m.forward(input)";
    "Fxn:input.sum(1,";
    "Fxn:True).expand(4,";
    "Fxn:5).repeat(num_modules,";
    "Fxn:self.assertEqual(output2,";
    "Fxn:m.backward(input,";
    "Fxn:torch.ones(output2.size()))";
    "Fxn:torch.ones(4,";
    "Fxn:2).fill_(num_modules";
    "Fxn:self.assertEqual(gradInput,";
    "Fxn:input.sum(0,";
    "Fxn:keepdim=True).expand(5,";
    "Fxn:self.assertEqual(gradWeight,";
    "Fxn:test_Parallel";
    "Fxn:torch.randn(3,";
    "Fxn:nn.Parallel(0,";
    "Fxn:m.add(nn.View(4,";
    "Fxn:m.add(nn.View(4,";
    "Fxn:m.add(nn.View(4,";
    "Fxn:m.__repr__()";
    "Fxn:m.forward(input)";
    "Fxn:input.transpose(0,";
    "Fxn:2).transpose(0,";
    "Fxn:self.assertEqual(output2,";
    "Fxn:m.backward(input,";
    "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_ParallelTable";
    "Fxn:torch.randn(3,";
    "Fxn:nn.ParallelTable()";
    "Fxn:p.add(nn.View(4,";
    "Fxn:p.add(nn.View(4,";
    "Fxn:p.add(nn.View(4,";
    "Fxn:nn.Sequential()";
    "Fxn:m.add(nn.SplitTable(0))";
    "Fxn:m.add(p)";
    "Fxn:m.add(nn.JoinTable(2))";
    "Fxn:p.__repr__()";
    "Fxn:m.forward(input)";
    "Fxn:input.transpose(0,";
    "Fxn:2).transpose(0,";
    "Fxn:self.assertEqual(output2,";
    "Fxn:m.backward(input,";
    "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_ConcatTable";
    "Fxn:torch.randn(3,";
    "Fxn:4).float(),";
    "Fxn:torch.randn(3,";
    "Fxn:4).float(),";
    "Fxn:[torch.randn(3,";
    "Fxn:4).float()]";
    "Fxn:torch.randn(3,";
    "Fxn:4).float(),";
    "Fxn:torch.randn(3,";
    "Fxn:4).float(),";
    "Fxn:torch.randn(3,";
    "Fxn:4).float()";
    "Fxn:nn.ConcatTable()";
    "Fxn:module.add(nn.Identity())";
    "Fxn:module.add(nn.Identity())";
    "Fxn:module.add(nn.Identity())";
    "Fxn:module.float()";
    "Fxn:module.__repr__()";
    "Fxn:module.forward(input)";
    "Fxn:self.assertEqual(output2,";
    "Fxn:module.backward(input,";
    "Fxn:[_gradOutput[0].sum(0,";
    "Fxn:_gradOutput[1].sum(";
    "Fxn:[_gradOutput[2].sum(0,";
    "Fxn:self.assertTrue(isinstance(gradInput,";
    "Fxn:self.assertFalse(isinstance(gradInput[0],";
    "Fxn:self.assertFalse(isinstance(gradInput[1],";
    "Fxn:self.assertTrue(isinstance(gradInput[2],";
    "Fxn:self.assertEqual(len(gradInput),";
    "Fxn:self.assertEqual(len(gradInput[2]),";
    "Fxn:iter_tensors(gradInput2)):";
    "Fxn:self.assertEqual(t1,";
    "Fxn:nn.ConcatTable()";
    "Fxn:test.add(nn.Identity())";
    "Fxn:test.add(nn.Identity())";
    "Fxn:[torch.randn(5),";
    "Fxn:torch.randn(5)]";
    "Fxn:[torch.randn(5)]";
    "Fxn:self.assertEqual(o1,";
    "Fxn:self.assertEqual(go1,";
    "Fxn:self.assertEqual(o2,";
    "Fxn:self.assertEqual(go2,";
    "Fxn:test_DepthConcat";
    "Fxn:torch.randn(2,";
    "Fxn:torch.randn(2,";
    "Fxn:nn.DepthConcat(1)";
    "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:concat.zeroGradParameters()";
    "Fxn:concat.forward(input)";
    "Fxn:concat.backward(input,";
    "Fxn:torch.Tensor(2,";
    "Fxn:12).zero_()";
    "Fxn:input.clone().zero_()";
    "Fxn:concat.get(i)";
    "Fxn:conv.gradWeight.clone()";
    "Fxn:conv.zeroGradParameters()";
    "Fxn:output[narrows[i]].copy_(conv.forward(input))";
    "Fxn:gradInput.add_(conv.backward(input,";
    "Fxn:self.assertEqual(gradWeight,";
    "Fxn:self.assertEqual(output,";
    "Fxn:self.assertEqual(gradInput,";
    "Fxn:concat.__repr__()";
    "Fxn:test_Contiguous";
    "Fxn:torch.randn(10,";
    "Fxn:nn.Contiguous()";
    "Fxn:noncontig.is_contiguous()";
    "Fxn:module.forward(noncontig)";
    "Fxn:self.assertEqual(output,";
    "Fxn:self.assertTrue(output.is_contiguous())";
    "Fxn:module.__repr__()";
    "Fxn:test_Index";
    "Fxn:nn.Index(0)";
    "Fxn:[torch.Tensor((10,";
    "Fxn:torch.LongTensor((0,";
    "Fxn:net.forward(input)";
    "Fxn:self.assertEqual(output,";
    "Fxn:torch.Tensor((10,";
    "Fxn:torch.Tensor((1,";
    "Fxn:net.backward(input,";
    "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:torch.Tensor((1,";
    "Fxn:[torch.Tensor(((10,";
    "Fxn:torch.LongTensor((0,";
    "Fxn:net.forward(input)";
    "Fxn:self.assertEqual(output,";
    "Fxn:torch.Tensor(((10,";
    "Fxn:torch.Tensor(((1,";
    "Fxn:net.backward(input,";
    "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:torch.Tensor(((2,";
    "Fxn:net.__repr__()";
    "Fxn:test_L1Penalty";
    "Fxn:nn.L1Penalty(weight,";
    "Fxn:torch.rand(2,";
    "Fxn:10).add_(-0.5)";
    "Fxn:m.forward(input)";
    "Fxn:m.backward(input,";
    "Fxn:torch.ones(input.size()))";
    "Fxn:self.assertEqual(input.abs().sum()";
    "Fxn:input.lt(0).type_as(grad).mul_(-1)).mul_(weight)";
    "Fxn:self.assertEqual(true_grad,";
    "Fxn:m.__repr__()";
    "Fxn:test_MaskedSelect";
    "Fxn:torch.randn(4,";
    "Fxn:torch.ByteTensor(4,";
    "Fxn:5).bernoulli_()";
    "Fxn:nn.MaskedSelect()";
    "Fxn:module.forward([input,";
    "Fxn:self.assertEqual(input.masked_select(mask),";
    "Fxn:torch.Tensor((20,";
    "Fxn:torch.Tensor(((10,";
    "Fxn:torch.Tensor(((20,";
    "Fxn:torch.ByteTensor(((1,";
    "Fxn:nn.MaskedSelect()";
    "Fxn:module.forward([input,";
    "Fxn:module.backward([input,";
    "Fxn:self.assertEqual(inTarget,";
    "Fxn:module.__repr__()";
    "Fxn:test_MultiCriterion";
    "Fxn:torch.rand(2,";
    "Fxn:torch.LongTensor((1,";
    "Fxn:nn.ClassNLLCriterion()";
    "Fxn:nn.CrossEntropyCriterion()";
    "Fxn:nn.MultiCriterion().add(nll,";
    "Fxn:0.5).add(nll2)";
    "Fxn:mc.forward(input,";
    "Fxn:nll.forward(input,";
    "Fxn:nll2.forward(input,";
    "Fxn:self.assertEqual(output,";
    "Fxn:mc.backward(input,";
    "Fxn:nll.backward(input,";
    "Fxn:target).clone().div(2).add(nll2.backward(input,";
    "Fxn:self.assertEqual(gradInput,";
    "Fxn:mc.float()";
    "Fxn:gradInput.clone()";
    "Fxn:input.float()";
    "Fxn:mc.forward(input3,";
    "Fxn:mc.backward(input3,";
    "Fxn:self.assertEqual(output,";
    "Fxn:self.assertEqual(gradInput.float(),";
    "Fxn:mc.__repr__()";
    "Fxn:mc.double()";
    "Fxn:[torch.randn(2,";
    "Fxn:[torch.randn(2,";
    "Fxn:torch.randn(2,";
    "Fxn:[torch.IntTensor((1,";
    "Fxn:[torch.IntTensor((5,";
    "Fxn:torch.IntTensor((4,";
    "Fxn:nn.ParallelCriterion().add(nll).add(nn.ParallelCriterion().add(nll.clone()).add(nll.clone()))";
    "Fxn:nn.ParallelCriterion().add(nll2).add(nn.ParallelCriterion().add(nll2.clone()).add(nll2.clone()))";
    "Fxn:nn.MultiCriterion().add(pnllc,";
    "Fxn:0.5).add(pnllc2)";
    "Fxn:mc.forward(input,";
    "Fxn:pnllc.forward(input,";
    "Fxn:pnllc2.forward(input,";
    "Fxn:self.assertEqual(output,";
    "Fxn:mc.backward(input,";
    "Fxn:pnllc.clone().backward(input,";
    "Fxn:pnllc2.backward(input,";
    "Fxn:gradInput2[0].div(2).add(gradInput2b[0])";
    "Fxn:gradInput2[1][0].div(2).add(gradInput2b[1][0])";
    "Fxn:gradInput2[1][1].div(2).add(gradInput2b[1][1])";
    "Fxn:self.assertEqual(gradInput[1],";
    "Fxn:self.assertEqual(gradInput[1][9],";
    "Fxn:self.assertEqual(gradInput[1][1],";
    "Fxn:test_ParallelCriterion";
    "Fxn:[torch.rand(2,";
    "Fxn:torch.randn(2,";
    "Fxn:[torch.LongTensor((1,";
    "Fxn:torch.randn(2,";
    "Fxn:nn.ClassNLLCriterion()";
    "Fxn:nn.MSECriterion()";
    "Fxn:nn.ParallelCriterion().add(nll,";
    "Fxn:0.5).add(mse)";
    "Fxn:pc.forward(input,";
    "Fxn:nll.forward(input[0],";
    "Fxn:mse.forward(input[1],";
    "Fxn:self.assertEqual(output,";
    "Fxn:[nll.backward(input[0],";
    "Fxn:target[0]).clone().div(2),";
    "Fxn:mse.backward(input[1],";
    "Fxn:pc.backward(input,";
    "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:self.assertEqual(gradInput[1],";
    "Fxn:pc.float()";
    "Fxn:gradInput[0].clone(),";
    "Fxn:gradInput[1].clone()";
    "Fxn:[input[0].float(),";
    "Fxn:input[1].float()]";
    "Fxn:target[1].float()]";
    "Fxn:pc.forward(input3,";
    "Fxn:pc.backward(input3,";
    "Fxn:self.assertEqual(output,";
    "Fxn:self.assertEqual(gradInput[0].float(),";
    "Fxn:self.assertEqual(gradInput[1].float(),";
    "Fxn:[torch.rand(2,";
    "Fxn:torch.randn(2,";
    "Fxn:torch.randn(2,";
    "Fxn:nn.MSECriterion()";
    "Fxn:nn.ParallelCriterion(True).add(mse,";
    "Fxn:0.5).add(nn.MSECriterion())";
    "Fxn:pc.forward(input,";
    "Fxn:mse.forward(input[0],";
    "Fxn:mse.forward(input[1],";
    "Fxn:self.assertEqual(output,";
    "Fxn:pc.backward(input,";
    "Fxn:[mse.backward(input[0],";
    "Fxn:target).clone().div(2),";
    "Fxn:mse.backward(input[1],";
    "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:self.assertEqual(gradInput[1],";
    "Fxn:[torch.randn(2,";
    "Fxn:[torch.rand(2,";
    "Fxn:torch.randn(2,";
    "Fxn:[torch.LongTensor((2,";
    "Fxn:[torch.LongTensor((1,";
    "Fxn:torch.randn(2,";
    "Fxn:nn.ClassNLLCriterion()";
    "Fxn:nn.ClassNLLCriterion()";
    "Fxn:nn.MSECriterion()";
    "Fxn:nn.ParallelCriterion().add(nll,";
    "Fxn:0.5).add(mse)";
    "Fxn:nn.ParallelCriterion().add(nll2,";
    "Fxn:0.4).add(pc)";
    "Fxn:pc2.forward(input,";
    "Fxn:nll.forward(input[1][0],";
    "Fxn:mse.forward(input[1][1],";
    "Fxn:self.assertEqual(output,";
    "Fxn:nll2.backward(input[0],";
    "Fxn:target[0]).clone().mul(0.4),";
    "Fxn:[nll.backward(input[1][1],";
    "Fxn:target[1][0]).clone().div(2),";
    "Fxn:mse.backward(input[1][1],";
    "Fxn:pc2.backward(input,";
    "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:self.assertEqual(gradInput[1][0],";
    "Fxn:self.assertEqual(gradInput[1][1],";
    "Fxn:pc.__repr__()";
    "Fxn:test_NarrowTable";
    "Fxn:[torch.Tensor(i)";
    "Fxn:nn.NarrowTable(1)";
    "Fxn:module.forward(input)";
    "Fxn:self.assertEqual(output,";
    "Fxn:nn.NarrowTable(2,";
    "Fxn:module.forward(input)";
    "Fxn:self.assertEqual(output,";
    "Fxn:module.__repr__()";
    "Fxn:test_accUpdateGradParameters";
    "Fxn:nn.LookupTable(5,";
    "Fxn:module.weight.fill_(2)";
    "Fxn:torch.LongTensor([1,";
    "Fxn:module.updateOutput(input)";
    "Fxn:module.backwardUpdate(input,";
    "Fxn:self.assertEqual(module.weight[0,";
    "Fxn:self.assertEqual(module.weight[3,";
    "Fxn:_build_net";
    "Fxn:.add(nn.Concat(0)";
    "Fxn:.add(nn.Linear(2,";
    "Fxn:.add(nn.Linear(2,";
    "Fxn:.add(nn.ReLU())";
    "Fxn:.add(nn.Linear(10,";
    "Fxn:test_parameters";
    "Fxn:self._build_net()";
    "Fxn:net.parameters()";
    "Fxn:self.assertEqual(len(param),";
    "Fxn:self.assertEqual(len(grad),";
    "Fxn:self.assertObjectIn(concat.modules[0].weight,";
    "Fxn:self.assertObjectIn(concat.modules[0].bias,";
    "Fxn:self.assertObjectIn(concat.modules[1].weight,";
    "Fxn:self.assertObjectIn(concat.modules[1].bias,";
    "Fxn:self.assertObjectIn(net.modules[2].weight,";
    "Fxn:self.assertObjectIn(net.modules[2].bias,";
    "Fxn:self.assertObjectIn(concat.modules[0].gradWeight,";
    "Fxn:self.assertObjectIn(concat.modules[0].gradBias,";
    "Fxn:self.assertObjectIn(concat.modules[1].gradWeight,";
    "Fxn:self.assertObjectIn(concat.modules[1].gradBias,";
    "Fxn:self.assertObjectIn(net.modules[2].gradWeight,";
    "Fxn:self.assertObjectIn(net.modules[2].gradBias,";
    "Fxn:test_flattenParameters";
    "Fxn:self._build_net()";
    "Fxn:net.flattenParameters()";
    "Fxn:self.assertEqual(param.dim(),";
    "Fxn:self.assertEqual(param.size(0),";
    "Fxn:self.assertEqual(grad_param.dim(),";
    "Fxn:self.assertEqual(grad_param.size(0),";
    "Fxn:test_findModules";
    "Fxn:self._build_net()";
    "Fxn:net.findModules(nn.Linear)";
    "Fxn:self.assertEqual(len(modules),";
    "Fxn:self.assertEqual(len(modules),";
    "Fxn:self.assertObjectIn(net.modules[0].modules[0],";
    "Fxn:self.assertObjectIn(net.modules[0].modules[1],";
    "Fxn:self.assertObjectIn(net.modules[2],";
    "Fxn:self.assertObjectIn(net.modules[0],";
    "Fxn:self.assertEqual(containers.count(net.modules[0]),";
    "Fxn:self.assertObjectIn(net,";
    "Fxn:self.assertObjectIn(m,";
    "Fxn:test_apply";
    "Fxn:self._build_net()";
    "Fxn:callback";
    "Fxn:self.assertNotIn(module,";
    "Fxn:seen_modules.add(module)";
    "Fxn:net.apply(callback)";
    "Fxn:self.assertEqual(len(seen_modules),";
    "Fxn:test_listModules";
    "Fxn:self._build_net()";
    "Fxn:callback";
    "Fxn:module_list.append(module)";
    "Fxn:net.apply(callback)";
    "Fxn:self.assertEqual(module_list,";
    "Fxn:net.listModules())";
    "Fxn:test_replace";
    "Fxn:self._build_net()";
    "Fxn:self._build_net()";
    "Fxn:callback";
    "Fxn:nn.Tanh()";
    "Fxn:net.replace(callback)";
    "Fxn:ref_net.listModules()):";
    "Fxn:self.assertIsInstance(module,";
    "Fxn:self.assertIsInstance(module,";
    "Fxn:prepare_tests()";
    "Fxn:run_tests()";
    "/test/test_multiprocessing.py";
    "Import:contextlib";
    "Import:import";
    "Import:import";
    "Import:sys";
    "Import:time";
    "Import:unittest";
    "Import:platform";
    "Import:torch";
    "Import:torch.cuda";
    "Import:torch.multiprocessing";
    "Import:Variable";
    "Import:Parameter";
    "Import:TestCase,";
    "class:SubProcess(mp.Process):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:run";
    "Fxn:self.tensor.add_(3)";
    "Fxn:simple_fill";
    "Fxn:queue.get()";
    "Fxn:event.set()";
    "Fxn:simple_pool_fill";
    "Fxn:tensor.fill_(4)";
    "Fxn:tensor.add(1)";
    "Fxn:send_tensor";
    "Fxn:torch.ones(5,";
    "Fxn:5).type(tp)";
    "Fxn:queue.put(t)";
    "Fxn:queue.put(t)";
    "Fxn:event.wait()";
    "Fxn:call_backward";
    "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:x.sum().backward()";
    "Fxn:sum_tensors";
    "Fxn:torch.cuda.device(1):";
    "Fxn:inq.get()";
    "Fxn:outq.put((tensor.sum().item(),";
    "Fxn:tensor.get_device(),";
    "Fxn:tensor.numel(),";
    "Fxn:tensor.storage().size()))";
    "Fxn:queue_get_exception";
    "Fxn:os.close(2)";
    "Fxn:torch.zeros(5,";
    "Fxn:5).cuda()";
    "Fxn:outqueue.put(e)";
    "Fxn:outqueue.put('no";
    "Fxn:cuda_multiply_two";
    "Fxn:ready.set()";
    "Fxn:torch.cuda.stream(torch.cuda.Stream()):";
    "Fxn:queue.get()";
    "Fxn:cuda_event.wait()";
    "Fxn:tensor.mul_(2)";
    "Fxn:cuda_event.record()";
    "Fxn:done.set()";
    "Fxn:autograd_sharing";
    "Fxn:queue.get()";
    "Fxn:ready.set()";
    "Fxn:master_modified.wait()";
    "Fxn:torch.arange(1,";
    "Fxn:26).view(5,";
    "Fxn:var.data.equal(expected_var)";
    "Fxn:torch.ones(5,";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:queue.put(is_ok)";
    "Fxn:fs_sharing";
    "Fxn:mp.get_sharing_strategy()";
    "Fxn:mp.set_sharing_strategy('file_system')";
    "Fxn:mp.set_sharing_strategy(prev_strategy)";
    "class:leak_checker(object):";
    "Fxn:__init__";
    "Fxn:[os.getpid()]";
    "Fxn:__enter__";
    "Fxn:self._get_next_fds(10)";
    "Fxn:__exit__";
    "Fxn:self._get_next_fds(10)";
    "Fxn:self.test_case.assertLessEqual(";
    "Fxn:self.test_case.assertFalse(self.has_shm_files())";
    "Fxn:check_pid";
    "Fxn:self.checked_pids.append(pid)";
    "Fxn:_get_next_fds";
    "Fxn:[os.dup(0)";
    "Fxn:os.close(fd)";
    "Fxn:has_shm_files";
    "Fxn:self._has_shm_files()";
    "Fxn:mp.get_sharing_strategy()";
    "Fxn:time.sleep(0.5)";
    "Fxn:self._has_shm_files()";
    "Fxn:_has_shm_files";
    "Fxn:gc.collect()";
    "Fxn:os.listdir('/dev/shm'):";
    "Fxn:filename.startswith(name):";
    "class:TestMultiprocessing(TestCase):";
    "Fxn:_test_sharing";
    "Fxn:test_fill";
    "Fxn:torch.zeros(5,";
    "Fxn:5).type(type)";
    "Fxn:ctx.Queue()";
    "Fxn:ctx.Event()";
    "Fxn:q.put(data)";
    "Fxn:ctx.Process(target=simple_fill,";
    "Fxn:args=(q,";
    "Fxn:lc.check_pid(p.pid)";
    "Fxn:p.start()";
    "Fxn:e.wait(10)";
    "Fxn:self.assertTrue(e.is_set())";
    "Fxn:self.assertTrue(data[0].eq(4).all())";
    "Fxn:self.assertTrue(data[1].eq(4).all())";
    "Fxn:p.join(1)";
    "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_receive";
    "Fxn:ctx.Queue()";
    "Fxn:ctx.Event()";
    "Fxn:ctx.Process(target=send_tensor,";
    "Fxn:args=(q,";
    "Fxn:lc.check_pid(p.pid)";
    "Fxn:p.start()";
    "Fxn:q.get()";
    "Fxn:q.get()";
    "Fxn:self.assertTrue(t1.eq(1).all())";
    "Fxn:self.assertTrue(id(t1.storage())";
    "Fxn:e.set()";
    "Fxn:p.join(1)";
    "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:leak_checker(self)";
    "Fxn:test_fill()";
    "Fxn:test_receive()";
    "Fxn:_test_preserve_sharing";
    "Fxn:do_test";
    "Fxn:torch.randn(5,";
    "Fxn:[x.storage(),";
    "Fxn:x.storage()[1:4],";
    "Fxn:ctx.Queue()";
    "Fxn:q.put(data)";
    "Fxn:q.get(timeout=1)";
    "Fxn:self.assertEqual(new_data,";
    "Fxn:self.assertEqual(new_data[0]._cdata,";
    "Fxn:self.assertEqual(t.storage()._cdata,";
    "Fxn:new_data[0].fill_(10)";
    "Fxn:self.assertEqual(new_data[1],";
    "Fxn:leak_checker(self):";
    "Fxn:do_test()";
    "Fxn:_test_pool";
    "Fxn:do_test";
    "Fxn:ctx.Pool(2)";
    "Fxn:lc.check_pid(proc.pid)";
    "Fxn:[torch.zeros(2,";
    "Fxn:p.map(simple_pool_fill,";
    "Fxn:self.assertEqual(len(results),";
    "Fxn:self.assertEqual(r,";
    "Fxn:torch.ones(2,";
    "Fxn:self.assertEqual(b,";
    "Fxn:torch.ones(2,";
    "Fxn:p.close()";
    "Fxn:p.join()";
    "Fxn:leak_checker(self)";
    "Fxn:do_test()";
    "Fxn:@unittest.skipIf(platform";
    "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fd_sharing";
    "Fxn:self._test_sharing(repeat=TEST_REPEATS)";
    "Fxn:@unittest.skipIf(platform";
    "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fd_preserve_sharing";
    "Fxn:self._test_preserve_sharing(repeat=TEST_REPEATS)";
    "Fxn:@unittest.skipIf(platform";
    "Fxn:test_fd_pool";
    "Fxn:self._test_pool(repeat=TEST_REPEATS)";
    "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fs_sharing";
    "Fxn:fs_sharing():";
    "Fxn:self._test_sharing(repeat=TEST_REPEATS)";
    "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fs_preserve_sharing";
    "Fxn:fs_sharing():";
    "Fxn:self._test_preserve_sharing(repeat=TEST_REPEATS)";
    "Fxn:test_fs_pool";
    "Fxn:fs_sharing():";
    "Fxn:self._test_pool(repeat=TEST_REPEATS)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_fs";
    "Fxn:queue_put";
    "Fxn:torch.DoubleStorage(4)";
    "Fxn:mp.Queue()";
    "Fxn:self.assertFalse(lc.has_shm_files())";
    "Fxn:q.put(x)";
    "Fxn:time.sleep(0.05)";
    "Fxn:self.assertTrue(lc.has_shm_files(wait=False))";
    "Fxn:q.get()";
    "Fxn:fs_sharing(),";
    "Fxn:leak_checker(self)";
    "Fxn:queue_put()";
    "Fxn:test_inherit_tensor";
    "Fxn:torch.zeros(5,";
    "Fxn:SubProcess(t.share_memory_())";
    "Fxn:p.start()";
    "Fxn:p.join(1)";
    "Fxn:self.assertEqual(t,";
    "Fxn:torch.ones(5,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda";
    "Fxn:torch.cuda.FloatTensor([1])";
    "Fxn:self._test_sharing(mp.get_context('spawn'),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_small_tensors";
    "Fxn:mp.get_context('spawn')";
    "Fxn:[torch.arange(i";
    "Fxn:5).cuda(device)]";
    "Fxn:ctx.Queue()";
    "Fxn:ctx.Queue()";
    "Fxn:inq.put(tensors)";
    "Fxn:ctx.Process(target=sum_tensors,";
    "Fxn:args=(inq,";
    "Fxn:p.start()";
    "Fxn:results.append(outq.get())";
    "Fxn:p.join()";
    "Fxn:self.assertEqual(v,";
    "Fxn:torch.arange(i";
    "Fxn:5).sum())";
    "Fxn:self.assertEqual(device,";
    "Fxn:self.assertEqual(tensor_size,";
    "Fxn:self.assertEqual(storage_size,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_cuda_bad_call";
    "Fxn:torch.zeros(5,";
    "Fxn:5).cuda().cpu()";
    "Fxn:mp.Queue()";
    "Fxn:mp.Queue()";
    "Fxn:mp.Process(target=queue_get_exception,";
    "Fxn:args=(inq,";
    "Fxn:p.start()";
    "Fxn:inq.put(t)";
    "Fxn:p.join()";
    "Fxn:self.assertIsInstance(outq.get(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_event";
    "Fxn:mp.get_context('spawn')";
    "Fxn:ctx.Queue()";
    "Fxn:ctx.Event()";
    "Fxn:ctx.Event()";
    "Fxn:ctx.Process(target=cuda_multiply_two,";
    "Fxn:args=(queue,";
    "Fxn:p.start()";
    "Fxn:ready.wait()";
    "Fxn:torch.cuda.stream(torch.cuda.Stream()):";
    "Fxn:torch.cuda.FloatTensor([1,";
    "Fxn:torch.cuda.Event(interprocess=True)";
    "Fxn:torch.cuda._sleep(20000000)";
    "Fxn:tensor.add_(1)";
    "Fxn:event.record()";
    "Fxn:queue.put((event,";
    "Fxn:done.wait()";
    "Fxn:event.synchronize()";
    "Fxn:self.assertEqual(list(tensor),";
    "Fxn:p.join()";
    "Fxn:_test_autograd_sharing";
    "Fxn:mp.Event()";
    "Fxn:mp.Event()";
    "Fxn:mp.Queue()";
    "Fxn:mp.Process(target=autograd_sharing,";
    "Fxn:args=(queue,";
    "Fxn:p.start()";
    "Fxn:Variable(torch.zeros(5,";
    "Fxn:queue.put(var)";
    "Fxn:ready.wait()";
    "Fxn:torch.ones(5,";
    "Fxn:master_modified.set()";
    "Fxn:queue.get()";
    "Fxn:self.assertTrue(worker_ok)";
    "Fxn:self.assertEqual(var.data,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertEqual(var.grad.data,";
    "Fxn:torch.ones(5,";
    "Fxn:p.join(1)";
    "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_variable_sharing";
    "Fxn:Variable(torch.arange(1,";
    "Fxn:26).view(5,";
    "Fxn:self._test_autograd_sharing(var)";
    "Fxn:test_parameter_sharing";
    "Fxn:Parameter(torch.arange(1,";
    "Fxn:26).view(5,";
    "Fxn:self._test_autograd_sharing(param)";
    "Fxn:test_empty_shared";
    "Fxn:torch.Tensor()";
    "Fxn:t.share_memory_()";
    "Fxn:_test_is_shared";
    "Fxn:torch.randn(5,";
    "Fxn:self.assertFalse(t.is_shared())";
    "Fxn:t.share_memory_()";
    "Fxn:self.assertTrue(t.is_shared())";
    "Fxn:@unittest.skipIf(platform";
    "Fxn:test_is_shared";
    "Fxn:self._test_is_shared()";
    "Fxn:test_fs_is_shared";
    "Fxn:fs_sharing():";
    "Fxn:self._test_is_shared()";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_is_shared_cuda";
    "Fxn:torch.randn(5,";
    "Fxn:5).cuda()";
    "Fxn:self.assertTrue(t.is_shared())";
    "Fxn:test_backwards_fork";
    "Fxn:r"backwards()";
    "Fxn:call_backward()";
    "Fxn:mp.Process(target=call_backward)";
    "Fxn:p.start()";
    "Fxn:p.join(1)";
    "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:run_tests()";
    "/test/test_nccl.py";
    "Import:unittest";
    "Import:torch";
    "Import:torch.cuda.nccl";
    "Import:torch.cuda";
    "Import:TestCase,";
    "class:TestNCCL(TestCase):";
    "Fxn:test_unique_id";
    "Fxn:nccl.unique_id()";
    "Fxn:self.assertIsInstance(uid,";
    "Fxn:self.assertGreater(len(uid),";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_broadcast";
    "Fxn:torch.FloatTensor(128).uniform_()";
    "Fxn:[expected.cuda()]";
    "Fxn:torch.cuda.device_count()):";
    "Fxn:torch.cuda.device(device):";
    "Fxn:tensors.append(torch.cuda.FloatTensor(128))";
    "Fxn:nccl.broadcast(tensors)";
    "Fxn:self.assertEqual(tensors[i],";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_reduce";
    "Fxn:[torch.FloatTensor(128).uniform_()";
    "Fxn:torch.FloatTensor(128).zero_()";
    "Fxn:expected.add_(t)";
    "Fxn:[tensors[i].cuda(i)";
    "Fxn:nccl.reduce(tensors)";
    "Fxn:self.assertEqual(tensors[0],";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_all_reduce";
    "Fxn:[torch.FloatTensor(128).uniform_()";
    "Fxn:torch.FloatTensor(128).zero_()";
    "Fxn:expected.add_(t)";
    "Fxn:[tensors[i].cuda(i)";
    "Fxn:nccl.all_reduce(tensors)";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_all_gather";
    "Fxn:[torch.FloatTensor(128).uniform_()";
    "Fxn:torch.cat(inputs,";
    "Fxn:[inputs[i].cuda(i)";
    "Fxn:[torch.cuda.FloatTensor(128";
    "Fxn:nccl.all_gather(inputs,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_reduce_scatter";
    "Fxn:[torch.FloatTensor(in_size).uniform_()";
    "Fxn:torch.FloatTensor(in_size).zero_()";
    "Fxn:expected.add_(t)";
    "Fxn:expected.view(nGPUs,";
    "Fxn:[inputs[i].cuda(i)";
    "Fxn:[torch.cuda.FloatTensor(out_size,";
    "Fxn:nccl.reduce_scatter(inputs,";
    "Fxn:self.assertEqual(outputs[i],";
    "Fxn:run_tests()";
    "/test/test_nn.py";
    "Import:math";
    "Import:random";
    "Import:string";
    "Import:unittest";
    "Import:itertools";
    "Import:contextlib";
    "Import:warnings";
    "Import:pickle";
    "Import:deepcopy";
    "Import:repeat,";
    "Import:wraps,";
    "Import:mul";
    "Import:OrderedDict";
    "Import:torch";
    "Import:torch.backends.cudnn";
    "Import:torch.nn";
    "Import:torch.nn.functional";
    "Import:torch.nn.parallel";
    "Import:torch.nn.init";
    "Import:torch.nn.utils.rnn";
    "Import:torch.legacy.nn";
    "Import:clip_grad_norm";
    "Import:parameters_to_vector,";
    "Import:Variable,";
    "Import:gradgradcheck";
    "Import:Parameter";
    "Import:Broadcast";
    "Import:NNTestCase,";
    "Import:freeze_rng_state,";
    "Import:stats";
    "class:PackedSequenceTest(TestCase):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:_ordered_sequence";
    "Fxn:[tensor_type(random.randint(1,";
    "Fxn:[Variable(s.random_())";
    "Fxn:_padded_sequence";
    "Fxn:self._ordered_sequence(tensor_type)";
    "Fxn:rnn_utils.pad_sequence(ordered)";
    "Fxn:test_type_casts";
    "Fxn:self._type_by_name.items():";
    "Fxn:self._type_by_name.items():";
    "Fxn:self._padded_sequence(input_type)";
    "Fxn:rnn_utils.pack_padded_sequence(padded,";
    "Fxn:cast_str)()";
    "Fxn:rnn_utils.pad_packed_sequence(masked)";
    "Fxn:self.assertEqual(unpacked.type(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_mask";
    "Fxn:self._padded_sequence(tensor_type)";
    "Fxn:rnn_utils.pack_padded_sequence(padded,";
    "Fxn:self.assertFalse(packed.is_cuda)";
    "Fxn:packed.cuda()";
    "Fxn:self.assertTrue(packed.is_cuda)";
    "Fxn:rnn_utils.pad_packed_sequence(packed)";
    "Fxn:self.assertEqual(unpacked.type(),";
    "Fxn:default_tensor_type";
    "Fxn:torch.typename(type)";
    "Fxn:decorator";
    "Fxn:@wraps(fn)";
    "Fxn:wrapper";
    "Fxn:torch.Tensor().type()";
    "Fxn:torch.set_default_tensor_type(type_str)";
    "Fxn:fn(*args,";
    "Fxn:torch.set_default_tensor_type(old_type)";
    "Fxn:_assertGradAndGradgradChecks";
    "Fxn:test_case.assertTrue(gradcheck(apply_fn,";
    "Fxn:test_case.assertTrue(gradgradcheck(apply_fn,";
    "class:InputVariableMixin(object):";
    "Fxn:_get_input";
    "Fxn:TestBase._get_input(self,";
    "Fxn:map_variables";
    "Fxn:i.is_floating_point():";
    "Fxn:map_variables(input)";
    "class:NewModuleTest(InputVariableMixin,";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:kwargs.get('cudnn',";
    "Fxn:kwargs.get('check_inplace',";
    "Fxn:kwargs.get('check_gradgrad',";
    "Fxn:_do_test";
    "Fxn:test_case.check_jacobian(module,";
    "Fxn:module.parameters())";
    "Fxn:_assertGradAndGradgradChecks(test_case,";
    "Fxn:test_case._forward(module,";
    "Fxn:module.__repr__()";
    "Fxn:self.constructor(*self.constructor_args,";
    "Fxn:freeze_rng_state():";
    "Fxn:module(input)";
    "Fxn:test_case.assertEqual(input._version,";
    "Fxn:deepcopy(input)";
    "Fxn:input_ip.clone()";
    "Fxn:freeze_rng_state():";
    "Fxn:module_ip(input_ip_clone)";
    "Fxn:test_case.assertNotEqual(input_ip_clone._version,";
    "Fxn:test_case.assertEqual(output,";
    "Fxn:output.data.clone().normal_()";
    "Fxn:input.grad.data.zero_()";
    "Fxn:output.backward(grad)";
    "Fxn:output_ip.backward(grad)";
    "Fxn:test_case.assertEqual(input.grad,";
    "Fxn:cuda()";
    "Fxn:input.cuda()";
    "Fxn:module.float().cuda()";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:torch.cuda.device_count()";
    "Fxn:input.cuda(1)";
    "Fxn:module.cuda(1)";
    "Fxn:torch.cuda.device(1):";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:input.float()";
    "Fxn:module.float()";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:input.double()";
    "Fxn:module.double()";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:cuda()";
    "Fxn:input.float().cuda()";
    "Fxn:module.float().cuda()";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:input.cpu()";
    "Fxn:module.cpu()";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:input.cuda()";
    "Fxn:module.cuda()";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:torch.cuda.device_count()";
    "Fxn:input.cuda(1)";
    "Fxn:module.cuda(1)";
    "Fxn:torch.cuda.device(1):";
    "Fxn:module(input)";
    "Fxn:module.parameters():";
    "Fxn:test_case.assertIsInstance(p,";
    "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:_get_target";
    "Fxn:self._get_arg('target',";
    "Fxn:constructor_args";
    "Fxn:self._get_arg('constructor_args',";
    "class:NewCriterionTest(InputVariableMixin,";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:kwargs.get('check_gradgrad',";
    "Fxn:_do_extra_tests";
    "Fxn:test_case.assertFalse(target.requires_grad)";
    "Fxn:module.parameters())";
    "Fxn:apply_fn";
    "Fxn:module(input,";
    "Fxn:apply_fn";
    "Fxn:module(input1,";
    "Fxn:gradcheck(apply_fn,";
    "Fxn:gradgradcheck(apply_fn,";
    "Fxn:_get_target";
    "Fxn:self._get_arg('target',";
    "Fxn:constructor_args";
    "Fxn:self._get_arg('constructor_args',";
    "class:TestNN(NNTestCase):";
    "Fxn:_forward";
    "Fxn:freeze_rng_state():";
    "Fxn:module(input)";
    "Fxn:_backward";
    "Fxn:output.backward(grad_output,";
    "Fxn:_forward_criterion";
    "Fxn:criterion(*args)";
    "Fxn:criterion(input,";
    "Fxn:output.item()";
    "Fxn:_backward_criterion";
    "Fxn:i.grad.data.zero_()";
    "Fxn:criterion(*args).backward()";
    "Fxn:_zero_grad_parameters";
    "Fxn:module.weight.grad.data.zero_()";
    "Fxn:module.weight.grad.detach_()";
    "Fxn:module.bias.grad.data.zero_()";
    "Fxn:module.bias.grad.detach_()";
    "Fxn:_get_parameters";
    "Fxn:module.parameters():";
    "Fxn:torch.zeros_like(p)";
    "Fxn:params.append(p)";
    "Fxn:d_params.append(p.grad)";
    "Fxn:test_module_backcompat";
    "Fxn:download_file('https://download.pytorch.org/test_data/linear.pt')";
    "Fxn:warnings.catch_warnings():";
    "Fxn:warnings.simplefilter('ignore',";
    "Fxn:torch.load(path)";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:3).float())";
    "Fxn:self.assertEqual(m(input).size(),";
    "Fxn:test_hooks";
    "Fxn:nn.Sigmoid()";
    "Fxn:Variable(torch.ones(5,";
    "Fxn:fw_hook";
    "Fxn:self.assertIsInstance(input,";
    "Fxn:self.assertIsInstance(output,";
    "Fxn:self.assertTrue(h_module";
    "Fxn:self.assertEqual(input[0].data,";
    "Fxn:torch.ones(5,";
    "Fxn:self.assertEqual(output.data,";
    "Fxn:torch.Tensor(5,";
    "Fxn:5).fill_(1";
    "Fxn:bw_hook";
    "Fxn:self.assertIsInstance(grad_input,";
    "Fxn:self.assertIsInstance(grad_output,";
    "Fxn:self.assertTrue(h_module";
    "Fxn:self.assertEqual(grad_output[0].data,";
    "Fxn:torch.ones(5,";
    "Fxn:module.register_forward_hook(lambda";
    "Fxn:fw_hook(1,";
    "Fxn:module(input)";
    "Fxn:module(input)";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:module.register_backward_hook(";
    "Fxn:bw_hook(1,";
    "Fxn:module(input)";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:output.backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:output.backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:module.register_forward_hook(lambda";
    "Fxn:fw_hook(2,";
    "Fxn:module(input)";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:module.register_backward_hook(lambda";
    "Fxn:bw_hook(2,";
    "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:test2_bwd.remove()";
    "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:test2_fwd.remove()";
    "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:test_fwd.remove()";
    "Fxn:test_bwd.remove()";
    "Fxn:test_hook_cpp";
    "Fxn:nn.BatchNorm1d(5)";
    "Fxn:hook";
    "Fxn:self.assertEqual(len(grad_inputs),";
    "Fxn:self.assertEqual(len(grad_outputs),";
    "Fxn:self.assertEqual(module,";
    "Fxn:bn.register_backward_hook(hook)";
    "Fxn:bn(Variable(torch.randn(5,";
    "Fxn:output.sum().backward()";
    "Fxn:test_hook_fail";
    "Fxn:nn.Sigmoid()";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:fw_fail1";
    "Fxn:fw_fail2";
    "Fxn:bw_fail1";
    "Fxn:bw_fail2";
    "Fxn:module.register_forward_hook(fw_fail1):";
    "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:module(input)";
    "Fxn:self.assertIn("fw_fail",";
    "Fxn:self.assertIn("didn't";
    "Fxn:module.register_forward_hook(fw_fail2):";
    "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:module(input)";
    "Fxn:self.assertIn("fw_fail2",";
    "Fxn:self.assertIn("didn't";
    "Fxn:module.register_backward_hook(bw_fail1):";
    "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:module(input).sum().backward()";
    "Fxn:self.assertIn("bw_fail",";
    "Fxn:self.assertIn("got";
    "Fxn:module.register_backward_hook(bw_fail2):";
    "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:module(input).sum().backward()";
    "Fxn:self.assertIn("bw_fail2",";
    "Fxn:self.assertIn("got";
    "Fxn:test_hook_writeable";
    "Fxn:nn.Linear(5,";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:bw_hook";
    "Fxn:self.assertIsInstance(grad,";
    "Fxn:self.assertIsInstance(grad,";
    "Fxn:module.register_backward_hook(bw_hook)";
    "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:torch.ones(5,";
    "Fxn:5).mm(module.weight.data)";
    "Fxn:self.assertEqual(input.grad.data,";
    "Fxn:test_zero_grad";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:nn.Linear(5,";
    "Fxn:module.parameters():";
    "Fxn:module.zero_grad()";
    "Fxn:module.zero_grad()";
    "Fxn:self.assertIsNone(module.weight.grad)";
    "Fxn:module(i).sum().backward()";
    "Fxn:self.assertIsNotNone(module.weight.grad)";
    "Fxn:self.assertGreater(module.weight.grad.data.abs().sum(),";
    "Fxn:module.zero_grad()";
    "Fxn:self.assertEqual(module.weight.grad.data,";
    "Fxn:module.weight.data.clone().zero_())";
    "Fxn:module.zero_grad()";
    "Fxn:self.assertIsNotNone(module.weight.grad)";
    "Fxn:self.assertIsNone(module.bias.grad)";
    "Fxn:module(i).sum().backward()";
    "Fxn:self.assertIsNotNone(module.weight.grad)";
    "Fxn:self.assertIsNotNone(module.bias.grad)";
    "Fxn:self.assertGreater(module.weight.grad.data.abs().sum(),";
    "Fxn:self.assertGreater(module.bias.grad.data.abs().sum(),";
    "Fxn:module.zero_grad()";
    "Fxn:self.assertEqual(module.weight.grad.data,";
    "Fxn:module.weight.data.clone().zero_())";
    "Fxn:self.assertEqual(module.bias.grad.data,";
    "Fxn:module.bias.data.clone().zero_())";
    "Fxn:test_no_grad";
    "Fxn:nn.Conv2d(2,";
    "Fxn:torch.randn(1,";
    "Fxn:Variable(input)";
    "Fxn:Variable(input.clone())";
    "Fxn:module(x)";
    "Fxn:self.assertTrue(output.requires_grad)";
    "Fxn:output.backward(torch.ones(1,";
    "Fxn:torch.no_grad():";
    "Fxn:module(y)";
    "Fxn:self.assertFalse(output2.requires_grad)";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:output2.backward(torch.ones(1,";
    "Fxn:_test_dropout";
    "Fxn:input.fill_(1";
    "Fxn:cls(p)";
    "Fxn:Variable(input,";
    "Fxn:module(input_var)";
    "Fxn:self.assertLess(abs(output.data.mean()";
    "Fxn:output.backward(input)";
    "Fxn:self.assertLess(abs(input_var.grad.data.mean()";
    "Fxn:cls(p,";
    "Fxn:Variable(input.clone(),";
    "Fxn:module(input_var";
    "Fxn:self.assertLess(abs(output.data.mean()";
    "Fxn:output.backward(input)";
    "Fxn:self.assertLess(abs(input_var.grad.data.mean()";
    "Fxn:module.__repr__()";
    "Fxn:test_parameters";
    "Fxn:num_params";
    "Import:SourceChangeWarning";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(3,";
    "Fxn:nn.Linear(10,";
    "Fxn:Net()";
    "Fxn:nn.Sequential(n,";
    "Fxn:self.assertEqual(num_params(l),";
    "Fxn:self.assertEqual(num_params(n),";
    "Fxn:self.assertEqual(num_params(s),";
    "Fxn:test_named_parameters";
    "Fxn:num_params";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(3,";
    "Fxn:nn.Linear(10,";
    "Fxn:Net()";
    "Fxn:nn.Sequential(n,";
    "Fxn:self.assertTrue(name";
    "Fxn:self.assertTrue(name";
    "Fxn:self.assertTrue(name";
    "Fxn:self.assertEqual(num_params(l),";
    "Fxn:self.assertEqual(num_params(n),";
    "Fxn:self.assertEqual(num_params(s),";
    "Fxn:test_call_supports_python_dict_output";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Linear(10,";
    "Fxn:self.register_backward_hook(self.hook)";
    "Fxn:hook";
    "Fxn:forward";
    "Fxn:self.l1(inputs).sum()}";
    "Fxn:Net()";
    "Fxn:net(Variable(torch.randn([5,";
    "Fxn:model_output["output"].backward()";
    "Fxn:self.assertTrue(net.check_backward_hook_flag)";
    "Fxn:test_children";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Sequential(l3,";
    "Fxn:nn.Sequential(l1,";
    "Fxn:self.assertEqual(list(s.children()),";
    "Fxn:test_dir";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:Parameter(torch.Tensor(2,";
    "Fxn:linear.register_buffer('_test_buffer',";
    "Fxn:torch.Tensor(2,";
    "Fxn:self.assertIn('_test_submodule',";
    "Fxn:self.assertIn('_test_parameter',";
    "Fxn:self.assertIn('_test_buffer',";
    "Fxn:self.assertTrue(hasattr(linear,";
    "Fxn:test_dir_digit";
    "Fxn:nn.Sequential(nn.Linear(2,";
    "Fxn:self.assertNotIn('0',";
    "Fxn:test_named_children";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Sequential(l3,";
    "Fxn:nn.Sequential()";
    "Fxn:s.add_module('layer1',";
    "Fxn:s.add_module('layer2',";
    "Fxn:s.add_module('layer3',";
    "Fxn:s.add_module('layer4',";
    "Fxn:s.add_module('subnet',";
    "Fxn:self.assertEqual(list(s.named_children()),";
    "Fxn:[('layer1',";
    "Fxn:test_modules";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Variable(torch.Tensor(3,";
    "Fxn:nn.Linear(10,";
    "Fxn:Net()";
    "Fxn:nn.Sequential(n,";
    "Fxn:self.assertEqual(list(s.modules()),";
    "Fxn:test_named_modules";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Variable(torch.Tensor(3,";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Sequential()";
    "Fxn:block.add_module('linear1',";
    "Fxn:block.add_module('linear2',";
    "Fxn:Net()";
    "Fxn:nn.Sequential(n,";
    "Fxn:self.assertEqual(list(s.named_modules()),";
    "Fxn:[('',";
    "Fxn:test_register_buffer_raises_error_if_attr_exists";
    "Fxn:nn.Module()";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.register_buffer('attribute_name',";
    "Fxn:torch.rand(5))";
    "Fxn:m.register_parameter('attribute_name',";
    "Fxn:nn.Parameter())";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.register_buffer('attribute_name',";
    "Fxn:torch.rand(5))";
    "Fxn:m.add_module('attribute_name',";
    "Fxn:nn.Module())";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.register_buffer('attribute_name',";
    "Fxn:torch.rand(5))";
    "Fxn:test_register_buffer_raises_error_if_not_tensor";
    "Fxn:nn.Module()";
    "Fxn:self.assertRaises(TypeError):";
    "Fxn:m.register_buffer('attribute_name',";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name";
    "Fxn:nn.Module()";
    "Fxn:torch.rand(5)";
    "Fxn:m.register_buffer('buffer_name',";
    "Fxn:self.assertEqual(m.buffer_name,";
    "Fxn:m.register_buffer('buffer_name',";
    "Fxn:self.assertEqual(m.buffer_name,";
    "Fxn:m.register_buffer('buffer_name',";
    "Fxn:self.assertEqual(m.buffer_name,";
    "Fxn:test_register_parameter_raises_error_if_attr_exists";
    "Fxn:nn.Module()";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.register_parameter('attribute_name',";
    "Fxn:nn.Parameter())";
    "Fxn:m.register_buffer('attribute_name',";
    "Fxn:torch.rand(5))";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.register_parameter('attribute_name',";
    "Fxn:nn.Parameter())";
    "Fxn:m.add_module('attribute_name',";
    "Fxn:nn.Module())";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.register_parameter('attribute_name',";
    "Fxn:nn.Parameter())";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name";
    "Fxn:nn.Module()";
    "Fxn:nn.Parameter(torch.rand(5))";
    "Fxn:nn.Parameter(param1.data";
    "Fxn:m.register_parameter('param_name',";
    "Fxn:self.assertEqual(m.param_name,";
    "Fxn:m.register_parameter('param_name',";
    "Fxn:self.assertEqual(m.param_name,";
    "Fxn:m.register_parameter('param_name',";
    "Fxn:self.assertEqual(m.param_name,";
    "Fxn:test_add_module_raises_error_if_attr_exists";
    "Fxn:nn.Module()";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.add_module('attribute_name',";
    "Fxn:nn.Module())";
    "Fxn:m.register_buffer('attribute_name',";
    "Fxn:torch.rand(5))";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.add_module('attribute_name',";
    "Fxn:nn.Module())";
    "Fxn:m.register_parameter('attribute_name',";
    "Fxn:nn.Parameter())";
    "Fxn:self.assertRaises(KeyError):";
    "Fxn:m.add_module('attribute_name',";
    "Fxn:nn.Module())";
    "Fxn:test_Sequential_getitem";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(20,";
    "Fxn:nn.Linear(30,";
    "Fxn:nn.Linear(40,";
    "Fxn:nn.Sequential(l1,";
    "Fxn:self.assertIs(n[0],";
    "Fxn:self.assertIs(n[1],";
    "Fxn:self.assertIs(n[2],";
    "Fxn:self.assertIs(n[3],";
    "Fxn:self.assertIs(n[torch.tensor(3,";
    "Fxn:self.assertEqual(n[1:],";
    "Fxn:nn.Sequential(l2,";
    "Fxn:self.assertEqual(n[3:],";
    "Fxn:nn.Sequential(l4))";
    "Fxn:self.assertEqual(n[:-1],";
    "Fxn:nn.Sequential(l1,";
    "Fxn:self.assertEqual(n[:-3],";
    "Fxn:nn.Sequential(l1))";
    "Fxn:self.assertEqual(n[::-1],";
    "Fxn:nn.Sequential(l4,";
    "Fxn:test_Sequential_setitem";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(20,";
    "Fxn:nn.Linear(30,";
    "Fxn:nn.Linear(40,";
    "Fxn:nn.Sequential(l1,";
    "Fxn:n[torch.tensor(1,";
    "Fxn:self.assertIs(n[0],";
    "Fxn:self.assertIs(n[1],";
    "Fxn:self.assertIs(n[2],";
    "Fxn:test_Sequential_setitem_named";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(20,";
    "Fxn:nn.Linear(30,";
    "Fxn:nn.Linear(40,";
    "Fxn:nn.Sequential(OrderedDict([";
    "Fxn:self.assertEqual(n.linear1,";
    "Fxn:self.assertEqual(n.linear3,";
    "Fxn:test_Sequential_delitem";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(20,";
    "Fxn:nn.Linear(30,";
    "Fxn:nn.Linear(40,";
    "Fxn:nn.Sequential(l1,";
    "Fxn:self.assertEqual(n,";
    "Fxn:nn.Sequential(l1,";
    "Fxn:self.assertEqual(n,";
    "Fxn:nn.Sequential(l1,";
    "Fxn:test_ModuleList";
    "Fxn:[nn.ReLU(),";
    "Fxn:nn.Linear(5,";
    "Fxn:nn.ModuleList(modules)";
    "Fxn:check";
    "Fxn:self.assertEqual(len(module_list),";
    "Fxn:self.assertIs(m1,";
    "Fxn:module_list.children()):";
    "Fxn:self.assertIs(m1,";
    "Fxn:self.assertIs(module_list[i],";
    "Fxn:check()";
    "Fxn:[nn.Conv2d(3,";
    "Fxn:check()";
    "Fxn:modules.append(nn.Tanh())";
    "Fxn:module_list.append(modules[-1])";
    "Fxn:check()";
    "Fxn:[nn.Linear(5,";
    "Fxn:nn.Sigmoid()]";
    "Fxn:modules.extend(next_modules)";
    "Fxn:module_list.extend(next_modules)";
    "Fxn:check()";
    "Fxn:nn.Conv2d(5,";
    "Fxn:check()";
    "Fxn:torch.tensor(2,";
    "Fxn:nn.Conv2d(5,";
    "Fxn:self.assertIs(module_list[idx],";
    "Fxn:check()";
    "Fxn:self.assertEqual(module_list[1:],";
    "Fxn:nn.ModuleList(modules[1:]))";
    "Fxn:self.assertEqual(module_list[3:],";
    "Fxn:nn.ModuleList(modules[3:]))";
    "Fxn:self.assertEqual(module_list[:-1],";
    "Fxn:nn.ModuleList(modules[:-1]))";
    "Fxn:self.assertEqual(module_list[:-3],";
    "Fxn:nn.ModuleList(modules[:-3]))";
    "Fxn:self.assertEqual(module_list[::-1],";
    "Fxn:nn.ModuleList(modules[::-1]))";
    "Fxn:self.assertEqual(module_list,";
    "Fxn:nn.ModuleList(modules[:-1]))";
    "Fxn:self.assertEqual(module_list,";
    "Fxn:nn.ModuleList(modules[:-1][0::2]))";
    "Fxn:self.assertRaises(TypeError):";
    "Fxn:nn.ReLU()";
    "Fxn:self.assertRaises(TypeError):";
    "Fxn:module_list.extend(nn.ReLU())";
    "Fxn:nn.Linear(1,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(3,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Sequential(l3,";
    "Fxn:nn.Sequential(";
    "Fxn:OrderedDict([";
    "Fxn:nn.ModuleList()";
    "Fxn:module_list.extend(s.modules())";
    "Fxn:check()";
    "Fxn:test_ParameterList";
    "Fxn:make_param";
    "Fxn:Parameter(torch.randn(10,";
    "Fxn:[make_param(),";
    "Fxn:make_param()]";
    "Fxn:nn.ParameterList(parameters)";
    "Fxn:check";
    "Fxn:self.assertEqual(len(parameters),";
    "Fxn:self.assertIs(p1,";
    "Fxn:param_list.parameters()):";
    "Fxn:self.assertIs(p1,";
    "Fxn:self.assertIs(parameters[i],";
    "Fxn:check()";
    "Fxn:[make_param()]";
    "Fxn:check()";
    "Fxn:parameters.append(make_param())";
    "Fxn:param_list.append(parameters[-1])";
    "Fxn:check()";
    "Fxn:[make_param(),";
    "Fxn:make_param()]";
    "Fxn:parameters.extend(next_params)";
    "Fxn:param_list.extend(next_params)";
    "Fxn:check()";
    "Fxn:make_param()";
    "Fxn:check()";
    "Fxn:torch.tensor(2,";
    "Fxn:make_param()";
    "Fxn:self.assertIs(param_list[idx],";
    "Fxn:check()";
    "Fxn:self.assertEqual(param_list[1:],";
    "Fxn:nn.ParameterList(parameters[1:]))";
    "Fxn:self.assertEqual(param_list[3:],";
    "Fxn:nn.ParameterList(parameters[3:]))";
    "Fxn:self.assertEqual(param_list[:-1],";
    "Fxn:nn.ParameterList(parameters[:-1]))";
    "Fxn:self.assertEqual(param_list[:-3],";
    "Fxn:nn.ParameterList(parameters[:-3]))";
    "Fxn:self.assertEqual(param_list[::-1],";
    "Fxn:nn.ParameterList(parameters[::-1]))";
    "Fxn:self.assertRaises(TypeError):";
    "Fxn:make_param()";
    "Fxn:self.assertRaises(TypeError):";
    "Fxn:param_list.extend(make_param())";
    "Fxn:nn.Linear(1,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Linear(3,";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Sequential(l3,";
    "Fxn:nn.Sequential(";
    "Fxn:OrderedDict([";
    "Fxn:nn.ParameterList()";
    "Fxn:param_list.extend(s.parameters())";
    "Fxn:check()";
    "Fxn:test_add_module";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Module()";
    "Fxn:net.add_module('empty',";
    "Fxn:self.assertEqual(net.l,";
    "Fxn:self.assertEqual(net.l2,";
    "Fxn:self.assertEqual(net.empty,";
    "Fxn:net.add_module('l3',";
    "Fxn:self.assertEqual(net.l3,";
    "Fxn:nn.Linear(20,";
    "Fxn:net.add_module('l',";
    "Fxn:self.assertEqual(net.l,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:net.add_module('x',";
    "Fxn:test_type";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Module()";
    "Fxn:net.add_module('empty',";
    "Fxn:net.register_buffer('indices',";
    "Fxn:torch.LongTensor(1))";
    "Fxn:net.float()";
    "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:self.assertIsInstance(net.indices,";
    "Fxn:net.double()";
    "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:self.assertIsInstance(net.indices,";
    "Fxn:net.float().cuda()";
    "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:self.assertIsInstance(net.indices,";
    "Fxn:net.type(torch.FloatTensor)";
    "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:net.type(torch.DoubleTensor)";
    "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:net.type(torch.cuda.FloatTensor)";
    "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:test_non_leaf_parameters";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Linear(10,";
    "Fxn:assign_weight";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:Parameter(torch.randn(10,";
    "Fxn:test_clip_grad_norm";
    "Fxn:nn.Linear(10,";
    "Fxn:compute_norm";
    "Fxn:l.parameters():";
    "Fxn:p.grad.data.abs().pow(norm_type).sum()";
    "Fxn:l.parameters())";
    "Fxn:compare_scaling";
    "Fxn:[p.grad.data.div(g).view(-1)";
    "Fxn:torch.cat(p_scale)";
    "Fxn:self.assertEqual(scale.std(),";
    "Fxn:torch.arange(1,";
    "Fxn:101).view(10,";
    "Fxn:torch.ones(10).div(1000)";
    "Fxn:Variable(g.clone().view_as(p.data))";
    "Fxn:compute_norm(norm_type)";
    "Fxn:clip_grad_norm(l.parameters(),";
    "Fxn:compute_norm(norm_type)";
    "Fxn:self.assertEqual(norm,";
    "Fxn:self.assertEqual(norm_after,";
    "Fxn:self.assertLessEqual(norm_after,";
    "Fxn:compare_scaling(grads)";
    "Fxn:torch.rand(10,";
    "Fxn:10).div(10000),";
    "Fxn:torch.ones(10).div(500)";
    "Fxn:p.grad.data.copy_(g)";
    "Fxn:compute_norm(norm_type)";
    "Fxn:clip_grad_norm(l.parameters(),";
    "Fxn:compute_norm(norm_type)";
    "Fxn:self.assertEqual(norm,";
    "Fxn:self.assertEqual(norm_before,";
    "Fxn:self.assertLessEqual(norm_after,";
    "Fxn:compare_scaling(grads)";
    "Fxn:self.assertEqual(scale,";
    "Fxn:test_parameters_to_vector";
    "Fxn:nn.Conv2d(3,";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Sequential(conv1,";
    "Fxn:parameters_to_vector(model.parameters())";
    "Fxn:self.assertEqual(vec.size(0),";
    "Fxn:test_vector_to_parameters";
    "Fxn:nn.Conv2d(3,";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.Sequential(conv1,";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:vector_to_parameters(vec,";
    "Fxn:model.parameters())";
    "Fxn:self.assertTrue(torch.equal(sample.data,";
    "Fxn:test_weight_norm";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:nn.Linear(5,";
    "Fxn:torch.nn.utils.weight_norm(m)";
    "Fxn:self.assertEqual(m.weight_v.size(),";
    "Fxn:m.weight.size())";
    "Fxn:self.assertEqual(m.weight_g.size(),";
    "Fxn:self.assertEqual(m(input),";
    "Fxn:torch.nn.utils.remove_weight_norm(m)";
    "Fxn:self.assertFalse(hasattr(m,";
    "Fxn:self.assertFalse(hasattr(m,";
    "Fxn:self.assertEqual(m(input),";
    "Fxn:torch.nn.utils.weight_norm(m,";
    "Fxn:self.assertEqual(m.weight_v.size(),";
    "Fxn:m.weight.size())";
    "Fxn:self.assertEqual(m.weight_g.size(),";
    "Fxn:self.assertEqual(m(input),";
    "Fxn:test_weight_norm_pickle";
    "Fxn:torch.nn.utils.weight_norm(nn.Linear(5,";
    "Fxn:pickle.loads(pickle.dumps(m))";
    "Fxn:self.assertIsInstance(m,";
    "Fxn:test_embedding_sparse_basic";
    "Fxn:nn.Embedding(10,";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:embedding(input).sum().backward()";
    "Fxn:self.assertTrue(embedding.weight.grad.is_sparse)";
    "Fxn:self.assertEqual(embedding.weight.grad.shape,";
    "Fxn:test_embedding_padding_idx";
    "Fxn:nn.Embedding(10,";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:embedding(input)";
    "Fxn:self.assertEqual(output[0][0].sum(),";
    "Fxn:self.assertEqual(output[1][2].sum(),";
    "Fxn:nn.Embedding(10,";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:embedding(input)";
    "Fxn:self.assertEqual(output[0][0].sum(),";
    "Fxn:self.assertEqual(output[1][2].sum(),";
    "Fxn:nn.Embedding(10,";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:embedding(input)";
    "Fxn:self.assertEqual(output[0][2].sum(),";
    "Fxn:self.assertEqual(output[1][1].sum(),";
    "Fxn:nn.Embedding(10,";
    "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:embedding(input)";
    "Fxn:self.assertEqual(output[0][2].sum(),";
    "Fxn:self.assertEqual(output[1][1].sum(),";
    "Fxn:self.assertRaises(AssertionError,";
    "Fxn:self.assertRaises(AssertionError,";
    "Fxn:test_embedding_max_norm";
    "Fxn:nn.Embedding(22,";
    "Fxn:Variable(torch.LongTensor([2,";
    "Fxn:embedding(input)";
    "Fxn:self.assertEqual(output[1],";
    "Fxn:self.assertTrue(output.data.norm(p=2,";
    "Fxn:dim=1).le(1).all())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_embedding_max_norm_cuda";
    "Fxn:nn.Embedding(22,";
    "Fxn:max_norm=1.0).cuda()";
    "Fxn:Variable(torch.LongTensor([2,";
    "Fxn:6])).cuda()";
    "Fxn:embedding(input)";
    "Fxn:self.assertEqual(output[1],";
    "Fxn:self.assertTrue(output.data.norm(p=2,";
    "Fxn:dim=1).le(1).all())";
    "Fxn:test_embedding_from_pretrained";
    "Fxn:torch.Tensor([[1,";
    "Fxn:nn.Embedding.from_pretrained(a)";
    "Fxn:self.assertEqual(a,";
    "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:embedding(input)";
    "Fxn:self.assertEqual(a,";
    "Fxn:test_embedding_functional";
    "Fxn:Variable(torch.LongTensor([";
    "Fxn:Variable(torch.rand(4,";
    "Fxn:torch.nn.Embedding(4,";
    "Fxn:embed_old(a)";
    "Fxn:F.embedding(a,";
    "Fxn:self.assertEqual(res_old,";
    "Fxn:_test_gumbel_softmax_st";
    "Fxn:torch.FloatTensor([[0.2,";
    "Fxn:torch.nn.functional.softmax(Variable(logits),";
    "Fxn:torch.zeros(num_draws,";
    "Fxn:torch.zeros(num_draws)";
    "Fxn:logits.cuda()";
    "Fxn:y_draws.cuda()";
    "Fxn:preds.cuda()";
    "Fxn:Variable(logits,";
    "Fxn:torch.nn.functional.gumbel_softmax(";
    "Fxn:y_draw.size()";
    "Fxn:logits.size()";
    "Fxn:Variable(logits.new([[0,";
    "Fxn:err).sum()";
    "Fxn:loss.backward()";
    "Fxn:logits_var.grad.data.std()";
    "Fxn:logits_var.grad.data.std()";
    "Fxn:y_draw.max(1)";
    "Fxn:1).int().sum()";
    "Fxn:0).int().sum()";
    "Fxn:1).int().sum()";
    "Fxn:test_gumbel_softmax_st";
    "Fxn:self._test_gumbel_softmax_st(False)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gumbel_softmax_st_cuda";
    "Fxn:self._test_gumbel_softmax_st(True)";
    "Fxn:_test_EmbeddingBag";
    "Fxn:nn.EmbeddingBag(5,";
    "Fxn:es.weight.data.copy_(torch.arange(1,";
    "Fxn:11).resize_as_(es.weight.data))";
    "Fxn:Variable(torch.LongTensor([3,";
    "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:torch.arange(1,";
    "Fxn:5).view(2,";
    "Fxn:2).type(torch.Tensor)";
    "Fxn:torch.Tensor(";
    "Fxn:torch.Tensor(";
    "Fxn:torch.Tensor(";
    "Fxn:torch.Tensor(";
    "Fxn:es.cuda()";
    "Fxn:input.cuda()";
    "Fxn:offsets.cuda()";
    "Fxn:grad_output.cuda()";
    "Fxn:expected_output.cuda()";
    "Fxn:expected_grad_weight.cuda()";
    "Fxn:es(input,";
    "Fxn:output.backward(grad_output)";
    "Fxn:es.weight.grad.data.to_dense()";
    "Fxn:self.assertEqual(output.data,";
    "Fxn:self.assertEqual(es_weight_grad,";
    "Fxn:Variable(input.data.view(2,";
    "Fxn:es.zero_grad()";
    "Fxn:es(input)";
    "Fxn:output.backward(grad_output)";
    "Fxn:es.weight.grad.data.to_dense()";
    "Fxn:self.assertEqual(output.data,";
    "Fxn:self.assertEqual(es_weight_grad,";
    "Fxn:_test_vs_Embedding";
    "Fxn:nn.EmbeddingBag(N,";
    "Fxn:nn.Embedding(N,";
    "Fxn:e.weight.data.copy_(es.weight.data)";
    "Fxn:Variable(torch.rand(B,";
    "Fxn:L).mul(N).long())";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:B).mul(L).long())";
    "Fxn:torch.rand(B,";
    "Fxn:D).type(torch.Tensor)";
    "Fxn:es.cuda()";
    "Fxn:e.cuda()";
    "Fxn:input.cuda()";
    "Fxn:offsets.cuda()";
    "Fxn:grad_output.cuda()";
    "Fxn:es(input.view(-1),";
    "Fxn:e(input).sum(1)";
    "Fxn:e(input).mean(1)";
    "Fxn:self.assertEqual(output,";
    "Fxn:output.backward(grad_output)";
    "Fxn:ref_output.backward(grad_output)";
    "Fxn:es.weight.grad.data.to_dense()";
    "Fxn:self.assertEqual(es_weight_grad,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:_test_vs_Embedding(N,";
    "Fxn:itertools.product([1,";
    "Fxn:_test_vs_Embedding(*p)";
    "Fxn:nn.EmbeddingBag(10,";
    "Fxn:Variable(torch.ones(3,";
    "Fxn:Variable(torch.arange(0,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:es(input,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:es(input.view(-1)))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:es(input.view(-1),";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:es(input.view(-1),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_pool3d_size_one_feature_dim";
    "Fxn:Variable(torch.randn(7,";
    "Fxn:2).cuda())";
    "Fxn:x.as_strided(x.size(),";
    "Fxn:x.cpu().as_strided(x.size(),";
    "Fxn:F.max_pool3d(t,";
    "Fxn:stride=(5,";
    "Fxn:F.avg_pool3d(t,";
    "Fxn:stride=(5,";
    "Fxn:to_test.items():";
    "Fxn:fn(y)";
    "Fxn:fn(x)";
    "Fxn:self.assertEqual(out_y,";
    "Fxn:out_x.cuda(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:4).cuda(),";
    "Fxn:F.avg_pool3d(x,";
    "Fxn:torch.randn(y.size()).cuda()";
    "Fxn:grad.set_(grad.storage(),";
    "Fxn:grad.size(),";
    "Fxn:grad.is_contiguous()";
    "Fxn:y.backward(grad)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_contig_wrong_stride_cudnn";
    "Fxn:torch.randn(1,";
    "Fxn:5).cuda()";
    "Fxn:x.set_(x.storage(),";
    "Fxn:x.size(),";
    "Fxn:self.assertTrue(x.is_contiguous())";
    "Fxn:F.conv_transpose2d(Variable(x),";
    "Fxn:Variable(torch.randn(16,";
    "Fxn:1)).cuda())";
    "Fxn:F.conv2d(Variable(x),";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:1)).cuda())";
    "Fxn:test_embedding_bag";
    "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_embedding_bag_cuda";
    "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:test_fractional_max_pool2d";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:x.new(1,";
    "Fxn:2).uniform_()";
    "Fxn:func";
    "Fxn:F.fractional_max_pool2d(";
    "Fxn:output_size=(3,";
    "Fxn:self.assertEqual(func(x).shape,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:x.new(2,";
    "Fxn:2).uniform_()";
    "Fxn:self.assertEqual(func(x).shape,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_Dropout";
    "Fxn:torch.Tensor(1000)";
    "Fxn:self._test_dropout(nn.Dropout,";
    "Fxn:test_Dropout2d";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:torch.Tensor(num_features,";
    "Fxn:self._test_dropout(nn.Dropout2d,";
    "Fxn:test_Dropout3d";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:torch.Tensor(num_features,";
    "Fxn:self._test_dropout(nn.Dropout3d,";
    "Fxn:test_AlphaDropout";
    "Fxn:torch.randn(5000)";
    "Fxn:input.mean()";
    "Fxn:input.std()";
    "Fxn:nn.AlphaDropout(p)";
    "Fxn:Variable(input,";
    "Fxn:module(input_var)";
    "Fxn:self.assertLess(abs(output.data.mean()";
    "Fxn:self.assertLess(abs(output.data.std()";
    "Fxn:output.backward(input)";
    "Fxn:_test_InstanceNorm_general";
    "Fxn:input.size(0),";
    "Fxn:input.size(1)";
    "Fxn:Variable(input.type(type),";
    "Fxn:cls(c,";
    "Fxn:eps=0).type(type)";
    "Fxn:IN(input_var)";
    "Fxn:output.view(b";
    "Fxn:out_reshaped.mean(1)";
    "Fxn:out_reshaped.var(1,";
    "Fxn:self.assertAlmostEqual(torch.abs(mean.data).mean(),";
    "Fxn:self.assertAlmostEqual(torch.abs(var.data).mean(),";
    "Fxn:output.data.clone().normal_()";
    "Fxn:output.data.clone()";
    "Fxn:output.backward(grad_out)";
    "Fxn:input_var.grad.data.clone()";
    "Fxn:IN.eval()";
    "Fxn:IN(input_var)";
    "Fxn:output.backward(grad_out)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(grad1,";
    "Fxn:cls(c,";
    "Fxn:track_running_stats=True).type(type)";
    "Fxn:IN(input_var.type(type))";
    "Fxn:input_var.transpose(1,";
    "Fxn:0).contiguous().view(c,";
    "Fxn:input_reshaped.mean(1)";
    "Fxn:input_var.transpose(1,";
    "Fxn:0).contiguous().view(c,";
    "Fxn:input_reshaped.var(2,";
    "Fxn:self.assertAlmostEqual(torch.abs(mean.data";
    "Fxn:IN.running_mean).mean(),";
    "Fxn:self.assertAlmostEqual(torch.abs(var.data.mean(1)";
    "Fxn:IN.running_var).mean(),";
    "Fxn:IN.eval()";
    "Fxn:torch.arange(c).type(type)).view(-1,";
    "Fxn:input.dim())])";
    "Fxn:IN(input_var";
    "Fxn:Variable(delta))";
    "Fxn:self.assertEqual(output.transpose(0,";
    "Fxn:1).contiguous().view(c,";
    "Fxn:-1).mean(1),";
    "Fxn:torch.arange(c))";
    "Fxn:_test_InstanceNorm_cuda_half";
    "Fxn:Variable(input.cuda().half().random_(1,";
    "Fxn:cls(input.size(1),";
    "Fxn:track_running_stats=True).cuda().half()";
    "Fxn:thnn_output.sum().backward()";
    "Fxn:input.grad.data.clone()";
    "Fxn:self.assertEqual(thnn_output.type(),";
    "Fxn:input.type())";
    "Fxn:m.float()";
    "Fxn:cudnn_output.sum().backward()";
    "Fxn:input.grad.data.clone()";
    "Fxn:self.assertEqual(cudnn_output.type(),";
    "Fxn:input.type())";
    "Fxn:self.assertAlmostEqual(cudnn_output,";
    "Fxn:self.assertAlmostEqual(cudnn_input_grad,";
    "Fxn:test_InstanceNorm1d_general";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(8,";
    "Fxn:torch.Tensor(b,";
    "Fxn:d).uniform_()";
    "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm1d,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_InstanceNorm1d_general_cuda";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(8,";
    "Fxn:torch.Tensor(b,";
    "Fxn:d).uniform_()";
    "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm1d,";
    "Fxn:self._test_InstanceNorm_cuda_half(nn.InstanceNorm1d,";
    "Fxn:test_InstanceNorm2d_general";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(6,";
    "Fxn:torch.Tensor(b,";
    "Fxn:w).uniform_()";
    "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm2d,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_InstanceNorm2d_general_cuda";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(6,";
    "Fxn:torch.Tensor(b,";
    "Fxn:w).uniform_()";
    "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm2d,";
    "Fxn:self._test_InstanceNorm_cuda_half(nn.InstanceNorm2d,";
    "Fxn:test_InstanceNorm3d_general";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(2,";
    "Fxn:random.randint(2,";
    "Fxn:random.randint(2,";
    "Fxn:torch.Tensor(b,";
    "Fxn:d).uniform_()";
    "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm3d,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_InstanceNorm3d_general_cuda";
    "Fxn:random.randint(3,";
    "Fxn:random.randint(2,";
    "Fxn:random.randint(2,";
    "Fxn:random.randint(2,";
    "Fxn:random.randint(2,";
    "Fxn:torch.Tensor(b,";
    "Fxn:d).uniform_()";
    "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm3d,";
    "Fxn:self._test_InstanceNorm_cuda_half(nn.InstanceNorm3d,";
    "Fxn:_test_LayerNorm_general";
    "Fxn:torch.LongTensor(i).random_(3,";
    "Fxn:6).tolist()";
    "Fxn:Variable(type(*shape).uniform_(0,";
    "Fxn:random.randint(1,";
    "Fxn:nn.LayerNorm(normalized_shape,";
    "Fxn:eps=0).type(type)";
    "Fxn:ln.weight.data.fill_(1)";
    "Fxn:ln.bias.data.fill_(0)";
    "Fxn:ln(x)";
    "Fxn:output.view(*(unnormalized_shape";
    "Fxn:out_reshaped.mean(-1)";
    "Fxn:out_reshaped.var(-1,";
    "Fxn:self.assertAlmostEqual(torch.abs(mean.data).mean(),";
    "Fxn:self.assertAlmostEqual(torch.abs(var.data).mean(),";
    "Fxn:torch.FloatTensor(2).uniform_(0.2,";
    "Fxn:2).tolist()";
    "Fxn:ln.weight.data.fill_(scale)";
    "Fxn:ln.bias.data.fill_(bias)";
    "Fxn:ln(x)";
    "Fxn:output.view(*(unnormalized_shape";
    "Fxn:out_reshaped.mean(-1)";
    "Fxn:out_reshaped.var(-1,";
    "Fxn:self.assertAlmostEqual(torch.abs(mean.data).mean(),";
    "Fxn:self.assertAlmostEqual(torch.abs(var.data).mean(),";
    "Fxn:nn.LayerNorm(normalized_shape,";
    "Fxn:track_running_stats=True).type(type)";
    "Fxn:ln(x).data.clone()";
    "Fxn:x.view(*(unnormalized_shape";
    "Fxn:input_reshaped.mean(-1).mean()";
    "Fxn:input_reshaped.var(-1,";
    "Fxn:unbiased=True).mean()";
    "Fxn:self.assertAlmostEqual(torch.abs(mean.data";
    "Fxn:ln.running_mean).mean(),";
    "Fxn:self.assertAlmostEqual(torch.abs(var.data";
    "Fxn:ln.running_var).mean(),";
    "Fxn:ln.eval()";
    "Fxn:ln.running_mean.clone()";
    "Fxn:ln.running_var.clone()";
    "Fxn:ln(x";
    "Fxn:ln.running_var.sqrt()[0]";
    "Fxn:self.assertAlmostEqual((output_new";
    "Fxn:output_ref).mean(),";
    "Fxn:self.assertEqual(old_running_mean,";
    "Fxn:self.assertEqual(old_running_var,";
    "Fxn:_test_LayerNorm_cuda_half";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:2).cuda().half().random_(1,";
    "Fxn:nn.LayerNorm([3,";
    "Fxn:2]).cuda().half()";
    "Fxn:output.sum().backward()";
    "Fxn:self.assertEqual(output.type(),";
    "Fxn:input.type())";
    "Fxn:test_LayerNorm_general";
    "Fxn:self._test_LayerNorm_general(torch.FloatTensor)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_LayerNorm_general_cuda";
    "Fxn:self._test_LayerNorm_general(torch.cuda.FloatTensor)";
    "Fxn:self._test_LayerNorm_cuda_half()";
    "Fxn:test_pad";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:F.pad(x,";
    "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:F.pad(x,";
    "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:F.pad(x,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.pad(x,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.pad(x,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.pad(x,";
    "Fxn:test_pad_scalar_error";
    "Fxn:torch.tensor(0,";
    "Fxn:self.assertRaises(AssertionError,";
    "Fxn:F.pad(inputs,";
    "Fxn:self.assertRaises(AssertionError,";
    "Fxn:F.pad(inputs,";
    "Fxn:test_normalize";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.normalize(x,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.normalize(x,";
    "Fxn:torch.randn((),";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.normalize(x,";
    "Fxn:_test_maxpool_indices";
    "Fxn:expected_indices";
    "Fxn:torch.DoubleTensor([1,";
    "Fxn:3]).repeat(2,";
    "Fxn:torch.DoubleTensor([[5,";
    "Fxn:15]]).repeat(2,";
    "Fxn:expected_grad";
    "Fxn:torch.DoubleTensor([0,";
    "Fxn:1]).repeat(2,";
    "Fxn:expected_grad(dim";
    "Fxn:torch.zeros(grad.size())";
    "Fxn:torch.stack((zero,";
    "Fxn:expected_output";
    "Fxn:torch.arange(2,";
    "Fxn:2).view(2,";
    "Fxn:torch.arange(6,";
    "Fxn:torch.stack([col,";
    "Fxn:1).view(2,";
    "Fxn:'AdaptiveMaxPool{}d'.format(num_dim)";
    "Fxn:'MaxPool{}d'.format(num_dim)";
    "Fxn:module_cls(2,";
    "Fxn:return_indices=True).type(type)";
    "Fxn:torch.arange(1,";
    "Fxn:1).view(2,";
    "Fxn:*repeat(4,";
    "Fxn:num_dim)).type(type)";
    "Fxn:Variable(input,";
    "Fxn:module(input_var)";
    "Fxn:expected_indices(num_dim)";
    "Fxn:expected_output(num_dim)";
    "Fxn:self.assertEqual(indices.dim(),";
    "Fxn:input.dim())";
    "Fxn:self.assertEqual(indices.data.squeeze(),";
    "Fxn:self.assertEqual(output.data.squeeze(),";
    "Fxn:self.assertTrue(output.requires_grad)";
    "Fxn:self.assertFalse(indices.requires_grad)";
    "Fxn:torch.ones(output.size()).type(type)";
    "Fxn:output.backward(grad_output,";
    "Fxn:expected_grad(num_dim)";
    "Fxn:self.assertEqual(input_var.grad.data,";
    "Fxn:expected_grad.view_as(input))";
    "Fxn:indices.add_(1)";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:output.backward(grad_output))";
    "Fxn:test_Conv2d_naive_groups";
    "Fxn:self._test_Conv2d_naive_groups()";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_naive_groups_cuda";
    "Fxn:self._test_Conv2d_naive_groups(torch.cuda.FloatTensor)";
    "Fxn:test_batchnorm_eval";
    "Fxn:self._test_batchnorm_eval()";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_batchnorm_eval_cuda";
    "Fxn:self._test_batchnorm_eval(torch.cuda.FloatTensor)";
    "Fxn:test_MaxPool1d_indices";
    "Fxn:self._test_maxpool_indices(1)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_MaxPool1d_indices_cuda";
    "Fxn:self._test_maxpool_indices(1,";
    "Fxn:test_MaxPool2d_indices";
    "Fxn:self._test_maxpool_indices(2)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_MaxPool2d_indices_cuda";
    "Fxn:self._test_maxpool_indices(2,";
    "Fxn:test_MaxPool3d_indices";
    "Fxn:self._test_maxpool_indices(3)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_MaxPool3d_indices_cuda";
    "Fxn:self._test_maxpool_indices(3,";
    "Fxn:test_AdaptiveMaxPool1d_indices";
    "Fxn:self._test_maxpool_indices(1,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_AdaptiveMaxPool1d_indices_cuda";
    "Fxn:self._test_maxpool_indices(1,";
    "Fxn:test_AdaptiveMaxPool2d_indices";
    "Fxn:self._test_maxpool_indices(2,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_AdaptiveMaxPool2d_indices_cuda";
    "Fxn:self._test_maxpool_indices(2,";
    "Fxn:test_AdaptiveMaxPool3d_indices";
    "Fxn:self._test_maxpool_indices(3,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_AdaptiveMaxPool3d_indices_cuda";
    "Fxn:self._test_maxpool_indices(3,";
    "Fxn:_test_scatter";
    "Fxn:Variable(tensor,";
    "Fxn:dp.scatter(x,";
    "Fxn:self.assertEqual(len(result),";
    "Fxn:self.assertEqual(result[0],";
    "Fxn:self.assertEqual(result[0].get_device(),";
    "Fxn:self.assertEqual(result[1],";
    "Fxn:self.assertEqual(result[1].get_device(),";
    "Fxn:result[0].data.clone().fill_(2)";
    "Fxn:result[0].backward(grad)";
    "Fxn:self.assertEqual(x.grad.data[:2],";
    "Fxn:self.assertEqual(x.grad.data[2:],";
    "Fxn:grad.clone().zero_())";
    "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:dp.scatter(y,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_scatter_cpu";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_scatter_gpu";
    "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:4).cuda())";
    "Fxn:_test_gather";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:4).cuda(0),";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:4).cuda(1),";
    "Fxn:dp.gather(inputs,";
    "Fxn:self.assertEqual(result.size(),";
    "Fxn:torch.Size([4,";
    "Fxn:self.assertEqual(result[:2],";
    "Fxn:self.assertEqual(result[2:],";
    "Fxn:self.assertEqual(result.get_device(),";
    "Fxn:self.assertFalse(result.is_cuda)";
    "Fxn:torch.randn(4,";
    "Fxn:grad.cuda(output_device)";
    "Fxn:result.backward(grad)";
    "Fxn:self.assertEqual(inputs[0].grad.data,";
    "Fxn:self.assertEqual(inputs[1].grad.data,";
    "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:dp.gather((x,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gather_cpu";
    "Fxn:self._test_gather(-1)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gather_gpu";
    "Fxn:self._test_gather(0)";
    "Fxn:_test_broadcast_double_backwards";
    "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:Broadcast.apply((0,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_broadcast_double_backwards_gpu";
    "Fxn:self._test_broadcast_double_backwards(torch.randn(4,";
    "Fxn:4).cuda(),";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda(),";
    "Fxn:torch.randn(4,";
    "Fxn:4).cuda())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_broadcast_not_requiring_grad";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:2).cuda(),";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:2).cuda(),";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:2).cuda(),";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:2).cuda(),";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:2).cuda(),";
    "Fxn:Broadcast.apply((0,";
    "Fxn:self.assertEqual(input_var.requires_grad,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_replicate";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:10).float().cuda())";
    "Fxn:module(input).data";
    "Fxn:dp.replicate(module,";
    "Fxn:replica.parameters():";
    "Fxn:self.assertEqual(p.get_device(),";
    "Fxn:input.cuda(i)";
    "Fxn:self.assertEqual(replica(replica_input).data,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_replicate_buffers";
    "Fxn:nn.Module()";
    "Fxn:nn.BatchNorm2d(10)";
    "Fxn:net.cuda()";
    "Fxn:dp.replicate(net,";
    "Fxn:self.assertEqual(replica.bn.running_mean.get_device(),";
    "Fxn:self.assertEqual(replica.bn.running_var.get_device(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_parallel_apply";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda(0)";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda(1)";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:10).float().cuda(0))";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:10).float().cuda(1))";
    "Fxn:l1(i1).data";
    "Fxn:l2(i2).data";
    "Fxn:dp.parallel_apply(modules,";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:Variable(i2.data.new()))";
    "Fxn:expected2.new())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_multiple_input";
    "class:TestModule(nn.Module):";
    "Fxn:forward";
    "Fxn:TestModule()";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).float(),";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).float(),";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:5).float(),";
    "Fxn:torch.randn(1).item()";
    "Fxn:expected.sum()";
    "Fxn:loss.backward()";
    "Fxn:var1.grad.clone()";
    "Fxn:var2.grad.clone()";
    "Fxn:local_test";
    "Fxn:var1.grad.data.fill_(0.0)";
    "Fxn:var2.grad.data.fill_(0.0)";
    "Fxn:out.sum()";
    "Fxn:loss.backward()";
    "Fxn:self.assertEqual(out,";
    "Fxn:self.assertEqual(gvar1_exp,";
    "Fxn:self.assertEqual(gvar2_exp,";
    "Fxn:dp.data_parallel(m,";
    "Fxn:local_test(out)";
    "Fxn:dp.data_parallel(m,";
    "Fxn:local_test(out)";
    "Fxn:dp.data_parallel(m,";
    "Fxn:local_test(out)";
    "Fxn:var1.grad.data.fill_(0.0)";
    "Fxn:var2.grad.data.fill_(0.0)";
    "Fxn:expected.sum()";
    "Fxn:loss.backward()";
    "Fxn:var1.grad.clone()";
    "Fxn:var2.grad.clone()";
    "Fxn:nn.DataParallel(TestModule())";
    "Fxn:dpm(var1,";
    "Fxn:local_test(out)";
    "Fxn:nn.DataParallel(TestModule(),";
    "Fxn:dpm(var1,";
    "Fxn:local_test(out)";
    "Fxn:dp.data_parallel(";
    "Fxn:local_test(out)";
    "Fxn:dp.data_parallel(";
    "Fxn:local_test(out)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_small_back";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda())";
    "Fxn:dp.data_parallel(l,";
    "Fxn:self.assertEqual(out,";
    "Fxn:l(i))";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_model_no_refcycles";
    "Import:class";
    "class:Model(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Linear(1,";
    "Fxn:forward";
    "Fxn:self.linear(x)";
    "Fxn:gc.collect()";
    "Fxn:nn.DataParallel(Model().cuda())";
    "Fxn:Variable(torch.randn(1).cuda())";
    "Fxn:model(data)";
    "Fxn:gc.collect()";
    "Fxn:self.assertEqual(refcycles,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_no_grad";
    "class:Layer(nn.Module):";
    "Fxn:forward";
    "Fxn:test.assertFalse(torch.is_grad_enabled())";
    "Fxn:Layer()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda())";
    "Fxn:torch.no_grad():";
    "Fxn:dp.data_parallel(l,";
    "Fxn:self.assertRaises(AssertionError,";
    "Fxn:dp.data_parallel(l,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda(1))";
    "Fxn:l.cuda(1)";
    "Fxn:l(i)";
    "Fxn:expected_out.sum()";
    "Fxn:loss.backward()";
    "Fxn:l.parameters():";
    "Fxn:expected_grads.append(param.grad.clone())";
    "Fxn:[(0,";
    "Fxn:torch.cuda.device(dev_id[0]):";
    "Fxn:l.cuda()";
    "Fxn:l.zero_grad()";
    "Fxn:dp.data_parallel(l,";
    "Fxn:out.sum()";
    "Fxn:loss.backward()";
    "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:l.parameters()):";
    "Fxn:self.assertEqual(param.grad.data,";
    "Fxn:l.cuda()";
    "Fxn:dp.data_parallel(l,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_sparse";
    "Fxn:nn.Embedding(10,";
    "Fxn:sparse=True).cuda(1)";
    "Fxn:Variable(torch.LongTensor(20,";
    "Fxn:5).random_(0,";
    "Fxn:10).cuda(1))";
    "Fxn:l(i)";
    "Fxn:expected_out.sum()";
    "Fxn:loss.backward()";
    "Fxn:l.parameters():";
    "Fxn:expected_grads.append(param.grad.clone())";
    "Fxn:[(0,";
    "Fxn:torch.cuda.device(dev_id[0]):";
    "Fxn:l.cuda()";
    "Fxn:l.zero_grad()";
    "Fxn:dp.data_parallel(l,";
    "Fxn:out.sum()";
    "Fxn:loss.backward()";
    "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:l.parameters()):";
    "Fxn:self.assertEqual(param.grad.data,";
    "Fxn:l.cuda()";
    "Fxn:dp.data_parallel(l,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_nested_output";
    "Fxn:fn";
    "Fxn:input.cos(),";
    "Fxn:[input.add(1)]),";
    "class:Net(nn.Module):";
    "Fxn:forward";
    "Fxn:fn(input)";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:2).float().cuda(1))";
    "Fxn:dp.data_parallel(Net(),";
    "Fxn:self.assertEqual(output,";
    "Fxn:fn(i))";
    "Fxn:self.assertIsInstance(output[0],";
    "Fxn:self.assertIsInstance(output[1],";
    "Fxn:self.assertIsInstance(output[1][0],";
    "Fxn:self.assertIsInstance(output[1][1],";
    "Fxn:self.assertIsInstance(output[1][2],";
    "Fxn:self.assertIsInstance(output[1][2][0],";
    "Fxn:self.assertIsInstance(output[2],";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_nested_input";
    "Fxn:fn";
    "class:Net(nn.Module):";
    "Fxn:forward";
    "Fxn:fn(input)";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:3).float().cuda(1))";
    "Fxn:i.sin())";
    "Fxn:dp.data_parallel(Net(),";
    "Fxn:self.assertEqual(output,";
    "Fxn:fn(input))";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_module";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda())";
    "Fxn:l(i).data";
    "Fxn:nn.DataParallel(l)";
    "Fxn:net(i)";
    "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_module_kwargs_only";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:self.l(input)";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda())";
    "Fxn:l(i).data";
    "Fxn:nn.DataParallel(Net())";
    "Fxn:n(input=i)";
    "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_module_kwargs_only_empty_list";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:self.l(input['data'])";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda())";
    "Fxn:l(i).data";
    "Fxn:nn.DataParallel(Net())";
    "Fxn:n(input={'data':";
    "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_module_kwargs_only_empty_dict";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:self.l(input['data'])";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda())";
    "Fxn:l(i).data";
    "Fxn:nn.DataParallel(Net())";
    "Fxn:n(input={'data':";
    "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_module_kwargs_only_empty_tuple";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:self.l(input['data'])";
    "Fxn:nn.Linear(10,";
    "Fxn:5).float().cuda()";
    "Fxn:Variable(torch.randn(20,";
    "Fxn:10).float().cuda())";
    "Fxn:l(i).data";
    "Fxn:nn.DataParallel(Net())";
    "Fxn:n(input={'data':";
    "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:self.assertEqual(out.data,";
    "Fxn:test_state_dict";
    "Fxn:nn.Linear(5,";
    "Fxn:nn.Module()";
    "Fxn:nn.Conv2d(3,";
    "Fxn:nn.Module()";
    "Fxn:nn.BatchNorm2d(2)";
    "Fxn:net.add_module('empty',";
    "Fxn:net.state_dict()";
    "Fxn:self.assertEqual(len(state_dict),";
    "Fxn:self.assertIn('linear1.weight',";
    "Fxn:self.assertIn('linear1.bias',";
    "Fxn:self.assertIn('linear2.weight',";
    "Fxn:self.assertIn('linear2.bias',";
    "Fxn:self.assertIn('block.conv.weight',";
    "Fxn:self.assertIn('block.conv.weight',";
    "Fxn:self.assertNotIn('block.conv.bias',";
    "Fxn:self.assertIn('bn.weight',";
    "Fxn:self.assertIn('bn.bias',";
    "Fxn:self.assertIn('bn.running_var',";
    "Fxn:self.assertIn('bn.running_mean',";
    "Fxn:self.assertFalse(any(map(lambda";
    "Fxn:k.startswith('empty'),";
    "Fxn:state_dict.keys())))";
    "Fxn:state_dict.items():";
    "Fxn:k.split('.'):";
    "Fxn:self.assertEqual(v.data_ptr(),";
    "Fxn:param.data_ptr())";
    "Fxn:nn.Linear(5,";
    "Fxn:l.state_dict()";
    "Fxn:self.assertEqual(len(state_dict),";
    "Fxn:self.assertEqual(state_dict['weight'].data_ptr(),";
    "Fxn:l.weight.data_ptr())";
    "Fxn:self.assertEqual(state_dict['bias'].data_ptr(),";
    "Fxn:l.bias.data_ptr())";
    "Fxn:test_load_state_dict";
    "Fxn:nn.Linear(5,";
    "Fxn:nn.Module()";
    "Fxn:nn.Conv2d(3,";
    "Fxn:nn.Conv2d(3,";
    "Fxn:nn.Module()";
    "Fxn:nn.BatchNorm2d(2)";
    "Fxn:net.add_module('empty',";
    "Fxn:net.state_dict()";
    "Fxn:state_dict.update({";
    "Fxn:torch.ones(5,";
    "Fxn:torch.arange(1,";
    "Fxn:torch.randn(2),";
    "Fxn:net.load_state_dict(state_dict)";
    "Fxn:self.assertEqual(net.linear1.weight.data,";
    "Fxn:self.assertEqual(net.block.conv1.bias.data,";
    "Fxn:self.assertEqual(net.bn.running_mean,";
    "Fxn:net.state_dict()";
    "Fxn:state_dict.update({'extra':";
    "Fxn:torch.ones(5)})";
    "Fxn:self.assertRaises(KeyError,";
    "Fxn:net.load_state_dict(state_dict))";
    "Fxn:net.state_dict()";
    "Fxn:self.assertRaises(KeyError,";
    "Fxn:net.load_state_dict(state_dict))";
    "Fxn:net.state_dict()";
    "Fxn:state_dict.update({'bn.running_mean':";
    "Fxn:torch.rand(14,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:net.load_state_dict(state_dict))";
    "Fxn:net.state_dict()";
    "Fxn:deepcopy(state_dict)";
    "Fxn:torch.ones(5,";
    "Fxn:torch.arange(1,";
    "Fxn:torch.randn(2),";
    "Fxn:torch.rand(3)";
    "Fxn:net.load_state_dict(state_dict,";
    "Fxn:self.assertEqual(net.linear1.weight.data,";
    "Fxn:self.assertEqual(net.block.conv1.bias.data,";
    "Fxn:self.assertEqual(net.bn.running_mean,";
    "Fxn:net.state_dict()";
    "Fxn:old_state_dict.items():";
    "Fxn:self.assertTrue(v.equal(new_state_dict[k]))";
    "Fxn:test_parameter_assignment";
    "Fxn:nn.Linear(5,";
    "Fxn:num_params";
    "Fxn:self.assertEqual(num_params(),";
    "Fxn:Parameter(torch.randn(5,";
    "Fxn:self.assertEqual(num_params(),";
    "Fxn:self.assertObjectIn(new_param,";
    "Fxn:l.parameters())";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:self.assertEqual(num_params(),";
    "Fxn:self.assertNotIn(id(var),";
    "Fxn:l.parameters()))";
    "Fxn:Variable(torch.Tensor(5,";
    "Fxn:self.assertEqual(num_params(),";
    "Fxn:Parameter(torch.Tensor(5,";
    "Fxn:self.assertEqual(num_params(),";
    "Fxn:assign_var";
    "Fxn:Variable(torch.Tensor(5,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:self.assertEqual(num_params(),";
    "Fxn:test_assignment";
    "Fxn:nn.Module()";
    "Fxn:nn.Parameter(torch.randn(2))";
    "Fxn:nn.Parameter(torch.randn(3))";
    "Fxn:nn.Parameter(torch.randn(4))";
    "Fxn:nn.Linear(4,";
    "Fxn:nn.Linear(5,";
    "Fxn:nn.Linear(6,";
    "Fxn:test_assignments";
    "Fxn:self.assertIsNone(l.a)";
    "Fxn:self.assertIn('a',";
    "Fxn:self.assertIs(l.a,";
    "Fxn:self.assertEqual(get_list(),";
    "Fxn:self.assertNotIn('a',";
    "Fxn:self.assertIsNone(l.b)";
    "Fxn:self.assertIn('b',";
    "Fxn:self.assertIs(l.b,";
    "Fxn:self.assertEqual(get_list(),";
    "Fxn:self.assertNotIn('b',";
    "Fxn:self.assertIsNone(l.a)";
    "Fxn:self.assertEqual(get_list(),";
    "Fxn:self.assertIs(l.a,";
    "Fxn:self.assertEqual(get_list(),";
    "Fxn:self.assertIs(l.a,";
    "Fxn:self.assertEqual(get_list(),";
    "Fxn:self.assertFalse(hasattr(l,";
    "Fxn:self.assertIs(l.a,";
    "Fxn:self.assertEqual(get_list(),";
    "Fxn:test_assignments(lambda:";
    "Fxn:self.assertEqual(list(l.parameters()),";
    "Fxn:test_assignments(lambda:";
    "Fxn:self.assertEqual(list(l.children()),";
    "Fxn:torch.randn(10)";
    "Fxn:l.register_buffer('buf',";
    "Fxn:self.assertIs(l.buf,";
    "Fxn:self.assertIs(l.buf,";
    "Fxn:self.assertNotIn('buf',";
    "Fxn:self.assertIn('buf',";
    "Fxn:l.state_dict())";
    "Fxn:self.assertIs(l.state_dict()['buf'],";
    "Fxn:test_Conv2d_inconsistent_types";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:7).float())";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:3).double())";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:nn.functional.conv2d(inputs.float(),";
    "Fxn:weights.float())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:7).float().cuda())";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:3).double().cuda())";
    "Fxn:Variable(torch.randn(1).double().cuda())";
    "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:weights.float(),";
    "Fxn:nn.functional.conv2d(inputs.float(),";
    "Fxn:weights.float(),";
    "Fxn:bias.float())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:7).float().cuda())";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:3).double().cuda())";
    "Fxn:Variable(torch.randn(1).double().cuda())";
    "Fxn:torch.backends.cudnn.flags(enabled=True):";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:weights.float(),";
    "Fxn:nn.functional.conv2d(inputs.float(),";
    "Fxn:weights.float(),";
    "Fxn:bias.float())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_deterministic_cudnn";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:5).type(dtype),";
    "Fxn:cudnn.flags(enabled=True,";
    "Fxn:torch.nn.Conv2d(3,";
    "Fxn:3).type(dtype)";
    "Fxn:torch.nn.Conv2d(3,";
    "Fxn:3).type(dtype)";
    "Fxn:conv2.bias.data.copy_(conv1.bias.data)";
    "Fxn:conv2.weight.data.copy_(conv1.weight.data)";
    "Fxn:conv1(inputs)";
    "Fxn:conv2(inputs)";
    "Fxn:self.assertEqual(out1,";
    "Fxn:torch.randn(out1.size()).type(dtype)";
    "Fxn:out1.backward(y)";
    "Fxn:out2.backward(y)";
    "Fxn:self.assertEqual(conv1.bias.grad.data,";
    "Fxn:self.assertEqual(conv1.weight.grad.data,";
    "Fxn:test_Conv2d_missing_argument";
    "Fxn:nn.Conv2d(3,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:c(None))";
    "Fxn:test_Conv2d_backward_twice";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:nn.Conv2d(3,";
    "Fxn:c(input)";
    "Fxn:o1.sum().backward()";
    "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:o1.sum().backward())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_large_workspace";
    "Fxn:run_test";
    "Fxn:torch.backends.cudnn.flags(benchmark=benchmark):";
    "Fxn:torch.nn.Conv2d(256,";
    "Fxn:padding=1).type(dtype)";
    "Fxn:torch.randn(size).type(dtype)";
    "Fxn:conv(Variable(x,";
    "Fxn:out.backward(torch.ones(out.size()).type(dtype))";
    "Fxn:run_test(benchmark=False)";
    "Fxn:run_test(benchmark=True)";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size";
    "Fxn:[nn.Conv1d(3,";
    "Fxn:nn.ConvTranspose1d(3,";
    "Fxn:nn.Conv2d(3,";
    "Fxn:nn.ConvTranspose2d(3,";
    "Fxn:nn.Conv3d(3,";
    "Fxn:nn.ConvTranspose3d(3,";
    "Fxn:[(2,";
    "Fxn:Variable(torch.Tensor(torch.Size((3,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:module(input))";
    "Fxn:test_conv_shapecheck";
    "Fxn:test";
    "Fxn:Variable(torch.Tensor(3,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:module(input))";
    "Fxn:module(input)";
    "Fxn:test(True,";
    "Fxn:nn.Conv1d(1,";
    "Fxn:test(True,";
    "Fxn:nn.Conv1d(1,";
    "Fxn:test(False,";
    "Fxn:nn.Conv1d(1,";
    "Fxn:test(False,";
    "Fxn:nn.Conv1d(1,";
    "Fxn:test(False,";
    "Fxn:nn.Conv1d(1,";
    "Fxn:test(True,";
    "Fxn:nn.Conv2d(1,";
    "Fxn:test(False,";
    "Fxn:nn.Conv2d(1,";
    "Fxn:test(False,";
    "Fxn:nn.Conv2d(1,";
    "Fxn:test(True,";
    "Fxn:nn.Conv3d(1,";
    "Fxn:test(False,";
    "Fxn:nn.Conv3d(1,";
    "Fxn:test(False,";
    "Fxn:nn.Conv3d(1,";
    "Fxn:test_ConvTranspose2d_output_size";
    "Fxn:nn.ConvTranspose2d(3,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:output_size=(h,";
    "Fxn:self.assertEqual(output.size()[2:],";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:_test_Conv2d_naive_groups";
    "Fxn:nn.Conv2d(4,";
    "Fxn:groups=2).type(test_type)";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:6).type(test_type),";
    "Fxn:torch.randn(2,";
    "Fxn:4).type(test_type)";
    "Fxn:output.backward(grad_output)";
    "Fxn:nn.Conv2d(2,";
    "Fxn:kernel_size=3).type(test_type)";
    "Fxn:m1.weight.data.copy_(m.weight.data[:2])";
    "Fxn:m1.bias.data.copy_(m.bias.data[:2])";
    "Fxn:Variable(i.data[:,";
    "Fxn::2].contiguous(),";
    "Fxn:output1.backward(grad_output[:,";
    "Fxn::2].contiguous())";
    "Fxn:nn.Conv2d(2,";
    "Fxn:kernel_size=3).type(test_type)";
    "Fxn:m2.weight.data.copy_(m.weight.data[2:])";
    "Fxn:m2.bias.data.copy_(m.bias.data[2:])";
    "Fxn:Variable(i.data[:,";
    "Fxn:2:].contiguous(),";
    "Fxn:output2.backward(grad_output[:,";
    "Fxn:2:].contiguous())";
    "Fxn:self.assertEqual(output,";
    "Fxn:torch.cat([output1,";
    "Fxn:self.assertEqual(i.grad.data,";
    "Fxn:torch.cat([i1.grad.data,";
    "Fxn:self.assertEqual(m.bias.grad.data,";
    "Fxn:torch.cat([m1.bias.grad.data,";
    "Fxn:self.assertEqual(m.weight.grad.data,";
    "Fxn:torch.cat([m1.weight.grad.data,";
    "Fxn:test_Conv2d_groups_nobias";
    "Fxn:nn.Conv2d(4,";
    "Fxn:bias=False).type(tp)";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:6).type(tp),";
    "Fxn:torch.randn(2,";
    "Fxn:4).type(tp)";
    "Fxn:output.backward(grad_output)";
    "Fxn:nn.Conv2d(2,";
    "Fxn:bias=False).type(tp)";
    "Fxn:m1.weight.data.copy_(m.weight.data[:2])";
    "Fxn:Variable(i.data[:,";
    "Fxn::2].contiguous(),";
    "Fxn:output1.backward(grad_output[:,";
    "Fxn::2].contiguous())";
    "Fxn:nn.Conv2d(2,";
    "Fxn:bias=False).type(tp)";
    "Fxn:m2.weight.data.copy_(m.weight.data[2:])";
    "Fxn:Variable(i.data[:,";
    "Fxn:2:].contiguous(),";
    "Fxn:output2.backward(grad_output[:,";
    "Fxn:2:].contiguous())";
    "Fxn:self.assertEqual(output,";
    "Fxn:torch.cat([output1,";
    "Fxn:self.assertEqual(i.grad.data,";
    "Fxn:torch.cat([i1.grad.data,";
    "Fxn:self.assertEqual(m.weight.grad.data,";
    "Fxn:torch.cat([m1.weight.grad.data,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_depthwise_naive_groups";
    "Fxn:nn.Conv2d(2,";
    "Fxn:groups=2).type(tp)";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:6).type(tp)";
    "Fxn:torch.randn(2,";
    "Fxn:4).type(tp)";
    "Fxn:output.backward(grad_output)";
    "Fxn:nn.Conv2d(1,";
    "Fxn:kernel_size=3).type(tp)";
    "Fxn:m.weight.data[:offset].clone()";
    "Fxn:m.bias.data[:offset].clone()";
    "Fxn:Variable(i.data[:,";
    "Fxn::1].contiguous(),";
    "Fxn:output1.backward(grad_output[:,";
    "Fxn::offset].contiguous())";
    "Fxn:nn.Conv2d(1,";
    "Fxn:kernel_size=3).type(tp)";
    "Fxn:m2.weight.data.copy_(m.weight.data[offset:])";
    "Fxn:m2.bias.data.copy_(m.bias.data[offset:])";
    "Fxn:Variable(i.data[:,";
    "Fxn:1:].contiguous(),";
    "Fxn:output2.backward(grad_output[:,";
    "Fxn:offset:].contiguous())";
    "Fxn:self.assertEqual(output,";
    "Fxn:torch.cat([output1,";
    "Fxn:self.assertEqual(i.grad.data,";
    "Fxn:torch.cat([i1.grad.data,";
    "Fxn:self.assertEqual(m.bias.grad.data,";
    "Fxn:torch.cat([m1.bias.grad.data,";
    "Fxn:self.assertEqual(m.weight.grad.data,";
    "Fxn:torch.cat([m1.weight.grad.data,";
    "Fxn:test_MaxUnpool2d_output_size";
    "Fxn:nn.MaxPool2d(3,";
    "Fxn:nn.MaxUnpool2d(3,";
    "Fxn:torch.rand(1,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:mu(output_big,";
    "Fxn:torch.rand(1,";
    "Fxn:torch.LongStorage(size)";
    "Fxn:torch.LongStorage((1,";
    "Fxn:mu(output_small,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:mu(output_small,";
    "Fxn:test_container_copy";
    "class:Model(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Linear(4,";
    "Fxn:forward";
    "Fxn:self.linear(input)";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:Model()";
    "Fxn:deepcopy(model)";
    "Fxn:self.assertEqual(model(input).data,";
    "Fxn:model_cp(input).data)";
    "Fxn:self.assertNotEqual(model(input).data,";
    "Fxn:model_cp(input).data)";
    "Fxn:test_RNN_cell";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:module(10,";
    "Fxn:cell(input,";
    "Fxn:hx.sum().backward()";
    "Fxn:_test_loss_equal_input_target_shape";
    "Fxn:F.mse_loss(x,";
    "Fxn:F.l1_loss(x,";
    "Fxn:F.smooth_l1_loss(x,";
    "Fxn:F.kl_div(x,";
    "Fxn:F.poisson_nll_loss(x,";
    "Fxn:Variable(cast(torch.randn(3,";
    "Fxn:Variable(cast(torch.randn(5,";
    "Fxn:losses.items():";
    "Fxn:self.assertRaises(Exception,";
    "Fxn:fn(input,";
    "Fxn:test_loss_equal_input_target_shape";
    "Fxn:self._test_loss_equal_input_target_shape(lambda";
    "Fxn:test_RNN_cell_no_broadcasting";
    "Fxn:test";
    "Fxn:cell_module(input_size,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:cell(input,";
    "Fxn:test_all";
    "Fxn:test(nn.RNNCell,";
    "Fxn:test(nn.GRUCell,";
    "Fxn:test(nn.LSTMCell,";
    "Fxn:test(nn.LSTMCell,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:test_all(hidden_size,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:test_all(hidden_size,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:test_all(hidden_size,";
    "Fxn:test_invalid_dropout_p";
    "Fxn:Variable(torch.ones(1))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:nn.Dropout(-0.1))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:nn.Dropout(1.1))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:nn.Dropout2d(-0.1))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:nn.Dropout2d(1.1))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:nn.Dropout3d(-0.1))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:nn.Dropout3d(1.1))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:F.dropout(v,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:F.dropout(v,";
    "Fxn:test_pad_sequence";
    "Fxn:pad";
    "Fxn:torch.cat(";
    "Fxn:tensor.data.new(";
    "Fxn:tensor.size(0),";
    "Fxn:*tensor.size()[1:]).zero_()])";
    "Fxn:Variable(torch.Tensor([1,";
    "Fxn:Variable(torch.Tensor([4,";
    "Fxn:Variable(torch.Tensor([6]))";
    "Fxn:Variable(torch.Tensor([[1,";
    "Fxn:rnn_utils.pad_sequence([a,";
    "Fxn:self.assertEqual(padded,";
    "Fxn:rnn_utils.pad_sequence([a,";
    "Fxn:self.assertEqual(padded,";
    "Fxn:expected.transpose(0,";
    "Fxn:Variable(torch.Tensor([[1,";
    "Fxn:rnn_utils.pad_sequence([a,";
    "Fxn:self.assertEqual(padded,";
    "Fxn:sequences.append(Variable(torch.rand(seq_len,";
    "Fxn:expected.append(pad(seq,";
    "Fxn:Variable(torch.stack(expected))";
    "Fxn:rnn_utils.pad_sequence(sequences,";
    "Fxn:self.assertEqual(padded,";
    "Fxn:rnn_utils.pad_sequence(sequences)";
    "Fxn:self.assertEqual(padded,";
    "Fxn:expected.transpose(0,";
    "Fxn:self.assertRaises(";
    "Fxn:rnn_utils.pad_sequence([b,";
    "Fxn:test_pack_sequence";
    "Fxn:_compatibility_test";
    "Fxn:rnn_utils.pad_sequence(sequences,";
    "Fxn:rnn_utils.pack_sequence(sequences)";
    "Fxn:rnn_utils.pad_packed_sequence(packed,";
    "Fxn:self.assertEqual(padded,";
    "Fxn:rnn_utils.pack_padded_sequence(padded,";
    "Fxn:self.assertEqual(packed,";
    "Fxn:Variable(torch.Tensor([1,";
    "Fxn:Variable(torch.Tensor([4,";
    "Fxn:Variable(torch.Tensor([6]))";
    "Fxn:rnn_utils.pack_sequence([a,";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(packed.batch_sizes,";
    "Fxn:self.assertEqual(packed.data.data,";
    "Fxn:lengths.append(seq_len)";
    "Fxn:sequences.append(Variable(torch.rand(seq_len,";
    "Fxn:_compatibility_test(sequences,";
    "Fxn:test_pack_padded_sequence";
    "Fxn:pad";
    "Fxn:torch.cat([tensor,";
    "Fxn:tensor.new(length";
    "Fxn:tensor.size(0),";
    "Fxn:*tensor.size()[1:]).zero_()])";
    "Fxn:[sum(map(bool,";
    "Fxn:torch.cat([pad(i";
    "Fxn:torch.arange(1,";
    "Fxn:1).view(l,";
    "Fxn:Variable(padded,";
    "Fxn:[[torch.arange(1,";
    "Fxn:torch.stack(expected_data,";
    "Fxn:src.transpose(0,";
    "Fxn:rnn_utils.pack_padded_sequence(src,";
    "Fxn:self.assertEqual(packed.data.data,";
    "Fxn:self.assertEqual(packed.batch_sizes,";
    "Fxn:rnn_utils.pad_packed_sequence(packed,";
    "Fxn:self.assertEqual(unpacked,";
    "Fxn:self.assertEqual(unpacked_len,";
    "Fxn:padded.grad.data.zero_()";
    "Fxn:unpacked.data.clone().normal_()";
    "Fxn:unpacked.backward(grad_output)";
    "Fxn:grad_output.transpose_(0,";
    "Fxn:self.assertEqual(padded.grad.data[:l,";
    "Fxn:self.assertEqual(padded.grad.data[l:,";
    "Fxn:i].abs().sum(),";
    "Fxn:_test_variable_sequence";
    "Fxn:pad";
    "Fxn:var.size(0)";
    "Fxn:torch.cat([var,";
    "Fxn:Variable(var.data.new(length";
    "Fxn:var.size(0),";
    "Fxn:*var.size()[1:]).zero_())])";
    "Fxn:Variable(torch.randn(max_length,";
    "Fxn:nn.LSTM(3,";
    "Fxn:deepcopy(lstm)";
    "Fxn:x_leaf.cuda()";
    "Fxn:lstm.cuda()";
    "Fxn:lstm2.cuda()";
    "Fxn:lstm2(x[:l,";
    "Fxn:pad(out,";
    "Fxn:seq_outs.append(out_pad)";
    "Fxn:seq_hiddens.append(hid)";
    "Fxn:torch.cat(seq_outs,";
    "Fxn:rnn_utils.pack_padded_sequence(x,";
    "Fxn:lstm(packed)";
    "Fxn:rnn_utils.pad_packed_sequence(packed_out)";
    "Fxn:self.assertEqual(packed_hidden,";
    "Fxn:self.assertEqual(unpacked,";
    "Fxn:self.assertEqual(unpacked_len,";
    "Fxn:seq_out.sum().backward()";
    "Fxn:x_leaf.grad.data.clone()";
    "Fxn:x_leaf.grad.data.zero_()";
    "Fxn:unpacked.sum().backward()";
    "Fxn:self.assertEqual(x_leaf.grad.data,";
    "Fxn:lstm2.parameters()):";
    "Fxn:self.assertEqual(p1.grad,";
    "Fxn:test_variable_sequence";
    "Fxn:self._test_variable_sequence(False)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_variable_sequence_cuda";
    "Fxn:self._test_variable_sequence(True)";
    "Fxn:test_LSTM_cell";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:nn.LSTMCell(10,";
    "Fxn:lstm(input,";
    "Fxn:cx).sum().backward()";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cudnn_weight_format";
    "Fxn:nn.LSTM(10,";
    "Fxn:nn.GRU(10,";
    "Fxn:nn.RNN(10,";
    "Fxn:rnn.cuda()";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:10).cuda(),";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:20).cuda(),";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:20).cuda(),";
    "Fxn:rnn(input,";
    "Fxn:output[0].sum().backward()";
    "Fxn:[v.grad.data.clone()";
    "Fxn:v.grad.data.zero_()";
    "Fxn:weight.data.clone()";
    "Fxn:weight.data.set_(weight_data)";
    "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:rnn(input,";
    "Fxn:self.assertEqual(len(w),";
    "Fxn:self.assertIn('weights";
    "Fxn:output_noncontig[0].sum().backward()";
    "Fxn:[v.grad.data.clone()";
    "Fxn:v.grad.data.zero_()";
    "Fxn:self.assertEqual(output,";
    "Fxn:self.assertEqual(grads_noncontig,";
    "Fxn:self.assertEqual(weight_data,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cudnn_weight_tying";
    "Fxn:nn.LSTM(10,";
    "Fxn:nn.GRU(10,";
    "Fxn:nn.RNN(10,";
    "Fxn:rnn.cuda()";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:10).cuda(),";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:20).cuda(),";
    "Fxn:torch.optim.SGD(rnn.parameters(),";
    "Fxn:opt.zero_grad()";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:20).cuda(),";
    "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:rnn(input,";
    "Fxn:output[0].sum().backward()";
    "Fxn:opt.step()";
    "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:rnn(input,";
    "Fxn:rnn.cpu()";
    "Fxn:hx[1].cpu())";
    "Fxn:hx.cpu()";
    "Fxn:rnn(input.cpu(),";
    "Fxn:self.assertEqual(output_cuda,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_rnn_fused";
    "Fxn:copy_rnn";
    "Fxn:x.data.copy_(y.data)";
    "Fxn:check_rnn_grads";
    "Fxn:self.assertEqual(x.grad,";
    "Fxn:torch.randn(seq_length,";
    "Fxn:torch.randn(seq_length,";
    "Fxn:torch.randn(num_layers,";
    "Fxn:torch.randn(num_layers,";
    "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:module(input_size,";
    "Fxn:module(input_size,";
    "Fxn:bias=bias).cuda()";
    "Fxn:copy_rnn(rnn,";
    "Fxn:Variable(hx_val.clone().add(1),";
    "Fxn:Variable(hx_val.clone().cuda().add(1),";
    "Fxn:Variable(hx_val.clone(),";
    "Fxn:Variable(hx_val.clone().cuda(),";
    "Fxn:Variable(input_val.clone(),";
    "Fxn:Variable(input_val.clone().cuda(),";
    "Fxn:rnn(inp,";
    "Fxn:rnn_cuda(inp_cu,";
    "Fxn:torch.autograd.backward(";
    "Fxn:torch.autograd.backward(";
    "Fxn:[grad_output.cuda(),";
    "Fxn:grad_hy.cuda(),";
    "Fxn:1).cuda()]";
    "Fxn:torch.autograd.backward([output1,";
    "Fxn:torch.autograd.backward([output2,";
    "Fxn:[grad_output.cuda(),";
    "Fxn:grad_hy.cuda()])";
    "Fxn:self.assertEqual(output1,";
    "Fxn:self.assertEqual(hy1,";
    "Fxn:check_rnn_grads(rnn,";
    "Fxn:self.assertEqual(inp.grad.data,";
    "Fxn:self.assertEqual(hx[0].grad.data,";
    "Fxn:self.assertEqual(hx[1].grad.data,";
    "Fxn:self.assertEqual(hx.grad.data,";
    "Fxn:test_rnn_args_check";
    "Fxn:test";
    "Fxn:get_inputs(input_shape,";
    "Fxn:mode)(input_size,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:model(input,";
    "Fxn:update_tuple";
    "Fxn:get_inputs";
    "Fxn:Variable(torch.randn(input_shape))";
    "Fxn:Variable(torch.randn(hidden_shape))";
    "Fxn:[(input,";
    "Fxn:[(input,";
    "Fxn:Variable(torch.randn(correct_hidden_shape))";
    "Fxn:update_tuple(correct_input_shape,";
    "Fxn:test(input_shape,";
    "Fxn:update_tuple(correct_hidden_shape,";
    "Fxn:test(input_shape,";
    "Fxn:update_tuple(correct_input_shape,";
    "Fxn:test(input_shape,";
    "Fxn:update_tuple(correct_hidden_shape,";
    "Fxn:test(input_shape,";
    "Fxn:update_tuple(correct_hidden_shape,";
    "Fxn:test(input_shape,";
    "Fxn:test_rnn_initial_hidden_state";
    "Fxn:mode)(30,";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:Variable(torch.Tensor(2,";
    "Fxn:20).zero_())";
    "Fxn:rnn(input,";
    "Fxn:rnn(input)";
    "Fxn:self.assertEqual(output1,";
    "Fxn:self.assertEqual(hidden1,";
    "Fxn:_test_rnn_retain_variables";
    "Fxn:[nn.LSTM(10,";
    "Fxn:num_layers=2).type(dtype),";
    "Fxn:nn.GRU(10,";
    "Fxn:num_layers=2).type(dtype),";
    "Fxn:nn.RNN(10,";
    "Fxn:num_layers=2).type(dtype)]";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:10).type(dtype),";
    "Fxn:rnn(input)";
    "Fxn:output[0].sum().backward(retain_graph=True)";
    "Fxn:[input.grad.data.clone()]";
    "Fxn:[p.grad.data.clone()";
    "Fxn:rnn.parameters()]";
    "Fxn:rnn.zero_grad()";
    "Fxn:input.grad.data.zero_()";
    "Fxn:output[0].sum().backward(retain_graph=True)";
    "Fxn:rnn.parameters()]";
    "Fxn:self.assertEqual(grads,";
    "Fxn:test_rnn_retain_variables";
    "Fxn:self._test_rnn_retain_variables(torch.DoubleTensor)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_rnn_retain_variables_cuda";
    "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:self._test_rnn_retain_variables(torch.cuda.FloatTensor)";
    "Fxn:self._test_rnn_retain_variables(torch.cuda.FloatTensor)";
    "Fxn:_test_RNN_cpu_vs_cudnn";
    "Fxn:forward_backward";
    "Fxn:x.data.copy_(y.data)";
    "Fxn:rnn_utils.PackedSequence(";
    "Fxn:Variable(input_val.data.data,";
    "Fxn:Variable(input_val.clone(),";
    "Fxn:Variable(hx_val.add(1),";
    "Fxn:Variable(hx_val.clone(),";
    "Fxn:rnn.cuda()";
    "Fxn:input_var.data.cuda()";
    "Fxn:hx[0].data.cuda()";
    "Fxn:hx[1].data.cuda()";
    "Fxn:hx.data.cuda()";
    "Fxn:grad_hy.cuda()";
    "Fxn:grad_output.cuda()";
    "Fxn:rnn(input,";
    "Fxn:torch.autograd.backward([output,";
    "Fxn:torch.autograd.backward([output,";
    "Fxn:make_noncontig";
    "Fxn:tensor.dim()";
    "Fxn:torch.stack([tensor.clone().zero_(),";
    "Fxn:ndim).select(ndim,";
    "Fxn:compare_cpu_gpu";
    "Fxn:self.assertEqual(list(outputs_cpu.keys()),";
    "Fxn:outputs_cpu.keys():";
    "Fxn:self.assertEqual(outputs_cpu[key],";
    "Fxn:self.assertEqual(cpu_weight.grad.data,";
    "Fxn:product((True,";
    "Fxn:torch.randn(batch,";
    "Fxn:torch.randn(batch,";
    "Fxn:torch.randn(seq_length,";
    "Fxn:torch.randn(seq_length,";
    "Fxn:make_noncontig(grad_output)";
    "Fxn:make_noncontig(grad_hy)";
    "Fxn:make_noncontig(input_val)";
    "Fxn:make_noncontig(hx_val)";
    "Fxn:torch.randn(num_layers";
    "Fxn:torch.randn(num_layers";
    "Fxn:Variable(torch.LongTensor(lengths))";
    "Fxn:Variable(input_val)";
    "Fxn:Variable(grad_output)";
    "Fxn:rnn_utils.pack_padded_sequence(input_val,";
    "Fxn:rnn_utils.pack_padded_sequence(grad_output,";
    "Fxn:module(input_size,";
    "Fxn:forward_backward(";
    "Fxn:module(input_size,";
    "Fxn:forward_backward(";
    "Fxn:compare_cpu_gpu(outputs_cpu,";
    "Fxn:torch.randn(num_layers,";
    "Fxn:torch.randn(seq_length,";
    "Fxn:torch.randn(";
    "Fxn:torch.randn(";
    "Fxn:nn.RNN(input_size,";
    "Fxn:forward_backward(False,";
    "Fxn:nn.RNN(input_size,";
    "Fxn:forward_backward(True,";
    "Fxn:compare_cpu_gpu(outputs_cpu,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:@default_tensor_type(torch.FloatTensor)";
    "Fxn:torch.cuda.DoubleTensor.sum()";
    "Fxn:test_RNN_cpu_vs_cudnn_no_dropout";
    "Fxn:self._test_RNN_cpu_vs_cudnn(0)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:@default_tensor_type(torch.FloatTensor)";
    "Fxn:torch.cuda.DoubleTensor.sum()";
    "Fxn:test_RNN_cpu_vs_cudnn_with_dropout";
    "Fxn:self._test_RNN_cpu_vs_cudnn(1)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_RNN_dropout";
    "Fxn:nn.RNN(10,";
    "Fxn:rnn.cuda()";
    "Fxn:rnn.train()";
    "Fxn:rnn.eval()";
    "Fxn:rnn.weight_ih_l0.data.fill_(1)";
    "Fxn:rnn.weight_hh_l0.data.fill_(1)";
    "Fxn:rnn.weight_ih_l1.data.fill_(1)";
    "Fxn:rnn.weight_hh_l1.data.fill_(1)";
    "Fxn:Variable(torch.Tensor(1,";
    "Fxn:10).fill_(1))";
    "Fxn:Variable(torch.Tensor(2,";
    "Fxn:1000).fill_(0))";
    "Fxn:input.cuda()";
    "Fxn:hx.cuda()";
    "Fxn:rnn(input,";
    "Fxn:self.assertEqual(output.data.min(),";
    "Fxn:output.data.max())";
    "Fxn:self.assertEqual(output_val,";
    "Fxn:self.assertEqual(output_val,";
    "Fxn:self.assertGreater(output_val,";
    "Fxn:self.assertLess(output_val,";
    "Fxn:self.assertLess(min(denorm_mod,";
    "Fxn:self.assertEqual(hy[0].data.min(),";
    "Fxn:hy[0].data.max())";
    "Fxn:self.assertEqual(hy[1].data.min(),";
    "Fxn:hy[1].data.max())";
    "Fxn:self.assertEqual(hy.data[0][0][0],";
    "Fxn:self.assertEqual(hy.data[1][0][0],";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_RNN_dropout_state";
    "Fxn:nn.RNN(100,";
    "Fxn:rnn.cuda()";
    "Fxn:rnn.train()";
    "Fxn:rnn.eval()";
    "Fxn:Variable(torch.Tensor(1,";
    "Fxn:100).uniform_())";
    "Fxn:Variable(torch.Tensor(2,";
    "Fxn:100).uniform_())";
    "Fxn:input.cuda()";
    "Fxn:hx.cuda()";
    "Fxn:rnn(input,";
    "Fxn:rnn(input,";
    "Fxn:pickle.dumps(rnn)";
    "Fxn:pickle.loads(rnn_pickle)";
    "Fxn:rnn2.flatten_parameters()";
    "Fxn:rnn2(input,";
    "Fxn:self.assertEqual(output1,";
    "Fxn:self.assertEqual(output1,";
    "Fxn:self.assertEqual(hy1,";
    "Fxn:self.assertEqual(hy1,";
    "Fxn:self.assertNotEqual(output1,";
    "Fxn:self.assertNotEqual(output1,";
    "Fxn:self.assertNotEqual(hy1,";
    "Fxn:self.assertNotEqual(hy1,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_RNN_change_dropout";
    "Fxn:product((True,";
    "Fxn:nn.RNN(100,";
    "Fxn:Variable(torch.Tensor(3,";
    "Fxn:100).uniform_())";
    "Fxn:input.data.cuda()";
    "Fxn:rnn.cuda()";
    "Fxn:rnn.train()";
    "Fxn:rnn.eval()";
    "Fxn:rnn(input)";
    "Fxn:rnn(input)";
    "Fxn:self.assertEqual(output1,";
    "Fxn:self.assertEqual(hy1,";
    "Fxn:self.assertNotEqual(output1,";
    "Fxn:self.assertNotEqual(hy1,";
    "Fxn:self.assertEqual(output1.data,";
    "Fxn:self.assertEqual(output2.data,";
    "Fxn:self.assertNotEqual(output1.data,";
    "Fxn:self.assertNotEqual(output2.data,";
    "Fxn:_verify_pixel_shuffle";
    "Fxn:self.assertEqual(output[:,";
    "Fxn:test_inplace_thnn";
    "Fxn:mod(inplace=True)";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:r(input";
    "Fxn:torch.randn(5,";
    "Fxn:grad_output.clone()";
    "Fxn:output.backward(grad_output)";
    "Fxn:self.assertEqual(grad_output,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_noncontig_conv_grad";
    "Fxn:nn.Conv2d(3,";
    "Fxn:padding=1).cuda()";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:10).cuda(),";
    "Fxn:module(input)";
    "Fxn:torch.randn(2,";
    "Fxn:10).cuda()[:,";
    "Fxn:grad.is_contiguous()";
    "Fxn:output.backward(grad,";
    "Fxn:self.assertIsNotNone(input.grad)";
    "Fxn:input.grad.data.clone()";
    "Fxn:input.grad.data.zero_()";
    "Fxn:output.backward(grad.contiguous())";
    "Fxn:self.assertEqual(result,";
    "Fxn:test_pixel_shuffle";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(2,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(5,";
    "Fxn:random.randint(5,";
    "Fxn:Variable(torch.Tensor(batch_size,";
    "Fxn:width).uniform_(),";
    "Fxn:nn.PixelShuffle(upscale_factor)";
    "Fxn:ps(input)";
    "Fxn:self._verify_pixel_shuffle(input.data,";
    "Fxn:output.backward(output.data)";
    "Fxn:self.assertEqual(input.data,";
    "Fxn:test_elu_inplace_view";
    "Fxn:Variable(torch.Tensor([1.0,";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:x.narrow(0,";
    "Fxn:F.elu(view,";
    "Fxn:self.assertIs(res,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_relu_inplace_view";
    "Fxn:Variable(torch.Tensor([1.0,";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:x.narrow(0,";
    "Fxn:F.relu(view,";
    "Fxn:self.assertIs(res,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size";
    "Fxn:Variable(torch.rand(5))";
    "Fxn:Variable(torch.rand(5,";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:nn.BCEWithLogitsLoss()(input,";
    "Fxn:Variable(torch.rand(5,";
    "Fxn:Variable(torch.rand(5))";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:nn.BCEWithLogitsLoss()(input,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss";
    "Fxn:nn.Sigmoid()";
    "Fxn:Variable(torch.rand(64,";
    "Fxn:Variable(torch.rand(64,";
    "Fxn:self.assertEqual(nn.BCEWithLogitsLoss()(output,";
    "Fxn:nn.BCELoss()(sigmoid(output),";
    "Fxn:torch.rand(4)";
    "Fxn:self.assertEqual(nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:Variable(torch.FloatTensor(4,";
    "Fxn:1).fill_(0))";
    "Fxn:Variable(torch.FloatTensor(4,";
    "Fxn:1).fill_(-100))";
    "Fxn:self.assertEqual(nn.BCEWithLogitsLoss()(output,";
    "Fxn:nn.BCELoss()(sigmoid(output),";
    "Fxn:self.assertEqual(nn.BCEWithLogitsLoss(reduce=False)(output,";
    "Fxn:nn.BCELoss(reduce=False)(sigmoid(output),";
    "Fxn:torch.FloatTensor(1).uniform_()";
    "Fxn:self.assertEqual(nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero";
    "Fxn:Variable(torch.zeros(3,";
    "Fxn:Variable(torch.zeros(3,";
    "Fxn:nn.BCEWithLogitsLoss(size_average=False)(output,";
    "Fxn:target).backward()";
    "Fxn:Variable(torch.Tensor(3,";
    "Fxn:1).fill_(0.5))";
    "Fxn:self.assertEqual(output.grad,";
    "Fxn:test_bce_with_logits_broadcasts_weights";
    "Fxn:Variable(torch.rand(16,";
    "Fxn:Variable(torch.rand(16,";
    "Fxn:torch.rand(4)";
    "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:weight.expand(16,";
    "Fxn:4).contiguous()";
    "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:self.assertEqual(out1,";
    "Fxn:torch.rand(16,";
    "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:weight.expand(16,";
    "Fxn:4).contiguous()";
    "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:self.assertEqual(out1,";
    "Fxn:test_bce_loss_broadcasts_weights";
    "Fxn:nn.Sigmoid()";
    "Fxn:Variable(torch.rand(16,";
    "Fxn:Variable(torch.rand(16,";
    "Fxn:torch.rand(4)";
    "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:weight.expand(16,";
    "Fxn:4).contiguous()";
    "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:self.assertEqual(out1,";
    "Fxn:torch.rand(16,";
    "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:weight.expand(16,";
    "Fxn:4).contiguous()";
    "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:self.assertEqual(out1,";
    "Fxn:test_elu_inplace_gradgrad";
    "Fxn:Variable(torch.randn(8),";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:F.elu(x,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_hardtanh_inplace_gradgrad";
    "Fxn:Variable(torch.randn(8),";
    "Fxn:func";
    "Fxn:root.clone()";
    "Fxn:F.hardtanh(x,";
    "Fxn:gradcheck(func,";
    "Fxn:gradgradcheck(func,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_batchnorm_cudnn_half";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:2).half().cuda().random_(1,";
    "Fxn:nn.BatchNorm2d(3).half().cuda()";
    "Fxn:thnn_output.sum().backward()";
    "Fxn:input.grad.data.clone()";
    "Fxn:self.assertEqual(thnn_output.type(),";
    "Fxn:input.type())";
    "Fxn:m.float()";
    "Fxn:cudnn_output.sum().backward()";
    "Fxn:input.grad.data.clone()";
    "Fxn:self.assertEqual(cudnn_output.type(),";
    "Fxn:input.type())";
    "Fxn:self.assertEqual(cudnn_output,";
    "Fxn:self.assertAlmostEqual(cudnn_input_grad,";
    "Fxn:_test_batchnorm_update_stats";
    "Fxn:nn.BatchNorm1d(3).type(test_type)";
    "Fxn:Variable(torch.rand(4,";
    "Fxn:3).type(test_type))";
    "Fxn:module.running_mean.clone()";
    "Fxn:module.running_var.clone()";
    "Fxn:module(data)";
    "Fxn:self.assertNotEqual(old_running_mean,";
    "Fxn:self.assertNotEqual(old_running_var,";
    "Fxn:module.eval()";
    "Fxn:module.running_mean.clone()";
    "Fxn:module.running_var.clone()";
    "Fxn:module(data)";
    "Fxn:self.assertEqual(old_running_mean,";
    "Fxn:self.assertEqual(old_running_var,";
    "Fxn:test_batchnorm_update_stats";
    "Fxn:self._test_batchnorm_update_stats()";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_batchnorm_update_stats_cuda";
    "Fxn:self._test_batchnorm_update_stats(torch.cuda.FloatTensor)";
    "Fxn:test_batchnorm_raises_error_if_running_mean_is_not_same_size_as_input";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:torch.rand(10)";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:F.batch_norm(input,";
    "Fxn:torch.rand(size),";
    "Fxn:test_batchnorm_raises_error_if_running_var_is_not_same_size_as_input";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:torch.rand(10)";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:F.batch_norm(input,";
    "Fxn:torch.rand(size))";
    "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:torch.rand(10)";
    "Fxn:torch.rand(10)";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:F.batch_norm(input,";
    "Fxn:weight=Parameter(torch.rand(size)))";
    "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:torch.rand(10)";
    "Fxn:torch.rand(10)";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:F.batch_norm(input,";
    "Fxn:bias=Parameter(torch.rand(size)))";
    "Fxn:_test_batchnorm_eval";
    "Fxn:nn.BatchNorm1d(3).type(test_type)";
    "Fxn:module.eval()";
    "Fxn:Variable(torch.rand(4,";
    "Fxn:3).type(test_type),";
    "Fxn:torch.rand(4,";
    "Fxn:3).type(test_type)";
    "Fxn:module(data)";
    "Fxn:res1.backward(grad)";
    "Fxn:data.grad.data.clone()";
    "Fxn:data.grad.data.zero_()";
    "Fxn:module(data)";
    "Fxn:res2.backward(grad)";
    "Fxn:data.grad.data.clone()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(grad1,";
    "Fxn:nn.BatchNorm1d(3,";
    "Fxn:track_running_stats=False).type(test_type)";
    "Fxn:Variable(torch.rand(4,";
    "Fxn:3).type(test_type),";
    "Fxn:torch.rand(4,";
    "Fxn:3).type(test_type)";
    "Fxn:module(data)";
    "Fxn:res1.backward(grad)";
    "Fxn:data.grad.data.clone()";
    "Fxn:module.eval()";
    "Fxn:data.grad.data.zero_()";
    "Fxn:module(data)";
    "Fxn:res2.backward(grad)";
    "Fxn:data.grad.data.clone()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(grad1,";
    "Fxn:test_pairwise_distance";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.pairwise_distance(x,";
    "Fxn:test_cosine_embedding_loss_no_reduce";
    "Fxn:Variable(torch.randn(15,";
    "Fxn:Variable(torch.randn(15,";
    "Fxn:Variable(torch.randn(15).sign())";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.cosine_embedding_loss(";
    "Fxn:self.assertEqual(F.cosine_embedding_loss(input1,";
    "Fxn:loss_reference_fns['CosineEmbeddingLoss'](input1,";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce";
    "Fxn:Variable(torch.randn(15,";
    "Fxn:Variable(torch.randn(15,";
    "Fxn:Variable(torch.randn(15).sign())";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.cosine_embedding_loss(";
    "Fxn:self.assertEqual(F.cosine_embedding_loss(input1,";
    "Fxn:loss_reference_fns['CosineEmbeddingLoss'](input1,";
    "Fxn:test_triplet_margin_loss";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.triplet_margin_loss(";
    "Fxn:test_triplet_margin_swap_loss";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.triplet_margin_loss(";
    "Fxn:test_cosine_similarity";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.cosine_similarity(x,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:Variable(torch.randn(4,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.cosine_similarity(x,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.cosine_similarity(x,";
    "Fxn:torch.randn((),";
    "Fxn:torch.randn((),";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.cosine_similarity(x,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.cosine_similarity(x,";
    "Fxn:Variable(torch.randn(input_size),";
    "Fxn:Variable(torch.randn(input_size),";
    "Fxn:self.assertEqual(F.cosine_similarity(input1,";
    "Fxn:dim=1).size(),";
    "Fxn:test_grid_sample";
    "Fxn:test_cpu_against_cuda";
    "Fxn:test_shape";
    "Fxn:Variable(torch.randn(C,";
    "Fxn:IW).transpose(0,";
    "Fxn:Variable(torch.randn(H,";
    "Fxn:2).transpose(0,";
    "Fxn:F.grid_sample(input_cpu,";
    "Fxn:self.assertTrue(out_cpu.size()";
    "Fxn:torch.Size([N,";
    "Fxn:Variable(input_cpu.data.transpose(0,";
    "Fxn:1).cuda().transpose(0,";
    "Fxn:Variable(grid_cpu.data.transpose(0,";
    "Fxn:1).cuda().transpose(0,";
    "Fxn:F.grid_sample(input_cuda,";
    "Fxn:self.assertEqual(out_cpu,";
    "Fxn:out_cpu.data.new(out_cpu.size()).normal_()";
    "Fxn:out_cpu.backward(gradients)";
    "Fxn:out_cuda.backward(gradients.cuda())";
    "Fxn:self.assertEqual(input_cpu.grad,";
    "Fxn:self.assertEqual(grid_cpu.grad,";
    "Fxn:torch.randn(C,";
    "Fxn:Variable(base_input.expand(input_cuda.size()),";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:F.grid_sample(input_cpu,";
    "Fxn:Variable(base_input.cuda().expand(input_cuda.size()),";
    "Fxn:Variable(grid_cpu.data.cuda(),";
    "Fxn:F.grid_sample(input_cuda,";
    "Fxn:self.assertEqual(out_cpu,";
    "Fxn:test_shape(N,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(IH";
    "Fxn:random.randint(IW";
    "Fxn:test_shape(N,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:test_shape(N,";
    "Fxn:Variable(torch.arange(1,";
    "Fxn:11).view(1,";
    "Fxn:Variable(torch.Tensor(";
    "Fxn:0.5]]).view(1,";
    "Fxn:F.grid_sample(input,";
    "Fxn:torch.Tensor(";
    "Fxn:7.0000]]).view(1,";
    "Fxn:torch.Tensor(";
    "Fxn:8.7500]]).view(1,";
    "Fxn:self.assertEqual(output.data,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:self.assertTrue(gradcheck(";
    "Fxn:F.grid_sample(inp,";
    "Fxn:test_cpu_against_cuda(N,";
    "Fxn:test_grid_sample_3d";
    "Fxn:test_cpu_against_cuda";
    "Fxn:test_shape";
    "Fxn:Variable(torch.randn(C,";
    "Fxn:IW).transpose(0,";
    "Fxn:Variable(torch.randn(D,";
    "Fxn:3).transpose(0,";
    "Fxn:F.grid_sample(input_cpu,";
    "Fxn:self.assertTrue(out_cpu.size()";
    "Fxn:torch.Size([N,";
    "Fxn:Variable(input_cpu.data.transpose(0,";
    "Fxn:1).cuda().transpose(0,";
    "Fxn:Variable(grid_cpu.data.transpose(0,";
    "Fxn:1).cuda().transpose(0,";
    "Fxn:F.grid_sample(input_cuda,";
    "Fxn:self.assertEqual(out_cpu,";
    "Fxn:out_cpu.data.new(out_cpu.size()).normal_()";
    "Fxn:out_cpu.backward(gradients)";
    "Fxn:out_cuda.backward(gradients.cuda())";
    "Fxn:self.assertEqual(input_cpu.grad,";
    "Fxn:self.assertEqual(grid_cpu.grad,";
    "Fxn:torch.randn(C,";
    "Fxn:Variable(base_input.expand(input_cuda.size()),";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:F.grid_sample(input_cpu,";
    "Fxn:Variable(base_input.cuda().expand(input_cuda.size()),";
    "Fxn:Variable(grid_cpu.data.cuda(),";
    "Fxn:F.grid_sample(input_cuda,";
    "Fxn:self.assertEqual(out_cpu,";
    "Fxn:test_shape(N,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(ID";
    "Fxn:random.randint(IH";
    "Fxn:random.randint(IW";
    "Fxn:test_shape(N,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:test_shape(N,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:self.assertTrue(gradcheck(";
    "Fxn:F.grid_sample(inp,";
    "Fxn:test_cpu_against_cuda(N,";
    "Fxn:test_affine_grid";
    "Fxn:Variable(torch.arange(1,";
    "Fxn:7).view(1,";
    "Fxn:F.affine_grid(input,";
    "Fxn:torch.Size([1,";
    "Fxn:torch.Tensor(";
    "Fxn:15]]]).view(1,";
    "Fxn:self.assertEqual(output.data,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:torch.Size([N,";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:F.affine_grid(inp,";
    "Fxn:Variable(torch.randn(N,";
    "Fxn:F.affine_grid(input_cpu,";
    "Fxn:torch.randn(out_cpu.size())";
    "Fxn:out_cpu.backward(gradients)";
    "Fxn:Variable(input_cpu.data.cuda(),";
    "Fxn:F.affine_grid(input_gpu,";
    "Fxn:out_cuda.backward(gradients.cuda())";
    "Fxn:self.assertEqual(out_cpu,";
    "Fxn:self.assertEqual(input_cpu.grad,";
    "Fxn:test_upsamplingNearest1d";
    "Fxn:nn.Upsample(size=4,";
    "Fxn:torch.ones(1,";
    "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:gradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingLinear1d";
    "Fxn:nn.Upsample(size=4,";
    "Fxn:torch.ones(1,";
    "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:gradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingNearest2d";
    "Fxn:nn.Upsample(size=4,";
    "Fxn:torch.ones(1,";
    "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:self.assertEqual(";
    "Fxn:F.upsample(input,";
    "Fxn:F.upsample(input,";
    "Fxn:gradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:gradgradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingBilinear2d";
    "Fxn:nn.Upsample(size=4,";
    "Fxn:torch.ones(1,";
    "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:gradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingNearest3d";
    "Fxn:nn.Upsample(size=4,";
    "Fxn:torch.ones(1,";
    "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:gradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingTrilinear3d";
    "Fxn:nn.Upsample(size=4,";
    "Fxn:torch.ones(1,";
    "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:Variable(torch.randn(1,";
    "Fxn:self.assertEqual(";
    "Fxn:F.upsample(input,";
    "Fxn:F.upsample(input,";
    "Fxn:gradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:gradgradcheck(lambda";
    "Fxn:F.upsample(x,";
    "Fxn:test_linear_broadcasting";
    "Fxn:nn.Linear(5,";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:5)).view(2,";
    "Fxn:self.assertEqual(expected,";
    "Fxn:test_bilinear";
    "Fxn:nn.Bilinear(10,";
    "Fxn:legacy.Bilinear(10,";
    "Fxn:module_legacy.weight.copy_(module.weight.data)";
    "Fxn:module_legacy.bias.copy_(module.bias.data)";
    "Fxn:torch.randn(4,";
    "Fxn:torch.randn(4,";
    "Fxn:module(Variable(input1),";
    "Fxn:Variable(input2))";
    "Fxn:module_legacy.forward([input1,";
    "Fxn:self.assertEqual(output.data,";
    "Fxn:Variable(input1,";
    "Fxn:Variable(input2,";
    "Fxn:module.zero_grad()";
    "Fxn:module_legacy.zeroGradParameters()";
    "Fxn:module(input1_1,";
    "Fxn:torch.randn(*output.size())";
    "Fxn:module_legacy.backward([input1,";
    "Fxn:output.backward(grad_output)";
    "Fxn:input1_1.grad.data.clone()";
    "Fxn:input2_1.grad.data.clone()";
    "Fxn:self.assertEqual(gi1,";
    "Fxn:self.assertEqual(gi2,";
    "Fxn:self.assertEqual(module.weight.grad.data,";
    "Fxn:self.assertEqual(module.bias.grad.data,";
    "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:F.bilinear(x1,";
    "Fxn:test_conv_tbc";
    "Fxn:Variable(torch.randn(9,";
    "Fxn:Variable(torch.randn(3,";
    "Fxn:Variable(torch.randn(6),";
    "Fxn:gradcheck(lambda";
    "Fxn:F.conv_tbc(i,";
    "Fxn:run_conv_double_back_test";
    "Fxn:torch.Tensor(1)";
    "Fxn:tensor.cuda()";
    "Fxn:Variable(tensor.new(batch_size,";
    "Fxn:x.data.normal_()";
    "Fxn:Variable(tensor.new(chan_out,";
    "Fxn:weight.data.normal_()";
    "Fxn:Variable(tensor.new(chan_out),";
    "Fxn:bias.data.normal_()";
    "Fxn:func";
    "Fxn:cudnn.flags(enabled=False):";
    "Fxn:F.conv2d(lx,";
    "Fxn:func(*inputs)";
    "Fxn:Variable(tensor.new(dummy_out.size()),";
    "Fxn:grad_y.data.normal_()";
    "Fxn:gradgradcheck(func,";
    "Fxn:test_conv_double_backward";
    "Fxn:[(3,";
    "Fxn:product([1,";
    "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:self.assertTrue(result,";
    "Fxn:test_conv_double_backward_no_bias";
    "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:self.assertTrue(result,";
    "Fxn:test_conv_double_backward_groups";
    "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:self.assertTrue(result,";
    "Fxn:test_conv_double_backward_stride";
    "Fxn:[(3,";
    "Fxn:product([2],";
    "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cudnn_noncontiguous_weight";
    "Fxn:contiguous()";
    "Fxn:Variable(torch.cuda.DoubleTensor([1,";
    "Fxn:1]).view(1,";
    "Fxn:Variable(torch.cuda.DoubleTensor([1]).expand(1,";
    "Fxn:Variable(torch.cuda.DoubleTensor([1]).expand(1,";
    "Fxn:2)).contiguous()";
    "Fxn:self.assertEqual(F.conv1d(input,";
    "Fxn:F.conv1d(input,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_conv_double_backward_cuda";
    "Fxn:[(3,";
    "Fxn:product([1],";
    "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:self.assertTrue(result,";
    "Import:sys";
    "Import:cPickle";
    "Import:pickle";
    "class:TestNNInit(TestCase):";
    "Fxn:setUp";
    "Fxn:self).setUp()";
    "Fxn:random.seed(123)";
    "Fxn:_is_normal";
    "Fxn:tensor.view(-1).tolist()";
    "Fxn:stats.kstest(samples,";
    "Fxn:args=(mean,";
    "Fxn:_is_uniform";
    "Fxn:tensor.view(-1).tolist()";
    "Fxn:stats.kstest(samples,";
    "Fxn:args=(a,";
    "Fxn:_create_random_nd_tensor";
    "Fxn:[random.randint(size_min,";
    "Fxn:torch.zeros(size)";
    "Fxn:Variable(tensor)";
    "Fxn:_random_float";
    "Fxn:random.random()";
    "Fxn:test_calculate_gain_linear";
    "Fxn:init.calculate_gain(fn)";
    "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_nonlinear";
    "Fxn:init.calculate_gain(fn)";
    "Fxn:self.assertEqual(gain,";
    "Fxn:self.assertEqual(gain,";
    "Fxn:self.assertEqual(gain,";
    "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_leaky_relu";
    "Fxn:init.calculate_gain('leaky_relu',";
    "Fxn:self.assertEqual(gain,";
    "Fxn:self.assertEqual(gain,";
    "Fxn:self.assertEqual(gain,";
    "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_leaky_relu_only_accepts_numbers";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:init.calculate_gain('leaky_relu',";
    "Fxn:test_calculate_gain_only_accepts_valid_nonlinearities";
    "Fxn:''.join([random.choice(string.ascii_lowercase)";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:init.calculate_gain(random_string)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_uniform";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self._random_float(-3,";
    "Fxn:self._random_float(1,";
    "Fxn:init.uniform(input_tensor,";
    "Fxn:self._is_uniform(input_tensor,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_normal";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self._random_float(-3,";
    "Fxn:self._random_float(1,";
    "Fxn:init.normal(input_tensor,";
    "Fxn:self._is_normal(input_tensor,";
    "Fxn:test_constant";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self._random_float(1,";
    "Fxn:init.constant(input_tensor,";
    "Fxn:self.assertEqual(input_tensor,";
    "Fxn:input_tensor.clone().fill_(val))";
    "Fxn:test_eye";
    "Fxn:self._create_random_nd_tensor(2,";
    "Fxn:init.eye(input_tensor)";
    "Fxn:test_eye_only_works_on_2d_inputs";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:init.eye(tensor)";
    "Fxn:test_dirac_properties";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:init.dirac(input_tensor)";
    "Fxn:input_tensor.size(0),";
    "Fxn:input_tensor.size(1)";
    "Fxn:torch.nonzero(input_tensor).size(0)";
    "Fxn:self.assertEqual(input_tensor.sum(),";
    "Fxn:test_dirac_identity";
    "Fxn:Variable(torch.randn(batch,";
    "Fxn:Variable(torch.zeros(out_c,";
    "Fxn:init.dirac(filter_var)";
    "Fxn:F.conv1d(input_var,";
    "Fxn:self.assertEqual(input_tensor[:,";
    "Fxn:torch.nonzero(output_tensor[:,";
    "Fxn::]).numel()";
    "Fxn:Variable(torch.randn(batch,";
    "Fxn:Variable(torch.zeros(out_c,";
    "Fxn:init.dirac(filter_var)";
    "Fxn:F.conv2d(input_var,";
    "Fxn:self.assertEqual(input_tensor[:,";
    "Fxn:torch.nonzero(output_tensor[:,";
    "Fxn::]).numel()";
    "Fxn:Variable(torch.randn(batch,";
    "Fxn:Variable(torch.zeros(out_c,";
    "Fxn:init.dirac(filter_var)";
    "Fxn:F.conv3d(input_var,";
    "Fxn:self.assertEqual(input_tensor[:,";
    "Fxn:torch.nonzero(output_tensor[:,";
    "Fxn::]).numel()";
    "Fxn:test_dirac_only_works_on_3_4_5d_inputs";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:init.dirac(tensor)";
    "Fxn:test_xavier_uniform_errors_on_inputs_smaller_than_2d";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:init.xavier_uniform(tensor)";
    "Fxn:test_xavier_normal_errors_on_inputs_smaller_than_2d";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:init.xavier_normal(tensor)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_xavier_uniform";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self._random_float(0.1,";
    "Fxn:init.xavier_uniform(input_tensor,";
    "Fxn:init.xavier_uniform(input_tensor)";
    "Fxn:input_tensor.size(1)";
    "Fxn:input_tensor.size(0)";
    "Fxn:input_tensor.dim()";
    "Fxn:0].numel()";
    "Fxn:0].numel()";
    "Fxn:math.sqrt(2.0";
    "Fxn:math.sqrt(3)";
    "Fxn:self._is_uniform(input_tensor,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_xavier_normal";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self._random_float(0.1,";
    "Fxn:init.xavier_normal(input_tensor,";
    "Fxn:init.xavier_normal(input_tensor)";
    "Fxn:input_tensor.size(1)";
    "Fxn:input_tensor.size(0)";
    "Fxn:input_tensor.dim()";
    "Fxn:0].numel()";
    "Fxn:0].numel()";
    "Fxn:math.sqrt(2.0";
    "Fxn:self._is_normal(input_tensor,";
    "Fxn:test_kaiming_uniform_errors_on_inputs_smaller_than_2d";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:init.kaiming_uniform(tensor)";
    "Fxn:test_kaiming_normal_errors_on_inputs_smaller_than_2d";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:init.kaiming_normal(tensor)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_kaiming_uniform";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self._random_float(0.1,";
    "Fxn:init.kaiming_uniform(input_tensor,";
    "Fxn:init.kaiming_uniform(input_tensor,";
    "Fxn:input_tensor.size(1)";
    "Fxn:input_tensor.size(0)";
    "Fxn:input_tensor.dim()";
    "Fxn:0].numel()";
    "Fxn:0].numel()";
    "Fxn:math.sqrt(2.0";
    "Fxn:math.sqrt(3.0)";
    "Fxn:self._is_uniform(input_tensor,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_kaiming_normal";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:self._random_float(0.1,";
    "Fxn:init.kaiming_normal(input_tensor,";
    "Fxn:init.kaiming_normal(input_tensor,";
    "Fxn:input_tensor.size(1)";
    "Fxn:input_tensor.size(0)";
    "Fxn:input_tensor.dim()";
    "Fxn:0].numel()";
    "Fxn:0].numel()";
    "Fxn:math.sqrt(2.0";
    "Fxn:self._is_normal(input_tensor,";
    "Fxn:test_sparse_only_works_on_2d_inputs";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:self._random_float(0.1,";
    "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:init.sparse(tensor,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_sparse_default_std";
    "Fxn:self._create_random_nd_tensor(2,";
    "Fxn:input_tensor.size(0),";
    "Fxn:input_tensor.size(1)";
    "Fxn:self._random_float(0.1,";
    "Fxn:self._random_float(0.01,";
    "Fxn:init.sparse(input_tensor,";
    "Fxn:init.sparse(input_tensor,";
    "Fxn:0].nelement()";
    "Fxn:math.ceil(sparsity";
    "Fxn:self._is_normal(input_tensor[input_tensor";
    "Fxn:test_orthogonal";
    "Fxn:torch.zeros(tensor_size)";
    "Fxn:Variable(input_tensor)";
    "Fxn:self._random_float(0.1,";
    "Fxn:init.orthogonal(input_tensor,";
    "Fxn:init.orthogonal(input_tensor)";
    "Fxn:reduce(mul,";
    "Fxn:input_tensor.view(rows,";
    "Fxn:self.assertEqual(torch.mm(flattened_tensor.t(),";
    "Fxn:torch.eye(cols)";
    "Fxn:self.assertEqual(torch.mm(flattened_tensor,";
    "Fxn:flattened_tensor.t()),";
    "Fxn:torch.eye(rows)";
    "Fxn:_rand_tensor_non_equal";
    "Fxn:reduce(mul,";
    "Fxn:torch.randperm(total).view(*size).double()";
    "Fxn:add_test";
    "Fxn:test.get_name()";
    "Fxn:RuntimeError('Found";
    "Fxn:RuntimeError('Found";
    "Fxn:test(self))";
    "Fxn:test_name.startswith("test_Hardshrink"):";
    "Fxn:test.test_cuda(self))";
    "Fxn:wrap_functional";
    "class:FunctionalModule(nn.Module):";
    "Fxn:forward";
    "Fxn:fn(*args,";
    "Fxn:torch.rand(15,";
    "Fxn:10).clamp_(1e-2,";
    "Fxn:torch.randn(15,";
    "Fxn:10).gt(0).double()";
    "Fxn:constructor_args=(torch.rand(10),),";
    "Fxn:torch.rand(15,";
    "Fxn:10).clamp_(1e-2,";
    "Fxn:torch.randn(15,";
    "Fxn:10).gt(0).double(),";
    "Fxn:constructor_args=(torch.rand(()),),";
    "Fxn:torch.rand(()).clamp_(1e-2,";
    "Fxn:torch.randn(()).gt(0).double(),";
    "Fxn:input_size=(2,";
    "Fxn:torch.rand(2,";
    "Fxn:5).mul(3).floor().long(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:size_average=get_size_average(m)),";
    "Fxn:input_size=(2,";
    "Fxn:target=torch.rand(2,";
    "Fxn:5).mul(3).floor().long(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:weight=get_weight(m)),";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(2,";
    "Fxn:torch.rand(2,";
    "Fxn:5).mul(3).floor().long(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:input_size=(2,";
    "Fxn:torch.rand(2,";
    "Fxn:2).mul(3).floor().long(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:size_average=get_size_average(m)),";
    "Fxn:input_size=(2,";
    "Fxn:torch.rand(2,";
    "Fxn:5).mul(3).floor().long(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:size_average=get_size_average(m)),";
    "Fxn:input_size=(2,";
    "Fxn:torch.randn(2,";
    "Fxn:5).floor_().abs_(),";
    "Fxn:constructor_args=(False,";
    "Fxn:torch.randn(2,";
    "Fxn:5).abs_().add_(0.001),";
    "Fxn:torch.randn(2,";
    "Fxn:5).floor_().abs_(),";
    "Fxn:input_size=(),";
    "Fxn:target_size=(),";
    "Fxn:i.numel()";
    "Fxn:t).abs().sum(),";
    "Fxn:torch.rand(()).log(),";
    "Fxn:torch.rand(()),";
    "Fxn:kldivloss_reference(i,";
    "Fxn:get_size_average(m),";
    "Fxn:input_size=(),";
    "Fxn:target_size=(),";
    "Fxn:t).abs().pow(2).sum()";
    "Fxn:get_size_average(m)";
    "Fxn:torch.rand(()).clamp_(1e-2,";
    "Fxn:torch.rand(()).gt(0).double(),";
    "Fxn:-((t";
    "Fxn:i.log()";
    "Fxn:i).log())";
    "Fxn:get_weight(m)).sum()";
    "Fxn:get_size_average(m)";
    "Fxn:constructor_args=(0.5,),";
    "Fxn:input_size=(),";
    "Fxn:torch.randn(()).gt(0).double().mul_(2).sub(1),";
    "Fxn:input_size=(),";
    "Fxn:target_size=(),";
    "Fxn:smoothl1loss_reference(i,";
    "Fxn:size_average=get_size_average(m)),";
    "Fxn:constructor_args=(torch.rand(10),),";
    "Fxn:torch.randn(5,";
    "Fxn:torch.rand(5,";
    "Fxn:10).mul(2).floor(),";
    "Fxn:-((t";
    "Fxn:i.sigmoid().log()";
    "Fxn:get_weight(m)).sum()";
    "Fxn:get_size_average(m)";
    "Fxn:poissonnllloss_no_reduce_test";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.poisson_nll_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.rand(10,";
    "Fxn:bceloss_no_reduce_test";
    "Fxn:Variable(torch.randn(15,";
    "Fxn:10).gt(0).double())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.binary_cross_entropy(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.rand(15,";
    "Fxn:10).clamp_(2.8e-2,";
    "Fxn:-(t";
    "Fxn:i.log()";
    "Fxn:i).log()),";
    "Fxn:bceloss_no_reduce_scalar_test";
    "Fxn:torch.randn(()).gt(0).double()";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.binary_cross_entropy(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.rand(()).clamp_(2.8e-2,";
    "Fxn:-(t";
    "Fxn:i.log()";
    "Fxn:i).log()),";
    "Fxn:bceloss_weights_no_reduce_test";
    "Fxn:Variable(torch.randn(15,";
    "Fxn:10).gt(0).double())";
    "Fxn:Variable(torch.rand(10))";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.binary_cross_entropy(i,";
    "Fxn:t.type_as(i),";
    "Fxn:weight=weights.type_as(i),";
    "Fxn:torch.rand(15,";
    "Fxn:10).clamp_(2.8e-2,";
    "Fxn:-(t";
    "Fxn:i.log()";
    "Fxn:i).log())";
    "Fxn:bceloss_weights_no_reduce_scalar_test";
    "Fxn:torch.randn(()).double()";
    "Fxn:torch.rand(())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.binary_cross_entropy(i,";
    "Fxn:t.type_as(i),";
    "Fxn:weight=weights.type_as(i),";
    "Fxn:torch.rand(()).clamp_(2.8e-2,";
    "Fxn:-(t";
    "Fxn:i.log()";
    "Fxn:i).log())";
    "Fxn:bce_with_logistic_no_reduce_test";
    "Fxn:Variable(torch.randn(15,";
    "Fxn:10).gt(0).double())";
    "Fxn:nn.Sigmoid()";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.binary_cross_entropy_with_logits(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.rand(15,";
    "Fxn:10).clamp_(2.8e-2,";
    "Fxn:-(t";
    "Fxn:sigmoid(i).log()";
    "Fxn:sigmoid(i)).log()),";
    "Fxn:bce_with_logistic_no_reduce_scalar_test";
    "Fxn:torch.randn(()).gt(0).double()";
    "Fxn:nn.Sigmoid()";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.binary_cross_entropy_with_logits(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.rand(()).clamp_(2.8e-2,";
    "Fxn:-(t";
    "Fxn:sigmoid(i).log()";
    "Fxn:sigmoid(i)).log()),";
    "Fxn:kldivloss_no_reduce_test";
    "Fxn:Variable(torch.randn(10,";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.kl_div(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.rand(10,";
    "Fxn:10).log(),";
    "Fxn:loss_reference_fns['KLDivLoss'](i,";
    "Fxn:t.type_as(i),";
    "Fxn:kldivloss_no_reduce_scalar_test";
    "Fxn:torch.randn(())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.kl_div(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.rand(()).log(),";
    "Fxn:loss_reference_fns['KLDivLoss'](i,";
    "Fxn:t.type_as(i),";
    "Fxn:l1loss_no_reduce_test";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.l1_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(2,";
    "Fxn:t.type_as(i)).abs(),";
    "Fxn:l1loss_no_reduce_scalar_test";
    "Fxn:torch.randn(())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.l1_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(()),";
    "Fxn:t.type_as(i)).abs(),";
    "Fxn:mseloss_no_reduce_test";
    "Fxn:Variable(torch.randn(*input_size))";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.mse_loss(i,";
    "Fxn:target.type_as(i),";
    "Fxn:target).pow(2),";
    "Fxn:mseloss_no_reduce_scalar_test";
    "Fxn:torch.randn(input_size)";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.mse_loss(i,";
    "Fxn:target.type_as(i),";
    "Fxn:target).pow(2),";
    "Fxn:nllloss_no_reduce_test";
    "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.rand(15,";
    "Fxn:10).log(),";
    "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss_no_reduce_ignore_index_test";
    "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.rand(15,";
    "Fxn:10).log(),";
    "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss_no_reduce_weights_test";
    "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:Variable(torch.rand(10))";
    "Fxn:kwargs";
    "Fxn:weight.type_as(i),";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i))),";
    "Fxn:torch.rand(15,";
    "Fxn:10).add(1e-2).log(),";
    "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i)),";
    "Fxn:nllloss_no_reduce_weights_ignore_index_test";
    "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:Variable(torch.rand(10))";
    "Fxn:kwargs";
    "Fxn:weight.type_as(i),";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i.data))),";
    "Fxn:torch.rand(15,";
    "Fxn:10).add(1e-2).log(),";
    "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i)),";
    "Fxn:nllloss_no_reduce_weights_ignore_index_neg_test";
    "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:Variable(torch.rand(10))";
    "Fxn:kwargs";
    "Fxn:weight.type_as(i),";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i))),";
    "Fxn:input=torch.rand(15,";
    "Fxn:10).add(1e-2).log(),";
    "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i)),";
    "Fxn:nllloss2d_no_reduce_test";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:5).mul(3).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.rand(2,";
    "Fxn:5).log(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss2d_no_reduce_ignore_index_test";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:5).mul(3).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.rand(2,";
    "Fxn:5).log(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss2d_no_reduce_weights_test";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:5).mul(3).floor().long())";
    "Fxn:torch.rand(3)";
    "Fxn:kwargs";
    "Fxn:weight.type_as(i),";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i))),";
    "Fxn:torch.rand(2,";
    "Fxn:5).log(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i)),";
    "Fxn:nlllossNd_no_reduce_test";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:2).mul(3).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.rand(2,";
    "Fxn:2).log(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:nlllossNd_no_reduce_ignore_index_test";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:2).mul(3).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.rand(2,";
    "Fxn:2).log(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:nlllossNd_no_reduce_weights_test";
    "Fxn:Variable(torch.rand(2,";
    "Fxn:2).mul(3).floor().long())";
    "Fxn:Variable(torch.rand(3))";
    "Fxn:kwargs";
    "Fxn:weight.type_as(i),";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.nll_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i))),";
    "Fxn:torch.rand(2,";
    "Fxn:2).log(),";
    "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:**kwargs(i)),";
    "Fxn:smoothl1loss_no_reduce_test";
    "Fxn:Variable(torch.randn(2,";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.smooth_l1_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(2,";
    "Fxn:loss_reference_fns['SmoothL1Loss'](i,";
    "Fxn:t.type_as(i),";
    "Fxn:smoothl1loss_no_reduce_scalar_test";
    "Fxn:torch.randn(())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.smooth_l1_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(()),";
    "Fxn:loss_reference_fns['SmoothL1Loss'](i,";
    "Fxn:t.type_as(i),";
    "Fxn:multilabelmarginloss_1d_no_reduce_test";
    "Fxn:Variable(torch.rand(10).mul(10).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multilabel_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.randn(10),";
    "Fxn:loss_reference_fns['MultiLabelMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:multilabelmarginloss_index_neg_test";
    "Fxn:Variable(torch.clamp(torch.rand(5,";
    "Fxn:10).add(-.5).mul(20).floor().long(),";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multilabel_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.randn(5,";
    "Fxn:loss_reference_fns['MultiLabelMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:multilabelmarginloss_no_reduce_test";
    "Fxn:Variable(torch.rand(5,";
    "Fxn:10).mul(10).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multilabel_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.randn(5,";
    "Fxn:loss_reference_fns['MultiLabelMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:hingeembeddingloss_no_reduce_test";
    "Fxn:Variable(torch.randn(10).gt(0).double().mul_(2).sub(1))";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.hinge_embedding_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(10),";
    "Fxn:loss_reference_fns['HingeEmbeddingLoss'](i,";
    "Fxn:t.type_as(i),";
    "Fxn:hingeembeddingloss_margin_no_reduce_test";
    "Fxn:Variable(torch.randn(10).gt(0).double().mul_(2).sub(1))";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.hinge_embedding_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(10),";
    "Fxn:loss_reference_fns['HingeEmbeddingLoss'](i,";
    "Fxn:t.type_as(i),";
    "Fxn:softmarginloss_no_reduce_test";
    "Fxn:Variable(torch.randn(5,";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.soft_margin_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(5,";
    "Fxn:loss_reference_fns['SoftMarginLoss'](i,";
    "Fxn:t.type_as(i),";
    "Fxn:multilabelsoftmarginloss_no_reduce_test";
    "Fxn:Variable(torch.rand(5,";
    "Fxn:10).mul(2).floor())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multilabel_soft_margin_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:torch.randn(5,";
    "Fxn:i.sigmoid().log()";
    "Fxn:get_size_average(m)";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test";
    "Fxn:Variable(torch.rand(5,";
    "Fxn:10).mul(2).floor())";
    "Fxn:Variable(torch.rand(10))";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multilabel_soft_margin_loss(i,";
    "Fxn:t.type_as(i),";
    "Fxn:weight=weights.type_as(i),";
    "Fxn:torch.randn(5,";
    "Fxn:i.sigmoid().log()";
    "Fxn:get_size_average(m)";
    "Fxn:multimarginloss_no_reduce_test";
    "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multi_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.randn(5,";
    "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_1d_no_reduce_test";
    "Fxn:Variable(torch.rand(1).mul(8).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multi_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.randn(10),";
    "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_p_no_reduce_test";
    "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multi_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.randn(5,";
    "Fxn:10).clamp_(1e-2,";
    "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_margin_no_reduce_test";
    "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multi_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:torch.randn(5,";
    "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_weights_no_reduce_test";
    "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:Variable(torch.rand(10))";
    "Fxn:constructor=wrap_functional(";
    "Fxn:F.multi_margin_loss(i,";
    "Fxn:t.type_as(i).long(),";
    "Fxn:weight=weights.type_as(i),";
    "Fxn:torch.randn(5,";
    "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:t.data.type_as(i).long(),";
    "Fxn:poissonnllloss_no_reduce_test(),";
    "Fxn:bceloss_no_reduce_test(),";
    "Fxn:bceloss_weights_no_reduce_test(),";
    "Fxn:bce_with_logistic_no_reduce_test(),";
    "Fxn:bceloss_no_reduce_scalar_test(),";
    "Fxn:bceloss_weights_no_reduce_scalar_test(),";
    "Fxn:bce_with_logistic_no_reduce_scalar_test(),";
    "Fxn:kldivloss_no_reduce_test(),";
    "Fxn:kldivloss_no_reduce_scalar_test(),";
    "Fxn:l1loss_no_reduce_test(),";
    "Fxn:l1loss_no_reduce_scalar_test(),";
    "Fxn:mseloss_no_reduce_test(),";
    "Fxn:mseloss_no_reduce_scalar_test(),";
    "Fxn:nllloss_no_reduce_test(),";
    "Fxn:nllloss_no_reduce_ignore_index_test(),";
    "Fxn:nllloss_no_reduce_weights_test(),";
    "Fxn:nllloss_no_reduce_weights_ignore_index_test(),";
    "Fxn:nllloss_no_reduce_weights_ignore_index_neg_test(),";
    "Fxn:nllloss2d_no_reduce_test(),";
    "Fxn:nllloss2d_no_reduce_weights_test(),";
    "Fxn:nllloss2d_no_reduce_ignore_index_test(),";
    "Fxn:nlllossNd_no_reduce_test(),";
    "Fxn:nlllossNd_no_reduce_weights_test(),";
    "Fxn:nlllossNd_no_reduce_ignore_index_test(),";
    "Fxn:smoothl1loss_no_reduce_test(),";
    "Fxn:smoothl1loss_no_reduce_scalar_test(),";
    "Fxn:multilabelmarginloss_1d_no_reduce_test(),";
    "Fxn:multilabelmarginloss_index_neg_test(),";
    "Fxn:multilabelmarginloss_no_reduce_test(),";
    "Fxn:hingeembeddingloss_no_reduce_test(),";
    "Fxn:hingeembeddingloss_margin_no_reduce_test(),";
    "Fxn:softmarginloss_no_reduce_test(),";
    "Fxn:multilabelsoftmarginloss_no_reduce_test(),";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test(),";
    "Fxn:multimarginloss_no_reduce_test(),";
    "Fxn:multimarginloss_1d_no_reduce_test(),";
    "Fxn:multimarginloss_p_no_reduce_test(),";
    "Fxn:multimarginloss_margin_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test(),";
    "Fxn:constructor_args=(10,),";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(5,),";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(10,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(10,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(5,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=([5],";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=([5],";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=([5],";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=([2,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=([2,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=([2,";
    "Fxn:input_size=(4,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(1,";
    "Fxn:nn.Conv1d(4,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv1d(4,";
    "Fxn:input_size=(2,";
    "Fxn:nn.ConvTranspose1d(3,";
    "Fxn:stride=(3,),";
    "Fxn:output_padding=(1,)),";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:nn.ConvTranspose1d(4,";
    "Fxn:stride=(3,),";
    "Fxn:output_padding=(1,),";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,),";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv2d(4,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv2d(4,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:nn.ConvTranspose2d(2,";
    "Fxn:input_size=(1,";
    "Fxn:nn.Conv2d(4,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv2d(4,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv2d(4,";
    "Fxn:stride=(2,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv2d(4,";
    "Fxn:padding=(1,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv2d(4,";
    "Fxn:dilation=(2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((3,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(2,),";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((2,),";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(1.5,";
    "Fxn:torch.rand(1,";
    "Fxn:constructor_args=(1.5,";
    "Fxn:torch.rand(1,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(1,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((-1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv3d(4,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv3d(3,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Conv3d(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=((1,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(4,";
    "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:constructor_args=(4,";
    "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:nn.EmbeddingBag(4,";
    "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:nn.Embedding(4,";
    "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:nn.FractionalMaxPool2d(";
    "Fxn:_random_samples=torch.DoubleTensor(1,";
    "Fxn:2).uniform_()),";
    "Fxn:input_size=(1,";
    "Fxn:nn.FractionalMaxPool2d((2,";
    "Fxn:output_size=(";
    "Fxn:_random_samples=torch.DoubleTensor(1,";
    "Fxn:2).uniform_()),";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(3,),";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((4,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((4,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(12,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=((4,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(None,";
    "Fxn:input_size=(1,";
    "Fxn:constructor_args=(3,),";
    "Fxn:_rand_tensor_non_equal(1,";
    "Fxn:constructor_args=(3,),";
    "Fxn:_rand_tensor_non_equal(1,";
    "Fxn:constructor_args=((3,";
    "Fxn:_rand_tensor_non_equal(1,";
    "Fxn:constructor_args=(3,),";
    "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:constructor_args=((3,";
    "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:constructor_args=(3,),";
    "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:constructor_args=((3,";
    "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:constructor_args=(3,),";
    "Fxn:torch.rand(1,";
    "Fxn:constructor_args=(3,),";
    "Fxn:torch.rand(1,";
    "Fxn:constructor_args=((3,";
    "Fxn:torch.rand(1,";
    "Fxn:constructor_args=(3,),";
    "Fxn:torch.rand(2,";
    "Fxn:constructor_args=((3,";
    "Fxn:torch.rand(2,";
    "Fxn:input_size=(3,";
    "Fxn:input_size=(),";
    "Fxn:input_size=(5,";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(5,";
    "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:input_size=(),";
    "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:input_size=(2,";
    "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:input_size=(),";
    "Fxn:nn.Unfold((2,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Fold((3,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Unfold(2,";
    "Fxn:input_size=(2,";
    "Fxn:nn.Fold(3,";
    "Fxn:input_size=(2,";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(),";
    "Fxn:input_size=(),";
    "Fxn:input_size=(),";
    "Fxn:constructor_args=(0.1,";
    "Fxn:input_size=(),";
    "Fxn:input_size=(),";
    "Fxn:i.clamp(-1,";
    "Fxn:input_size=(),";
    "Fxn:input_size=(),";
    "Fxn:constructor_args=(0,),";
    "Fxn:input_size=(),";
    "Fxn:torch.exp(i).div(torch.exp(i).sum(0,";
    "Fxn:constructor_args=(0,),";
    "Fxn:input_size=(),";
    "Fxn:torch.exp(i).div_(torch.exp(i).sum(0,";
    "Fxn:False)).log_(),";
    "Fxn:constructor_args=(2.,),";
    "Fxn:input_size=(),";
    "Fxn:constructor_args=(2.,),";
    "Fxn:input_size=(),";
    "Fxn:constructor_args=(0.5,),";
    "Fxn:input_size=(),";
    "Fxn:input_size=(),";
    "Fxn:i.sigmoid().log(),";
    "Fxn:constructor_args=(2,";
    "Fxn:input_size=(),";
    "Fxn:reference_fn=(lambda";
    "Fxn:-100).type_as(i)";
    "Fxn:-100).type_as(i)";
    "Fxn:torch.log(1";
    "Fxn:torch.exp(2";
    "Fxn:constructor_args=(1,),";
    "Fxn:input_size=(),";
    "Fxn:input_size=(),";
    "Fxn:torch.clamp(i,";
    "Fxn:torch.clamp(i,";
    "Fxn:input_size=(),";
    "Fxn:i.div(1";
    "Fxn:torch.abs(i)),";
    "Fxn:constructor_args=(0,),";
    "Fxn:input_size=(),";
    "Fxn:input_size=(),";
    "Fxn:test_params.pop('module_name')";
    "Fxn:NewModuleTest(**test_params)";
    "Fxn:add_test(test)";
    "Fxn:test_params.get('desc',";
    "Fxn:gen_eval_constructor";
    "Fxn:eval_constructor";
    "Fxn:constructor(*args,";
    "Fxn:gen_eval_constructor(test_params['constructor'])";
    "Fxn:NewModuleTest(**test_params)";
    "Fxn:add_test(test)";
    "Fxn:test_params.pop('module_name')";
    "Fxn:NewCriterionTest(**test_params)";
    "Fxn:add_test(test)";
    "Fxn:test_params.get('desc',";
    "Fxn:gen_no_size_average_constructor";
    "Fxn:no_size_average_constructor";
    "Fxn:constructor(*args,";
    "Fxn:gen_no_size_average_constructor(test_params['constructor'])";
    "Fxn:NewCriterionTest(**test_params)";
    "Fxn:add_test(test)";
    "class:UnpoolingNet(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:self.unpool(*self.pool(input))";
    "Fxn:add_test(NewModuleTest(";
    "Fxn:UnpoolingNet(";
    "Fxn:nn.MaxPool1d(2,";
    "Fxn:nn.MaxUnpool1d(2)),";
    "Fxn:input_size=(1,";
    "Fxn:add_test(NewModuleTest(";
    "Fxn:UnpoolingNet(";
    "Fxn:nn.MaxPool2d(2,";
    "Fxn:nn.MaxUnpool2d(2)),";
    "Fxn:input_size=(1,";
    "Fxn:add_test(NewModuleTest(";
    "Fxn:UnpoolingNet(";
    "Fxn:nn.MaxPool3d(2,";
    "Fxn:nn.MaxUnpool3d(2)),";
    "Fxn:input_size=(1,";
    "Fxn:run_tests()";
    "/test/test_optim.py";
    "Import:math";
    "Import:unittest";
    "Import:functools";
    "Import:deepcopy";
    "Import:torch";
    "Import:torch.optim";
    "Import:torch.legacy.optim";
    "Import:torch.nn.functional";
    "Import:SGD";
    "Import:Variable";
    "Import:sparse";
    "Import:LambdaLR,";
    "Import:TestCase,";
    "Fxn:rosenbrock";
    "Fxn:drosenbrock";
    "Fxn:wrap_old_fn";
    "Fxn:wrapper";
    "class:TestOptim(TestCase):";
    "Fxn:_test_rosenbrock";
    "Fxn:torch.Tensor([1.5,";
    "Fxn:Variable(torch.Tensor([1.5,";
    "Fxn:constructor([params])";
    "Fxn:torch.Tensor([1,";
    "Fxn:params.data.dist(solution)";
    "Fxn:eval";
    "Fxn:optimizer.zero_grad()";
    "Fxn:rosenbrock(params)";
    "Fxn:loss.backward()";
    "Fxn:loss.backward()";
    "Fxn:params.grad.data.copy_(drosenbrock(params.data))";
    "Fxn:optimizer.step(eval)";
    "Fxn:old_fn(lambda";
    "Fxn:drosenbrock(params_t)),";
    "Fxn:self.assertEqual(params.data,";
    "Fxn:self.assertLessEqual(params.data.dist(solution),";
    "Fxn:_test_rosenbrock_sparse";
    "Fxn:torch.Tensor([1.5,";
    "Fxn:Variable(params_t,";
    "Fxn:constructor([params])";
    "Fxn:Variable(params_t.clone(),";
    "Fxn:constructor([params_c])";
    "Fxn:torch.Tensor([1,";
    "Fxn:params.data.dist(solution)";
    "Fxn:eval";
    "Fxn:optimizer.zero_grad()";
    "Fxn:rosenbrock(params)";
    "Fxn:loss.backward()";
    "Fxn:drosenbrock(params.data)";
    "Fxn:torch.LongTensor([[0,";
    "Fxn:torch.DoubleTensor([x";
    "Fxn:torch.LongTensor([[1,";
    "Fxn:torch.DoubleTensor([y";
    "Fxn:sparse.DoubleTensor(i,";
    "Fxn:torch.Size([2]))";
    "Fxn:x.to_dense()";
    "Fxn:optimizer.step(functools.partial(eval,";
    "Fxn:optimizer_c.step(functools.partial(eval,";
    "Fxn:self.assertEqual(params.data,";
    "Fxn:self.assertLessEqual(params.data.dist(solution),";
    "Fxn:_test_basic_cases_template";
    "Fxn:Variable(weight,";
    "Fxn:Variable(bias,";
    "Fxn:Variable(input)";
    "Fxn:constructor(weight,";
    "Fxn:optimizer.__repr__()";
    "Fxn:fn";
    "Fxn:optimizer.zero_grad()";
    "Fxn:weight.mv(input)";
    "Fxn:y.get_device()";
    "Fxn:bias.get_device():";
    "Fxn:y.cuda(bias.get_device())";
    "Fxn:bias).pow(2).sum()";
    "Fxn:loss.backward()";
    "Fxn:fn().item()";
    "Fxn:optimizer.step(fn)";
    "Fxn:self.assertLess(fn().item(),";
    "Fxn:_test_state_dict";
    "Fxn:Variable(weight,";
    "Fxn:Variable(bias,";
    "Fxn:Variable(input)";
    "Fxn:fn_base";
    "Fxn:optimizer.zero_grad()";
    "Fxn:bias).pow(2).sum()";
    "Fxn:loss.backward()";
    "Fxn:constructor(weight,";
    "Fxn:functools.partial(fn_base,";
    "Fxn:optimizer.step(fn)";
    "Fxn:Variable(weight.data.clone(),";
    "Fxn:Variable(bias.data.clone(),";
    "Fxn:constructor(weight_c,";
    "Fxn:functools.partial(fn_base,";
    "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:optimizer_c.load_state_dict(state_dict_c)";
    "Fxn:optimizer.step(fn)";
    "Fxn:optimizer_c.step(fn_c)";
    "Fxn:self.assertEqual(weight,";
    "Fxn:self.assertEqual(bias,";
    "Fxn:self.assertEqual(state_dict,";
    "Fxn:torch.cuda.is_available():";
    "Fxn:Variable(input.data.float().cuda())";
    "Fxn:Variable(weight.data.float().cuda(),";
    "Fxn:Variable(bias.data.float().cuda(),";
    "Fxn:constructor(weight_cuda,";
    "Fxn:functools.partial(fn_base,";
    "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:optimizer_cuda.load_state_dict(state_dict_c)";
    "Fxn:self.assertEqual(state_dict,";
    "Fxn:optimizer.step(fn)";
    "Fxn:optimizer_cuda.step(fn_cuda)";
    "Fxn:self.assertEqual(weight,";
    "Fxn:self.assertEqual(bias,";
    "Fxn:_test_basic_cases";
    "Fxn:self._test_state_dict(";
    "Fxn:torch.randn(10,";
    "Fxn:torch.randn(10),";
    "Fxn:torch.randn(5),";
    "Fxn:self._test_basic_cases_template(";
    "Fxn:torch.randn(10,";
    "Fxn:torch.randn(10),";
    "Fxn:torch.randn(5),";
    "Fxn:self._test_basic_cases_template(";
    "Fxn:torch.randn(10,";
    "Fxn:torch.randn(10,";
    "Fxn:torch.randn(5),";
    "Fxn:torch.cuda.is_available():";
    "Fxn:self._test_basic_cases_template(";
    "Fxn:torch.randn(10,";
    "Fxn:5).cuda(),";
    "Fxn:torch.randn(10).cuda(),";
    "Fxn:torch.randn(5).cuda(),";
    "Fxn:torch.cuda.device_count()";
    "Fxn:self._test_basic_cases_template(";
    "Fxn:torch.randn(10,";
    "Fxn:5).cuda(0),";
    "Fxn:torch.randn(10).cuda(1),";
    "Fxn:torch.randn(5).cuda(0),";
    "Fxn:_build_params_dict";
    "Fxn:[dict(params=[weight]),";
    "Fxn:_build_params_dict_single";
    "Fxn:[dict(params=bias,";
    "Fxn:test_sgd";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.SGD(params,";
    "Fxn:wrap_old_fn(old_optim.sgd,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.SGD(params,";
    "Fxn:wrap_old_fn(old_optim.sgd,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.SGD([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.SGD(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.SGD(";
    "Fxn:self._build_params_dict_single(weight,";
    "Fxn:test_sgd_sparse";
    "Fxn:self._test_rosenbrock_sparse(";
    "Fxn:optim.SGD(params,";
    "Fxn:test_adam";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adam(params,";
    "Fxn:wrap_old_fn(old_optim.adam,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adam(params,";
    "Fxn:wrap_old_fn(old_optim.adam,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adam([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adam(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adam([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adam(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:self.assertRaisesRegex(ValueError,";
    "Fxn:optim.Adam(None,";
    "Fxn:betas=(1.0,";
    "Fxn:test_sparse_adam";
    "Fxn:self._test_rosenbrock_sparse(";
    "Fxn:optim.SparseAdam(params,";
    "Fxn:test_adadelta";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adadelta(params),";
    "Fxn:wrap_old_fn(old_optim.adadelta)";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adadelta(params,";
    "Fxn:wrap_old_fn(old_optim.adadelta,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adadelta(params,";
    "Fxn:wrap_old_fn(old_optim.adadelta,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adadelta([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adadelta(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:test_adagrad";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adagrad(params,";
    "Fxn:wrap_old_fn(old_optim.adagrad,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adagrad(params,";
    "Fxn:wrap_old_fn(old_optim.adagrad,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adagrad(params,";
    "Fxn:wrap_old_fn(old_optim.adagrad,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adagrad([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adagrad(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:test_adagrad_sparse";
    "Fxn:self._test_rosenbrock_sparse(";
    "Fxn:optim.Adagrad(params,";
    "Fxn:test_adamax";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adamax(params,";
    "Fxn:wrap_old_fn(old_optim.adamax,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adamax(params,";
    "Fxn:wrap_old_fn(old_optim.adamax,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Adamax(params,";
    "Fxn:betas=(0.95,";
    "Fxn:wrap_old_fn(old_optim.adamax,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adagrad([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adagrad(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:test_rmsprop";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.RMSprop(params,";
    "Fxn:wrap_old_fn(old_optim.rmsprop,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.RMSprop(params,";
    "Fxn:wrap_old_fn(old_optim.rmsprop,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.RMSprop(params,";
    "Fxn:wrap_old_fn(old_optim.rmsprop,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adagrad([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Adagrad(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:test_asgd";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.ASGD(params,";
    "Fxn:wrap_old_fn(old_optim.asgd,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.ASGD(params,";
    "Fxn:wrap_old_fn(old_optim.asgd,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.ASGD(params,";
    "Fxn:wrap_old_fn(old_optim.asgd,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.ASGD([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.ASGD(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:test_rprop";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Rprop(params,";
    "Fxn:wrap_old_fn(old_optim.rprop,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Rprop(params,";
    "Fxn:etas=(0.6,";
    "Fxn:wrap_old_fn(old_optim.rprop,";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.Rprop(params,";
    "Fxn:step_sizes=(1e-4,";
    "Fxn:wrap_old_fn(old_optim.rprop,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Rprop([weight,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.Rprop(";
    "Fxn:self._build_params_dict(weight,";
    "Fxn:test_lbfgs";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.LBFGS(params),";
    "Fxn:wrap_old_fn(old_optim.lbfgs)";
    "Fxn:self._test_rosenbrock(";
    "Fxn:optim.LBFGS(params,";
    "Fxn:wrap_old_fn(old_optim.lbfgs,";
    "Fxn:self._test_basic_cases(";
    "Fxn:optim.LBFGS([weight,";
    "Fxn:test_invalid_param_type";
    "Fxn:self.assertRaises(TypeError):";
    "Fxn:optim.SGD(Variable(torch.randn(5,";
    "class:SchedulerTestNet(torch.nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.nn.Conv2d(1,";
    "Fxn:torch.nn.Conv2d(1,";
    "Fxn:forward";
    "Fxn:self.conv2(F.relu(self.conv1(x)))";
    "class:TestLRScheduler(TestCase):";
    "Fxn:setUp";
    "Fxn:SchedulerTestNet()";
    "Fxn:SGD(";
    "Fxn:self.net.conv1.parameters()},";
    "Fxn:self.net.conv2.parameters(),";
    "Fxn:test_step_lr";
    "Fxn:StepLR(self.opt,";
    "Fxn:self._test(scheduler,";
    "Fxn:test_multi_step_lr";
    "Fxn:MultiStepLR(self.opt,";
    "Fxn:self._test(scheduler,";
    "Fxn:test_exp_lr";
    "Fxn:ExponentialLR(self.opt,";
    "Fxn:self._test(scheduler,";
    "Fxn:test_cos_anneal_lr";
    "Fxn:math.cos(math.pi";
    "Fxn:CosineAnnealingLR(self.opt,";
    "Fxn:self._test(scheduler,";
    "Fxn:test_reduce_lr_on_plateau1";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau2";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau3";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau4";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau5";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau6";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau7";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau8";
    "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_lambda_lr";
    "Fxn:LambdaLR(self.opt,";
    "Fxn:self._test(scheduler,";
    "Fxn:_test";
    "Fxn:scheduler.step(epoch)";
    "Fxn:self.assertAlmostEqual(target[epoch],";
    "Fxn:{}'.format(";
    "Fxn:_test_reduce_lr_on_plateau";
    "Fxn:scheduler.step(metrics[epoch])";
    "Fxn:self.assertAlmostEqual(target[epoch],";
    "Fxn:{}'.format(";
    "Fxn:run_tests()";
    "/test/test_sparse.py";
    "Import:torch";
    "Import:sparse";
    "Import:itertools";
    "Import:random";
    "Import:unittest";
    "Import:TestCase,";
    "Import:TEST_CUDA";
    "Import:TestTorch";
    "Import:Number";
    "Fxn:cpu_only";
    "Fxn:outer";
    "Fxn:cuda_only";
    "Fxn:outer";
    "class:TestSparse(TestCase):";
    "Fxn:setUp";
    "Fxn:self).setUp()";
    "Fxn:_gen_sparse";
    "Fxn:torch.randn(*v_size)";
    "Fxn:torch.rand(d,";
    "Fxn:torch.cat([r,";
    "Fxn:torch.Tensor(with_size[:d]).repeat(nnz";
    "Fxn:1).transpose(0,";
    "Fxn:i.type(torch.LongTensor)";
    "Fxn:torch.sparse.DoubleTensor(i,";
    "Fxn:torch.Size(with_size))";
    "Fxn:self.assert_uncoalesced(x)";
    "Fxn:torch.randn(*v_size)";
    "Fxn:torch.rand(d,";
    "Fxn:torch.Tensor(with_size[:d]).repeat(nnz,";
    "Fxn:1).transpose(0,";
    "Fxn:i.type(torch.LongTensor)";
    "Fxn:torch.sparse.DoubleTensor(i,";
    "Fxn:torch.Size(with_size))";
    "Fxn:x.cuda(),";
    "Fxn:i.cuda(),";
    "Fxn:v.cuda()";
    "Fxn:i.clone(),";
    "Fxn:v.clone()";
    "Fxn:assert_uncoalesced";
    "Fxn:x.is_coalesced()";
    "Fxn:x._indices().clone()";
    "Fxn:x._values().clone().fill_(1)";
    "Fxn:torch.sparse.DoubleTensor(i,";
    "Fxn:x.size())";
    "Fxn:self.safeCoalesce(y)";
    "Fxn:1).sum()";
    "Fxn:randn";
    "Fxn:self.ValueTensor(*args,";
    "Fxn:**kwargs).normal_()";
    "Fxn:test_basic";
    "Fxn:self._gen_sparse(3,";
    "Fxn:self.assertEqual(i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(v,";
    "Fxn:x._values())";
    "Fxn:self._gen_sparse(3,";
    "Fxn:self.assertEqual(i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(v,";
    "Fxn:x._values())";
    "Fxn:self.assertEqual(x.ndimension(),";
    "Fxn:self.assertEqual(self.safeCoalesce(x)._nnz(),";
    "Fxn:self.assertEqual(x.size(i),";
    "Fxn:self.IndexTensor([[9,";
    "Fxn:self.ValueTensor([[idx**2,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([10,";
    "Fxn:self.assertEqual(self.safeCoalesce(x)._nnz(),";
    "Fxn:self.SparseTensor()";
    "Fxn:self.assertEqual(x._indices().numel(),";
    "Fxn:self.assertEqual(x._values().numel(),";
    "Fxn:test_ctor_size_checks";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([2,";
    "Fxn:self.assertRaises(";
    "Fxn:self.SparseTensor(indices,";
    "Fxn:torch.Size([2,";
    "Fxn:self.ValueTensor([";
    "Fxn:self.assertRaises(";
    "Fxn:self.SparseTensor(indices,";
    "Fxn:torch.Size([2,";
    "Fxn:test_to_dense";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([2,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3,";
    "Fxn:self.ValueTensor([";
    "Fxn:x.to_dense()";
    "Fxn:x.to_dense()";
    "Fxn:x.to_dense()";
    "Fxn:self.assertEqual(res,";
    "Fxn:x.to_dense())";
    "Fxn:self.assertEqual(res,";
    "Fxn:self.safeToDense(x))";
    "Fxn:test_shared";
    "Fxn:self.IndexTensor([[2]])";
    "Fxn:self.ValueTensor([5])";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3]))";
    "Fxn:self.assertEqual(self.ValueTensor([0,";
    "Fxn:self.safeToDense(x))";
    "Fxn:self.assertEqual(self.ValueTensor([6,";
    "Fxn:self.safeToDense(x))";
    "Fxn:test_to_dense_hybrid";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([[2,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3,";
    "Fxn:self.ValueTensor([";
    "Fxn:x.to_dense()";
    "Fxn:x.to_dense()";
    "Fxn:x.to_dense()";
    "Fxn:self.assertEqual(res,";
    "Fxn:x.to_dense())";
    "Fxn:self.assertEqual(res,";
    "Fxn:self.safeToDense(x))";
    "Fxn:test_contig";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([1,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([100,";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([2,";
    "Fxn:self.safeCoalesce(x)";
    "Fxn:self.assertEqual(exp_i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(exp_v,";
    "Fxn:x._values())";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3,";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([2,";
    "Fxn:self.safeCoalesce(x)";
    "Fxn:self.assertEqual(exp_i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(exp_v,";
    "Fxn:x._values())";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3,";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([6,";
    "Fxn:self.safeCoalesce(x)";
    "Fxn:self.assertEqual(exp_i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(exp_v,";
    "Fxn:x._values())";
    "Fxn:test_contig_hybrid";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([100,";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([";
    "Fxn:self.safeCoalesce(x)";
    "Fxn:self.assertEqual(exp_i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(exp_v,";
    "Fxn:x._values())";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([[3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3,";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([[2,";
    "Fxn:self.safeCoalesce(x)";
    "Fxn:self.assertEqual(exp_i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(exp_v,";
    "Fxn:x._values())";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([[3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3,";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([[6,";
    "Fxn:self.safeCoalesce(x)";
    "Fxn:self.assertEqual(exp_i,";
    "Fxn:x._indices())";
    "Fxn:self.assertEqual(exp_v,";
    "Fxn:x._values())";
    "Fxn:test_clone";
    "Fxn:self._gen_sparse(4,";
    "Fxn:self.assertFalse(x.is_coalesced())";
    "Fxn:x.clone()";
    "Fxn:self.assertFalse(y.is_coalesced())";
    "Fxn:x.coalesce()";
    "Fxn:self.assertTrue(x.is_coalesced())";
    "Fxn:x.clone()";
    "Fxn:self.assertTrue(y.is_coalesced())";
    "Fxn:test_cuda_empty";
    "Fxn:torch.sparse.FloatTensor(2,";
    "Fxn:x.cuda(0)";
    "Fxn:self.assertEqual(x._dimI(),";
    "Fxn:y._dimI())";
    "Fxn:self.assertEqual(x._dimV(),";
    "Fxn:y._dimV())";
    "Fxn:y.cpu()";
    "Fxn:self.assertEqual(y._dimI(),";
    "Fxn:x._dimI())";
    "Fxn:self.assertEqual(y._dimV(),";
    "Fxn:x._dimV())";
    "Fxn:test_transpose";
    "Fxn:self._gen_sparse(4,";
    "Fxn:self.safeToDense(x)";
    "Fxn:itertools.combinations(range(4),";
    "Fxn:x.transpose_(i,";
    "Fxn:y.transpose(i,";
    "Fxn:self.assertEqual(self.safeToDense(x),";
    "Fxn:x.transpose(i,";
    "Fxn:y.transpose(i,";
    "Fxn:self.assertEqual(self.safeToDense(x),";
    "Fxn:test_transpose_coalesce_invariant";
    "Fxn:self._gen_sparse(2,";
    "Fxn:4)[0].coalesce()";
    "Fxn:x_coalesced._indices()";
    "Fxn:x_coalesced._values()";
    "Fxn:self.SparseTensor(";
    "Fxn:torch.cat([x_indices,";
    "Fxn:torch.cat([x_values,";
    "Fxn:x_coalesced.size())";
    "Fxn:self.assertTrue(x_coalesced.is_coalesced())";
    "Fxn:self.assertFalse(y_uncoalesced.is_coalesced())";
    "Fxn:self.assertTrue(x_coalesced.transpose(0,";
    "Fxn:1).is_coalesced())";
    "Fxn:self.assertFalse(y_uncoalesced.transpose(0,";
    "Fxn:1).is_coalesced())";
    "Fxn:x_coalesced.transpose_(0,";
    "Fxn:y_uncoalesced.transpose_(0,";
    "Fxn:self.assertTrue(x_coalesced.is_coalesced())";
    "Fxn:self.assertFalse(y_uncoalesced.is_coalesced())";
    "Fxn:test_mm";
    "Fxn:test_shape";
    "Fxn:self._gen_sparse(2,";
    "Fxn:torch.randn(di,";
    "Fxn:torch.randn(dj,";
    "Fxn:random.random()";
    "Fxn:random.random()";
    "Fxn:torch.addmm(alpha,";
    "Fxn:torch.addmm(alpha,";
    "Fxn:self.safeToDense(x),";
    "Fxn:self.assertEqual(res,";
    "Fxn:torch.addmm(t,";
    "Fxn:torch.addmm(t,";
    "Fxn:self.safeToDense(x),";
    "Fxn:self.assertEqual(res,";
    "Fxn:torch.mm(x,";
    "Fxn:torch.mm(self.safeToDense(x),";
    "Fxn:self.assertEqual(res,";
    "Fxn:test_shape(10,";
    "Fxn:test_shape(100,";
    "Fxn:test_shape(64,";
    "Fxn:test_saddmm";
    "Fxn:test_shape";
    "Fxn:self._gen_sparse(2,";
    "Fxn:self._gen_sparse(2,";
    "Fxn:torch.randn(dj,";
    "Fxn:random.random()";
    "Fxn:random.random()";
    "Fxn:torch.saddmm(alpha,";
    "Fxn:torch.addmm(alpha,";
    "Fxn:self.safeToDense(t),";
    "Fxn:self.safeToDense(x),";
    "Fxn:self.assertEqual(self.safeToDense(res),";
    "Fxn:torch.saddmm(t,";
    "Fxn:torch.addmm(self.safeToDense(t),";
    "Fxn:self.safeToDense(x),";
    "Fxn:self.assertEqual(self.safeToDense(res),";
    "Fxn:torch.smm(x,";
    "Fxn:torch.mm(self.safeToDense(x),";
    "Fxn:self.assertEqual(self.safeToDense(res),";
    "Fxn:test_shape(7,";
    "Fxn:test_shape(1000,";
    "Fxn:test_shape(3000,";
    "Fxn:test_dsmm";
    "Fxn:test_shape";
    "Fxn:self._gen_sparse(2,";
    "Fxn:self.randn(dj,";
    "Fxn:torch.dsmm(x,";
    "Fxn:torch.mm(self.safeToDense(x),";
    "Fxn:self.assertEqual(res,";
    "Fxn:test_shape(7,";
    "Fxn:test_shape(1000,";
    "Fxn:test_shape(3000,";
    "Fxn:test_hsmm";
    "Fxn:test_shape";
    "Fxn:self._gen_sparse(2,";
    "Fxn:self.randn(dj,";
    "Fxn:torch.hsmm(x,";
    "Fxn:self.safeToDense(),";
    "Fxn:torch.mm(x.to_dense(),";
    "Fxn:self.assertEqual(res.to_dense(),";
    "Fxn:test_shape(7,";
    "Fxn:test_shape(1000,";
    "Fxn:test_shape(3000,";
    "Fxn:_test_spadd_shape";
    "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:self.randn(*shape)";
    "Fxn:random.random()";
    "Fxn:torch.add(y,";
    "Fxn:self.safeToDense(x)";
    "Fxn:self.assertEqual(res,";
    "Fxn:self.randn(*s)";
    "Fxn:y.transpose_(0,";
    "Fxn:random.random()";
    "Fxn:torch.add(y,";
    "Fxn:self.safeToDense(x)";
    "Fxn:self.assertEqual(res,";
    "Fxn:test_spadd";
    "Fxn:self._test_spadd_shape([5,";
    "Fxn:self._test_spadd_shape([10,";
    "Fxn:self._test_spadd_shape([50,";
    "Fxn:self._test_spadd_shape([5,";
    "Fxn:test_spadd_hybrid";
    "Fxn:self._test_spadd_shape([5,";
    "Fxn:self._test_spadd_shape([10,";
    "Fxn:self._test_spadd_shape([50,";
    "Fxn:self._test_spadd_shape([5,";
    "Fxn:test_norm";
    "Fxn:self._gen_sparse(3,";
    "Fxn:x.coalesce()";
    "Fxn:self.assertEqual(x.norm(),";
    "Fxn:y._values().norm())";
    "Fxn:_test_basic_ops_shape";
    "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:x1.clone()";
    "Fxn:y2.add_(x2)";
    "Fxn:self.safeToDense(x1)";
    "Fxn:self.safeToDense(x2)";
    "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:x1.clone()";
    "Fxn:y2.sub_(x2)";
    "Fxn:self.safeToDense(x1)";
    "Fxn:self.safeToDense(x2)";
    "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:x1.clone()";
    "Fxn:y2.mul_(x2)";
    "Fxn:self.safeToDense(x1)";
    "Fxn:self.safeToDense(x2)";
    "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:x1.clone()";
    "Fxn:y2.mul_(37.5)";
    "Fxn:self.safeToDense(x1)";
    "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:x1.clone()";
    "Fxn:y2.div_(37.5)";
    "Fxn:self.safeToDense(x1)";
    "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:x1.clone()";
    "Fxn:y2.pow(2)";
    "Fxn:self.safeToDense(x1)";
    "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:x1.clone()";
    "Fxn:y.zero_()";
    "Fxn:torch.zeros(x1.size())";
    "Fxn:self.assertEqual(self.safeToDense(y),";
    "Fxn:self.assertFalse(x1.is_coalesced())";
    "Fxn:x1.coalesce()";
    "Fxn:x1.coalesce()";
    "Fxn:self.assertFalse(x1.is_coalesced())";
    "Fxn:self.assertTrue(y.is_coalesced())";
    "Fxn:self.assertEqual(x1,";
    "Fxn:y._values().add_(1)";
    "Fxn:self.assertEqual(z._values()";
    "Fxn:y._values())";
    "Fxn:test_basic_ops";
    "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:self._test_basic_ops_shape([10,";
    "Fxn:self._test_basic_ops_shape([50,";
    "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:test_basic_ops_hybrid";
    "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:self._test_basic_ops_shape([10,";
    "Fxn:self._test_basic_ops_shape([50,";
    "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:_test_sparse_mask_shape";
    "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:x1.clone()";
    "Fxn:y2.add_(x2)";
    "Fxn:self.safeToDense(x1)";
    "Fxn:self.safeToDense(x2)";
    "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_sparse_mask_fixed";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([1,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([5,";
    "Fxn:4])).coalesce()";
    "Fxn:self.ValueTensor([";
    "Fxn:self.ValueTensor([7,";
    "Fxn:dense._sparse_mask(x)";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([5,";
    "Fxn:self.assertEqual(res,";
    "Fxn:test_sparse_mask";
    "Fxn:self._test_sparse_mask_fixed()";
    "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:self._test_sparse_mask_shape([10,";
    "Fxn:self._test_sparse_mask_shape([50,";
    "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:_test_zeros";
    "Fxn:self._gen_sparse(len(out_shape_i),";
    "Fxn:torch.zeros(*shape,";
    "Fxn:self.assertEqual(tuple(out.size()),";
    "Fxn:self.assertTrue(out._indices().numel()";
    "Fxn:out._values().numel()";
    "Fxn:self.assertEqual(out._nnz(),";
    "Fxn:self.assertEqual(out._dimI(),";
    "Fxn:self.assertEqual(out._dimV(),";
    "Fxn:test_zeros";
    "Fxn:self._test_zeros([2,";
    "Fxn:_test_zeros_like";
    "Fxn:self._gen_sparse(len(template_shape_i),";
    "Fxn:torch.zeros_like(t)";
    "Fxn:self.assertEqual(tuple(res.size()),";
    "Fxn:self.assertTrue(res._indices().numel()";
    "Fxn:res._values().numel()";
    "Fxn:self.assertEqual(res._nnz(),";
    "Fxn:self.assertEqual(res._dimI(),";
    "Fxn:self.assertEqual(res._dimV(),";
    "Fxn:test_zeros_like";
    "Fxn:self._test_zeros_like(i_shapes[:i_dim],";
    "Fxn:_test_sparse_mask_hybrid_fixed";
    "Fxn:self.IndexTensor([";
    "Fxn:self.ValueTensor([[1,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([5,";
    "Fxn:2])).coalesce()";
    "Fxn:self.ValueTensor([";
    "Fxn:dense._sparse_mask(x)";
    "Fxn:self.ValueTensor([[7,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([5,";
    "Fxn:self.assertEqual(res,";
    "Fxn:test_sparse_variable_methods";
    "Fxn:self.IndexTensor([[0,";
    "Fxn:self.ValueTensor([3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([2,";
    "Fxn:Variable(sparse_mat)";
    "Fxn:torch.zeros_like(x),";
    "Fxn:x.transpose(0,";
    "Fxn:x.transpose(0,";
    "Fxn:x.t(),";
    "Fxn:x.t_(),";
    "Fxn:x.div(2),";
    "Fxn:x.div_(2),";
    "Fxn:x.pow(2),";
    "Fxn:x._nnz(),";
    "Fxn:x.is_coalesced(),";
    "Fxn:x.coalesce(),";
    "Fxn:x.to_dense(),";
    "Fxn:x._dimI(),";
    "Fxn:x._dimV(),";
    "Fxn:x.norm(),";
    "Fxn:to_test_one_arg.items():";
    "Fxn:sparse_var.clone()";
    "Fxn:sparse_mat.clone()";
    "Fxn:test_fn(var1)";
    "Fxn:test_fn(tensor1)";
    "Fxn:self.assertEqual(out_var,";
    "Fxn:self.assertEqual(test_fn(var1).data,";
    "Fxn:test_fn(tensor1),";
    "Fxn:self.IndexTensor([[0,";
    "Fxn:self.ValueTensor([3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([2,";
    "Fxn:Variable(sparse_mat2)";
    "Fxn:x.sub(y),";
    "Fxn:x.sub_(y),";
    "Fxn:x.mul(y),";
    "Fxn:x.mul_(y),";
    "Fxn:to_test_two_arg.items():";
    "Fxn:sparse_var.clone()";
    "Fxn:sparse_var2.clone()";
    "Fxn:sparse_mat.clone()";
    "Fxn:sparse_mat2.clone()";
    "Fxn:self.assertEqual(test_fn(var1,";
    "Fxn:test_fn(tensor1,";
    "Fxn:sp.sspaddmm(sp,";
    "Fxn:sp.sspaddmm(2,";
    "Fxn:sp.sspaddmm(3,";
    "Fxn:de.addmm(sp,";
    "Fxn:de.addmm(sp,";
    "Fxn:torch.mm(sp,";
    "Fxn:torch.mm(sp,";
    "Fxn:self.IndexTensor([[0,";
    "Fxn:self.ValueTensor([3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3,";
    "Fxn:Variable(sparse_mat)";
    "Fxn:sparse_mat.to_dense().random_(0,";
    "Fxn:Variable(dense_mat)";
    "Fxn:sparse_var.clone()";
    "Fxn:dense_var.clone()";
    "Fxn:sparse_mat.clone()";
    "Fxn:dense_mat.clone()";
    "Fxn:self.assertEqual(test_fn(sp_var,";
    "Fxn:test_fn(sp_mat,";
    "Fxn:test_sparse_mask_hybrid";
    "Fxn:self._test_sparse_mask_hybrid_fixed()";
    "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:self._test_sparse_mask_shape([10,";
    "Fxn:self._test_sparse_mask_shape([50,";
    "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:test_sparse_add_coalesce";
    "Fxn:self.IndexTensor([[1,";
    "Fxn:self.ValueTensor([3,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3]))";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3]))";
    "Fxn:self.assertFalse(z._indices().numel()";
    "Fxn:z.is_coalesced())";
    "Fxn:test_storage_not_null";
    "Fxn:torch.cuda.sparse.FloatTensor(2)";
    "Fxn:self.assertNotEqual(x.get_device(),";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_same_gpu";
    "Fxn:self.IndexTensor([[2]]).cuda(1)";
    "Fxn:self.ValueTensor([5]).cuda(1)";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3]),";
    "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:self.assertEqual(x._values().get_device(),";
    "Fxn:self.assertEqual(x._indices().get_device(),";
    "Fxn:self.SparseTensor(3,";
    "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:self.assertEqual(x._values().get_device(),";
    "Fxn:self.assertEqual(x._indices().get_device(),";
    "Fxn:self.ValueTensor([5]).cuda(0)";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:self.SparseTensor(i,";
    "Fxn:torch.Size([3])))";
    "Fxn:_test_new_device";
    "Fxn:torch.cuda.device(device):";
    "Fxn:torch.cuda.sparse.DoubleTensor(*size)";
    "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:x.new()";
    "Fxn:x.new(2,";
    "Fxn:self.assertEqual(x1.get_device(),";
    "Fxn:self.assertEqual(x2.get_device(),";
    "Fxn:test_new_device_single_gpu";
    "Fxn:self._test_new_device((),";
    "Fxn:self._test_new_device((30,";
    "Fxn:self._test_new_device((30,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_new_device_multi_gpu";
    "Fxn:self._test_new_device((),";
    "Fxn:self._test_new_device((30,";
    "Fxn:self._test_new_device((30,";
    "Fxn:test_new";
    "Fxn:self._gen_sparse(3,";
    "Fxn:self.assertEqual(x.new(indices,";
    "Fxn:self.assertEqual(x.new(indices,";
    "Fxn:x.size()),";
    "Fxn:self.assertIs(torch.sparse.uint8,";
    "Fxn:x.new(dtype=torch.sparse.uint8).dtype)";
    "Fxn:self.assertIs(torch.sparse.uint8,";
    "Fxn:x.new(1,";
    "Fxn:test_dtypes";
    "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:TestTorch._test_dtypes(self,";
    "Fxn:test_empty_full";
    "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:TestTorch._test_empty_full(self,";
    "Fxn:test_is_sparse";
    "Fxn:torch.randn(3,";
    "Fxn:self.assertFalse(x.is_sparse)";
    "Fxn:self.SparseTensor()";
    "Fxn:self.assertTrue(x.is_sparse)";
    "Fxn:test_resize_as";
    "Fxn:do_test";
    "Fxn:t.new().resize_as_(t).zero_()";
    "Fxn:self.assertEqual(y.shape,";
    "Fxn:self.assertEqual(t,";
    "Fxn:do_test(self.SparseTensor())";
    "Import:Variable";
    "class:TestUncoalescedSparse(TestSparse):";
    "Fxn:setUp";
    "Fxn:self).setUp()";
    "Fxn:@unittest.skipIf(not";
    "class:TestCudaSparse(TestSparse):";
    "Fxn:setUp";
    "Fxn:self).setUp()";
    "Fxn:@unittest.skipIf(not";
    "class:TestCudaUncoalescedSparse(TestCudaSparse):";
    "Fxn:setUp";
    "Fxn:self).setUp()";
    "Fxn:run_tests()";
    "/test/test_torch.py";
    "Import:sys";
    "Import:import";
    "Import:import";
    "Import:math";
    "Import:random";
    "Import:operator";
    "Import:copy";
    "Import:torch";
    "Import:torch.cuda";
    "Import:tempfile";
    "Import:unittest";
    "Import:warnings";
    "Import:pickle";
    "Import:from_dlpack,";
    "Import:product,";
    "Import:reduce";
    "Import:TestCase,";
    "Import:numpy";
    "Import:signal";
    "class:FilelikeMock(object):";
    "Fxn:__init__";
    "Fxn:io.BytesIO(data)";
    "Fxn:trace";
    "Fxn:result";
    "Fxn:self.calls.add(name)";
    "Fxn:fn(*args,";
    "Fxn:trace(getattr(self.bytesio,";
    "Fxn:fileno_opt";
    "Fxn:io.UnsupportedOperation('Not";
    "Fxn:readinto_opt";
    "Fxn:self.calls.add('readinto')";
    "Fxn:self.bytesio.readinto(view)";
    "Fxn:was_called";
    "class:BytesIOContext(io.BytesIO):";
    "Fxn:__enter__";
    "Fxn:__exit__";
    "class:TestTorch(TestCase):";
    "Fxn:test_dot";
    "Fxn:types.items():";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.dot(v1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:types.items():";
    "Fxn:torch.randn(1).type(tname).expand(100)";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.dot(v1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_ger";
    "Fxn:types.items():";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.ger(v1,";
    "Fxn:torch.zeros(100,";
    "Fxn:100).type(tname)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:types.items():";
    "Fxn:torch.randn(1).type(tname).expand(100)";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.ger(v1,";
    "Fxn:torch.zeros(100,";
    "Fxn:100).type(tname)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_addr";
    "Fxn:run_test";
    "Fxn:m_transform(m.clone())";
    "Fxn:m.clone()";
    "Fxn:torch.addr(m,";
    "Fxn:self.assertEqual(m,";
    "Fxn:types.items():";
    "Fxn:[(100,";
    "Fxn:torch.randn(h,";
    "Fxn:w).type(tname)";
    "Fxn:torch.randn(h).type(tname)";
    "Fxn:torch.randn(w).type(tname)";
    "Fxn:run_test(m,";
    "Fxn:run_test(m,";
    "Fxn:x.transpose(0,";
    "Fxn:torch.randn(1).type(tname).expand(h)";
    "Fxn:run_test(m,";
    "Fxn:run_test(m,";
    "Fxn:x.transpose(0,";
    "Fxn:test_addmv";
    "Fxn:types.items():";
    "Fxn:torch.randn(10).type(tname)";
    "Fxn:torch.randn(10,";
    "Fxn:100).type(tname)";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.addmv(t,";
    "Fxn:torch.zeros(10).type(tname)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:types.items():";
    "Fxn:torch.randn(1).type(tname).expand(10)";
    "Fxn:torch.randn(10,";
    "Fxn:1).type(tname).expand(10,";
    "Fxn:torch.randn(100).type(tname)";
    "Fxn:torch.addmv(t,";
    "Fxn:torch.zeros(10).type(tname)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_addmm";
    "Fxn:types.items():";
    "Fxn:torch.randn(10,";
    "Fxn:25).type(tname)";
    "Fxn:torch.randn(10,";
    "Fxn:50).type(tname)";
    "Fxn:torch.randn(50,";
    "Fxn:25).type(tname)";
    "Fxn:torch.addmm(M,";
    "Fxn:torch.zeros(10,";
    "Fxn:25).type(tname)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:types.items():";
    "Fxn:torch.randn(10,";
    "Fxn:1).type(tname).expand(10,";
    "Fxn:torch.randn(10,";
    "Fxn:1).type(tname).expand(10,";
    "Fxn:torch.randn(50,";
    "Fxn:25).type(tname)";
    "Fxn:torch.addmm(M,";
    "Fxn:torch.zeros(10,";
    "Fxn:25).type(tname)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_linear_algebra_scalar_raises";
    "Fxn:torch.randn(5,";
    "Fxn:torch.randn(5)";
    "Fxn:torch.tensor(7)";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.mv(m,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.addmv(v,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.ger(v,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.ger(s,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.addr(m,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.addr(m,";
    "Fxn:_testMath";
    "Fxn:torch.randn(*size)";
    "Fxn:torchfn(m1[4])";
    "Fxn:res1.clone().zero_()";
    "Fxn:mathfn(v.item())";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(*size)";
    "Fxn:torchfn(m1[:,";
    "Fxn:res1.clone().zero_()";
    "Fxn:mathfn(v.item())";
    "Fxn:self.assertEqual(res1,";
    "Fxn:_testMathByName";
    "Fxn:self._testMath(torchfn,";
    "Fxn:test_sin";
    "Fxn:self._testMathByName('sin')";
    "Fxn:test_sinh";
    "Fxn:self._testMathByName('sinh')";
    "Fxn:test_lgamma";
    "Fxn:self._testMathByName('lgamma')";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_digamma";
    "Fxn:self._testMath(torch.digamma,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_polygamma";
    "Fxn:self._testMath(lambda";
    "Fxn:torch.polygamma(n,";
    "Fxn:polygamma(n,";
    "Fxn:x)[()])";
    "Fxn:test_asin";
    "Fxn:self._testMath(torch.asin,";
    "Fxn:math.asin(x)";
    "Fxn:test_cos";
    "Fxn:self._testMathByName('cos')";
    "Fxn:test_cosh";
    "Fxn:self._testMathByName('cosh')";
    "Fxn:test_acos";
    "Fxn:self._testMath(torch.acos,";
    "Fxn:math.acos(x)";
    "Fxn:test_tan";
    "Fxn:self._testMathByName('tan')";
    "Fxn:test_tanh";
    "Fxn:self._testMathByName('tanh')";
    "Fxn:test_atan";
    "Fxn:self._testMathByName('atan')";
    "Fxn:test_log";
    "Fxn:self._testMath(torch.log,";
    "Fxn:math.log(x)";
    "Fxn:test_sqrt";
    "Fxn:self._testMath(torch.sqrt,";
    "Fxn:math.sqrt(x)";
    "Fxn:test_erf";
    "Fxn:self._testMathByName('erf')";
    "Fxn:test_erfinv";
    "Fxn:checkType";
    "Fxn:torch.randn(4,";
    "Fxn:out=tensor()).clamp(-2.,";
    "Fxn:self.assertEqual(tensor(inputValues).erf().erfinv(),";
    "Fxn:tensor(inputValues))";
    "Fxn:self.assertTrue(torch.equal(tensor([-1,";
    "Fxn:1]).erfinv(),";
    "Fxn:tensor([float('-inf'),";
    "Fxn:self.assertEqual(tensor([-2,";
    "Fxn:2]).erfinv(),";
    "Fxn:tensor([float('nan'),";
    "Fxn:checkType(torch.FloatTensor)";
    "Fxn:checkType(torch.DoubleTensor)";
    "Fxn:test_exp";
    "Fxn:self._testMathByName('exp')";
    "Fxn:test_expm1";
    "Fxn:self._testMathByName('expm1')";
    "Fxn:test_floor";
    "Fxn:self._testMathByName('floor')";
    "Fxn:test_ceil";
    "Fxn:self._testMathByName('ceil')";
    "Fxn:test_rsqrt";
    "Fxn:self._testMath(torch.rsqrt,";
    "Fxn:math.sqrt(x)";
    "Fxn:test_sigmoid";
    "Fxn:checkType";
    "Fxn:self.assertEqual(tensor(inputValues).sigmoid(),";
    "Fxn:tensor(expectedOutput),";
    "Fxn:checkType(torch.FloatTensor)";
    "Fxn:checkType(torch.DoubleTensor)";
    "Fxn:test_frac";
    "Fxn:self._testMath(torch.frac,";
    "Fxn:math.fmod(x,";
    "Fxn:test_trunc";
    "Fxn:self._testMath(torch.trunc,";
    "Fxn:math.fmod(x,";
    "Fxn:test_round";
    "Fxn:self._testMath(torch.round,";
    "Fxn:test_has_storage";
    "Fxn:self.assertIsNotNone(torch.Tensor().storage())";
    "Fxn:self.assertIsNotNone(torch.Tensor(0).storage())";
    "Fxn:self.assertIsNotNone(torch.Tensor([]).storage())";
    "Fxn:self.assertIsNotNone(torch.Tensor().clone().storage())";
    "Fxn:self.assertIsNotNone(torch.Tensor([0,";
    "Fxn:0]).nonzero().storage())";
    "Fxn:self.assertIsNotNone(torch.Tensor().new().storage())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_has_storage_numpy";
    "Fxn:np.array([1],";
    "Fxn:self.assertIsNotNone(torch.FloatTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.DoubleTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.IntTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.LongTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.ByteTensor(arr).storage())";
    "Fxn:torch.cuda.is_available():";
    "Fxn:self.assertIsNotNone(torch.cuda.FloatTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.cuda.DoubleTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.cuda.IntTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.cuda.LongTensor(arr).storage())";
    "Fxn:self.assertIsNotNone(torch.cuda.ByteTensor(arr).storage())";
    "Fxn:_testSelection";
    "Fxn:torch.randn(100,";
    "Fxn:torchfn(m1)";
    "Fxn:iter_indices(m1):";
    "Fxn:mathfn(res2,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(10,";
    "Fxn:torchfn(m2)";
    "Fxn:iter_indices(m2):";
    "Fxn:mathfn(res2,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(100,";
    "Fxn:torchfn(m1,";
    "Fxn:0:1].clone().squeeze()";
    "Fxn:res1ind.clone().fill_(0)";
    "Fxn:iter_indices(m1):";
    "Fxn:mathfn(res2val[i],";
    "Fxn:self.assertEqual(res1ind[i],";
    "Fxn:self.assertLessEqual(abs(maxerr),";
    "Fxn:torch.randn(100)";
    "Fxn:torch.max(m1,";
    "Fxn:self.assertTrue(math.isnan(res1val))";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:torchfn(m1)";
    "Fxn:self.assertTrue(math.isnan(res1val))";
    "Fxn:test_max";
    "Fxn:self._testSelection(torch.max,";
    "Fxn:test_min";
    "Fxn:self._testSelection(torch.min,";
    "Fxn:_test_dim_reduction";
    "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:self.assertEqual(x.sum().item(),";
    "Fxn:self.assertEqual(x.sum(0),";
    "Fxn:torch.FloatTensor([4,";
    "Fxn:self.assertEqual(x.sum(1),";
    "Fxn:torch.FloatTensor([2,";
    "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:torch.sum(x,";
    "Fxn:self.assertEqual(x.sum(0),";
    "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:self.assertEqual(x.mean().item(),";
    "Fxn:self.assertEqual(x.mean(0),";
    "Fxn:torch.FloatTensor([2.0,";
    "Fxn:self.assertEqual(x.mean(1),";
    "Fxn:torch.FloatTensor([2.0";
    "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:self.assertEqual(x.prod().item(),";
    "Fxn:self.assertEqual(x.prod(0),";
    "Fxn:torch.FloatTensor([-5,";
    "Fxn:self.assertEqual(x.prod(1),";
    "Fxn:torch.FloatTensor([-2,";
    "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:self.assertEqual(x.max().item(),";
    "Fxn:self.assertEqual(x.max(0),";
    "Fxn:torch.FloatTensor([1,";
    "Fxn:self.assertEqual(x.max(1),";
    "Fxn:torch.FloatTensor([1,";
    "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:self.assertEqual(x.min().item(),";
    "Fxn:self.assertEqual(x.min(0),";
    "Fxn:torch.FloatTensor([0,";
    "Fxn:self.assertEqual(x.min(1),";
    "Fxn:torch.FloatTensor([0,";
    "Fxn:normfn_attr";
    "Fxn:attr(t,";
    "Fxn:fn";
    "Fxn:fn_attr(x,";
    "Fxn:fn_tuple";
    "Fxn:fn_attr(x,";
    "Fxn:test_multidim";
    "Fxn:self.assertEqual(fn(x,";
    "Fxn:dim).unsqueeze(dim),";
    "Fxn:fn(x,";
    "Fxn:self.assertEqual(x.ndimension()";
    "Fxn:fn(x,";
    "Fxn:dim).ndimension())";
    "Fxn:self.assertEqual(x.ndimension(),";
    "Fxn:fn(x,";
    "Fxn:keepdim=True).ndimension())";
    "Fxn:cast(torch.randn(3,";
    "Fxn:random.randint(0,";
    "Fxn:test_multidim(x,";
    "Fxn:cast(torch.randn(1))";
    "Fxn:self.assertEqual(fn(x,";
    "Fxn:self.assertEqual(fn(x,";
    "Fxn:random.randint(0,";
    "Fxn:cast(torch.randn(dims))";
    "Fxn:test_multidim(x,";
    "Fxn:cast(torch.randn(5,";
    "Fxn:cast(torch.randn(5,";
    "Fxn:cast(torch.zeros(5,";
    "Fxn:3).long()";
    "Fxn:fn_tuple(y,";
    "Fxn:out=(values[:,";
    "Fxn:fn_tuple(y,";
    "Fxn:self.assertEqual(values[:,";
    "Fxn:kwarg'.format(fn_name))";
    "Fxn:self.assertEqual(indices[:,";
    "Fxn:kwarg'.format(fn_name))";
    "Fxn:cast(torch.randn(5,";
    "Fxn:cast(torch.randn(5,";
    "Fxn:fn(y,";
    "Fxn:fn(y,";
    "Fxn:self.assertEqual(x[:,";
    "Fxn:kwarg'.format(fn_name))";
    "Fxn:test_dim_reduction";
    "Fxn:self._test_dim_reduction(self,";
    "Fxn:_testCSelection";
    "Fxn:torch.rand(*size)";
    "Fxn:torch.rand(*size)";
    "Fxn:torchfn(a,";
    "Fxn:torch.zeros(*size)";
    "Fxn:expected_c.map2_(a,";
    "Fxn:mathfn(a,";
    "Fxn:self.assertEqual(expected_c,";
    "Fxn:test_max_elementwise";
    "Fxn:self._testCSelection(torch.max,";
    "Fxn:test_min_elementwise";
    "Fxn:self._testCSelection(torch.min,";
    "Fxn:test_lerp";
    "Fxn:TH_lerp";
    "Fxn:torch.rand(*size)";
    "Fxn:torch.rand(*size)";
    "Fxn:random.random()";
    "Fxn:torch.lerp(a,";
    "Fxn:a.clone()";
    "Fxn:expected.map2_(a,";
    "Fxn:TH_lerp(a,";
    "Fxn:self.assertEqual(result,";
    "Fxn:test_all_any";
    "Fxn:test";
    "Fxn:torch.ones(*size).byte()";
    "Fxn:self.assertTrue(x.all())";
    "Fxn:self.assertTrue(x.any())";
    "Fxn:self.assertFalse(x.all())";
    "Fxn:self.assertTrue(x.any())";
    "Fxn:x.zero_()";
    "Fxn:self.assertFalse(x.all())";
    "Fxn:self.assertFalse(x.any())";
    "Fxn:x.fill_(2)";
    "Fxn:self.assertTrue(x.all())";
    "Fxn:self.assertTrue(x.any())";
    "Fxn:test((10,))";
    "Fxn:test((5,";
    "Fxn:test_all_any_empty";
    "Fxn:torch.ByteTensor()";
    "Fxn:self.assertTrue(x.all())";
    "Fxn:self.assertFalse(x.any())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_all_any_empty_cuda";
    "Fxn:torch.cuda.ByteTensor()";
    "Fxn:self.assertTrue(x.all())";
    "Fxn:self.assertFalse(x.any())";
    "Fxn:test_mv";
    "Fxn:torch.randn(100,";
    "Fxn:torch.randn(100)";
    "Fxn:torch.mv(m1,";
    "Fxn:res1.clone().zero_()";
    "Fxn:iter_indices(m1):";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_add";
    "Fxn:torch.add([res,]";
    "Fxn:torch.randn(100,";
    "Fxn:torch.randn(100)";
    "Fxn:torch.add(m1[4],";
    "Fxn:res1.clone().zero_()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(100,";
    "Fxn:torch.randn(100)";
    "Fxn:torch.add(m1[:,";
    "Fxn:res1.clone().zero_()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.add([res,]";
    "Fxn:torch.randn(10,";
    "Fxn:m1.clone()";
    "Fxn:res1[3].add_(2)";
    "Fxn:m1.clone()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(10,";
    "Fxn:m1.clone()";
    "Fxn:3].add_(2)";
    "Fxn:m1.clone()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.add([res,]";
    "Fxn:test_csub";
    "Fxn:torch.randn(100,";
    "Fxn:a.clone().normal_()";
    "Fxn:torch.add(a,";
    "Fxn:a.clone()";
    "Fxn:res_csub.sub_(b)";
    "Fxn:self.assertEqual(res_add,";
    "Fxn:torch.randn(100,";
    "Fxn:torch.add(a,";
    "Fxn:a.clone()";
    "Fxn:res_csub.sub_(scalar)";
    "Fxn:self.assertEqual(res_add,";
    "Fxn:_test_neg";
    "Fxn:cast(torch.randn(100,";
    "Fxn:90).type(t))";
    "Fxn:cast(torch.Tensor(100,";
    "Fxn:90).type(t).random_())";
    "Fxn:cast(torch.Tensor().type(t)).resize_as_(a).zero_()";
    "Fxn:torch.add(zeros,";
    "Fxn:torch.add(zeros,";
    "Fxn:a.clone()";
    "Fxn:res_neg.neg_()";
    "Fxn:self.assertEqual(res_neg,";
    "Fxn:a.clone().neg()";
    "Fxn:self.assertEqual(res_neg_out_place,";
    "Fxn:-a.clone()";
    "Fxn:self.assertEqual(res_neg_op,";
    "Fxn:test_neg";
    "Fxn:self._test_neg(self,";
    "Fxn:test_reciprocal";
    "Fxn:torch.randn(100,";
    "Fxn:a.clone()";
    "Fxn:res_reciprocal.reciprocal_()";
    "Fxn:self.assertEqual(res_reciprocal,";
    "Fxn:test_mul";
    "Fxn:torch.randn(10,";
    "Fxn:m1.clone()";
    "Fxn:3].mul_(2)";
    "Fxn:m1.clone()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_div";
    "Fxn:torch.randn(10,";
    "Fxn:m1.clone()";
    "Fxn:3].div_(2)";
    "Fxn:m1.clone()";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_fmod";
    "Fxn:torch.Tensor(10,";
    "Fxn:10).uniform_(-10.,";
    "Fxn:m1.clone()";
    "Fxn:3].fmod_(q)";
    "Fxn:m1.clone()";
    "Fxn:math.fmod(res2[i,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_remainder";
    "Fxn:torch.Tensor(10,";
    "Fxn:10).uniform_(-10.,";
    "Fxn:m1.clone()";
    "Fxn:m1.clone()";
    "Fxn:torch.arange(-5.1,";
    "Fxn:col_idx].remainder_(q)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:m1.clone()";
    "Fxn:res1.remainder_(qs.unsqueeze(0).expand_as(res1))";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.LongTensor(10,";
    "Fxn:10).random_(-10,";
    "Fxn:long_m1.clone()";
    "Fxn:long_m1.clone()";
    "Fxn:torch.arange(-5,";
    "Fxn:5).long()";
    "Fxn:col_idx].remainder_(long_q)";
    "Fxn:self.assertEqual(long_res1,";
    "Fxn:long_m1.clone()";
    "Fxn:long_res1.remainder_(long_qs.unsqueeze(0).expand_as(long_res1))";
    "Fxn:test_mm";
    "Fxn:matrixmultiply";
    "Fxn:mat1.size(0)";
    "Fxn:mat1.size(1)";
    "Fxn:mat2.size(1)";
    "Fxn:torch.zeros(n,";
    "Fxn:iter_indices(res):";
    "Fxn:torch.randn(n,";
    "Fxn:torch.randn(m,";
    "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply(mat1,";
    "Fxn:self.assertEqual(res,";
    "Fxn:torch.randn(n,";
    "Fxn:torch.randn(p,";
    "Fxn:m).t()";
    "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply(mat1,";
    "Fxn:self.assertEqual(res,";
    "Fxn:torch.randn(m,";
    "Fxn:n).t()";
    "Fxn:torch.randn(m,";
    "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply(mat1,";
    "Fxn:self.assertEqual(res,";
    "Fxn:torch.randn(m,";
    "Fxn:n).t()";
    "Fxn:torch.randn(p,";
    "Fxn:m).t()";
    "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply(mat1,";
    "Fxn:self.assertEqual(res,";
    "Fxn:torch.randn(n,";
    "Fxn:torch.randn(m,";
    "Fxn:1).expand(m,";
    "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply(mat1,";
    "Fxn:self.assertEqual(res,";
    "Fxn:_test_btrifact";
    "Fxn:torch.FloatTensor((((1.3722,";
    "Fxn:cast(a)";
    "Fxn:a.btrifact()";
    "Fxn:cast(torch.IntTensor())";
    "Fxn:warnings.catch_warnings(record=True):";
    "Fxn:a.btrifact(info=info)";
    "Fxn:self.assertEqual(info.abs().sum(),";
    "Fxn:a.btrifact_with_info()";
    "Fxn:self.assertEqual(a_LU,";
    "Fxn:self.assertEqual(pivots,";
    "Fxn:self.assertEqual(info,";
    "Fxn:torch.btriunpack(a_LU,";
    "Fxn:torch.bmm(P,";
    "Fxn:torch.bmm(a_L,";
    "Fxn:self.assertEqual(a_,";
    "Fxn:test_btrifact";
    "Fxn:self._test_btrifact(self,";
    "Fxn:_test_btrisolve";
    "Fxn:torch.FloatTensor((((1.3722,";
    "Fxn:torch.FloatTensor(((4.02,";
    "Fxn:cast(a),";
    "Fxn:cast(b)";
    "Fxn:a.btrifact_with_info()";
    "Fxn:self.assertEqual(info.abs().sum(),";
    "Fxn:torch.btrisolve(b,";
    "Fxn:torch.bmm(a,";
    "Fxn:x.unsqueeze(2)).squeeze()";
    "Fxn:self.assertEqual(b_,";
    "Fxn:test_btrisolve";
    "Fxn:self._test_btrisolve(self,";
    "Fxn:test_bmm";
    "Fxn:torch.randn(num_batches,";
    "Fxn:torch.randn(num_batches,";
    "Fxn:torch.bmm(b1,";
    "Fxn:torch.mm(b1[i],";
    "Fxn:self.assertEqual(r,";
    "Fxn:test_addbmm";
    "Fxn:torch.randn(num_batches,";
    "Fxn:torch.randn(num_batches,";
    "Fxn:torch.bmm(b1,";
    "Fxn:torch.Tensor().resize_as_(res[0]).zero_()";
    "Fxn:res2.addbmm_(b1,";
    "Fxn:self.assertEqual(res2,";
    "Fxn:res.sum(0,";
    "Fxn:res2.addbmm_(1,";
    "Fxn:self.assertEqual(res2,";
    "Fxn:res.sum(0,";
    "Fxn:res2.addbmm_(1.,";
    "Fxn:self.assertEqual(res2,";
    "Fxn:res.sum(0,";
    "Fxn:torch.addbmm(1,";
    "Fxn:self.assertEqual(res3,";
    "Fxn:torch.addbmm(1,";
    "Fxn:self.assertEqual(res4,";
    "Fxn:res.sum(0,";
    "Fxn:torch.addbmm(0,";
    "Fxn:self.assertEqual(res5,";
    "Fxn:res.sum(0,";
    "Fxn:torch.addbmm(.1,";
    "Fxn:self.assertEqual(res6,";
    "Fxn:test_baddbmm";
    "Fxn:torch.randn(num_batches,";
    "Fxn:torch.randn(num_batches,";
    "Fxn:torch.bmm(b1,";
    "Fxn:torch.Tensor().resize_as_(res).zero_()";
    "Fxn:res2.baddbmm_(b1,";
    "Fxn:self.assertEqual(res2,";
    "Fxn:res2.baddbmm_(1,";
    "Fxn:self.assertEqual(res2,";
    "Fxn:res2.baddbmm_(1,";
    "Fxn:self.assertEqual(res2,";
    "Fxn:torch.baddbmm(1,";
    "Fxn:self.assertEqual(res3,";
    "Fxn:torch.baddbmm(1,";
    "Fxn:self.assertEqual(res4,";
    "Fxn:torch.baddbmm(0,";
    "Fxn:self.assertEqual(res5,";
    "Fxn:torch.baddbmm(.1,";
    "Fxn:self.assertEqual(res6,";
    "Fxn:test_clamp";
    "Fxn:torch.rand(100).mul(5).add(-2.5)";
    "Fxn:m1.clone()";
    "Fxn:res1.clamp_(min_val,";
    "Fxn:m1.clone()";
    "Fxn:iter_indices(res2):";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.clamp(m1,";
    "Fxn:m1.clone()";
    "Fxn:iter_indices(res2):";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.clamp(m1,";
    "Fxn:m1.clone()";
    "Fxn:iter_indices(res2):";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_pow";
    "Fxn:torch.pow([res,]";
    "Fxn:torch.rand(100,";
    "Fxn:torch.pow(m1[4],";
    "Fxn:res1.clone().zero_()";
    "Fxn:math.pow(m1[4][i],";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.rand(100,";
    "Fxn:torch.pow(m1[:,";
    "Fxn:res1.clone().zero_()";
    "Fxn:math.pow(m1[i,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(100,";
    "Fxn:torch.pow(3,";
    "Fxn:res1.clone().zero_()";
    "Fxn:math.pow(3,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(100,";
    "Fxn:torch.pow(3,";
    "Fxn:res1.clone().zero_()";
    "Fxn:math.pow(3,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_rpow";
    "Fxn:torch.randn(10,";
    "Fxn:self.assertEqual(torch.pow(2,";
    "Fxn:_test_int_pow";
    "Fxn:check_against_np";
    "Fxn:tensor.cpu().numpy()";
    "Fxn:exp.cpu().numpy()";
    "Fxn:torch.LongTensor(tensor_np";
    "Fxn:exp_np).type_as(tensor)";
    "Fxn:self.assertEqual(torch.pow(tensor,";
    "Fxn:self.assertEqual(tensor.pow(exp),";
    "Fxn:torch.pow(tensor,";
    "Fxn:x.long(),";
    "Fxn:x.short(),";
    "Fxn:x.byte(),";
    "Fxn:typecasts.append(lambda";
    "Fxn:x.int())";
    "Fxn:cast(torch.LongTensor(shape).random_(-10,";
    "Fxn:cast(torch.LongTensor(shape).random_(0,";
    "Fxn:typecast(tensor)";
    "Fxn:typecast(exp)";
    "Fxn:check_against_np(t,";
    "Fxn:test_int_pow";
    "Fxn:self._test_int_pow(self,";
    "Fxn:_test_cop";
    "Fxn:reference_implementation";
    "Fxn:iter_indices(sm1):";
    "Fxn:sm1.size(0)";
    "Fxn:mathfn(sm1[i,";
    "Fxn:torch.randn(10,";
    "Fxn:torch.randn(10,";
    "Fxn:torchfn(sm1,";
    "Fxn:sm2.view(10,";
    "Fxn:reference_implementation(res1.clone())";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.randn(10,";
    "Fxn:torch.randn(10";
    "Fxn:sm1.size()";
    "Fxn:sm2.set_(sm2.storage(),";
    "Fxn:sm2.storage_offset(),";
    "Fxn:sm1.size(),";
    "Fxn:sm2.stride()[0]))";
    "Fxn:torchfn(sm1,";
    "Fxn:sm2.set_(sm2.storage(),";
    "Fxn:sm2.storage_offset(),";
    "Fxn:4].size(),";
    "Fxn:4].stride())";
    "Fxn:reference_implementation(res1.clone())";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_cdiv";
    "Fxn:self._test_cop(torch.div,";
    "Fxn:test_cfmod";
    "Fxn:self._test_cop(torch.fmod,";
    "Fxn:test_cremainder";
    "Fxn:self._test_cop(torch.remainder,";
    "Fxn:test_cmul";
    "Fxn:self._test_cop(torch.mul,";
    "Fxn:test_cpow";
    "Fxn:self._test_cop(torch.pow,";
    "Fxn:math.pow(x,";
    "Fxn:test_sum";
    "Fxn:torch.rand(100,";
    "Fxn:torch.sum(x,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.sum(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_prod";
    "Fxn:torch.rand(100,";
    "Fxn:torch.prod(x,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.prod(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_cumsum";
    "Fxn:torch.rand(100,";
    "Fxn:torch.cumsum(x,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.cumsum(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_cumprod";
    "Fxn:torch.rand(100,";
    "Fxn:torch.cumprod(x,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.cumprod(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_cross";
    "Fxn:torch.rand(100,";
    "Fxn:torch.rand(100,";
    "Fxn:torch.cross(x,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.cross(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_zeros";
    "Fxn:torch.zeros(100,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.zeros(100,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_zeros_like";
    "Fxn:torch.zeros(100,";
    "Fxn:torch.zeros_like(expected)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_zeros_like_cuda";
    "Fxn:torch.zeros(100,";
    "Fxn:100).cuda()";
    "Fxn:torch.zeros_like(expected)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_zeros_like_multiple_device";
    "Fxn:torch.zeros(100,";
    "Fxn:100).cuda()";
    "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:torch.zeros_like(x)";
    "Fxn:self.assertEqual(output,";
    "Fxn:test_histc";
    "Fxn:torch.Tensor((2,";
    "Fxn:torch.histc(x,";
    "Fxn:torch.Tensor((0,";
    "Fxn:self.assertEqual(y,";
    "Fxn:test_ones";
    "Fxn:torch.ones(100,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.ones(100,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_ones_like";
    "Fxn:torch.ones(100,";
    "Fxn:torch.ones_like(expected)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_ones_like_cuda";
    "Fxn:torch.ones(100,";
    "Fxn:100).cuda()";
    "Fxn:torch.ones_like(expected)";
    "Fxn:self.assertEqual(res1,";
    "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_ones_like_multiple_device";
    "Fxn:torch.ones(100,";
    "Fxn:100).cuda()";
    "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:torch.ones_like(x)";
    "Fxn:self.assertEqual(output,";
    "Fxn:_test_dtypes";
    "Fxn:torch.cuda.is_available()";
    "Fxn:torch.cuda.device_count()";
    "Fxn:torch.zeros((2,";
    "Fxn:self.assertIs(dtype,";
    "Fxn:self.assertEqual(1,";
    "Fxn:out.get_device())";
    "Fxn:torch.zeros((2,";
    "Fxn:self.assertIs(dtype,";
    "Fxn:self.assertEqual(dtype";
    "Fxn:self.assertEqual(is_sparse,";
    "Fxn:test_dtypes";
    "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:self._test_dtypes(self,";
    "Fxn:_test_empty_full";
    "Fxn:torch.cuda.is_available()";
    "Fxn:torch.Size([2,";
    "Fxn:check_value";
    "Fxn:self.assertEqual(shape,";
    "Fxn:self.assertIs(dtype,";
    "Fxn:self.assertEqual(tensor.requires_grad,";
    "Fxn:self.assertEqual(device,";
    "Fxn:tensor.get_device())";
    "Fxn:tensor.new(shape).fill_(value)";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:get_int64_dtype";
    "Fxn:'.'.join(str(dtype).split('.')[1:-1])";
    "Fxn:operator.attrgetter(module)(torch).int64";
    "Fxn:check_value(torch.empty(shape),";
    "Fxn:check_value(torch.full(shape,";
    "Fxn:get_int64_dtype(dtype)";
    "Fxn:torch.cuda.device_count()";
    "Fxn:torch.empty(shape,";
    "Fxn:check_value(v,";
    "Fxn:v.new()";
    "Fxn:check_value(torch.empty(shape,";
    "Fxn:check_value(v.new_empty(shape),";
    "Fxn:check_value(v.new_empty(shape,";
    "Fxn:check_value(torch.empty_like(v),";
    "Fxn:check_value(torch.empty_like(v,";
    "Fxn:torch.full(shape,";
    "Fxn:check_value(v,";
    "Fxn:check_value(v.new_full(shape,";
    "Fxn:v.new()";
    "Fxn:check_value(torch.full(shape,";
    "Fxn:check_value(v.new_full(shape,";
    "Fxn:check_value(torch.full_like(v,";
    "Fxn:check_value(torch.full_like(v,";
    "Fxn:test_empty_full";
    "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:self._test_empty_full(self,";
    "Fxn:test_dtype_out_match";
    "Fxn:torch.autograd.Variable(torch.DoubleTensor(2,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.zeros((2,";
    "Fxn:test_constructor_dtypes";
    "Fxn:torch.Tensor().type()";
    "Fxn:self.assertIs(torch.Tensor().dtype,";
    "Fxn:torch.set_default_tensor_type('torch.FloatTensor')";
    "Fxn:self.assertIs(torch.float32,";
    "Fxn:self.assertIs(torch.float32,";
    "Fxn:self.assertEqual(torch.FloatStorage,";
    "Fxn:torch.set_default_tensor_type(torch.float64)";
    "Fxn:self.assertIs(torch.float64,";
    "Fxn:self.assertIs(torch.float64,";
    "Fxn:self.assertEqual(torch.DoubleStorage,";
    "Fxn:torch.set_default_tensor_type('torch.Tensor')";
    "Fxn:self.assertIs(torch.float64,";
    "Fxn:self.assertIs(torch.float64,";
    "Fxn:self.assertEqual(torch.DoubleStorage,";
    "Fxn:torch.cuda.is_available():";
    "Fxn:torch.set_default_tensor_type(torch.cuda.float32)";
    "Fxn:self.assertIs(torch.cuda.float32,";
    "Fxn:self.assertIs(torch.cuda.float32,";
    "Fxn:self.assertEqual(torch.cuda.FloatStorage,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:torch.set_default_tensor_type('torch.IntTensor'))";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:torch.set_default_tensor_type(torch.int64))";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:torch.set_default_tensor_type(torch.sparse.int64))";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:torch.set_default_tensor_type(torch.sparse.float64))";
    "Fxn:torch.set_default_tensor_type(default_type)";
    "Fxn:test_tensor_factory";
    "Fxn:torch.Tensor([1,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.tensor([1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertIs(torch.int,";
    "Fxn:torch.tensor(expected)";
    "Fxn:self.assertEqual(res2,";
    "Fxn:self.assertEqual(expected,";
    "Fxn:torch.ones_like(expected))";
    "Fxn:torch.tensor(expected,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertIs(torch.int,";
    "Fxn:np.array([5.])";
    "Fxn:torch.tensor(a)";
    "Fxn:self.assertEqual(5.,";
    "Fxn:res1[0].item())";
    "Fxn:self.assertEqual(5.,";
    "Fxn:res1[0].item())";
    "Fxn:test_new_tensor";
    "Fxn:torch.autograd.Variable(torch.ByteTensor([1,";
    "Fxn:expected.new_tensor([1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:expected.new_tensor([1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertIs(torch.int,";
    "Fxn:expected.new_tensor(expected)";
    "Fxn:self.assertEqual(res2,";
    "Fxn:self.assertEqual(expected,";
    "Fxn:torch.ones_like(expected))";
    "Fxn:expected.new_tensor(expected,";
    "Fxn:self.assertEqual(res2,";
    "Fxn:self.assertIs(torch.int,";
    "Fxn:np.array([5.])";
    "Fxn:torch.tensor(a)";
    "Fxn:res1.new_tensor(a)";
    "Fxn:self.assertEqual(5.,";
    "Fxn:res1[0].item())";
    "Fxn:self.assertEqual(5.,";
    "Fxn:res1[0].item())";
    "Fxn:torch.cuda.device_count()";
    "Fxn:expected.cuda(1)";
    "Fxn:expected.new_tensor([1,";
    "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:expected.get_device())";
    "Fxn:expected.new_tensor([1,";
    "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:expected.get_device())";
    "Fxn:expected.new_tensor(expected)";
    "Fxn:self.assertEqual(res2.get_device(),";
    "Fxn:expected.get_device())";
    "Fxn:expected.new_tensor(expected,";
    "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:self.assertEqual(res2.get_device(),";
    "Fxn:expected.get_device())";
    "Fxn:expected.new_tensor(expected,";
    "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:self.assertEqual(res2.get_device(),";
    "Fxn:expected.new_tensor(1)";
    "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:expected.get_device())";
    "Fxn:expected.new_tensor(1,";
    "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:expected.get_device())";
    "Fxn:test_diag";
    "Fxn:torch.rand(100,";
    "Fxn:torch.diag(x)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.diag(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:_test_diagonal";
    "Fxn:torch.randn((100,";
    "Fxn:torch.diagonal(x)";
    "Fxn:torch.diag(x)";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.randn((100,";
    "Fxn:torch.diagonal(x,";
    "Fxn:torch.diag(x,";
    "Fxn:self.assertEqual(result,";
    "Fxn:test_diagonal";
    "Fxn:self._test_diagonal(self,";
    "Fxn:_test_diagflat";
    "Fxn:torch.randn((100,),";
    "Fxn:torch.diagflat(x)";
    "Fxn:torch.diag(x)";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.randn((100,),";
    "Fxn:torch.diagflat(x,";
    "Fxn:torch.diag(x,";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.randn((2,";
    "Fxn:torch.diagflat(x)";
    "Fxn:torch.diag(x.contiguous().view(-1))";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.randn((2,";
    "Fxn:dtype=dtype).transpose(2,";
    "Fxn:self.assertFalse(x.is_contiguous())";
    "Fxn:torch.diagflat(x)";
    "Fxn:torch.diag(x.contiguous().view(-1))";
    "Fxn:self.assertEqual(result,";
    "Fxn:test_diagflat";
    "Fxn:self._test_diagflat(self,";
    "Fxn:test_eye";
    "Fxn:torch.eye(100,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.eye(100,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_renorm";
    "Fxn:torch.randn(10,";
    "Fxn:torch.Tensor()";
    "Fxn:renorm";
    "Fxn:matrix.transpose(dim,";
    "Fxn:0).contiguous()";
    "Fxn:m1.clone().resize_(m1.size(0),";
    "Fxn:m1.size(0))))";
    "Fxn:m2.norm(value,";
    "Fxn:norms.clone()";
    "Fxn:new_norms[torch.gt(norms,";
    "Fxn:new_norms.div_(norms.add_(1e-7))";
    "Fxn:m1.mul_(new_norms.expand_as(m1))";
    "Fxn:m1.transpose(dim,";
    "Fxn:m1.norm(2,";
    "Fxn:1).mean()";
    "Fxn:renorm(m1,";
    "Fxn:m1.renorm_(2,";
    "Fxn:self.assertEqual(m1,";
    "Fxn:self.assertEqual(m1.norm(2,";
    "Fxn:m2.norm(2,";
    "Fxn:torch.randn(3,";
    "Fxn:m1.transpose(1,";
    "Fxn:2).contiguous().clone().resize_(15,";
    "Fxn:m2.norm(2,";
    "Fxn:0).mean()";
    "Fxn:renorm(m2,";
    "Fxn:m1.renorm_(2,";
    "Fxn:m1.transpose(1,";
    "Fxn:2).contiguous().clone().resize_(15,";
    "Fxn:self.assertEqual(m3,";
    "Fxn:self.assertEqual(m3.norm(2,";
    "Fxn:m2.norm(2,";
    "Fxn:_test_multinomial";
    "Fxn:make_prob_dist";
    "Fxn:[5])).uniform_()[:,";
    "Fxn:prob_dist.transpose(1,";
    "Fxn:prob_dist.is_contiguous()";
    "Fxn:make_prob_dist([n_row,";
    "Fxn:torch.LongTensor(n_row).random_(-2,";
    "Fxn:n_col).tolist()";
    "Fxn:torch.multinomial(prob_dist,";
    "Fxn:self.assertEqual(prob_dist.dim(),";
    "Fxn:self.assertEqual(sample_indices.size(1),";
    "Fxn:self.assertNotEqual(sample_indices[i,";
    "Fxn:make_prob_dist([n_row,";
    "Fxn:torch.LongTensor(n_row).random_(-1,";
    "Fxn:n_col).tolist()";
    "Fxn:torch.multinomial(prob_dist,";
    "Fxn:self.assertEqual(prob_dist.dim(),";
    "Fxn:self.assertEqual(sample_indices.size(1),";
    "Fxn:self.assertNotEqual(sample_idx,";
    "Fxn:self.assertNotIn(sample_idx,";
    "Fxn:make_prob_dist([n_col],";
    "Fxn:is_contiguous).fill_(1)";
    "Fxn:torch.multinomial(prob_dist,";
    "Fxn:self.assertNotEqual(sample_index,";
    "Fxn:sample_indices.dim()";
    "Fxn:self.assertEqual(sample_indices.dim(),";
    "Fxn:self.assertEqual(prob_dist.dim(),";
    "Fxn:self.assertEqual(sample_indices.size(0),";
    "Fxn:test_multinomial";
    "Fxn:self._test_multinomial(self,";
    "Fxn:test_range";
    "Fxn:torch.range(0,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.range(0,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.zeros(2,";
    "Fxn:torch.range(0,";
    "Fxn:out=x.narrow(1,";
    "Fxn:torch.Tensor(((0,";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.Tensor((1,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.range(1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.ones(1)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.range(1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.range(1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.range(0.6,";
    "Fxn:out=torch.FloatTensor())";
    "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:torch.range(1,";
    "Fxn:out=torch.FloatTensor())";
    "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:torch.range(0.6,";
    "Fxn:out=torch.DoubleTensor())";
    "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:torch.range(1,";
    "Fxn:out=torch.DoubleTensor())";
    "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:test_arange";
    "Fxn:torch.arange(0,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.arange(0,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.arange(10)";
    "Fxn:torch.arange(0,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.zeros(2,";
    "Fxn:torch.arange(0,";
    "Fxn:out=x.narrow(1,";
    "Fxn:torch.Tensor(((0,";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.Tensor((1,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.arange(1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.ones(1)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.arange(1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.arange(1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.arange(0.6,";
    "Fxn:out=torch.FloatTensor())";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.arange(1,";
    "Fxn:out=torch.FloatTensor())";
    "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:self.assertEqual(res1[0],";
    "Fxn:self.assertEqual(res1[29],";
    "Fxn:torch.arange(0.6,";
    "Fxn:out=torch.DoubleTensor())";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.arange(1,";
    "Fxn:out=torch.DoubleTensor())";
    "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:self.assertEqual(res1[0],";
    "Fxn:self.assertEqual(res1[29],";
    "Fxn:torch.arange(0,";
    "Fxn:self.assertEqual(r.min(),";
    "Fxn:self.assertEqual(r.max(),";
    "Fxn:self.assertEqual(r.numel(),";
    "Fxn:torch.arange(0,";
    "Fxn:self.assertEqual(r.min(),";
    "Fxn:self.assertEqual(r.max(),";
    "Fxn:self.assertEqual(r.numel(),";
    "Fxn:torch.arange(0,";
    "Fxn:torch.arange(0,";
    "Fxn:torch.arange(0,";
    "Fxn:self.assertEqual(r1[:-1],";
    "Fxn:self.assertEqual(r2,";
    "Fxn:torch.arange(10,";
    "Fxn:torch.arange(10,";
    "Fxn:torch.arange(10,";
    "Fxn:self.assertEqual(r1,";
    "Fxn:self.assertEqual(r2,";
    "Fxn:_select_broadcastable_dims";
    "Fxn:random.randint(1,";
    "Fxn:[random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:_test_broadcast";
    "Fxn:self._select_broadcastable_dims()";
    "Fxn:cast(torch.randn(*dims_small).float())";
    "Fxn:cast(torch.randn(*dims_large).float())";
    "Fxn:small.expand(*dims_full)";
    "Fxn:large.expand(*dims_full)";
    "Fxn:self._select_broadcastable_dims(dims_full)";
    "Fxn:cast(torch.randn(*dims_small2).float())";
    "Fxn:small2.expand(*dims_full)";
    "Fxn:tensorfn";
    "Fxn:myfn(t1,";
    "Fxn:myfn(t1";
    "Fxn:myfn(1,";
    "Fxn:myfn(t1)";
    "Fxn:[(large,";
    "Fxn:tensorfn(method_expanded,";
    "Fxn:tensorfn(method,";
    "Fxn:self.assertEqual(r1,";
    "Fxn:torchfn";
    "Fxn:fntorch(t1,";
    "Fxn:fntorch(t1,";
    "Fxn:fntorch(t1,";
    "Fxn:cast(torch.arange(1,";
    "Fxn:t1.nelement()";
    "Fxn:1).float()))";
    "Fxn:fntorch(t1,";
    "Fxn:fntorch(t1,";
    "Fxn:fntorch(t1,";
    "Fxn:[(large,";
    "Fxn:torchfn(expanded[first],";
    "Fxn:torchfn(first,";
    "Fxn:self.assertEqual(r1,";
    "Fxn:argument(s)";
    "Fxn:large_expanded.clone()";
    "Fxn:tensorfn_inplace";
    "Fxn:t0_fn(t1,";
    "Fxn:t0_fn(t1";
    "Fxn:cast(torch.arange(1,";
    "Fxn:t0.nelement()";
    "Fxn:1).float()))";
    "Fxn:t0_fn(t1";
    "Fxn:t0_fn(t1,";
    "Fxn:t0_fn(t1,";
    "Fxn:t0_fn(1.0,";
    "Fxn:t0_fn(t1)";
    "Fxn:tensorfn_inplace(large_expanded,";
    "Fxn:tensorfn_inplace(large_expanded_clone,";
    "Fxn:large_expanded.stride()";
    "Fxn:large_expanded_clone.stride()):";
    "Fxn:self.assertEqual(r1,";
    "Fxn:broadcastable";
    "Fxn:t1.expand_as(t0)";
    "Fxn:t2.expand_as(t0)";
    "Fxn:_test_in_place_broadcastable";
    "Fxn:broadcastable(t0,";
    "Fxn:t0.numel()";
    "Fxn:t1.numel()";
    "Fxn:t2.numel()";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensorfn_inplace(t0,";
    "Fxn:tensorfn_inplace(t0,";
    "Fxn:_test_in_place_broadcastable(small,";
    "Fxn:_test_in_place_broadcastable(small,";
    "Fxn:_test_in_place_broadcastable(small2,";
    "Fxn:_test_in_place_broadcastable(small2,";
    "Fxn:test_broadcast";
    "Fxn:self._test_broadcast(self,";
    "Fxn:_test_contiguous";
    "Fxn:cast(torch.randn(1,";
    "Fxn:self.assertTrue(x.is_contiguous())";
    "Fxn:x.set_(x.storage(),";
    "Fxn:x.size(),";
    "Fxn:self.assertTrue(x.is_contiguous())";
    "Fxn:test_contiguous";
    "Fxn:self._test_contiguous(self,";
    "Fxn:test_scalars_as_floats";
    "Fxn:torch.tensor(2)";
    "Fxn:torch.tensor(3)";
    "Fxn:self.assertEqual(y.addcmul(y,";
    "Fxn:torch.tensor(2,";
    "Fxn:self.assertRaises(Exception,";
    "Fxn:y.addcmul(y,";
    "Fxn:_test_broadcast_fused_matmul";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:dims_full_for_fn";
    "Fxn:AssertionError("unknown";
    "Fxn:dims_full_for_fn()";
    "Fxn:self._select_broadcastable_dims(t0_dims_full)";
    "Fxn:cast(torch.randn(*t0_dims_small).float())";
    "Fxn:cast(torch.randn(*t1_dims).float())";
    "Fxn:cast(torch.randn(*t2_dims).float())";
    "Fxn:cast(t0_small.expand(*t0_dims_full))";
    "Fxn:fntorch(t0_small,";
    "Fxn:fntorch(t0_full,";
    "Fxn:self.assertEqual(r0,";
    "Fxn:test_broadcast_fused_matmul";
    "Fxn:self._test_broadcast_fused_matmul(self,";
    "Fxn:_test_broadcast_batched_matmul";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:[random.randint(1,";
    "Fxn:self._select_broadcastable_dims(full_batch_dims)";
    "Fxn:verify_batched_matmul";
    "Fxn:cast(torch.randn(*(small_dims)).float())";
    "Fxn:cast(torch.randn(*(dim0_dims)).float())";
    "Fxn:cast(torch.randn(*(full_batch_dims";
    "Fxn:full_mat_dims)).float())";
    "Fxn:maybe_squeeze_result";
    "Fxn:l.dim()";
    "Fxn:result.squeeze(-2)";
    "Fxn:r.dim()";
    "Fxn:result.squeeze(-1)";
    "Fxn:lhs.expand(*(torch.Size(full_batch_dims)";
    "Fxn:torch.Size(lhs_mat_dims)))";
    "Fxn:rhs.unsqueeze(-1)).";
    "Fxn:expand(*(torch.Size(full_batch_dims)";
    "Fxn:torch.Size(rhs_mat_dims))))";
    "Fxn:maybe_squeeze_result(lhs_expanded,";
    "Fxn:lhs_expanded_matmul_fn(rhs_expanded))";
    "Fxn:maybe_squeeze_result(l,";
    "Fxn:l_matmul_fn(r))";
    "Fxn:self.assertEqual(truth,";
    "Fxn:maybe_squeeze_result(l,";
    "Fxn:torch.matmul(l,";
    "Fxn:self.assertEqual(truth,";
    "Fxn:rhs_expanded.contiguous().view(-1,";
    "Fxn:self.assertEqual(truth.view(-1,";
    "Fxn:bmm_result.view(-1,";
    "Fxn:product((True,";
    "Fxn:verify_batched_matmul(*indices)";
    "Fxn:test_broadcast_batched_matmul";
    "Fxn:self._test_broadcast_batched_matmul(self,";
    "Fxn:test_copy_broadcast";
    "Fxn:torch.zeros(5,";
    "Fxn:6).copy_(torch.zeros(6))";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.zeros(5,";
    "Fxn:6).copy_(torch.zeros(30)))";
    "Fxn:test_randperm";
    "Fxn:torch.get_rng_state()";
    "Fxn:torch.randperm(100)";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.set_rng_state(_RNGState)";
    "Fxn:torch.randperm(100,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_random";
    "Fxn:p<=(2/(ub-lb))^200=6e-36";
    "Fxn:torch.FloatTensor(200)";
    "Fxn:t.fill_(-1)";
    "Fxn:t.random_(lb,";
    "Fxn:self.assertEqual(t.min(),";
    "Fxn:self.assertEqual(t.max(),";
    "Fxn:t.fill_(-1)";
    "Fxn:t.random_(ub)";
    "Fxn:self.assertEqual(t.min(),";
    "Fxn:self.assertEqual(t.max(),";
    "Fxn:assertIsOrdered";
    "Fxn:check_order";
    "Fxn:check_order";
    "Fxn:error('unknown";
    "Fxn:"descending"'.format(order))";
    "Fxn:product(range(SIZE),";
    "Fxn:self.assertTrue(check_order(mxx[j][k";
    "Fxn:{}'.format(order,";
    "Fxn:x.size(x.dim()";
    "Fxn:seen.clear()";
    "Fxn:self.assertEqual(x[k][ixx[k][j]],";
    "Fxn:{}'.format(order,";
    "Fxn:seen.add(ixx[k][j])";
    "Fxn:self.assertEqual(len(seen),";
    "Fxn:test_sort";
    "Fxn:torch.rand(SIZE,";
    "Fxn:torch.sort(x)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.sort(x,";
    "Fxn:out=(res2val,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:self.assertIsOrdered('ascending',";
    "Fxn:self.assertEqual(";
    "Fxn:torch.sort(torch.Tensor((50,";
    "Fxn:torch.Tensor((10,";
    "Fxn:torch.floor(torch.rand(SIZE,";
    "Fxn:torch.sort(x,";
    "Fxn:out=(res2val,";
    "Fxn:self.assertIsOrdered('ascending',";
    "Fxn:torch.rand(SIZE,";
    "Fxn:torch.sort(x,";
    "Fxn:x.dim()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.sort(x,";
    "Fxn:x.dim()";
    "Fxn:out=(res2val,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:self.assertIsOrdered('descending',";
    "Fxn:self.assertEqual(";
    "Fxn:torch.sort(torch.Tensor((10,";
    "Fxn:torch.Tensor((50,";
    "Fxn:self.assertIsOrdered('descending',";
    "Fxn:test_topk";
    "Fxn:topKViaSort";
    "Fxn:t.sort(dim,";
    "Fxn:sorted.narrow(dim,";
    "Fxn:indices.narrow(dim,";
    "Fxn:compareTensors";
    "Fxn:self.assertEqual(res1,";
    "Fxn:ind1.eq(ind2).all():";
    "Fxn:t.gather(dim,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:compare";
    "Fxn:t.topk(k,";
    "Fxn:topKViaSort(t,";
    "Fxn:compareTensors(t,";
    "Fxn:torch.rand(random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randint(1,";
    "Fxn:random.randrange(t.ndimension())";
    "Fxn:random.randrange(t.ndimension())";
    "Fxn:t.transpose(dim1,";
    "Fxn:random.randrange(testTensor.ndimension())";
    "Fxn:random.randint(1,";
    "Fxn:testTensor.size(dim))";
    "Fxn:compare(testTensor,";
    "Fxn:test_topk_arguments";
    "Fxn:torch.randn(10,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:q.topk(4,";
    "Fxn:test_kthvalue";
    "Fxn:torch.rand(SIZE,";
    "Fxn:x.clone()";
    "Fxn:random.randint(1,";
    "Fxn:torch.kthvalue(x,";
    "Fxn:torch.sort(x)";
    "Fxn:self.assertEqual(res1val[:,";
    "Fxn:self.assertEqual(res1ind[:,";
    "Fxn:random.randint(1,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.kthvalue(x,";
    "Fxn:out=(res1val,";
    "Fxn:torch.sort(x)";
    "Fxn:self.assertEqual(res1val[:,";
    "Fxn:self.assertEqual(res1ind[:,";
    "Fxn:random.randint(1,";
    "Fxn:torch.kthvalue(x,";
    "Fxn:torch.sort(x,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:x.narrow(1,";
    "Fxn:y.contiguous()";
    "Fxn:random.randint(1,";
    "Fxn:torch.kthvalue(y,";
    "Fxn:torch.kthvalue(y0,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.Tensor((3,";
    "Fxn:self.assertEqual(torch.kthvalue(y,";
    "Fxn:self.assertEqual(torch.kthvalue(y,";
    "Fxn:test_median";
    "Fxn:torch.rand(size,";
    "Fxn:x.clone()";
    "Fxn:x.nelement()";
    "Fxn:torch.median(x)";
    "Fxn:torch.sort(x.view(nelem))";
    "Fxn:self.assertEqual(res2val[ind],";
    "Fxn:torch.median(x,";
    "Fxn:torch.sort(x)";
    "Fxn:self.assertEqual(res2val.select(1,";
    "Fxn:self.assertEqual(res2val.select(1,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.median(x,";
    "Fxn:out=(res2val,";
    "Fxn:self.assertEqual(res2val,";
    "Fxn:self.assertEqual(res2ind,";
    "Fxn:torch.median(x,";
    "Fxn:torch.sort(x,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:self.assertEqual(x,";
    "Fxn:test_mode";
    "Fxn:torch.arange(1,";
    "Fxn:1).clone().resize_(SIZE,";
    "Fxn:x.clone()";
    "Fxn:torch.Tensor(SIZE).fill_(1)";
    "Fxn:torch.LongTensor(SIZE).fill_(1)";
    "Fxn:torch.mode(x,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.mode(x,";
    "Fxn:out=(res2val,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:torch.mode(x,";
    "Fxn:self.assertEqual(res1val,";
    "Fxn:self.assertEqual(res1ind,";
    "Fxn:self.assertEqual(x,";
    "Fxn:test_tril";
    "Fxn:torch.rand(SIZE,";
    "Fxn:torch.tril(x)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.tril(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_triu";
    "Fxn:torch.rand(SIZE,";
    "Fxn:torch.triu(x)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.triu(x,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_cat";
    "Fxn:torch.rand(13,";
    "Fxn:SIZE).transpose(0,";
    "Fxn:torch.rand(17,";
    "Fxn:SIZE).transpose(0,";
    "Fxn:torch.rand(19,";
    "Fxn:SIZE).transpose(0,";
    "Fxn:torch.cat((x,";
    "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:torch.randn(20,";
    "Fxn:self.assertEqual(torch.cat(torch.split(x,";
    "Fxn:self.assertEqual(torch.cat(torch.chunk(x,";
    "Fxn:torch.randn(1,";
    "Fxn:torch.cat([x,";
    "Fxn:self.assertEqual(z.size(),";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.cat([]))";
    "Fxn:test_cat_bad_input_sizes";
    "Fxn:torch.randn(2,";
    "Fxn:torch.randn(2,";
    "Fxn:torch.randn(2,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.cat([x,";
    "Fxn:torch.randn(2,";
    "Fxn:torch.randn(2,";
    "Fxn:torch.randn(2,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.cat([x,";
    "Fxn:test_cat_scalars";
    "Fxn:torch.tensor(0)";
    "Fxn:torch.tensor(1)";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.cat([x,";
    "Fxn:test_stack";
    "Fxn:torch.rand(2,";
    "Fxn:torch.rand(2,";
    "Fxn:torch.rand(2,";
    "Fxn:torch.stack((x,";
    "Fxn:torch.stack((x,";
    "Fxn:x.size()[:dim]";
    "Fxn:x.size()[dim:]";
    "Fxn:self.assertEqual(res,";
    "Fxn:self.assertEqual(res.size(),";
    "Fxn:self.assertEqual(res.select(dim,";
    "Fxn:self.assertEqual(res.select(dim,";
    "Fxn:self.assertEqual(res.select(dim,";
    "Fxn:test_stack_out";
    "Fxn:torch.rand(2,";
    "Fxn:torch.rand(2,";
    "Fxn:torch.rand(2,";
    "Fxn:x.size()[:dim]";
    "Fxn:x.size()[dim:]";
    "Fxn:x.new(expected_size)";
    "Fxn:x.new(expected_size)";
    "Fxn:res_out.data_ptr()";
    "Fxn:res_neg_out.data_ptr()";
    "Fxn:torch.stack((x,";
    "Fxn:torch.stack((x,";
    "Fxn:self.assertEqual(res_out,";
    "Fxn:self.assertEqual(res_out.size(),";
    "Fxn:self.assertEqual(res_out_dp,";
    "Fxn:res_out.data_ptr())";
    "Fxn:self.assertEqual(res_out_neg_dp,";
    "Fxn:res_neg_out.data_ptr())";
    "Fxn:self.assertEqual(res_out.select(dim,";
    "Fxn:self.assertEqual(res_out.select(dim,";
    "Fxn:self.assertEqual(res_out.select(dim,";
    "Fxn:test_unbind";
    "Fxn:torch.rand(2,";
    "Fxn:torch.unbind(x,";
    "Fxn:self.assertEqual(x.size(dim),";
    "Fxn:self.assertEqual(x.select(dim,";
    "Fxn:test_linspace";
    "Fxn:random.random()";
    "Fxn:random.random()";
    "Fxn:torch.linspace(_from,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.linspace(_from,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.linspace(0,";
    "Fxn:self.assertEqual(torch.linspace(0,";
    "Fxn:torch.zeros(1),";
    "Fxn:self.assertEqual(torch.linspace(2,";
    "Fxn:torch.Tensor((2,";
    "Fxn:torch.zeros(2,";
    "Fxn:torch.linspace(0,";
    "Fxn:out=x.narrow(1,";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.Tensor(((0,";
    "Fxn:test_logspace";
    "Fxn:random.random()";
    "Fxn:random.random()";
    "Fxn:torch.logspace(_from,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.logspace(_from,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.logspace(0,";
    "Fxn:self.assertEqual(torch.logspace(0,";
    "Fxn:torch.ones(1),";
    "Fxn:self.assertEqual(torch.logspace(1,";
    "Fxn:torch.Tensor((10,";
    "Fxn:torch.zeros(2,";
    "Fxn:torch.logspace(0,";
    "Fxn:out=x.narrow(1,";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.Tensor(((0,";
    "Fxn:test_rand";
    "Fxn:torch.manual_seed(123456)";
    "Fxn:torch.rand(SIZE,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.manual_seed(123456)";
    "Fxn:torch.rand(SIZE,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_randn";
    "Fxn:torch.manual_seed(123456)";
    "Fxn:torch.randn(SIZE,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.manual_seed(123456)";
    "Fxn:torch.randn(SIZE,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_slice";
    "Fxn:torch.Tensor()";
    "Fxn:torch.arange(0,";
    "Fxn:16).view(4,";
    "Fxn:self.assertEqual(x.slice(),";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:1).data.tolist(),";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:-3).data.tolist(),";
    "Fxn:self.assertEqual(x.slice(start=-2,";
    "Fxn:dim=1).data.tolist(),";
    "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:2).data.tolist(),";
    "Fxn:test_is_signed";
    "Fxn:self.assertEqual(torch.IntTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.ByteTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.CharTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.FloatTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.HalfTensor(10).is_signed(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_is_signed_cuda";
    "Fxn:self.assertEqual(torch.cuda.IntTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.cuda.ByteTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.cuda.CharTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.cuda.FloatTensor(5).is_signed(),";
    "Fxn:self.assertEqual(torch.cuda.HalfTensor(10).is_signed(),";
    "Fxn:test_gesv";
    "Fxn:torch.Tensor(((6.80,";
    "Fxn:-6.87))).t()";
    "Fxn:torch.Tensor(((4.02,";
    "Fxn:8.99))).t()";
    "Fxn:torch.gesv(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(a,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.gesv(b,";
    "Fxn:out=(tb,";
    "Fxn:torch.gesv(b,";
    "Fxn:out=(b,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.gesv(b,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.gesv(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.gesv(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_qr";
    "Fxn:canonicalize";
    "Fxn:r.diag().sign().diag()";
    "Fxn:torch.mm(q,";
    "Fxn:torch.mm(d,";
    "Fxn:canon_and_check";
    "Fxn:canonicalize(q,";
    "Fxn:canonicalize(expected_q,";
    "Fxn:self.assertEqual(q_canon,";
    "Fxn:self.assertEqual(r_canon,";
    "Fxn:check_qr";
    "Fxn:torch.qr(a)";
    "Fxn:canon_and_check(q,";
    "Fxn:torch.Tensor(),";
    "Fxn:torch.Tensor()";
    "Fxn:torch.qr(a,";
    "Fxn:out=(q,";
    "Fxn:canon_and_check(q,";
    "Fxn:a.size(0)";
    "Fxn:a.size(1)";
    "Fxn:torch.geqrf(a)";
    "Fxn:self.assertEqual(result.size(0),";
    "Fxn:self.assertEqual(result.size(1),";
    "Fxn:self.assertEqual(tau.size(0),";
    "Fxn:torch.triu(result.narrow(0,";
    "Fxn:torch.orgqr(result,";
    "Fxn:q.narrow(1,";
    "Fxn:canon_and_check(q,";
    "Fxn:torch.Tensor(((1,";
    "Fxn:torch.Tensor((";
    "Fxn:torch.Tensor((";
    "Fxn:check_qr(a,";
    "Fxn:torch.Tensor((";
    "Fxn:torch.Tensor((";
    "Fxn:torch.Tensor((";
    "Fxn:check_qr(a,";
    "Fxn:torch.Tensor((";
    "Fxn:torch.Tensor((";
    "Fxn:torch.Tensor((";
    "Fxn:check_qr(a,";
    "Fxn:torch.randn(1000,";
    "Fxn:torch.qr(a)";
    "Fxn:torch.mm(q,";
    "Fxn:self.assertEqual(a,";
    "Fxn:test_ormqr";
    "Fxn:torch.randn(10,";
    "Fxn:torch.randn(10,";
    "Fxn:torch.qr(mat1)";
    "Fxn:torch.geqrf(mat1)";
    "Fxn:torch.mm(q,";
    "Fxn:torch.ormqr(m,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.mm(mat2,";
    "Fxn:torch.ormqr(m,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.mm(q.t(),";
    "Fxn:torch.ormqr(m,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.mm(mat2,";
    "Fxn:q.t())";
    "Fxn:torch.ormqr(m,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_trtrs";
    "Fxn:torch.Tensor(((6.80,";
    "Fxn:-6.87))).t()";
    "Fxn:torch.Tensor(((4.02,";
    "Fxn:8.99))).t()";
    "Fxn:torch.triu(a)";
    "Fxn:torch.tril(a)";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(U,";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(U,";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(L,";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(L,";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(U.t(),";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(U.t(),";
    "Fxn:torch.trtrs(b,";
    "Fxn:U.t(),";
    "Fxn:self.assertLessEqual(x.dist(y),";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(L.t(),";
    "Fxn:torch.trtrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(L.t(),";
    "Fxn:torch.trtrs(b,";
    "Fxn:L.t(),";
    "Fxn:self.assertLessEqual(x.dist(y),";
    "Fxn:torch.trtrs(b,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.trtrs(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:tb.zero_()";
    "Fxn:torch.trtrs(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:test_gels";
    "Fxn:_test_underdetermined";
    "Fxn:a.size()[0]";
    "Fxn:a.size()[1]";
    "Fxn:assert(m";
    "Fxn:a.clone()";
    "Fxn:b.clone()";
    "Fxn:torch.gels(b,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(b,";
    "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:b).norm(),";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.gels(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(b,";
    "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:b).norm(),";
    "Fxn:torch.gels(b,";
    "Fxn:out=(b,";
    "Fxn:self.assertEqual((torch.mm(a_copy,";
    "Fxn:b_copy).norm(),";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:_test_overdetermined";
    "Fxn:a.size()[0]";
    "Fxn:a.size()[1]";
    "Fxn:assert(m";
    "Fxn:check_norm";
    "Fxn:a.size()[1]";
    "Fxn:b).norm()";
    "Fxn:self.assertEqual(resid_norm,";
    "Fxn:self.assertEqual(resid_info.norm(),";
    "Fxn:a.clone()";
    "Fxn:b.clone()";
    "Fxn:torch.gels(b,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(b,";
    "Fxn:check_norm(a,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.gels(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual(a,";
    "Fxn:self.assertEqual(b,";
    "Fxn:check_norm(a,";
    "Fxn:torch.gels(b,";
    "Fxn:out=(b,";
    "Fxn:check_norm(a_copy,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:self.assertEqual(res1,";
    "Fxn:torch.Tensor(((1.44,";
    "Fxn:2.06))).t()";
    "Fxn:torch.Tensor(((8.58,";
    "Fxn:-0.26))).t()";
    "Fxn:_test_underdetermined(a,";
    "Fxn:torch.Tensor(((1.44,";
    "Fxn:4.70))).t()";
    "Fxn:torch.Tensor(((8.58,";
    "Fxn:-2.52))).t()";
    "Fxn:_test_overdetermined(a,";
    "Fxn:torch.Tensor(((1.44,";
    "Fxn:-6.64))).t()";
    "Fxn:torch.Tensor(((8.58,";
    "Fxn:-0.70))).t()";
    "Fxn:_test_underdetermined(a,";
    "Fxn:torch.Tensor(((1.44,";
    "Fxn:2.06))).t()";
    "Fxn:torch.Tensor(((8.58,";
    "Fxn:-0.26))).t()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.gels(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:b).norm(),";
    "Fxn:torch.gels(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:b).norm(),";
    "Fxn:torch.gels(b,";
    "Fxn:out=(tb,";
    "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:b).norm(),";
    "Fxn:test_eig";
    "Fxn:torch.Tensor(((1.96,";
    "Fxn:-7.10))).t().contiguous()";
    "Fxn:torch.eig(a)[0]";
    "Fxn:torch.eig(a,";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.eig(a,";
    "Fxn:out=(te,";
    "Fxn:self.assertEqual(e,";
    "Fxn:self.assertEqual(ee,";
    "Fxn:self.assertEqual(ee,";
    "Fxn:self.assertEqual(vv,";
    "Fxn:self.assertEqual(vv,";
    "Fxn:torch.randn(4,";
    "Fxn:torch.mm(X.t(),";
    "Fxn:torch.zeros(4,";
    "Fxn:torch.zeros(4,";
    "Fxn:torch.eig(X,";
    "Fxn:out=(e,";
    "Fxn:torch.mm(torch.mm(v,";
    "Fxn:torch.diag(e.select(1,";
    "Fxn:v.t())";
    "Fxn:self.assertEqual(X,";
    "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:torch.eig(X,";
    "Fxn:out=(e,";
    "Fxn:torch.mm(v,";
    "Fxn:torch.mm(e.select(1,";
    "Fxn:0).diag(),";
    "Fxn:v.t()))";
    "Fxn:self.assertEqual(X,";
    "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:torch.randn(4,";
    "Fxn:torch.mm(X.t(),";
    "Fxn:torch.zeros(4,";
    "Fxn:torch.zeros(4,";
    "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:self.assertFalse(e.is_contiguous(),";
    "Fxn:torch.eig(X,";
    "Fxn:out=(e,";
    "Fxn:torch.mm(torch.mm(v,";
    "Fxn:torch.diag(e.select(1,";
    "Fxn:v.t())";
    "Fxn:self.assertEqual(X,";
    "Fxn:test_symeig";
    "Fxn:torch.rand(100,";
    "Fxn:torch.mm(xval.t(),";
    "Fxn:torch.zeros(3)";
    "Fxn:torch.zeros(3,";
    "Fxn:self.assertTrue(resv.is_contiguous(),";
    "Fxn:torch.symeig(cov.clone(),";
    "Fxn:out=(rese,";
    "Fxn:torch.mm(torch.mm(resv,";
    "Fxn:torch.diag(rese)),";
    "Fxn:resv.t())";
    "Fxn:self.assertEqual(cov,";
    "Fxn:self.assertFalse(resv.is_contiguous(),";
    "Fxn:torch.symeig(cov.clone(),";
    "Fxn:out=(rese,";
    "Fxn:torch.mm(torch.mm(resv,";
    "Fxn:torch.diag(rese)),";
    "Fxn:resv.t())";
    "Fxn:self.assertEqual(cov,";
    "Fxn:torch.rand(5,";
    "Fxn:X.t()";
    "Fxn:torch.zeros(4,";
    "Fxn:2).select(1,";
    "Fxn:torch.zeros(4,";
    "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:self.assertFalse(e.is_contiguous(),";
    "Fxn:torch.symeig(X,";
    "Fxn:out=(e,";
    "Fxn:torch.mm(torch.mm(v,";
    "Fxn:torch.diag(e)),";
    "Fxn:v.t())";
    "Fxn:self.assertEqual(X,";
    "Fxn:test_svd";
    "Fxn:torch.Tensor(((8.79,";
    "Fxn:-5.31))).t().clone()";
    "Fxn:torch.svd(a)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.svd(a,";
    "Fxn:out=(uu,";
    "Fxn:self.assertEqual(u,";
    "Fxn:self.assertEqual(u,";
    "Fxn:self.assertEqual(s,";
    "Fxn:self.assertEqual(s,";
    "Fxn:self.assertEqual(v,";
    "Fxn:self.assertEqual(v,";
    "Fxn:torch.randn(4,";
    "Fxn:torch.svd(X)";
    "Fxn:torch.mm(U,";
    "Fxn:torch.mm(S.diag(),";
    "Fxn:V.t()))";
    "Fxn:self.assertEqual(X,";
    "Fxn:self.assertFalse(U.is_contiguous(),";
    "Fxn:torch.svd(X,";
    "Fxn:out=(U,";
    "Fxn:torch.mm(U,";
    "Fxn:torch.mm(S.diag(),";
    "Fxn:V.t()))";
    "Fxn:self.assertEqual(X,";
    "Fxn:torch.randn(5,";
    "Fxn:torch.zeros(5,";
    "Fxn:torch.zeros(5,";
    "Fxn:torch.zeros(5,";
    "Fxn:self.assertFalse(U.is_contiguous(),";
    "Fxn:self.assertFalse(S.is_contiguous(),";
    "Fxn:self.assertFalse(V.is_contiguous(),";
    "Fxn:torch.svd(X,";
    "Fxn:out=(U,";
    "Fxn:torch.mm(U,";
    "Fxn:torch.mm(S.diag(),";
    "Fxn:V.t()))";
    "Fxn:self.assertEqual(X,";
    "Fxn:_test_window_function";
    "Fxn:torch.from_numpy(signal.get_window(scipy_name,";
    "Fxn:self.assertEqual(torch_method(size,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_hann_window";
    "Fxn:self._test_window_function(self,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_hamming_window";
    "Fxn:self._test_window_function(self,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_bartlett_window";
    "Fxn:self._test_window_function(self,";
    "Fxn:test_inverse";
    "Fxn:torch.randn(5,";
    "Fxn:torch.inverse(M)";
    "Fxn:torch.eye(5)";
    "Fxn:self.assertFalse(MI.is_contiguous(),";
    "Fxn:self.assertEqual(E,";
    "Fxn:torch.mm(M,";
    "Fxn:self.assertEqual(E,";
    "Fxn:torch.mm(MI,";
    "Fxn:torch.Tensor(5,";
    "Fxn:torch.inverse(M,";
    "Fxn:self.assertFalse(MII.is_contiguous(),";
    "Fxn:self.assertEqual(MII,";
    "Fxn:torch.inverse(M,";
    "Fxn:self.assertFalse(MII.is_contiguous(),";
    "Fxn:self.assertEqual(MII,";
    "Fxn:_test_det_logdet_slogdet";
    "Fxn:reference_det";
    "Fxn:M.clone()";
    "Fxn:M.size(0)";
    "Fxn:M.diag().prod()";
    "Fxn:test_single_det";
    "Fxn:M.det()";
    "Fxn:M.logdet()";
    "Fxn:M.slogdet()";
    "Fxn:self.assertEqual(det,";
    "Fxn:det.item()";
    "Fxn:self.assertTrue(logdet.item()";
    "Fxn:logdet.item(),";
    "Fxn:case)'.format(desc))";
    "Fxn:self.assertTrue(sdet.item()";
    "Fxn:case)'.format(desc))";
    "Fxn:self.assertEqual(logabsdet.exp(),";
    "Fxn:det.abs(),";
    "Fxn:case)'.format(desc))";
    "Fxn:det.item()";
    "Fxn:self.assertEqual(logdet.exp().item(),";
    "Fxn:case)'.format(desc))";
    "Fxn:self.assertTrue(sdet.item()";
    "Fxn:case)'.format(desc))";
    "Fxn:self.assertEqual(logabsdet.exp().item(),";
    "Fxn:case)'.format(desc))";
    "Fxn:self.assertEqual(logdet.exp(),";
    "Fxn:case)'.format(desc))";
    "Fxn:self.assertTrue(sdet.item()";
    "Fxn:case)'.format(desc))";
    "Fxn:self.assertEqual(logabsdet.exp(),";
    "Fxn:case)'.format(desc))";
    "Fxn:conv_fn(torch.eye(5))";
    "Fxn:test_single_det(eye,";
    "Fxn:torch.tensor(1,";
    "Fxn:test";
    "Fxn:M.size(0)";
    "Fxn:conv_fn(M)";
    "Fxn:M.det()";
    "Fxn:reference_det(M)";
    "Fxn:test_single_det(M,";
    "Fxn:test_single_det(M,";
    "Fxn:M.inverse().det().pow_(-1),";
    "Fxn:test_single_det(M,";
    "Fxn:M.t().det(),";
    "Fxn:M.clone()";
    "Fxn:test_single_det(M_clone,";
    "Fxn:M.clone()";
    "Fxn:test_single_det(M_clone,";
    "Fxn:[(0,";
    "Fxn:M_det.clone().zero_()";
    "Fxn:M.clone()";
    "Fxn:test_single_det(M_clone,";
    "Fxn:M.clone()";
    "Fxn:test_single_det(M_clone,";
    "Fxn:[(0.3,";
    "Fxn:M.clone()";
    "Fxn:test_single_det(M_clone,";
    "Fxn:M.clone()";
    "Fxn:test_single_det(M_clone,";
    "Fxn:get_random_mat_scale";
    "Fxn:det(A^2)]";
    "Fxn:log((n-1)!)";
    "Fxn:Var[det(A)]";
    "Fxn:E[det(A^2)]";
    "Fxn:det(A^2)]";
    "Fxn:stddev[det(A)]";
    "Fxn:)^(-1/n)";
    "Fxn:)^(-1/(2n))";
    "Fxn:math.factorial(n";
    "Fxn:get_random_mat_scale(n)";
    "Fxn:test(torch.randn(n,";
    "Fxn:torch.randn(n,";
    "Fxn:test(r.mm(r.t()))";
    "Fxn:torch.randn(n,";
    "Fxn:test(r.mm(r.t())";
    "Fxn:torch.eye(n)";
    "Fxn:torch.randn(n,";
    "Fxn:test(r)";
    "Fxn:test((torch.randn(n,";
    "Fxn:torch.randn(n,";
    "Fxn:r.svd()";
    "Fxn:reference_det(u)";
    "Fxn:reference_det(v)";
    "Fxn:test(u.mm(s.diag()).mm(v))";
    "Fxn:test_det_logdet_slogdet";
    "Fxn:self._test_det_logdet_slogdet(self,";
    "Fxn:_test_stft";
    "Fxn:naive_stft";
    "Fxn:x.clone()";
    "Fxn:x.new(frame_length).fill_(1)";
    "Fxn:window.clone()";
    "Fxn:x.dim()";
    "Fxn:x.view(1,";
    "Fxn:x.size(0)";
    "Fxn:x.new(batch,";
    "Fxn:pad_end).fill_(0)";
    "Fxn:torch.cat([x,";
    "Fxn:x.size(1)";
    "Fxn:signal.stft(";
    "Fxn:)[2].transpose((0,";
    "Fxn:np.abs(window.sum().item())";
    "Fxn:torch.Tensor(np.stack([sp_result.real,";
    "Fxn:x.new(batch,";
    "Fxn:conv_fn(torch.arange(frame_length))";
    "Fxn:radians.cos().mul_(window)";
    "Fxn:-radians.sin().mul_(window)";
    "Fxn:t:(t";
    "Fxn:seg.dot(re_kernel)";
    "Fxn:seg.dot(im_kernel)";
    "Fxn:conv_fn(result)";
    "Fxn:_test";
    "Fxn:Variable(conv_fn(torch.randn(*sizes)))";
    "Fxn:Variable(conv_fn(window.clone()))";
    "Fxn:x.stft(frame_length,";
    "Fxn:naive_stft(x,";
    "Fxn:self.assertEqual(result.data,";
    "Fxn:self.assertRaises(expected_error,";
    "Fxn:x.stft(frame_length,";
    "Fxn:_test((2,";
    "Fxn:_test((4,";
    "Fxn:_test((10,),";
    "Fxn:_test((10,";
    "Fxn:_test((2,";
    "Fxn:window=torch.randn(4),";
    "Fxn:_test((4,";
    "Fxn:window=torch.randn(90),";
    "Fxn:_test((10,),";
    "Fxn:window=torch.randn(7),";
    "Fxn:_test((10,";
    "Fxn:window=torch.randn(1024),";
    "Fxn:_test((2,";
    "Fxn:window=torch.randn(4),";
    "Fxn:_test((4,";
    "Fxn:window=torch.randn(90),";
    "Fxn:_test((10,),";
    "Fxn:window=torch.randn(7),";
    "Fxn:_test((10,";
    "Fxn:window=torch.randn(1024),";
    "Fxn:_test((2,";
    "Fxn:window=torch.randn(4),";
    "Fxn:_test((4,";
    "Fxn:window=torch.randn(90),";
    "Fxn:_test((10,),";
    "Fxn:window=torch.randn(7),";
    "Fxn:_test((10,";
    "Fxn:window=torch.randn(1024),";
    "Fxn:_test((10,";
    "Fxn:_test((10,),";
    "Fxn:_test((10,),";
    "Fxn:_test((10,),";
    "Fxn:_test((10,),";
    "Fxn:_test((10,),";
    "Fxn:window=torch.randn(11),";
    "Fxn:_test((10,),";
    "Fxn:window=torch.randn(1,";
    "Fxn:test_stft";
    "Fxn:self._test_stft(self,";
    "Fxn:@unittest.skip("Not";
    "Fxn:test_conv2";
    "Fxn:torch.rand(math.floor(torch.uniform(50,";
    "Fxn:math.floor(torch.uniform(50,";
    "Fxn:torch.rand(math.floor(torch.uniform(10,";
    "Fxn:math.floor(torch.uniform(10,";
    "Fxn:torch.conv2(x,";
    "Fxn:torch.conv2(x,";
    "Fxn:torch.conv2(x,";
    "Fxn:k.clone()";
    "Fxn:k.storage()";
    "Fxn:ki.storage()";
    "Fxn:kis[ks.size()";
    "Fxn:i=ks.size(),";
    "Fxn:kis[ks.size()-i+1]=ks[i]";
    "Fxn:torch.xcorr2(x,";
    "Fxn:torch.xcorr2(x,";
    "Fxn:torch.xcorr2(x,";
    "Fxn:self.assertEqual(imvc,";
    "Fxn:self.assertEqual(imvc,";
    "Fxn:self.assertEqual(imvc,";
    "Fxn:self.assertEqual(imfc,";
    "Fxn:self.assertLessEqual(math.abs(x.dot(x)";
    "Fxn:torch.xcorr2(x,";
    "Fxn:torch.Tensor(2,";
    "Fxn:x.size(1),";
    "Fxn:x.size(2))";
    "Fxn:xx[1].copy_(x)";
    "Fxn:xx[2].copy_(x)";
    "Fxn:torch.Tensor(2,";
    "Fxn:k.size(1),";
    "Fxn:k.size(2))";
    "Fxn:kk[1].copy_(k)";
    "Fxn:kk[2].copy_(k)";
    "Fxn:torch.conv2(xx,";
    "Fxn:torch.conv2(xx,";
    "Fxn:torch.conv2(xx,";
    "Fxn:self.assertEqual(immvc[0],";
    "Fxn:self.assertEqual(immvc[0],";
    "Fxn:self.assertEqual(immvc2[0],";
    "Fxn:self.assertEqual(immfc[0],";
    "Fxn:self.assertEqual(immfc[0],";
    "Fxn:@unittest.skip("Not";
    "Fxn:test_conv3";
    "Fxn:torch.rand(math.floor(torch.uniform(20,";
    "Fxn:math.floor(torch.uniform(20,";
    "Fxn:math.floor(torch.uniform(20,";
    "Fxn:torch.rand(math.floor(torch.uniform(5,";
    "Fxn:math.floor(torch.uniform(5,";
    "Fxn:math.floor(torch.uniform(5,";
    "Fxn:torch.conv3(x,";
    "Fxn:torch.conv3(x,";
    "Fxn:torch.conv3(x,";
    "Fxn:k.clone()";
    "Fxn:k.storage()";
    "Fxn:ki.storage()";
    "Fxn:kis[ks.size()";
    "Fxn:torch.xcorr3(x,";
    "Fxn:torch.xcorr3(x,";
    "Fxn:torch.xcorr3(x,";
    "Fxn:self.assertEqual(imvc,";
    "Fxn:self.assertEqual(imvc,";
    "Fxn:self.assertEqual(imvc,";
    "Fxn:self.assertEqual(imfc,";
    "Fxn:self.assertLessEqual(math.abs(x.dot(x)";
    "Fxn:torch.xcorr3(x,";
    "Fxn:torch.Tensor(2,";
    "Fxn:x.size(1),";
    "Fxn:x.size(2),";
    "Fxn:x.size(3))";
    "Fxn:xx[1].copy_(x)";
    "Fxn:xx[2].copy_(x)";
    "Fxn:torch.Tensor(2,";
    "Fxn:k.size(1),";
    "Fxn:k.size(2),";
    "Fxn:k.size(3))";
    "Fxn:kk[1].copy_(k)";
    "Fxn:kk[2].copy_(k)";
    "Fxn:torch.conv3(xx,";
    "Fxn:torch.conv3(xx,";
    "Fxn:torch.conv3(xx,";
    "Fxn:self.assertEqual(immvc[0],";
    "Fxn:self.assertEqual(immvc[0],";
    "Fxn:self.assertEqual(immvc2[0],";
    "Fxn:self.assertEqual(immfc[0],";
    "Fxn:self.assertEqual(immfc[0],";
    "Fxn:@unittest.skip("Not";
    "Fxn:_test_conv_corr_eq";
    "Fxn:math.floor(random.randint(20,";
    "Fxn:math.floor(random.randint(20,";
    "Fxn:math.floor(random.randint(20,";
    "Fxn:math.floor(random.randint(5,";
    "Fxn:math.floor(random.randint(5,";
    "Fxn:math.floor(random.randint(5,";
    "Fxn:torch.rand(ix,";
    "Fxn:torch.rand(kx,";
    "Fxn:fn(x,";
    "Fxn:torch.zeros(o3.size())";
    "Fxn:fn_2_to_3(x,";
    "Fxn:self.assertEqual(o3,";
    "Fxn:@unittest.skip("Not";
    "Fxn:test_xcorr3_xcorr2_eq";
    "Fxn:reference";
    "Fxn:o32[i].add(torch.xcorr2(x[i";
    "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:torch.xcorr3(x,";
    "Fxn:@unittest.skip("Not";
    "Fxn:test_xcorr3_xcorr2_eq_full";
    "Fxn:reference";
    "Fxn:o32[i].add(torch.xcorr2(x[i],";
    "Fxn:k[k.size(1)";
    "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:torch.xcorr3(x,";
    "Fxn:@unittest.skip("Not";
    "Fxn:test_conv3_conv2_eq_valid";
    "Fxn:reference";
    "Fxn:o32[i].add(torch.conv2(x[i";
    "Fxn:k[k.size(1)";
    "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:torch.conv3(x,";
    "Fxn:@unittest.skip("Not";
    "Fxn:test_fconv3_fconv2_eq";
    "Fxn:reference";
    "Fxn:1].add(torch.conv2(x[i],";
    "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:torch.conv3(x,";
    "Fxn:test_logical";
    "Fxn:torch.rand(100,";
    "Fxn:torch.gt(x,";
    "Fxn:torch.lt(x,";
    "Fxn:torch.eq(x,";
    "Fxn:torch.ne(x,";
    "Fxn:self.assertEqual(neqs.long().sum(),";
    "Fxn:xne.long().sum(),";
    "Fxn:self.assertEqual(x.nelement(),";
    "Fxn:all.long().sum())";
    "Fxn:test_isnan";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(torch.isnan(x),";
    "Fxn:torch.ByteTensor([0,";
    "Fxn:test_RNGState";
    "Fxn:torch.get_rng_state()";
    "Fxn:state.clone()";
    "Fxn:torch.rand(1000)";
    "Fxn:self.assertEqual(state.ne(stateCloned).long().sum(),";
    "Fxn:torch.set_rng_state(state)";
    "Fxn:torch.rand(1000)";
    "Fxn:self.assertEqual(before,";
    "Fxn:test_RNGStateAliasing";
    "Fxn:torch.Generator()";
    "Fxn:gen.set_state(torch.get_rng_state())";
    "Fxn:self.assertEqual(gen.get_state(),";
    "Fxn:torch.get_rng_state())";
    "Fxn:torch.rand(1000)";
    "Fxn:torch.rand(100000)";
    "Fxn:torch.rand(1000,";
    "Fxn:self.assertEqual(target_value,";
    "Fxn:test_boxMullerState";
    "Fxn:torch.manual_seed(123)";
    "Fxn:torch.randn(odd_number)";
    "Fxn:torch.get_rng_state()";
    "Fxn:torch.randn(odd_number)";
    "Fxn:torch.set_rng_state(state)";
    "Fxn:torch.randn(odd_number)";
    "Fxn:torch.manual_seed(123)";
    "Fxn:torch.randn(odd_number)";
    "Fxn:self.assertEqual(midstream,";
    "Fxn:self.assertEqual(seeded,";
    "Fxn:test_manual_seed";
    "Fxn:torch.get_rng_state()";
    "Fxn:torch.manual_seed(2)";
    "Fxn:torch.randn(100)";
    "Fxn:self.assertEqual(torch.initial_seed(),";
    "Fxn:torch.manual_seed(2)";
    "Fxn:torch.randn(100)";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.set_rng_state(rng_state)";
    "Fxn:test_cholesky";
    "Fxn:torch.rand(10,";
    "Fxn:torch.mm(x,";
    "Fxn:x.t())";
    "Fxn:torch.potrf(A)";
    "Fxn:torch.mm(C.t(),";
    "Fxn:self.assertEqual(A,";
    "Fxn:torch.potrf(A,";
    "Fxn:torch.mm(U.t(),";
    "Fxn:self.assertEqual(A,";
    "Fxn:torch.potrf(A,";
    "Fxn:torch.mm(L,";
    "Fxn:L.t())";
    "Fxn:self.assertEqual(A,";
    "Fxn:test_potrs";
    "Fxn:torch.Tensor(((6.80,";
    "Fxn:-6.87))).t()";
    "Fxn:torch.Tensor(((4.02,";
    "Fxn:8.99))).t()";
    "Fxn:torch.mm(a,";
    "Fxn:a.t())";
    "Fxn:torch.potrf(a)";
    "Fxn:torch.potrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(a,";
    "Fxn:torch.potrf(a,";
    "Fxn:torch.potrs(b,";
    "Fxn:self.assertLessEqual(b.dist(torch.mm(a,";
    "Fxn:tset_potri";
    "Fxn:torch.Tensor(((6.80,";
    "Fxn:-6.87))).t()";
    "Fxn:a.t()";
    "Fxn:torch.inverse(a)";
    "Fxn:torch.potrf(a)";
    "Fxn:torch.potri(chol)";
    "Fxn:self.assertLessEqual(inv0.dist(inv1),";
    "Fxn:torch.potrf(a,";
    "Fxn:torch.potri(chol,";
    "Fxn:self.assertLessEqual(inv0.dist(inv1),";
    "Fxn:torch.potrf(a,";
    "Fxn:torch.potri(chol,";
    "Fxn:self.assertLessEqual(inv0.dist(inv1),";
    "Fxn:test_pstrf";
    "Fxn:checkPsdCholesky";
    "Fxn:torch.empty_like(a)";
    "Fxn:a.new(a.size(0)).int()";
    "Fxn:torch.pstrf(*args,";
    "Fxn:torch.mm(u,";
    "Fxn:u.t())";
    "Fxn:torch.mm(u.t(),";
    "Fxn:piv.long()";
    "Fxn:a.index_select(0,";
    "Fxn:piv).index_select(1,";
    "Fxn:self.assertEqual(a_permuted,";
    "Fxn:torch.Tensor(*dim).uniform_()";
    "Fxn:torch.mm(m,";
    "Fxn:m.t())";
    "Fxn:checkPsdCholesky(a,";
    "Fxn:test_numel";
    "Fxn:torch.ByteTensor(3,";
    "Fxn:self.assertEqual(b.nelement(),";
    "Fxn:self.assertEqual(b.numel(),";
    "Fxn:_consecutive";
    "Fxn:torch.ones(int(torch.Tensor(size).prod(0))).cumsum(0)";
    "Fxn:sequence.add_(start";
    "Fxn:sequence.resize_(*size)";
    "Fxn:_test_index";
    "Fxn:consec";
    "Fxn:torch.ones(int(torch.Tensor(size).prod(0))).cumsum(0)";
    "Fxn:sequence.add_(start";
    "Fxn:sequence.view(*size)";
    "Fxn:conv_fn(consec((3,";
    "Fxn:self.assertEqual(reference[conv_fn(torch.LongTensor())],";
    "Fxn:reference.new())";
    "Fxn:self.assertEqual(reference[0],";
    "Fxn:consec((3,";
    "Fxn:self.assertEqual(reference[1],";
    "Fxn:consec((3,";
    "Fxn:self.assertEqual(reference[2],";
    "Fxn:consec((3,";
    "Fxn:self.assertEqual(reference[0,";
    "Fxn:consec((3,),";
    "Fxn:self.assertEqual(reference[0:2],";
    "Fxn:consec((2,";
    "Fxn:self.assertEqual(reference[2,";
    "Fxn:self.assertEqual(reference[:],";
    "Fxn:consec((3,";
    "Fxn:self.assertEqual(reference[...,";
    "Fxn:torch.Tensor([[3,";
    "Fxn:self.assertEqual(reference[0,";
    "Fxn:torch.Tensor([3,";
    "Fxn:self.assertEqual(reference[...,";
    "Fxn:self.assertEqual(reference[0,";
    "Fxn:self.assertEqual(reference[0,";
    "Fxn:self.assertEqual(reference[...,";
    "Fxn:self.assertEqual(reference[2,";
    "Fxn:self.assertEqual(reference[2,";
    "Fxn:self.assertEqual(reference[2,";
    "Fxn:self.assertEqual(reference[...],";
    "Fxn:conv_fn(consec((3,";
    "Fxn:self.assertEqual(reference_5d[...,";
    "Fxn:self.assertEqual(reference_5d[2,";
    "Fxn:self.assertEqual(reference_5d[2,";
    "Fxn:self.assertEqual(reference_5d[...],";
    "Fxn:conv_fn(consec((5,";
    "Fxn:conv_fn(torch.LongTensor([2,";
    "Fxn:self.assertEqual(reference[idx],";
    "Fxn:torch.stack([reference[2],";
    "Fxn:self.assertEqual(reference[2,";
    "Fxn:torch.stack([reference[2,";
    "Fxn:self.assertEqual(reference[3,";
    "Fxn:torch.stack([reference[3,";
    "Fxn:self.assertEqual(reference[2,";
    "Fxn:reference[2].unsqueeze(0))";
    "Fxn:self.assertEqual(reference[2,";
    "Fxn:reference[2].unsqueeze(0).unsqueeze(0))";
    "Fxn:self.assertEqual(reference[2:4,";
    "Fxn:reference[2:4].unsqueeze(1))";
    "Fxn:self.assertEqual(reference[None,";
    "Fxn:reference.unsqueeze(0)[:,";
    "Fxn:2].unsqueeze(0).unsqueeze(0))";
    "Fxn:self.assertEqual(reference[None,";
    "Fxn:reference.unsqueeze(0)[:,";
    "Fxn:2:5].unsqueeze(2).unsqueeze(2))";
    "Fxn:consec((10,";
    "Fxn:self.assertEqual(reference[1:5:2],";
    "Fxn:torch.stack([reference[1],";
    "Fxn:self.assertEqual(reference[1:6:2],";
    "Fxn:torch.stack([reference[1],";
    "Fxn:self.assertEqual(reference[1:9:4],";
    "Fxn:torch.stack([reference[1],";
    "Fxn:self.assertEqual(reference[2:4,";
    "Fxn:torch.stack([reference[2:4,";
    "Fxn:self.assertEqual(reference[3,";
    "Fxn:torch.stack([reference[3,";
    "Fxn:self.assertEqual(reference[None,";
    "Fxn:torch.stack([reference[2,";
    "Fxn:0).unsqueeze(0))";
    "Fxn:self.assertEqual(reference[:,";
    "Fxn:torch.stack([reference[:,";
    "Fxn:[list(range(i,";
    "Fxn:conv_fn(torch.DoubleTensor(lst))";
    "Fxn:random.randrange(10)";
    "Fxn:random.randrange(1,";
    "Fxn:random.randrange(1,";
    "Fxn:random.randrange(2)";
    "Fxn:random.randrange(10)";
    "Fxn:random.randrange(1,";
    "Fxn:random.randrange(1,";
    "Fxn:self.assertEqual(torch.DoubleTensor(lst_indexed),";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index";
    "Fxn:self._test_index(self,";
    "Fxn:_test_advancedindex";
    "Fxn:consec";
    "Fxn:reduce(lambda";
    "Fxn:torch.ones(numel).cumsum(0)";
    "Fxn:sequence.add_(start";
    "Fxn:sequence.view(*size)";
    "Fxn:ri";
    "Fxn:random.randint(0,";
    "Fxn:conv_fn(torch.LongTensor(indices))";
    "Fxn:conv_fn(consec((10,)))";
    "Fxn:self.assertEqual(reference[[0]],";
    "Fxn:consec((1,)))";
    "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:consec((1,)))";
    "Fxn:self.assertEqual(reference[ri([3]),";
    "Fxn:consec((1,),";
    "Fxn:self.assertEqual(reference[[2,";
    "Fxn:consec((3,),";
    "Fxn:self.assertEqual(reference[ri([2,";
    "Fxn:consec((3,),";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(reference[[0]],";
    "Fxn:torch.Tensor([-2]))";
    "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:torch.Tensor([-1]))";
    "Fxn:self.assertEqual(reference[[2,";
    "Fxn:torch.Tensor([4,";
    "Fxn:reference[ri([2,";
    "Fxn:self.assertEqual(reference[ri([2,";
    "Fxn:torch.Tensor([3,";
    "Fxn:reference[ri([0,";
    "Fxn:conv_fn(torch.Tensor([5,";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:torch.Tensor([5,";
    "Fxn:conv_fn(consec((10,)))";
    "Fxn:conv_fn(torch.Tensor())";
    "Fxn:strided.set_(reference.storage(),";
    "Fxn:size=torch.Size([4]),";
    "Fxn:self.assertEqual(strided[[0]],";
    "Fxn:torch.Tensor([1]))";
    "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:torch.Tensor([1]))";
    "Fxn:self.assertEqual(strided[ri([3]),";
    "Fxn:torch.Tensor([7]))";
    "Fxn:self.assertEqual(strided[[1,";
    "Fxn:torch.Tensor([3,";
    "Fxn:self.assertEqual(strided[ri([1,";
    "Fxn:torch.Tensor([3,";
    "Fxn:self.assertEqual(strided[ri([[2,";
    "Fxn:torch.Tensor([[5,";
    "Fxn:conv_fn(torch.Tensor())";
    "Fxn:strided.set_(reference.storage(),";
    "Fxn:size=torch.Size([2]),";
    "Fxn:self.assertEqual(strided[[0]],";
    "Fxn:torch.Tensor([5]))";
    "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:torch.Tensor([5]))";
    "Fxn:self.assertEqual(strided[ri([1]),";
    "Fxn:torch.Tensor([9]))";
    "Fxn:self.assertEqual(strided[[0,";
    "Fxn:torch.Tensor([5,";
    "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:torch.Tensor([5,";
    "Fxn:self.assertEqual(strided[ri([[0,";
    "Fxn:torch.Tensor([[5,";
    "Fxn:conv_fn(consec((3,";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri([0])],";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([2,";
    "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri([0])],";
    "Fxn:consec((1,)))";
    "Fxn:self.assertEqual(reference[ri([2]),";
    "Fxn:ri([1])],";
    "Fxn:consec((1,),";
    "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri([0,";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri([1])]],";
    "Fxn:torch.Tensor([2,";
    "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri([0,";
    "Fxn:torch.Tensor([1,";
    "Fxn:ri([[0,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[1,";
    "Fxn:ri([[0,";
    "Fxn:ri([1,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[2,";
    "Fxn:ri([[0,";
    "Fxn:ri([[0,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[1,";
    "Fxn:reference[ri([0]),";
    "Fxn:ri([1])]";
    "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([-1]))";
    "Fxn:reference[ri([0,";
    "Fxn:ri([0])]";
    "Fxn:conv_fn(torch.Tensor([-1,";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri([0])],";
    "Fxn:torch.Tensor([-1,";
    "Fxn:conv_fn(torch.Tensor([[4,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[4,";
    "Fxn:conv_fn(torch.Tensor([[0,";
    "Fxn:11]])).t_()";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri([0])],";
    "Fxn:torch.Tensor([0,";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([4,";
    "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri([0])],";
    "Fxn:torch.Tensor([0]))";
    "Fxn:self.assertEqual(reference[ri([2]),";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([6]))";
    "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri([0,";
    "Fxn:torch.Tensor([0,";
    "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri([1])]],";
    "Fxn:torch.Tensor([4,";
    "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri([0,";
    "Fxn:torch.Tensor([0,";
    "Fxn:ri([[0,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[0,";
    "Fxn:ri([[0,";
    "Fxn:ri([1,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[4,";
    "Fxn:ri([[0,";
    "Fxn:ri([[0,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[0,";
    "Fxn:reference[ri([0]),";
    "Fxn:ri([1])]";
    "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([-1]))";
    "Fxn:reference[ri([0,";
    "Fxn:ri([0])]";
    "Fxn:conv_fn(torch.Tensor([-1,";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri([0])],";
    "Fxn:torch.Tensor([-1,";
    "Fxn:conv_fn(torch.Tensor([[4,";
    "Fxn:self.assertEqual(reference[rows,";
    "Fxn:torch.Tensor([[4,";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:24).view(3,";
    "Fxn:conv_fn(torch.Tensor())";
    "Fxn:strided.set_(reference.storage(),";
    "Fxn:size=torch.Size([2,";
    "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri([0])],";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([3,";
    "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri([0])],";
    "Fxn:torch.Tensor([1]))";
    "Fxn:self.assertEqual(strided[ri([1]),";
    "Fxn:ri([3])],";
    "Fxn:torch.Tensor([15]))";
    "Fxn:self.assertEqual(strided[[ri([0,";
    "Fxn:ri([0,";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(strided[[ri([1]),";
    "Fxn:ri([0,";
    "Fxn:torch.Tensor([9,";
    "Fxn:self.assertEqual(strided[[ri([0,";
    "Fxn:ri([0,";
    "Fxn:torch.Tensor([1,";
    "Fxn:ri([[0,";
    "Fxn:self.assertEqual(strided[rows,";
    "Fxn:torch.Tensor([[1,";
    "Fxn:ri([[0,";
    "Fxn:ri([1,";
    "Fxn:self.assertEqual(strided[rows,";
    "Fxn:torch.Tensor([[3,";
    "Fxn:ri([[0,";
    "Fxn:ri([[0,";
    "Fxn:self.assertEqual(strided[rows,";
    "Fxn:torch.Tensor([[1,";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:24).view(3,";
    "Fxn:conv_fn(torch.Tensor())";
    "Fxn:strided.set_(reference.storage(),";
    "Fxn:size=torch.Size([2,";
    "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([11]))";
    "Fxn:strided[ri([0]),";
    "Fxn:ri([1])]";
    "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([-1]))";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:24).view(3,";
    "Fxn:conv_fn(torch.Tensor())";
    "Fxn:strided.set_(reference.storage(),";
    "Fxn:size=torch.Size([2,";
    "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri([1,";
    "Fxn:torch.Tensor([11,";
    "Fxn:strided[ri([0,";
    "Fxn:ri([1,";
    "Fxn:conv_fn(torch.Tensor([-1,";
    "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri([1,";
    "Fxn:torch.Tensor([-1,";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:24).view(3,";
    "Fxn:conv_fn(torch.Tensor())";
    "Fxn:strided.set_(reference.storage(),";
    "Fxn:size=torch.Size([2,";
    "Fxn:ri([[0],";
    "Fxn:ri([[0,";
    "Fxn:self.assertEqual(strided[rows,";
    "Fxn:torch.Tensor([[10,";
    "Fxn:conv_fn(torch.Tensor([[4,";
    "Fxn:self.assertEqual(strided[rows,";
    "Fxn:torch.Tensor([[4,";
    "Fxn:conv_fn(consec((3,";
    "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:torch.Tensor([[1,";
    "Fxn:self.assertEqual(reference[ri([1]),";
    "Fxn:torch.Tensor([[3,";
    "Fxn:self.assertEqual(reference[...,";
    "Fxn:ri([1])],";
    "Fxn:torch.Tensor([[2],";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:reference[ri([1]),";
    "Fxn:ri([0,";
    "Fxn:ri([3])]";
    "Fxn:tensor_indices_to_np";
    "Fxn:tensor.cpu()";
    "Fxn:tensor.numpy()";
    "Fxn:get_numpy";
    "Fxn:tensor_indices_to_np(tensor,";
    "Fxn:torch.Tensor(npt[idxs])";
    "Fxn:set_numpy";
    "Fxn:value.cpu()";
    "Fxn:value.numpy()";
    "Fxn:tensor_indices_to_np(tensor,";
    "Fxn:assert_get_eq";
    "Fxn:self.assertEqual(reference[indexer],";
    "Fxn:conv_fn(get_numpy(reference,";
    "Fxn:assert_set_eq";
    "Fxn:tensor.clone()";
    "Fxn:tensor.clone()";
    "Fxn:conv_fn(torch.Tensor(set_numpy(numt,";
    "Fxn:self.assertEqual(pyt,";
    "Fxn:get_set_tensor";
    "Fxn:indexed[indexer].size()";
    "Fxn:indexed[indexer].numel()";
    "Fxn:conv_fn(torch.randperm(set_count).view(set_size).double())";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:20).view(4,";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[[slice(None),";
    "Fxn:assert_get_eq(reference,";
    "Fxn:assert_set_eq(reference,";
    "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor(reference,";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:160).view(4,";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:assert_get_eq(reference,";
    "Fxn:assert_set_eq(reference,";
    "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor(reference,";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:1296).view(3,";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:assert_get_eq(reference,";
    "Fxn:assert_set_eq(reference,";
    "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor(reference,";
    "Fxn:[slice(None),";
    "Fxn:[slice(None),";
    "Fxn:assert_get_eq(reference,";
    "Fxn:assert_set_eq(reference,";
    "Fxn:test_advancedindex";
    "Fxn:self._test_advancedindex(self,";
    "Fxn:_test_advancedindex_big";
    "Fxn:conv_fn(torch.arange(0,";
    "Fxn:123344).int())";
    "Fxn:self.assertEqual(reference[[0,";
    "Fxn:torch.LongTensor([0,";
    "Fxn:test_advancedindex_big";
    "Fxn:self._test_advancedindex_big(self,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_newaxis_numpy_comparison";
    "Fxn:run_test";
    "Fxn:tensor.numpy()";
    "Fxn:self.assertEqual(tensor[idx],";
    "Fxn:torch.arange(0,";
    "Fxn:run_test(x,";
    "Fxn:torch.arange(0,";
    "Fxn:12).view(3,";
    "Fxn:run_test(x,";
    "Fxn:test_newindex";
    "Fxn:self._consecutive((3,";
    "Fxn:__index__()";
    "Fxn:checkPartialAssign";
    "Fxn:torch.zeros(3,";
    "Fxn:self._consecutive((3,";
    "Fxn:self.assertEqual(reference[index],";
    "Fxn:self._consecutive((3,";
    "Fxn:self.assertEqual(reference,";
    "Fxn:torch.zeros(3,";
    "Fxn:checkPartialAssign(0)";
    "Fxn:checkPartialAssign(1)";
    "Fxn:checkPartialAssign(2)";
    "Fxn:checkPartialAssign((0,";
    "Fxn:checkPartialAssign((1,";
    "Fxn:checkPartialAssign((0,";
    "Fxn:checkPartialAssign(torch.LongTensor((0,";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertRaises(TypeError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:self.assertRaises(IndexError):";
    "Fxn:test_index_copy";
    "Fxn:torch.randn(num_dest,";
    "Fxn:torch.randn(num_copy,";
    "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:dest.clone()";
    "Fxn:dest.index_copy_(0,";
    "Fxn:self.assertEqual(dest,";
    "Fxn:torch.randn(num_dest)";
    "Fxn:torch.randn(num_copy)";
    "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:dest.clone()";
    "Fxn:dest.index_copy_(0,";
    "Fxn:self.assertEqual(dest,";
    "Fxn:test_index_add";
    "Fxn:torch.randn(num_dest,";
    "Fxn:torch.randn(num_copy,";
    "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:dest.clone()";
    "Fxn:dest.index_add_(0,";
    "Fxn:self.assertEqual(dest,";
    "Fxn:torch.randn(num_dest)";
    "Fxn:torch.randn(num_copy)";
    "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:dest.clone()";
    "Fxn:dest.index_add_(0,";
    "Fxn:self.assertEqual(dest,";
    "Fxn:test_index_select";
    "Fxn:torch.randn(3,";
    "Fxn:torch.LongTensor([2,";
    "Fxn:torch.index_select(src,";
    "Fxn:self.assertEqual(dest.shape,";
    "Fxn:self.assertEqual(dest[i],";
    "Fxn:torch.randn(5";
    "Fxn:torch.index_select(src,";
    "Fxn:out=out.view(5,";
    "Fxn:self.assertEqual(dest.shape,";
    "Fxn:self.assertEqual(dest[i],";
    "Fxn:out.fill_(0.123)";
    "Fxn:self.assertEqual(out,";
    "Fxn:dest.view(-1))";
    "Fxn:test_take";
    "Fxn:check";
    "Fxn:src.contiguous().view(-1).index_select(";
    "Fxn:idx.contiguous().view(-1)).view_as(idx)";
    "Fxn:src.take(idx)";
    "Fxn:self.assertEqual(actual.size(),";
    "Fxn:idx.size())";
    "Fxn:self.assertEqual(expected,";
    "Fxn:torch.randn(2,";
    "Fxn:torch.LongTensor([[0,";
    "Fxn:check(src,";
    "Fxn:check(src.transpose(1,";
    "Fxn:test_put_";
    "Fxn:check";
    "Fxn:dst.clone().view(-1).index_copy_(";
    "Fxn:idx.contiguous().view(-1),";
    "Fxn:value.contiguous().view(-1))";
    "Fxn:expected.view_as(dst)";
    "Fxn:dst.put_(idx,";
    "Fxn:self.assertEqual(expected,";
    "Fxn:torch.randn(2,";
    "Fxn:torch.LongTensor([[0,";
    "Fxn:torch.randn(2,";
    "Fxn:check(dst,";
    "Fxn:check(dst.transpose(1,";
    "Fxn:test_put_accumulate";
    "Fxn:torch.ones(2,";
    "Fxn:torch.LongTensor([[0,";
    "Fxn:torch.Tensor([1,";
    "Fxn:dst.put_(idx,";
    "Fxn:self.assertEqual(dst.tolist(),";
    "Fxn:_fill_indices";
    "Fxn:idx.size(dim)";
    "Fxn:idx[tuple(ii)]";
    "Fxn:torch.randperm(dim_size)[0:elems_per_row]";
    "Fxn:_test_gather";
    "Fxn:random.randint(10,";
    "Fxn:random.randint(10,";
    "Fxn:random.randint(10,";
    "Fxn:random.randint(1,";
    "Fxn:random.randrange(3)";
    "Fxn:torch.randn(m,";
    "Fxn:torch.LongTensor().resize_(*idx_size)";
    "Fxn:TestTorch._fill_indices(self,";
    "Fxn:src.size(dim),";
    "Fxn:cast(src)";
    "Fxn:cast(idx)";
    "Fxn:torch.gather(src,";
    "Fxn:cast(torch.Tensor().resize_(*idx_size))";
    "Fxn:src[tuple(ii)]";
    "Fxn:self.assertEqual(actual,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.gather(src,";
    "Fxn:cast(torch.randn(3,";
    "Fxn:src.max(2,";
    "Fxn:cast(expected)";
    "Fxn:cast(idx)";
    "Fxn:torch.gather(src,";
    "Fxn:self.assertEqual(actual,";
    "Fxn:test_gather";
    "Fxn:self._test_gather(self,";
    "Fxn:_test_scatter_base";
    "Fxn:random.randint(10,";
    "Fxn:random.randint(10,";
    "Fxn:random.randint(10,";
    "Fxn:random.randint(1,";
    "Fxn:random.randrange(3)";
    "Fxn:cast(torch.LongTensor().resize_(*idx_size))";
    "Fxn:TestTorch._fill_indices(self,";
    "Fxn:random.random()";
    "Fxn:cast(torch.Tensor(*idx_size).normal_())";
    "Fxn:cast(torch.randn(m,";
    "Fxn:method)(dim,";
    "Fxn:base.clone()";
    "Fxn:expected[tuple(ii)]";
    "Fxn:expected[tuple(ii)]";
    "Fxn:expected[tuple(ii)]";
    "Fxn:self.assertEqual(actual,";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:method)(dim,";
    "Fxn:test_scatter";
    "Fxn:self._test_scatter_base(self,";
    "Fxn:test_scatterAdd";
    "Fxn:self._test_scatter_base(self,";
    "Fxn:test_scatterFill";
    "Fxn:self._test_scatter_base(self,";
    "Fxn:test_masked_scatter";
    "Fxn:torch.randn(num_dest)";
    "Fxn:torch.randn(num_copy)";
    "Fxn:torch.ByteTensor((0,";
    "Fxn:dest.clone()";
    "Fxn:dest.masked_scatter_(mask,";
    "Fxn:self.assertEqual(dest,";
    "Fxn:torch.randn(num_dest)";
    "Fxn:dest.masked_scatter_(mask,";
    "Fxn:torch.randn(num_copy";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:dest.masked_scatter_(mask,";
    "Fxn:test_masked_select";
    "Fxn:torch.randn(num_src)";
    "Fxn:torch.rand(num_src).clamp(0,";
    "Fxn:1).mul(2).floor().byte()";
    "Fxn:src.masked_select(mask)";
    "Fxn:self.assertEqual(dst,";
    "Fxn:torch.Tensor(dst2),";
    "Fxn:test_masked_fill";
    "Fxn:torch.randn(num_dest)";
    "Fxn:torch.rand(num_dest).mul(2).floor().byte()";
    "Fxn:random.random()";
    "Fxn:dst.clone()";
    "Fxn:dst.masked_fill_(mask,";
    "Fxn:self.assertEqual(dst,";
    "Fxn:test_abs";
    "Fxn:torch.rand(size).mul(max_val)";
    "Fxn:torch.rand(size).mul(2).floor().mul(2).add(-1)";
    "Fxn:original.type(t)";
    "Fxn:switch.type(t)";
    "Fxn:torch.mul(data,";
    "Fxn:self.assertTensorsSlowEqual(res.abs(),";
    "Fxn:torch.LongTensor((-bignumber,))";
    "Fxn:self.assertGreater(res.abs()[0],";
    "Fxn:test_unbiased";
    "Fxn:torch.randn(100)";
    "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:tensor.var(0,";
    "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:tensor.var(unbiased=True))";
    "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:tensor.var(0,";
    "Fxn:torch.FloatTensor([1.0,";
    "Fxn:self.assertEqual(tensor.var(unbiased=True),";
    "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:torch.FloatTensor([1.0,";
    "Fxn:self.assertEqual(tensor.var(unbiased=True),";
    "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:torch.randn(100)";
    "Fxn:self.assertEqual(tensor.std(0),";
    "Fxn:tensor.std(0,";
    "Fxn:self.assertEqual(tensor.std(),";
    "Fxn:tensor.std(unbiased=True))";
    "Fxn:self.assertEqual(tensor.std(unbiased=False),";
    "Fxn:tensor.std(0,";
    "Fxn:test_var_stability";
    "Fxn:torch.FloatTensor([2281.5,";
    "Fxn:self.assertEqual(tensor.var(dim=0),";
    "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:_test_view";
    "Fxn:cast(torch.rand(15))";
    "Fxn:cast(torch.rand(3,";
    "Fxn:cast(torch.Tensor())";
    "Fxn:template.size()";
    "Fxn:self.assertEqual(tensor.view_as(template).size(),";
    "Fxn:self.assertEqual(tensor.view(3,";
    "Fxn:5).size(),";
    "Fxn:self.assertEqual(tensor.view(torch.Size([3,";
    "Fxn:5])).size(),";
    "Fxn:self.assertEqual(tensor.view(-1,";
    "Fxn:5).size(),";
    "Fxn:self.assertEqual(tensor.view(3,";
    "Fxn:-1).size(),";
    "Fxn:tensor.view(5,";
    "Fxn:tensor_view.fill_(random.uniform(0,";
    "Fxn:self.assertEqual(empty.view_as(empty),";
    "Fxn:self.assertEqual(empty.view(0),";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor.view(15,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor.view(7,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor.view(15,";
    "Fxn:cast(torch.rand(4,";
    "Fxn:3)).transpose(-1,";
    "Fxn:2).transpose(-2,";
    "Fxn:tensor.clone()";
    "Fxn:self.assertEqual(tensor.view(*view_size),";
    "Fxn:contig_tensor.view(*view_size))";
    "Fxn:self.assertEqual(tensor.view(*view_size),";
    "Fxn:contig_tensor.view(*view_size))";
    "Fxn:self.assertEqual(tensor.view(*view_size),";
    "Fxn:contig_tensor.view(*view_size))";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor.view(-1))";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor.view(24,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor.view(8,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor.view(8,";
    "Fxn:cast(torch.Tensor(1,";
    "Fxn:1)).expand(3,";
    "Fxn:tensor.clone()";
    "Fxn:self.assertEqual(tensor.view(-1),";
    "Fxn:contig_tensor.view(-1))";
    "Fxn:self.assertEqual(tensor.view(1,";
    "Fxn:contig_tensor.view(1,";
    "Fxn:self.assertEqual(tensor.view(-1,";
    "Fxn:contig_tensor.view(-1,";
    "Fxn:self.assertEqual(tensor.view(6,";
    "Fxn:contig_tensor.view(6,";
    "Fxn:self.assertEqual(tensor.view(1,";
    "Fxn:contig_tensor.view(1,";
    "Fxn:test_view";
    "Fxn:TestTorch._test_view(self,";
    "Fxn:test_reshape";
    "Fxn:torch.randn(3,";
    "Fxn:self.assertEqual(x.data_ptr(),";
    "Fxn:x.reshape(-1).data_ptr())";
    "Fxn:self.assertEqual(x.data_ptr(),";
    "Fxn:x.reshape(1,";
    "Fxn:1).data_ptr())";
    "Fxn:self.assertEqual(torch.reshape(x,";
    "Fxn:x.reshape(9))";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:x.reshape(-1,";
    "Fxn:torch.randn(4,";
    "Fxn:self.assertNotEqual(y.data_ptr(),";
    "Fxn:y.reshape(-1).data_ptr())";
    "Fxn:self.assertEqual(y.contiguous().view(-1),";
    "Fxn:y.reshape(-1))";
    "Fxn:self.assertEqual(y.reshape(2,";
    "Fxn:4).data_ptr(),";
    "Fxn:y.data_ptr())";
    "Fxn:torch.randn(())";
    "Fxn:self.assertEqual(s.data_ptr(),";
    "Fxn:s.reshape(()).data_ptr())";
    "Fxn:self.assertEqual(s.reshape(-1).shape,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:s.reshape(2))";
    "Fxn:torch.tensor([])";
    "Fxn:self.assertEqual(empty,";
    "Fxn:empty.reshape(-1))";
    "Fxn:self.assertEqual(empty,";
    "Fxn:empty.reshape([0]))";
    "Fxn:self.assertEqual(empty.reshape([0,";
    "Fxn:self.assertEqual(empty.reshape([1,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:empty.reshape(1))";
    "Fxn:test_expand";
    "Fxn:torch.rand(1,";
    "Fxn:torch.rand(5)";
    "Fxn:torch.rand(4,";
    "Fxn:template.size()";
    "Fxn:self.assertEqual(tensor.expand_as(template).size(),";
    "Fxn:self.assertEqual(tensor.expand(4,";
    "Fxn:5).size(),";
    "Fxn:self.assertEqual(tensor.expand(target).size(),";
    "Fxn:self.assertEqual(tensor2.expand_as(template).size(),";
    "Fxn:self.assertEqual(tensor2.expand(4,";
    "Fxn:5).size(),";
    "Fxn:self.assertEqual(tensor2.expand(target).size(),";
    "Fxn:self.assertEqual(tensor2.expand(1,";
    "Fxn:5).expand(2,";
    "Fxn:tensor2.repeat(2,";
    "Fxn:torch.randn(5,";
    "Fxn:self.assertFalse(noncontig.is_contiguous())";
    "Fxn:self.assertEqual(noncontig.expand(2,";
    "Fxn:noncontig.contiguous().repeat(2,";
    "Fxn:tensor2.expand(1,";
    "Fxn:tensor2.unsqueeze(0).unsqueeze(1)";
    "Fxn:self.assertEqual(expanded,";
    "Fxn:self.assertEqual(expanded.stride(),";
    "Fxn:unsqueezed.stride())";
    "Fxn:self.assertEqual(tensor.expand(4,";
    "Fxn:tensor.expand(4,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:tensor2.expand(-1,";
    "Fxn:self.assertEqual(torch.zeros(0).expand((0,)),";
    "Fxn:torch.zeros(0))";
    "Fxn:test_repeat";
    "Fxn:torch.rand(*initial_shape)";
    "Fxn:torch.Size(size)";
    "Fxn:self.assertEqual(tensor.repeat(*size).size(),";
    "Fxn:self.assertEqual(tensor.repeat(torchSize).size(),";
    "Fxn:tensor.repeat(*size)";
    "Fxn:self.assertEqual(result.size(),";
    "Fxn:tensor.repeat(torchSize)";
    "Fxn:self.assertEqual(result.size(),";
    "Fxn:self.assertEqual(result.mean(0).view(8,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_repeat_tile";
    "Fxn:_generate_noncontiguous_input";
    "Fxn:np.broadcast_to(np.random.random((1,";
    "Fxn:torch.from_numpy(_generate_noncontiguous_input()),):";
    "Fxn:self.assertEqual(tensor.repeat(*repeat).numpy(),";
    "Fxn:np.tile(tensor.numpy(),";
    "Fxn:test_is_same_size";
    "Fxn:torch.Tensor(3,";
    "Fxn:torch.Tensor(3,";
    "Fxn:torch.Tensor(1,";
    "Fxn:torch.Tensor(3,";
    "Fxn:self.assertFalse(t1.is_same_size(t2))";
    "Fxn:self.assertFalse(t1.is_same_size(t3))";
    "Fxn:self.assertTrue(t1.is_same_size(t4))";
    "Fxn:test_is_set_to";
    "Fxn:torch.Tensor(3,";
    "Fxn:torch.Tensor(3,";
    "Fxn:torch.Tensor().set_(t1)";
    "Fxn:t3.clone().resize_(12,";
    "Fxn:self.assertFalse(t1.is_set_to(t2))";
    "Fxn:self.assertTrue(t1.is_set_to(t3))";
    "Fxn:self.assertTrue(t3.is_set_to(t1),";
    "Fxn:self.assertFalse(t1.is_set_to(t4))";
    "Fxn:self.assertFalse(torch.Tensor().is_set_to(torch.Tensor()),";
    "Fxn:test_tensor_set";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor(3,";
    "Fxn:10).uniform_()";
    "Fxn:t1.set_(t2)";
    "Fxn:self.assertEqual(t1.storage()._cdata,";
    "Fxn:t2.storage()._cdata)";
    "Fxn:torch.Size([9,";
    "Fxn:t1.set_(t2.storage(),";
    "Fxn:self.assertEqual(t1.size(),";
    "Fxn:t1.set_(t2.storage(),";
    "Fxn:self.assertEqual(t1.size(),";
    "Fxn:self.assertEqual(t1.stride(),";
    "Fxn:t1.set_(t2.storage(),";
    "Fxn:self.assertEqual(t1.stride(),";
    "Fxn:t1.set_(t2.storage(),";
    "Fxn:self.assertEqual(t1.size(),";
    "Fxn:self.assertEqual(t1.stride(),";
    "Fxn:test_equal";
    "Fxn:torch.Tensor((3,";
    "Fxn:t1.contiguous()";
    "Fxn:torch.Tensor((1,";
    "Fxn:torch.Tensor((3,";
    "Fxn:torch.Tensor()";
    "Fxn:self.assertTrue(t1.equal(t2))";
    "Fxn:self.assertFalse(t1.equal(t3))";
    "Fxn:self.assertFalse(t1.equal(t4))";
    "Fxn:self.assertFalse(t1.equal(t5))";
    "Fxn:self.assertTrue(torch.equal(t1,";
    "Fxn:self.assertFalse(torch.equal(t1,";
    "Fxn:self.assertFalse(torch.equal(t1,";
    "Fxn:self.assertFalse(torch.equal(t1,";
    "Fxn:torch.Tensor(((1,";
    "Fxn:s1.clone()";
    "Fxn:torch.Tensor(((2,";
    "Fxn:torch.Tensor(((0,";
    "Fxn:self.assertFalse(s1.is_contiguous())";
    "Fxn:self.assertTrue(s1.equal(s2))";
    "Fxn:self.assertTrue(s1.equal(s3))";
    "Fxn:self.assertFalse(s1.equal(s4))";
    "Fxn:self.assertTrue(torch.equal(s1,";
    "Fxn:self.assertTrue(torch.equal(s1,";
    "Fxn:self.assertFalse(torch.equal(s1,";
    "Fxn:test_element_size";
    "Fxn:torch.ByteStorage().element_size()";
    "Fxn:torch.CharStorage().element_size()";
    "Fxn:torch.ShortStorage().element_size()";
    "Fxn:torch.IntStorage().element_size()";
    "Fxn:torch.LongStorage().element_size()";
    "Fxn:torch.FloatStorage().element_size()";
    "Fxn:torch.DoubleStorage().element_size()";
    "Fxn:self.assertEqual(byte,";
    "Fxn:torch.ByteTensor().element_size())";
    "Fxn:self.assertEqual(char,";
    "Fxn:torch.CharTensor().element_size())";
    "Fxn:self.assertEqual(short,";
    "Fxn:torch.ShortTensor().element_size())";
    "Fxn:self.assertEqual(int,";
    "Fxn:torch.IntTensor().element_size())";
    "Fxn:self.assertEqual(long,";
    "Fxn:torch.LongTensor().element_size())";
    "Fxn:self.assertEqual(float,";
    "Fxn:torch.FloatTensor().element_size())";
    "Fxn:self.assertEqual(double,";
    "Fxn:torch.DoubleTensor().element_size())";
    "Fxn:self.assertGreater(byte,";
    "Fxn:self.assertGreater(char,";
    "Fxn:self.assertGreater(short,";
    "Fxn:self.assertGreater(int,";
    "Fxn:self.assertGreater(long,";
    "Fxn:self.assertGreater(float,";
    "Fxn:self.assertGreater(double,";
    "Fxn:self.assertEqual(byte,";
    "Fxn:self.assertEqual(char,";
    "Fxn:self.assertGreaterEqual(short,";
    "Fxn:self.assertGreaterEqual(int,";
    "Fxn:self.assertGreaterEqual(int,";
    "Fxn:self.assertGreaterEqual(long,";
    "Fxn:self.assertGreaterEqual(long,";
    "Fxn:self.assertGreaterEqual(double,";
    "Fxn:test_split";
    "Fxn:torch.rand(7,";
    "Fxn:tensor.split(split_size,";
    "Fxn:self.assertEqual(split.size(),";
    "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:torch.randn(20,";
    "Fxn:tensor.split(split_sizes,";
    "Fxn:self.assertEqual(split.size(),";
    "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:tensor.split(split_sizes,";
    "Fxn:self.assertEqual(split.size(),";
    "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:test_chunk";
    "Fxn:torch.rand(4,";
    "Fxn:tensor.chunk(num_chunks,";
    "Fxn:self.assertEqual(split.size(),";
    "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:test_tolist";
    "Fxn:torch.Tensor(list0D)";
    "Fxn:self.assertEqual(tensor0D.tolist(),";
    "Fxn:torch.Tensor(table1D)";
    "Fxn:torch.Storage(table1D)";
    "Fxn:self.assertEqual(tensor1D.tolist(),";
    "Fxn:self.assertEqual(storage.tolist(),";
    "Fxn:self.assertEqual(tensor1D.tolist(),";
    "Fxn:self.assertEqual(storage.tolist(),";
    "Fxn:torch.Tensor(table2D)";
    "Fxn:self.assertEqual(tensor2D.tolist(),";
    "Fxn:torch.Tensor([[[1,";
    "Fxn:tensor3D.select(1,";
    "Fxn:self.assertFalse(tensorNonContig.is_contiguous())";
    "Fxn:self.assertEqual(tensorNonContig.tolist(),";
    "Fxn:test_permute";
    "Fxn:torch.randperm(7).tolist()";
    "Fxn:torch.Tensor(*orig).fill_(0)";
    "Fxn:x.permute(*perm).size()))";
    "Fxn:self.assertEqual(perm,";
    "Fxn:self.assertEqual(x.size(),";
    "Fxn:test_storage";
    "Fxn:torch.randn(3,";
    "Fxn:self.assertEqual(v.storage()[0],";
    "Fxn:self.assertEqual(v.storage()[14],";
    "Fxn:test_storageview";
    "Fxn:torch.LongStorage((3,";
    "Fxn:torch.LongStorage(s1,";
    "Fxn:self.assertEqual(s2.size(),";
    "Fxn:self.assertEqual(s2[0],";
    "Fxn:self.assertEqual(s2[1],";
    "Fxn:self.assertEqual(13,";
    "Fxn:test_nonzero";
    "Fxn:torch.Size((12,)),";
    "Fxn:torch.Size((12,";
    "Fxn:torch.Size((1,";
    "Fxn:torch.Size((6,";
    "Fxn:torch.Size((3,";
    "Fxn:torch.rand(num_src).mul(2).floor().type(t)";
    "Fxn:tensor.sum()";
    "Fxn:tensor.clone().resize_(shape)";
    "Fxn:torch.nonzero(tensor)";
    "Fxn:tensor.nonzero()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.nonzero(tensor,";
    "Fxn:self.assertEqual(dst1.select(1,";
    "Fxn:torch.LongTensor(dst),";
    "Fxn:self.assertEqual(dst2.select(1,";
    "Fxn:torch.LongTensor(dst),";
    "Fxn:self.assertEqual(dst3.select(1,";
    "Fxn:torch.LongTensor(dst),";
    "Fxn:self.assertNotEqual(tensor[dst1[i,";
    "Fxn:1]].item(),";
    "Fxn:self.assertNotEqual(tensor[dst1[i,";
    "Fxn:2]].item(),";
    "Fxn:test_deepcopy";
    "Fxn:torch.randn(5,";
    "Fxn:torch.randn(5,";
    "Fxn:a.view(25)";
    "Fxn:[a.storage(),";
    "Fxn:b.storage()],";
    "Fxn:deepcopy(q)";
    "Fxn:self.assertEqual(w[0],";
    "Fxn:self.assertEqual(w[1][0],";
    "Fxn:self.assertEqual(w[1][1],";
    "Fxn:self.assertEqual(w[1],";
    "Fxn:self.assertEqual(w[2],";
    "Fxn:w[0].add_(1)";
    "Fxn:self.assertEqual(w[1][0][i],";
    "Fxn:self.assertEqual(w[3],";
    "Fxn:w[2].sub_(1)";
    "Fxn:self.assertEqual(w[1][1][i],";
    "Fxn:test_deepcopy_scalar";
    "Fxn:torch.tensor(5)";
    "Fxn:self.assertEqual(a.size(),";
    "Fxn:deepcopy(a).size())";
    "Fxn:self.assertEqual(a,";
    "Fxn:deepcopy(a))";
    "Fxn:test_copy";
    "Fxn:torch.randn(5,";
    "Fxn:a.clone()";
    "Fxn:copy(a)";
    "Fxn:b.fill_(1)";
    "Fxn:self.assertEqual(a,";
    "Fxn:test_pickle";
    "Fxn:torch.randn(5,";
    "Fxn:pickle.dumps(a)";
    "Fxn:pickle.loads(serialized)";
    "Fxn:self.assertEqual(a,";
    "Fxn:test_norm_fastpaths";
    "Fxn:torch.randn(3,";
    "Fxn:torch.norm(x,";
    "Fxn:torch.pow(x.abs().pow(4.5).sum(1),";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.norm(x,";
    "Fxn:0).type_as(x).sum(1)";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.norm(x,";
    "Fxn:x.abs().sum(1)";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.norm(x,";
    "Fxn:torch.sqrt(x.pow(2).sum(1))";
    "Fxn:self.assertEqual(result,";
    "Fxn:torch.norm(x,";
    "Fxn:torch.pow(x.pow(3).abs().sum(1),";
    "Fxn:self.assertEqual(result,";
    "Fxn:test_bernoulli";
    "Fxn:torch.ByteTensor(10,";
    "Fxn:isBinary";
    "Fxn:torch.ne(t,";
    "Fxn:0).mul_(torch.ne(t,";
    "Fxn:1)).sum()";
    "Fxn:t.bernoulli_(p)";
    "Fxn:self.assertTrue(isBinary(t))";
    "Fxn:torch.rand(10,";
    "Fxn:t.bernoulli_(p)";
    "Fxn:self.assertTrue(isBinary(t))";
    "Fxn:torch.rand(5,";
    "Fxn:self.assertTrue(isBinary(q.bernoulli()))";
    "Fxn:test_normal";
    "Fxn:torch.Tensor(100,";
    "Fxn:q.normal_()";
    "Fxn:self.assertEqual(q.mean(),";
    "Fxn:self.assertEqual(q.std(),";
    "Fxn:q.normal_(2,";
    "Fxn:self.assertEqual(q.mean(),";
    "Fxn:self.assertEqual(q.std(),";
    "Fxn:torch.Tensor(100,";
    "Fxn:torch.Tensor(100,";
    "Fxn:torch.normal(mean)";
    "Fxn:self.assertEqual(r[:50].mean(),";
    "Fxn:self.assertEqual(r[50:].mean(),";
    "Fxn:self.assertEqual(r.std(),";
    "Fxn:torch.normal(mean,";
    "Fxn:self.assertEqual(r[:50].mean(),";
    "Fxn:self.assertEqual(r[50:].mean(),";
    "Fxn:self.assertEqual(r.std(),";
    "Fxn:torch.normal(2,";
    "Fxn:self.assertEqual(r.mean(),";
    "Fxn:self.assertEqual(r[:,";
    "Fxn::50].std(),";
    "Fxn:self.assertEqual(r[:,";
    "Fxn:50:].std(),";
    "Fxn:torch.normal(mean,";
    "Fxn:self.assertEqual(r[:50].mean(),";
    "Fxn:self.assertEqual(r[50:].mean(),";
    "Fxn:self.assertEqual(r[:,";
    "Fxn::50].std(),";
    "Fxn:self.assertEqual(r[:,";
    "Fxn:50:].std(),";
    "Fxn:_test_serialization";
    "Fxn:[torch.randn(5,";
    "Fxn:5).float()";
    "Fxn:[a[0].storage()]";
    "Fxn:[a[0].storage()[1:4]]";
    "Fxn:[torch.arange(1,";
    "Fxn:11).int()]";
    "Fxn:torch.FloatTensor().set_(a[0].storage()[1:4],";
    "Fxn:torch.FloatTensor().set_(a[0].storage()[1:4],";
    "Fxn:[(t1.storage(),";
    "Fxn:t1.storage(),";
    "Fxn:t2.storage())]";
    "Fxn:[a[0].storage()[0:2]]";
    "Fxn:torch.save(...)";
    "Fxn:filecontext_lambda()";
    "Fxn:torch.save(b,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(handle)";
    "Fxn:self.assertEqual(b,";
    "Fxn:self.assertTrue(isinstance(c[0],";
    "Fxn:self.assertTrue(isinstance(c[1],";
    "Fxn:self.assertTrue(isinstance(c[2],";
    "Fxn:self.assertTrue(isinstance(c[3],";
    "Fxn:self.assertTrue(isinstance(c[4],";
    "Fxn:c[0].fill_(10)";
    "Fxn:self.assertEqual(c[0],";
    "Fxn:self.assertEqual(c[4],";
    "Fxn:torch.FloatStorage(25).fill_(10),";
    "Fxn:c[1].fill_(20)";
    "Fxn:self.assertEqual(c[1],";
    "Fxn:self.assertEqual(c[4][1:4],";
    "Fxn:self.assertEqual(views[0]._cdata,";
    "Fxn:self.assertEqual(views[0],";
    "Fxn:self.assertNotEqual(views[0]._cdata,";
    "Fxn:self.assertEqual(rootview.data_ptr(),";
    "Fxn:c[0].data_ptr())";
    "Fxn:test_serialization";
    "Fxn:self._test_serialization(tempfile.NamedTemporaryFile)";
    "Fxn:test_serialization_filelike";
    "Fxn:self._test_serialization(BytesIOContext,";
    "Fxn:_test_serialization_offset";
    "Fxn:torch.randn(5,";
    "Fxn:tempfile.TemporaryFile()";
    "Fxn:pickle.dump(i,";
    "Fxn:torch.save(a,";
    "Fxn:f.seek(0)";
    "Fxn:pickle.load(f)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertTrue(torch.equal(a,";
    "Fxn:self.assertEqual(i,";
    "Fxn:test_serialization_offset";
    "Fxn:self._test_serialization_offset(tempfile.TemporaryFile)";
    "Fxn:test_serialization_offset_filelike";
    "Fxn:self._test_serialization_offset(BytesIOContext)";
    "Fxn:test_half_tensor";
    "Fxn:torch.randn(5,";
    "Fxn:5).float()";
    "Fxn:torch.randn(5,";
    "Fxn:5).float()";
    "Fxn:x.half(),";
    "Fxn:y.half()";
    "Fxn:self.assertEqual(x.half().float(),";
    "Fxn:torch.Tensor(5,";
    "Fxn:self.assertEqual(z.copy_(xh),";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(xh,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertEqual(xh.float(),";
    "Fxn:xh2.float())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_half_tensor_cuda";
    "Fxn:torch.randn(5,";
    "Fxn:5).half()";
    "Fxn:self.assertEqual(x.cuda(),";
    "Fxn:x.cuda()";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.save(xc,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertIsInstance(xc2,";
    "Fxn:self.assertEqual(xc.float(),";
    "Fxn:xc2.float())";
    "Fxn:_test_serialization_cuda";
    "Fxn:torch.cuda.device_count()";
    "Fxn:torch.cuda.FloatTensor(5).fill_(1)";
    "Fxn:torch.cuda.set_device(device_count";
    "Fxn:torch.cuda.FloatTensor(3).fill_(2)";
    "Fxn:torch.cuda.set_device(0)";
    "Fxn:filecontext_lambda()";
    "Fxn:torch.save(b,";
    "Fxn:f.seek(0)";
    "Fxn:torch.load(f)";
    "Fxn:self.assertEqual(b,";
    "Fxn:self.assertEqual(u0.get_device(),";
    "Fxn:self.assertEqual(un.get_device(),";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_serialization_cuda";
    "Fxn:self._test_serialization_cuda(tempfile.NamedTemporaryFile)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_serialization_cuda_filelike";
    "Fxn:self._test_serialization_cuda(BytesIOContext)";
    "Fxn:test_serialization_backwards_compat";
    "Fxn:[torch.arange(1";
    "Fxn:i).view(5,";
    "Fxn:5).float()";
    "Fxn:[a[0].storage()]";
    "Fxn:[a[0].storage()[1:4]]";
    "Fxn:download_file('https://download.pytorch.org/test_data/legacy_serialized.pt')";
    "Fxn:torch.load(path)";
    "Fxn:self.assertEqual(b,";
    "Fxn:self.assertTrue(isinstance(c[0],";
    "Fxn:self.assertTrue(isinstance(c[1],";
    "Fxn:self.assertTrue(isinstance(c[2],";
    "Fxn:self.assertTrue(isinstance(c[3],";
    "Fxn:self.assertTrue(isinstance(c[4],";
    "Fxn:c[0].fill_(10)";
    "Fxn:self.assertEqual(c[0],";
    "Fxn:self.assertEqual(c[4],";
    "Fxn:torch.FloatStorage(25).fill_(10),";
    "Fxn:c[1].fill_(20)";
    "Fxn:self.assertEqual(c[1],";
    "Fxn:self.assertEqual(c[4][1:4],";
    "Fxn:_test_serialization_container";
    "Fxn:'tmpmodule{}'.format(unique_key)";
    "Fxn:import_module";
    "Fxn:importlib.util.spec_from_file_location(name,";
    "Fxn:importlib.util.module_from_spec(spec)";
    "Fxn:spec.loader.exec_module(module)";
    "Fxn:imp.load_source(name,";
    "Fxn:filecontext_lambda()";
    "Fxn:os.path.join(os.path.dirname(__file__),";
    "Fxn:import_module(tmpmodule_name,";
    "Fxn:torch.save(module.Net(),";
    "Fxn:checkpoint.seek(0)";
    "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:torch.load(checkpoint)";
    "Fxn:self.assertTrue(isinstance(loaded,";
    "Fxn:self.assertEquals(len(w),";
    "Fxn:os.path.join(os.path.dirname(__file__),";
    "Fxn:import_module(tmpmodule_name,";
    "Fxn:checkpoint.seek(0)";
    "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:torch.load(checkpoint)";
    "Fxn:self.assertTrue(isinstance(loaded,";
    "Fxn:self.assertEquals(len(w),";
    "Fxn:self.assertTrue(w[0].category,";
    "Fxn:test_serialization_container";
    "Fxn:self._test_serialization_container('file',";
    "Fxn:test_serialization_container_filelike";
    "Fxn:self._test_serialization_container('filelike',";
    "Fxn:test_serialization_map_location";
    "Fxn:download_file('https://download.pytorch.org/test_data/gpu_tensors.pt')";
    "Fxn:map_location";
    "Fxn:load_bytes";
    "Fxn:io.BytesIO(f.read())";
    "Fxn:torch.load(fileobject_lambda(),";
    "Fxn:self.assertIsInstance(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:torch.FloatTensor([[1.0,";
    "Fxn:test_serialization_filelike_api_requirements";
    "Fxn:FilelikeMock(b'',";
    "Fxn:torch.randn(3,";
    "Fxn:torch.save(tensor,";
    "Fxn:self.assertTrue(expected_superset.issuperset(filemock.calls))";
    "Fxn:filemock.seek(0)";
    "Fxn:filemock.calls.clear()";
    "Fxn:torch.load(filemock)";
    "Fxn:self.assertTrue(expected_superset.issuperset(filemock.calls))";
    "Fxn:_test_serialization_filelike";
    "Fxn:mock(b'')";
    "Fxn:torch.save(tensor,";
    "Fxn:f.seek(0)";
    "Fxn:mock(f.read())";
    "Fxn:torch.load(data)";
    "Fxn:self.assertTrue(torch.equal(tensor,";
    "Fxn:msg.format(desc))";
    "Fxn:test_serialization_filelike_missing_attrs";
    "Fxn:FilelikeMock(x)),";
    "Fxn:FilelikeMock(x,";
    "Fxn:FilelikeMock(x,";
    "Fxn:torch.randn(3,";
    "Fxn:self._test_serialization_filelike(to_serialize,";
    "Fxn:test_serialization_filelike_stress";
    "Fxn:torch.randn(11";
    "Fxn:self._test_serialization_filelike(a,";
    "Fxn:FilelikeMock(x,";
    "Fxn:'read()";
    "Fxn:self._test_serialization_filelike(a,";
    "Fxn:FilelikeMock(x,";
    "Fxn:'readinto()";
    "Fxn:test_serialization_filelike_uses_readinto";
    "Fxn:torch.randn(5,";
    "Fxn:io.BytesIO()";
    "Fxn:torch.save(a,";
    "Fxn:f.seek(0)";
    "Fxn:FilelikeMock(f.read(),";
    "Fxn:torch.load(data)";
    "Fxn:self.assertTrue(data.was_called('readinto'))";
    "Fxn:test_from_buffer";
    "Fxn:self.assertEqual(torch.ByteStorage.from_buffer(a).tolist(),";
    "Fxn:torch.ShortStorage.from_buffer(a,";
    "Fxn:self.assertEqual(shorts.size(),";
    "Fxn:self.assertEqual(shorts.tolist(),";
    "Fxn:torch.IntStorage.from_buffer(a,";
    "Fxn:self.assertEqual(ints.size(),";
    "Fxn:self.assertEqual(ints[0],";
    "Fxn:torch.FloatStorage.from_buffer(f,";
    "Fxn:self.assertEqual(floats.size(),";
    "Fxn:self.assertEqual(floats[0],";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_from_file";
    "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:torch.FloatStorage.from_file(f.name,";
    "Fxn:torch.FloatTensor(s1).copy_(torch.randn(size))";
    "Fxn:torch.FloatStorage.from_file(f.name,";
    "Fxn:torch.FloatTensor(s2)";
    "Fxn:self.assertEqual(t1,";
    "Fxn:random.uniform(-1,";
    "Fxn:t1.fill_(rnum)";
    "Fxn:self.assertEqual(t1,";
    "Fxn:random.uniform(-1,";
    "Fxn:t2.fill_(rnum)";
    "Fxn:self.assertEqual(t1,";
    "Fxn:test_print";
    "Fxn:torch.cuda.is_available():";
    "Fxn:100).fill_(1)";
    "Fxn:obj.__repr__()";
    "Fxn:torch.cuda.is_available():";
    "Fxn:obj.__repr__()";
    "Fxn:torch.Tensor([4,";
    "Fxn:x.__repr__()";
    "Fxn:torch.DoubleTensor([1e-324,";
    "Fxn:x.__repr__()";
    "Fxn:test_sizeof";
    "Fxn:torch.randn(0).storage().__sizeof__()";
    "Fxn:torch.randn(10).storage().__sizeof__()";
    "Fxn:torch.randn(100).storage().__sizeof__()";
    "Fxn:self.assertEqual((sizeof_100";
    "Fxn:self.assertEqual((sizeof_100";
    "Fxn:torch.randn(0).type(torch.ByteTensor).storage().__sizeof__()";
    "Fxn:torch.randn(10).type(torch.ByteTensor).storage().__sizeof__()";
    "Fxn:torch.randn(100).type(torch.ByteTensor).storage().__sizeof__()";
    "Fxn:self.assertEqual((sizeof_100";
    "Fxn:self.assertEqual((sizeof_100";
    "Fxn:test_unsqueeze";
    "Fxn:torch.randn(2,";
    "Fxn:x.unsqueeze(1)";
    "Fxn:self.assertEqual(y,";
    "Fxn:x.view(2,";
    "Fxn:x.clone().unsqueeze_(2)";
    "Fxn:self.assertEqual(y,";
    "Fxn:x.view(2,";
    "Fxn:self.assertFalse(x.is_contiguous())";
    "Fxn:x.unsqueeze(1)";
    "Fxn:self.assertEqual(y,";
    "Fxn:x.contiguous().view(2,";
    "Fxn:x.clone().unsqueeze_(2)";
    "Fxn:self.assertEqual(y,";
    "Fxn:x.contiguous().view(2,";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:torch.Tensor().unsqueeze(0))";
    "Fxn:test_iter";
    "Fxn:torch.randn(5,";
    "Fxn:self.assertEqual(sub,";
    "Fxn:torch.Tensor()";
    "Fxn:self.assertEqual(list(x),";
    "Fxn:test_accreal_type";
    "Fxn:torch.ones(2,";
    "Fxn:self.assertIsInstance(x.double().sum().item(),";
    "Fxn:self.assertIsInstance(x.float().sum().item(),";
    "Fxn:self.assertIsInstance(x.long().sum().item(),";
    "Fxn:self.assertIsInstance(x.int().sum().item(),";
    "Fxn:self.assertIsInstance(x.short().sum().item(),";
    "Fxn:self.assertIsInstance(x.char().sum().item(),";
    "Fxn:self.assertIsInstance(x.byte().sum().item(),";
    "Fxn:test_assertEqual";
    "Fxn:torch.FloatTensor([0])";
    "Fxn:self.assertEqual(x,";
    "Fxn:torch.autograd.Variable(x)";
    "Fxn:self.assertEqual(xv,";
    "Fxn:self.assertEqual(x,";
    "Fxn:self.assertEqual(xv,";
    "Fxn:test_new";
    "Fxn:torch.autograd.Variable(torch.Tensor())";
    "Fxn:torch.autograd.Variable(torch.randn(4,";
    "Fxn:torch.autograd.Variable(torch.IntTensor([1,";
    "Fxn:self.assertEqual(x.new().shape,";
    "Fxn:self.assertEqual(x.new(),";
    "Fxn:self.assertIs(torch.uint8,";
    "Fxn:x.new(dtype=torch.uint8).dtype)";
    "Fxn:self.assertEqual(x.new(1,";
    "Fxn:self.assertEqual(x.new(torch.Size([3,";
    "Fxn:self.assertIs(torch.uint8,";
    "Fxn:x.new(1,";
    "Fxn:self.assertIs(torch.uint8,";
    "Fxn:x.new(torch.Size([3,";
    "Fxn:self.assertEqual(x.new([3,";
    "Fxn:self.assertEqual(x.new([3,";
    "Fxn:4]).tolist(),";
    "Fxn:self.assertEqual(x.new((3,";
    "Fxn:4)).tolist(),";
    "Fxn:self.assertIs(torch.uint8,";
    "Fxn:x.new((3,";
    "Fxn:self.assertEqual(x.new([np.int32(3),";
    "Fxn:np.float64(4)]).tolist(),";
    "Fxn:self.assertIs(torch.uint8,";
    "Fxn:x.new([np.int32(3),";
    "Fxn:np.float64(4)],";
    "Fxn:self.assertEqual(x.new(np.array((3,";
    "Fxn:4))).tolist(),";
    "Fxn:self.assertIs(torch.int64,";
    "Fxn:x.new(np.array((3,";
    "Fxn:self.assertEqual(x.new([z[2],";
    "Fxn:3]).tolist(),";
    "Fxn:self.assertIs(torch.uint8,";
    "Fxn:x.new([z[2],";
    "Fxn:self.assertEqual(x.new(size=(3,";
    "Fxn:self.assertEqual(x.new(tuple()).shape,";
    "Fxn:self.assertEqual(x.new(y.storage()).data_ptr(),";
    "Fxn:y.data_ptr())";
    "Fxn:self.assertEqual(x.new(y).data_ptr(),";
    "Fxn:y.data_ptr())";
    "Fxn:self.assertIsNot(x.new(y),";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:x.new(z))";
    "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:x.new(z.storage()))";
    "Fxn:test_empty_like";
    "Fxn:torch.autograd.Variable(torch.Tensor())";
    "Fxn:torch.autograd.Variable(torch.randn(4,";
    "Fxn:torch.autograd.Variable(torch.IntTensor([1,";
    "Fxn:self.assertEqual(torch.empty_like(a).shape,";
    "Fxn:self.assertEqual(torch.empty_like(a).type(),";
    "Fxn:a.type())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_pin_memory";
    "Fxn:torch.randn(3,";
    "Fxn:self.assertFalse(x.is_pinned())";
    "Fxn:x.pin_memory()";
    "Fxn:self.assertTrue(pinned.is_pinned())";
    "Fxn:self.assertEqual(pinned,";
    "Fxn:self.assertNotEqual(pinned.data_ptr(),";
    "Fxn:x.data_ptr())";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy_unresizable";
    "Fxn:np.zeros((2,";
    "Fxn:torch.from_numpy(x)";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:x.resize((5,";
    "Fxn:torch.randn(5,";
    "Fxn:z.numpy()";
    "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:z.resize_(10,";
    "Fxn:self.assertRaises(ValueError):";
    "Fxn:w.resize((10,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_toNumpy";
    "Fxn:torch.randn(sz).mul(255).type(tp)";
    "Fxn:x.numpy()";
    "Fxn:self.assertEqual(x[i],";
    "Fxn:torch.randn(sz";
    "Fxn:2).mul(255).type(tp)";
    "Fxn:xm.narrow(0,";
    "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:x.numpy()";
    "Fxn:self.assertEqual(x[i],";
    "Fxn:check2d";
    "Fxn:self.assertEqual(x[i][j],";
    "Fxn:torch.Tensor().type(tp)";
    "Fxn:x.numpy()";
    "Fxn:self.assertEqual(y.size,";
    "Fxn:torch.randn(sz1,";
    "Fxn:sz2).mul(255).type(tp)";
    "Fxn:x.numpy()";
    "Fxn:check2d(x,";
    "Fxn:self.assertTrue(y.flags['C_CONTIGUOUS'])";
    "Fxn:torch.randn(sz1";
    "Fxn:sz2).mul(255).type(tp)";
    "Fxn:xm.narrow(0,";
    "Fxn:x.numpy()";
    "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:check2d(x,";
    "Fxn:self.assertTrue(y.flags['C_CONTIGUOUS'])";
    "Fxn:torch.randn(sz2,";
    "Fxn:sz1).mul(255).type(tp).t()";
    "Fxn:x.numpy()";
    "Fxn:check2d(x,";
    "Fxn:self.assertFalse(y.flags['C_CONTIGUOUS'])";
    "Fxn:torch.randn(sz2";
    "Fxn:sz1).mul(255).type(tp)";
    "Fxn:xm.narrow(0,";
    "Fxn:sz2).t()";
    "Fxn:x.numpy()";
    "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:check2d(x,";
    "Fxn:torch.randn(sz2";
    "Fxn:2).mul(255).type(tp)";
    "Fxn:xm.narrow(0,";
    "Fxn:sz2).narrow(1,";
    "Fxn:sz1).t()";
    "Fxn:x.numpy()";
    "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:check2d(x,";
    "Fxn:torch.randn(3,";
    "Fxn:4).mul(255).type(tp)";
    "Fxn:x.numpy()";
    "Fxn:self.assertTrue(y.flags.writeable)";
    "Fxn:self.assertTrue(x[0][1]";
    "Fxn:x.t().numpy()";
    "Fxn:self.assertTrue(y.flags.writeable)";
    "Fxn:self.assertTrue(x[0][1]";
    "Fxn:test_dlpack_conversion";
    "Fxn:torch.randn(1,";
    "Fxn:4).type('torch.FloatTensor')";
    "Fxn:from_dlpack(to_dlpack(x))";
    "Fxn:self.assertEqual(z,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_dlpack_cuda";
    "Fxn:torch.randn(1,";
    "Fxn:4).cuda()";
    "Fxn:from_dlpack(to_dlpack(x))";
    "Fxn:self.assertEqual(z,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_from_numpy";
    "Fxn:np.array([1,";
    "Fxn:torch.from_numpy(array)";
    "Fxn:self.assertEqual(tensor_from_array[i],";
    "Fxn:np.linspace(1,";
    "Fxn:torch.arange(1,";
    "Fxn:126).view(5,";
    "Fxn:self.assertEqual(torch.from_numpy(x),";
    "Fxn:np.linspace(1,";
    "Fxn:torch.arange(1,";
    "Fxn:26).view(5,";
    "Fxn:5).t()";
    "Fxn:self.assertEqual(torch.from_numpy(x.T),";
    "Fxn:np.linspace(1,";
    "Fxn:torch.arange(1,";
    "Fxn:126).view(5,";
    "Fxn:self.assertEqual(torch.from_numpy(x),";
    "Fxn:np.zeros((0,";
    "Fxn:self.assertEqual(torch.from_numpy(x).shape,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_ctor_with_numpy_array";
    "Fxn:np.array([1,";
    "Fxn:torch.DoubleTensor(array)";
    "Fxn:self.assertEqual(tensor[i],";
    "Fxn:torch.cuda.is_available():";
    "Fxn:torch.cuda.DoubleTensor(array)";
    "Fxn:self.assertEqual(tensor[i],";
    "Fxn:torch.FloatTensor(array)";
    "Fxn:self.assertEqual(tensor[i],";
    "Fxn:torch.HalfTensor(array)";
    "Fxn:self.assertEqual(tensor[i],";
    "Fxn:torch.cuda.is_available():";
    "Fxn:torch.cuda.FloatTensor(array)";
    "Fxn:self.assertEqual(tensor[i],";
    "Fxn:torch.cuda.HalfTensor(array)";
    "Fxn:self.assertEqual(tensor[i],";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy_index";
    "Fxn:np.int32([0,";
    "Fxn:torch.randn(5,";
    "Fxn:self.assertFalse(isinstance(idx,";
    "Fxn:self.assertEqual(x[idx],";
    "Fxn:x[int(idx)])";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy_array_interface";
    "Fxn:np.dtype(dtype).kind";
    "Fxn:torch.Tensor([1,";
    "Fxn:4]).type(tp)";
    "Fxn:np.array([1,";
    "Fxn:torch.Tensor([1,";
    "Fxn:-4]).type(tp)";
    "Fxn:np.array([1,";
    "Fxn:np.asarray(x)";
    "Fxn:self.assertIsInstance(asarray,";
    "Fxn:self.assertEqual(asarray.dtype,";
    "Fxn:self.assertEqual(asarray[i],";
    "Fxn:np.abs(x)";
    "Fxn:np.abs(array)";
    "Fxn:self.assertIsInstance(abs_x,";
    "Fxn:self.assertEqual(abs_x[i],";
    "Fxn:torch.IntTensor([1,";
    "Fxn:np.asarray(x,";
    "Fxn:self.assertEqual(asarray.dtype,";
    "Fxn:np.dtype(dtype).kind";
    "Fxn:np.array([1,";
    "Fxn:self.assertEqual(asarray[i],";
    "Fxn:self.assertEqual(asarray[i],";
    "Fxn:torch.Tensor([1,";
    "Fxn:4]).type(tp)";
    "Fxn:np.array([1,";
    "Fxn:ufunc(x)";
    "Fxn:ufunc(array)";
    "Fxn:self.assertIsInstance(res_x,";
    "Fxn:self.assertEqual(res_x[i],";
    "Fxn:torch.Tensor([1,";
    "Fxn:4]).type(tp)";
    "Fxn:np.array([1,";
    "Fxn:np.greater_equal(x,";
    "Fxn:np.greater_equal(array,";
    "Fxn:2).astype('uint8')";
    "Fxn:self.assertIsInstance(geq2_x,";
    "Fxn:self.assertEqual(geq2_x[i],";
    "Fxn:test_error_msg_type_translation";
    "Fxn:self.assertRaisesRegex(";
    "Fxn:'(?=.*torch\.DoubleTensor)(?=.*torch\.LongTensor)'):";
    "Fxn:torch.autograd.Variable(torch.randn(1,";
    "Fxn:6).double())";
    "Fxn:torch.zeros(1,";
    "Fxn:3).long()";
    "Fxn:torch.nn.Conv2d(1,";
    "Fxn:model(input)";
    "Fxn:test_comparison_ops";
    "Fxn:torch.randn(5,";
    "Fxn:torch.randn(5,";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertEqual(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertEqual(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertEqual(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertEqual(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertEqual(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertEqual(x[idx]";
    "Fxn:test_bitwise_ops";
    "Fxn:torch.randn(5,";
    "Fxn:5).gt(0)";
    "Fxn:torch.randn(5,";
    "Fxn:5).gt(0)";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertTrue(x[idx]";
    "Fxn:self.assertFalse(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertTrue(x[idx]";
    "Fxn:self.assertFalse(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertTrue(x[idx]";
    "Fxn:self.assertFalse(x[idx]";
    "Fxn:iter_indices(x):";
    "Fxn:self.assertEqual(1";
    "Fxn:x.clone()";
    "Fxn:self.assertEqual(x_clone,";
    "Fxn:x.clone()";
    "Fxn:self.assertEqual(x_clone,";
    "Fxn:x.clone()";
    "Fxn:self.assertEqual(x_clone,";
    "Fxn:test_invert";
    "Fxn:torch.ByteTensor([0,";
    "Fxn:self.assertEqual((~x).tolist(),";
    "Fxn:test_apply";
    "Fxn:torch.arange(1,";
    "Fxn:x.clone().apply_(lambda";
    "Fxn:self.assertEqual(res,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:x.apply_(lambda";
    "Fxn:test_map";
    "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:torch.autograd.Variable(torch.randn(3))";
    "Fxn:x.clone()";
    "Fxn:res.map_(y,";
    "Fxn:self.assertEqual(res,";
    "Fxn:self.assertRaisesRegex(TypeError,";
    "Fxn:res.map_(y,";
    "Fxn:test_map2";
    "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:torch.autograd.Variable(torch.randn(3))";
    "Fxn:torch.autograd.Variable(torch.randn(1,";
    "Fxn:x.clone()";
    "Fxn:res.map2_(y,";
    "Fxn:self.assertEqual(res,";
    "Fxn:self.assertRaisesRegex(";
    "Fxn:res.map2_(y,";
    "Fxn:test_Size";
    "Fxn:torch.Size([1,";
    "Fxn:self.assertIsInstance(x,";
    "Fxn:self.assertEqual(x[0],";
    "Fxn:self.assertEqual(x[1],";
    "Fxn:self.assertEqual(x[2],";
    "Fxn:self.assertEqual(len(x),";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:torch.Size(torch.ones(3)))";
    "Fxn:self.assertIsInstance(x";
    "Fxn:self.assertIsInstance(x[:-1],";
    "Fxn:self.assertIsInstance(x";
    "Fxn:THTensor_(copyTranspose)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_big_transpose";
    "Fxn:torch.rand(456,";
    "Fxn:t.t().contiguous()";
    "Fxn:torch.from_numpy(t.numpy().transpose())";
    "Fxn:self.assertEqual(t1,";
    "Fxn:test_inplace_division";
    "Fxn:torch.rand(5,";
    "Fxn:self.assertEqual(id_before,";
    "Fxn:test_simple_scalar_cast";
    "Fxn:[torch.Tensor([1.5]),";
    "Fxn:torch.zeros(1,";
    "Fxn:self.assertEqual(int(tensor),";
    "Fxn:self.assertEqual(float(tensor),";
    "Fxn:self.assertEqual(long(tensor),";
    "Fxn:long(value))";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:self.assertRaises(ValueError,";
    "Fxn:long(tensor))";
    "Fxn:test_offset_scalar_cast";
    "Fxn:torch.Tensor([1,";
    "Fxn:self.assertEqual(int(y),";
    "Fxn:@unittest.skipIf(True,";
    "Fxn:test_set_flush_denormal";
    "Fxn:torch.FloatTensor([1.0,";
    "Fxn:torch.DoubleTensor([1.0,";
    "Fxn:self.assertEqual(float_tensor[0],";
    "Fxn:self.assertEqual(float_tensor[1],";
    "Fxn:self.assertEqual(double_tensor[0],";
    "Fxn:self.assertEqual(double_tensor[1],";
    "Fxn:self.assertEqual(double_tensor[2],";
    "Fxn:torch.set_flush_denormal(True)";
    "Fxn:self.assertEqual(float_tensor[0],";
    "Fxn:self.assertEqual(float_tensor[1],";
    "Fxn:self.assertEqual(double_tensor[0],";
    "Fxn:self.assertEqual(double_tensor[1],";
    "Fxn:self.assertEqual(double_tensor[2],";
    "Fxn:torch.set_flush_denormal(False)";
    "Fxn:test_unique_cpu";
    "Fxn:torch.LongTensor([1,";
    "Fxn:torch.LongTensor([1,";
    "Fxn:torch.LongTensor([0,";
    "Fxn:torch.unique(x)";
    "Fxn:self.assertEqual(";
    "Fxn:expected_unique.tolist(),";
    "Fxn:x.unique(return_inverse=True)";
    "Fxn:self.assertEqual(";
    "Fxn:expected_unique.tolist(),";
    "Fxn:self.assertEqual(expected_inverse.numel(),";
    "Fxn:x_inverse.numel())";
    "Fxn:x.unique(sorted=True)";
    "Fxn:self.assertEqual(expected_unique,";
    "Fxn:torch.unique(";
    "Fxn:self.assertEqual(expected_unique,";
    "Fxn:self.assertEqual(expected_inverse,";
    "Fxn:x.view(2,";
    "Fxn:y.unique(sorted=True,";
    "Fxn:self.assertEqual(expected_unique,";
    "Fxn:self.assertEqual(expected_inverse.view(y.size()),";
    "Fxn:torch.unique(";
    "Fxn:torch.IntTensor([2,";
    "Fxn:self.assertEqual(torch.IntTensor([1,";
    "Fxn:self.assertEqual(torch.LongTensor([1,";
    "Fxn:torch.unique(";
    "Fxn:torch.DoubleTensor([2.,";
    "Fxn:self.assertEqual(torch.DoubleTensor([1.5,";
    "Fxn:self.assertEqual(torch.LongTensor([1,";
    "Fxn:torch.unique(";
    "Fxn:torch.ByteTensor([133,";
    "Fxn:self.assertEqual(torch.ByteTensor([7,";
    "Fxn:self.assertEqual(torch.LongTensor([3,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:torch.cuda.is_available(),";
    "Fxn:test_unique_cuda";
    "Fxn:self.assertRaises(";
    "Fxn:torch.cuda.LongTensor([0,";
    "Fxn:1]).unique())";
    "Fxn:self.assertRaises(";
    "Fxn:torch.unique(torch.cuda.FloatTensor([0.,";
    "Fxn:make_neg_dim_test";
    "Fxn:neg_dim_test";
    "Fxn:[torch.randn(arg)";
    "Fxn:torch.randn(*tensor_arg)";
    "Fxn:arg_constr()))";
    "Fxn:combinations(range(ndim),";
    "Fxn:arg_constr()";
    "Fxn:copy.deepcopy(arg)";
    "Fxn:name)(*arg)";
    "Fxn:name)(*arg_neg)";
    "Fxn:self.assertEqual(a,";
    "Fxn:x.clone()";
    "Fxn:'_')(*arg)";
    "Fxn:x.clone()";
    "Fxn:'_')(*arg_neg)";
    "Fxn:self.assertEqual(a,";
    "Fxn:name)(x,";
    "Fxn:name)(x,";
    "Fxn:self.assertEqual(a,";
    "Fxn:idx_tensor";
    "Fxn:torch.LongTensor(*size).random_(0,";
    "Fxn:[(2,";
    "Fxn:idx_tensor((10,";
    "Fxn:idx_tensor((10,),";
    "Fxn:idx_tensor((10,),";
    "Fxn:torch.randn(10,";
    "Fxn:idx_tensor((10,),";
    "Fxn:torch.randn(10,";
    "Fxn:idx_tensor((10,),";
    "Fxn:idx_tensor((10,";
    "Fxn:torch.randn(10,";
    "Fxn:make_neg_dim_test(name,";
    "Fxn:run_tests()";
    "Import:digamma";
    "Import:polygamma";
    "Import:numpy";
    "Import:deepcopy";
    "Import:deepcopy";
    "Import:copy";
    "Import:cPickle";
    "Import:pickle";
    "Import:importlib.util";
    "Import:imp";
    "/test/test_utils.py";
    "Import:print_function";
    "Import:sys";
    "Import:import";
    "Import:math";
    "Import:shutil";
    "Import:random";
    "Import:tempfile";
    "Import:unittest";
    "Import:traceback";
    "Import:torch";
    "Import:torch.utils.data";
    "Import:torch.cuda";
    "Import:warnings";
    "Import:Variable";
    "Import:Trainer";
    "Import:torch.utils.trainer.plugins.plugin";
    "Import:Plugin";
    "Import:load_lua";
    "Import:prepare_onnx_paddings";
    "Import:check_onnx_broadcast";
    "Import:IS_WINDOWS";
    "Import:TestCase,";
    "Import:cffi";
    "Import:compile_extension";
    "class:SimplePlugin(Plugin):";
    "Fxn:__init__";
    "Fxn:self).__init__(interval)";
    "Fxn:register";
    "Fxn:iteration";
    "Fxn:epoch";
    "Fxn:batch";
    "Fxn:update";
    "class:ModelMock(object):";
    "Fxn:__init__";
    "Fxn:Variable(torch.ones(1,";
    "Fxn:__call__";
    "class:CriterionMock(object):";
    "Fxn:__init__";
    "Fxn:__call__";
    "class:OptimizerMock(object):";
    "Fxn:__init__";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:zero_grad";
    "class:DatasetMock(object):";
    "Fxn:__iter__";
    "Fxn:torch.randn(2,";
    "Fxn:torch.randperm(10)[:2]";
    "Fxn:__len__";
    "class:TestDataLoader(TestCase):";
    "Fxn:setUp";
    "Fxn:torch.randn(5,";
    "Fxn:test_single_keep";
    "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:self.assertEqual(len(list(dataiter)),";
    "Fxn:test_single_drop";
    "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:self.assertEqual(len(list(dataiter)),";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_multi_keep";
    "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:self.assertEqual(len(list(dataiter)),";
    "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_multi_drop";
    "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:self.assertEqual(len(list(dataiter)),";
    "class:TestTrainer(TestCase):";
    "Fxn:setUp";
    "Fxn:OptimizerMock()";
    "Fxn:Trainer(ModelMock(),";
    "Fxn:CriterionMock(),";
    "Fxn:DatasetMock())";
    "Fxn:test_register_plugin";
    "Fxn:SimplePlugin(interval)";
    "Fxn:self.trainer.register_plugin(simple_plugin)";
    "Fxn:self.assertEqual(simple_plugin.trainer,";
    "Fxn:test_optimizer_step";
    "Fxn:self.trainer.run(epochs=1)";
    "Fxn:self.assertEqual(self.trainer.optimizer.num_steps,";
    "Fxn:test_plugin_interval";
    "Fxn:self.setUp()";
    "Fxn:SimplePlugin(interval)";
    "Fxn:self.trainer.register_plugin(simple_plugin)";
    "Fxn:self.trainer.run(epochs=self.num_epochs)";
    "Fxn:math.floor(num_triggers";
    "Fxn:self.assertEqual(num_calls,";
    "Fxn:test_model_called";
    "Fxn:self.trainer.run(epochs=self.num_epochs)";
    "Fxn:self.assertEqual(num_model_calls,";
    "Fxn:self.assertEqual(num_calls,";
    "Fxn:self.assertLessEqual(lower_bound,";
    "Fxn:self.assertLessEqual(num_calls,";
    "Fxn:test_model_gradient";
    "Fxn:self.trainer.run(epochs=self.num_epochs)";
    "Fxn:torch.ones(1,";
    "Fxn:self.assertEqual(output_var.grad.data,";
    "Fxn:os.path.abspath(os.path.dirname(str(__file__)))";
    "class:TestFFI(TestCase):";
    "Fxn:setUp";
    "Fxn:tempfile.mkdtemp()";
    "Fxn:os.chdir(self.tmpdir)";
    "Fxn:sys.path.append(self.tmpdir)";
    "Fxn:tearDown";
    "Fxn:shutil.rmtree(self.tmpdir)";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_cpu";
    "Fxn:compile_extension(";
    "Fxn:torch.ones(2,";
    "Fxn:2).float()";
    "Fxn:cpulib.good_func(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:torch.ones(2,";
    "Fxn:cpulib.new_tensor(4)";
    "Fxn:self.assertEqual(new_tensor,";
    "Fxn:torch.ones(4,";
    "Fxn:cpulib.int_to_float(5)";
    "Fxn:self.assertIs(type(f),";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:cpulib.good_func(tensor.double(),";
    "Fxn:self.assertRaises(torch.FatalError,";
    "Fxn:cpulib.bad_func(tensor,";
    "Fxn:@unittest.skipIf(not";
    "Fxn:test_gpu";
    "Fxn:compile_extension(";
    "Fxn:torch.ones(2,";
    "Fxn:2).float()";
    "Fxn:gpulib.good_func(tensor,";
    "Fxn:self.assertEqual(tensor,";
    "Fxn:torch.ones(2,";
    "Fxn:tensor.cuda().fill_(1)";
    "Fxn:gpulib.cuda_func(ctensor,";
    "Fxn:self.assertEqual(ctensor,";
    "Fxn:torch.ones(2,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:gpulib.cuda_func(tensor,";
    "Fxn:self.assertRaises(TypeError,";
    "Fxn:gpulib.cuda_func(ctensor.storage(),";
    "Import:cpulib";
    "Import:gpulib";
    "class:TestLuaReader(TestCase):";
    "Fxn:_module_test";
    "Fxn:do_test";
    "Fxn:name)(input)";
    "Fxn:module.forward(input)";
    "Fxn:module.zeroGradParameters()";
    "Fxn:module.backward(input,";
    "Fxn:self.assertEqual(output,";
    "Fxn:self.assertEqual(grad_input,";
    "Fxn:module.parameters()";
    "Fxn:module.parameters()";
    "Fxn:self.assertEqual(params,";
    "Fxn:self.assertEqual(d_params,";
    "Fxn:self.assertFalse('params'";
    "Fxn:self.assertFalse('params'";
    "Fxn:_criterion_test";
    "Fxn:do_test";
    "Fxn:name)(input,";
    "Fxn:module.forward(input,";
    "Fxn:module.backward(input,";
    "Fxn:self.assertEqual(output,";
    "Fxn:self.assertEqual(grad_input,";
    "Fxn:init";
    "Fxn:download_file('https://download.pytorch.org/test_data/legacy_modules.t7')";
    "Fxn:load_lua(path,";
    "Fxn:tests['modules'].items():";
    "Fxn:name.replace('nn.',";
    "Fxn:cls._module_test(name,";
    "Fxn:tests['criterions'].items():";
    "Fxn:name.replace('nn.',";
    "Fxn:cls._criterion_test(name,";
    "Fxn:_transform_Index";
    "Fxn:input[1].sub(1)]";
    "Fxn:_transform_LookupTable";
    "Fxn:input.sub(1)";
    "Fxn:_transform_MultiLabelMarginCriterion";
    "Fxn:target.sub(1)";
    "Fxn:_transform_ClassNLLCriterion";
    "Fxn:target.sub(1)";
    "Fxn:_transform_SpatialClassNLLCriterion";
    "Fxn:target.sub(1)";
    "Fxn:_transform_ClassSimplexCriterion";
    "Fxn:target.sub(1)";
    "Fxn:_transform_CrossEntropyCriterion";
    "Fxn:target.sub(1)";
    "Fxn:_transform_ParallelCriterion";
    "Fxn:[target[0].sub(1),";
    "Fxn:_transform_MultiCriterion";
    "Fxn:target.sub(1)";
    "Fxn:_transform_MultiMarginCriterion";
    "Fxn:target.sub(1)";
    "class:TestONNXUtils(TestCase):";
    "Fxn:test_prepare_onnx_paddings";
    "Fxn:prepare_onnx_paddings(len(sizes),";
    "Fxn:self.assertEqual(paddings,";
    "Fxn:test_check_onnx_broadcast";
    "Fxn:try_check_onnx_broadcast";
    "Fxn:check_onnx_broadcast(dims1,";
    "Fxn:self.assertEqual(broadcast,";
    "Fxn:self.assertEqual(fail,";
    "Fxn:numel(dims2)";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:numel(dims2)";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:numel(dims2)";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:numel(s2)";
    "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:TestLuaReader.init()";
    "Fxn:run_tests()";
    "/test/cpp_extensions/setup.py";
    "Import:torch.cuda";
    "Import:setup";
    "Import:CppExtension,";
    "/test/data/network1.py";
    "Import:torch.nn";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Linear(10,";
    "/test/data/network2.py";
    "Import:torch.nn";
    "class:Net(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Linear(10,";
    "Fxn:nn.ReLU()";
    "/test/error_messages/storage.py";
    "Import:torch";
    "Fxn:check_error";
    "Fxn:assign";
    "/test/optim/test.py";
    "Import:json";
    "Import:torch";
    "Import:torch.legacy.optim";
    "Import:pprint";
    "Fxn:rosenbrock";
    "Fxn:drosenbrock";
    "/tools/__init__.py";
    "/tools/autograd/gen_autograd.py";
    "Import:argparse";
    "Import:copy";
    "Import:import";
    "Import:yaml";
    "Import:defaultdict";
    "Import:YamlLoader,";
    "Fxn:format_return_type";
    "Fxn:load_aten_declarations";
    "Fxn:load_deprecated_signatures";
    "Fxn:group_declarations_by_signature";
    "Fxn:get_signature";
    "Fxn:gen_autograd";
    "Import:load_derivatives";
    "Import:gen_variable_type";
    "Import:gen_autograd_functions";
    "Import:gen_python_functions";
    "Fxn:main";
    "/tools/autograd/gen_autograd_functions.py";
    "Import:.utils";
    "Import:nested_dict,";
    "Import:VIEW_FUNCTIONS,";
    "Import:IDENT_REGEX";
    "Fxn:gen_autograd_functions";
    "Fxn:process_function";
    "Fxn:save_arg";
    "Fxn:emit_derivative";
    "Fxn:uses_ident";
    "Fxn:uses_retain_variables";
    "Fxn:uses_single_grad";
    "/tools/autograd/gen_python_functions.py";
    "Import:defaultdict";
    "Import:.nested_dict";
    "Import:nested_dict";
    "Import:import_module";
    "Import:template_path";
    "Import:write";
    "Fxn:should_generate_python_binding";
    "Fxn:gen_py_variable_methods";
    "Fxn:should_bind";
    "Fxn:gen_py_nn_functions";
    "Fxn:should_bind";
    "Fxn:gen_py_torch_functions";
    "Fxn:should_bind";
    "Fxn:group_declarations_by_name";
    "Fxn:get_type_default";
    "Fxn:create_python_bindings";
    "Fxn:first_tensor_arg";
    "Fxn:auto_gpu";
    "Fxn:emit_single_dispatch";
    "Fxn:is_output";
    "Fxn:parse_arg";
    "Fxn:append_actuals_formals";
    "Fxn:emit_dispatch";
    "Fxn:get_python_binding_arguments";
    "Fxn:process_function";
    "Fxn:group_declarations";
    "Fxn:get_python_signature";
    "Fxn:get_typed_arg";
    "/tools/autograd/gen_variable_type.py";
    "Import:print_function";
    "Import:import";
    "Import:sys";
    "Import:CodeTemplate,";
    "Import:VIEW_FUNCTIONS,";
    "Import:uses_single_grad";
    "Fxn:gen_variable_type";
    "Fxn:emit_method_definition";
    "Fxn:emit_body";
    "Fxn:is_differentiable";
    "Fxn:setup_derivative";
    "Fxn:error_msg";
    "Fxn:find_args_with_derivatives";
    "Fxn:emit_check_no_requires_grad";
    "Fxn:save_variables";
    "Fxn:reference_args";
    "Fxn:get_trace_outputs";
    "Fxn:emit_record_trace";
    "Fxn:declare_returned_variables";
    "Fxn:wrap_output";
    "Fxn:emit_call";
    "Fxn:tie_return_values";
    "Fxn:get_return_value";
    "Fxn:emit_history";
    "Fxn:emit_save_outputs";
    "Fxn:emit_check_inplace";
    "Fxn:emit_increment_version";
    "Fxn:unpack_args";
    "Fxn:requires_unpack";
    "Fxn:dispatch_strategy";
    "/tools/autograd/load_derivatives.py";
    "Import:defaultdict";
    "Import:copy";
    "Import:import";
    "Import:yaml";
    "Import:YamlLoader";
    "Import:IDENT_REGEX,";
    "Import:HARDCODED_DIFFERENTIABLE_OUTPUTS";
    "Fxn:load_derivatives";
    "Fxn:create_autograd_function";
    "Fxn:create_derivative";
    "Fxn:transform_return";
    "Fxn:process_definition";
    "Fxn:canonical_declaration";
    "Fxn:split_names";
    "Fxn:lookup_pred";
    "Fxn:check_grad_usage";
    "Fxn:set_up_derivatives";
    "Fxn:unzip";
    "Fxn:ensure_unique_names";
    "Fxn:get_signature";
    "Fxn:used_gradient_indices";
    "Fxn:saved_variables";
    "Fxn:repl";
    "Fxn:all_saved_variables";
    "Fxn:to_camel_case";
    "Fxn:match_declarations_with_autograd_functions";
    "Fxn:find_function";
    "/tools/autograd/nested_dict.py";
    "class:nested_dict(object):";
    "Fxn:__init__";
    "Fxn:__contains__";
    "Fxn:__getitem__";
    "Fxn:self.base.get(x)";
    "/tools/autograd/utils.py";
    "Import:import";
    "Import:tools.shared.module_loader";
    "Import:import_module";
    "Import:nested_dict";
    "Import:CLoader";
    "Import:Loader";
    "Fxn:split_name_params";
    "Fxn:write";
    "/tools/autograd/__init__.py";
    "/tools/cwrap/cwrap.py";
    "Import:import";
    "Import:yaml";
    "Import:Template";
    "Import:deepcopy";
    "Import:ArgcountChecker,";
    "Import:cwrap_common";
    "class:cwrap(object):";
    "Fxn:__init__";
    "Fxn:source.replace('.cwrap',";
    "Fxn:[cls()";
    "Fxn:plugin.initialize(self)";
    "Fxn:os.path.dirname(os.path.abspath(source))";
    "Fxn:f.read()";
    "Fxn:self.wrap_declarations(declarations)";
    "Fxn:plugin.process_full_file(wrapper)";
    "Fxn:f.read()";
    "Fxn:{}".format(destination))";
    "Fxn:f.write(wrapper)";
    "Fxn:{}".format(destination))";
    "Fxn:wrap_declarations";
    "Fxn:declarations.split('\n')";
    "Fxn:yaml.load('\n'.join(declaration_lines))";
    "Fxn:cwrap_common.set_declaration_defaults(declaration)";
    "Fxn:plugin.process_declarations(declarations)";
    "Fxn:self.generate_wrapper(declaration)";
    "Fxn:plugin.process_wrapper(wrapper,";
    "Fxn:output.append(wrapper)";
    "Fxn:declaration_lines.append(line)";
    "Fxn:os.path.join(self.base_path,";
    "Fxn:line[6:].strip())";
    "Fxn:f.read().split('\n')";
    "Fxn:output.append(line)";
    "Fxn:'\n'.join(output)";
    "Fxn:parse_arguments";
    "Fxn:arg.partition('";
    "Fxn:new_args.append({'type':";
    "Fxn:arg['arg'].partition('";
    "Fxn:new_args.append(arg)";
    "Fxn:search_plugins";
    "Fxn:fnname)(*args)";
    "Fxn:fallback(*args)";
    "Fxn:get_type_check";
    "Fxn:self.search_plugins('get_type_check',";
    "Fxn:get_type_unpack";
    "Fxn:self.search_plugins('get_type_unpack',";
    "Fxn:get_return_wrapper";
    "Fxn:self.search_plugins('get_return_wrapper',";
    "Fxn:get_wrapper_template";
    "Fxn:self.search_plugins('get_wrapper_template',";
    "Fxn:get_assign_args";
    "Fxn:self.search_plugins('get_assign_args',";
    "Fxn:get_arg_accessor";
    "Fxn:wrap_accessor";
    "Fxn:arg.get('idx')";
    "Fxn:RuntimeError("Missing";
    "Fxn:{}'".format(";
    "Fxn:'PyTuple_GET_ITEM(args,";
    "Fxn:{})'.format(arg['idx'])";
    "Fxn:self.search_plugins('get_arg_accessor',";
    "Fxn:generate_wrapper";
    "Fxn:self.generate_option(option,";
    "Fxn:is_first=(i";
    "Fxn:plugin.process_option_code(option_wrapper,";
    "Fxn:self.get_wrapper_template(declaration).substitute(name=declaration['name'],";
    "Fxn:map_selected_arguments";
    "Fxn:self.get_arg_accessor(arg,";
    "Fxn:base_fn_name)(arg,";
    "Fxn:RuntimeError("Missing";
    "Fxn:{}'".format(";
    "Fxn:tmpl.substitute(arg=accessor,";
    "Fxn:idx=arg.get('idx'))";
    "Fxn:plugin_fn_name)(res,";
    "Fxn:result.append(res)";
    "Fxn:build_option_args";
    "Fxn:self.get_assign_args(arguments)";
    "Fxn:call_arg.append(unpack)";
    "Fxn:self.ARG_ASSIGN_TEMPLATE.substitute(";
    "Fxn:assignement.append(res)";
    "Fxn:call_arg.append(var_name)";
    "Fxn:indent_code";
    "Fxn:s.strip(),";
    "Fxn:code.split('\n'))";
    "Fxn:line.count('}')";
    "Fxn:line.count('{')";
    "Fxn:line.count('(')";
    "Fxn:line.count(')')";
    "Fxn:generate_option";
    "Fxn:arg.get('ignore_check')";
    "Fxn:arg.get('no_idx'),";
    "Fxn:self.map_selected_arguments('get_type_check',";
    "Fxn:'.join(arg_checks)";
    "Fxn:plugin.process_all_checks(arg_checks,";
    "Fxn:plugin.process_pre_arg_assign(pre_arg_assign,";
    "Fxn:self.map_selected_arguments('get_type_unpack',";
    "Fxn:self.build_option_args(option['arguments'],";
    "Fxn:'.join(call_arg)";
    "Fxn:plugin.process_all_call_arg(call_arg,";
    "Fxn:self.get_return_wrapper(option).substitute()";
    "Fxn:self.FUNCTION_CALL_TEMPLATE.substitute(capture_result='',";
    "Fxn:self.get_return_wrapper(option).substitute(result='__result')";
    "Fxn:self.FUNCTION_CALL_TEMPLATE.substitute(capture_result=(option['return']";
    "Fxn:deepcopy(self.OPTION_CODE_TEMPLATE)";
    "Fxn:plugin.process_option_code_template(code_template,";
    "Fxn:Template('\n'.join(code_template))";
    "Fxn:code_template.substitute(call=call,";
    "Fxn:self.indent_code(code)";
    "Fxn:self.indent_code('\n'.join(pre_arg_assign))";
    "Fxn:self.indent_code('\n'.join(arg_assign))";
    "Fxn:self.OPTION_TEMPLATE.substitute(";
    "Fxn:els=('}";
    "/tools/cwrap/__init__.py";
    "Import:cwrap";
    "/tools/cwrap/plugins/ArgcountChecker.py";
    "Import:CWrapPlugin";
    "class:ArgcountChecker(CWrapPlugin):";
    "Fxn:process_all_checks";
    "Fxn:option.get('argcount_offset',";
    "Fxn:&&'.format(str(argcount))";
    "/tools/cwrap/plugins/ArgcountSortPlugin.py";
    "Import:import";
    "Import:CWrapPlugin";
    "Import:cwrap_common";
    "class:ArgcountSortPlugin(CWrapPlugin):";
    "Fxn:__init__";
    "Fxn:process_declarations";
    "Fxn:cwrap_common.sort_by_number_of_options(declaration,";
    "/tools/cwrap/plugins/ArgumentReferences.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:ArgumentReferences(CWrapPlugin):";
    "Fxn:initialize";
    "Fxn:process_declarations";
    "Fxn:_get_true_idx";
    "Fxn:arg.get('ignore_check',";
    "Fxn:get_arg_accessor";
    "Fxn:arg.get('is_reference',";
    "Fxn:self.cwrap.get_arg_accessor(referenced,";
    "/tools/cwrap/plugins/AssertNDim.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:AssertNDim(CWrapPlugin):";
    "Fxn:process_option_code_template";
    "Fxn:arg.get('assert_ndim')";
    "Fxn:arg.get('assign_name',";
    "Fxn:new_code_pre.append(self.PRE_CODE_TEMPLATE.substitute(op=op,";
    "/tools/cwrap/plugins/AutoGPU.py";
    "Import:CWrapPlugin";
    "class:AutoGPU(CWrapPlugin):";
    "Fxn:__init__";
    "Fxn:process_pre_arg_assign";
    "Fxn:option.get('auto_gpu',";
    "Fxn:auto_gpu(get_device(args));'";
    "/tools/cwrap/plugins/BeforeAfterCall.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:BeforeAfterCall(CWrapPlugin):";
    "Fxn:initialize";
    "Fxn:insert_snippet";
    "Fxn:option.get(name)";
    "Fxn:prepend_str.get(backend,";
    "Fxn:Template(prepend_str)";
    "Fxn:self.cwrap.get_arg_accessor(arg,";
    "Fxn:before_call_template.substitute(args)";
    "Fxn:template.insert(offset,";
    "Fxn:process_pre_arg_assign";
    "Fxn:option.get('before_arg_assign'):";
    "Fxn:self.insert_snippet(template,";
    "Fxn:process_option_code_template";
    "Fxn:option.get('before_call')";
    "Fxn:option.get('after_call'):";
    "Fxn:template.index('$call')";
    "Fxn:self.insert_snippet(template,";
    "Fxn:template.index('$call')";
    "Fxn:self.insert_snippet(template,";
    "/tools/cwrap/plugins/BoolOption.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "Import:sys";
    "class:BoolOption(CWrapPlugin):";
    "Fxn:is_bool_option";
    "Fxn:process_declarations";
    "Fxn:self.is_bool_option(arg):";
    "Fxn:get_type_check";
    "Fxn:arg.get('is_bool_option',";
    "Fxn:Template('PyBool_Check($arg)')";
    "Fxn:get_type_unpack";
    "Fxn:arg.get('is_bool_option',";
    "Fxn:Template(self.UNPACK_TEMPLATE.safe_substitute(";
    "/tools/cwrap/plugins/Broadcast.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:Broadcast(CWrapPlugin):";
    "Fxn:getPreArgStringTemplate";
    "Fxn:${arg_op_other}_guard(nullptr);\n"""";
    "Fxn:${arg_op_other}_guard(nullptr);\n"";
    "Fxn:${arg_op_other}_guard(nullptr);\n"";
    "Fxn:Template(ret)";
    "Fxn:getNewForExpand";
    "Fxn:"""THTensor_(new)(LIBRARY_STATE_NOARGS);\n"""";
    "Fxn:"_new(LIBRARY_STATE_NOARGS);\n"";
    "Fxn:"_new(LIBRARY_STATE_NOARGS);\n"";
    "Fxn:getExpandTemplate";
    "Fxn:Template(";
    "Fxn:"if(expand_success)";
    "Fxn:Template(";
    "Fxn:getOutPlacePreExpand2Template";
    "Fxn:"""THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:self.getNewForExpand(type_op_a)";
    "Fxn:self.getNewForExpand(type_op_other)";
    "Fxn:"""expand_outplace2(LIBRARY_STATE";
    "Fxn:${arg_op_a}_guard.get(),";
    "Fxn:${arg_op_other}_guard.get(),";
    "Fxn:${arg_op_a}_guard.get();";
    "Fxn:${arg_op_other}_guard.get();"""";
    "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:getOutPlacePreExpand3Template";
    "Fxn:"""(THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:self.getNewForExpand(type_op_a)";
    "Fxn:self.getNewForExpand(type_op_other1)";
    "Fxn:self.getNewForExpand(type_op_other2)";
    "Fxn:"""expand_outplace3(LIBRARY_STATE";
    "Fxn:${arg_op_a}_guard.get(),";
    "Fxn:${arg_op_other1}_guard.get(),";
    "Fxn:${arg_op_other2}_guard.get(),";
    "Fxn:${arg_op_a}_guard.get();";
    "Fxn:${arg_op_other1}_guard.get();";
    "Fxn:${arg_op_other2}_guard.get();"""";
    "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:Template(";
    "Fxn:"""if(THTensor_(nDimension)(LIBRARY_STATE";
    "Fxn:THError("Argument";
    "Fxn:THTensor_(nDimension)(LIBRARY_STATE";
    "Fxn:THTensor_(size)(LIBRARY_STATE";
    "Fxn:Template(";
    "Fxn:${arg_op_a}_storage(THLongStorage_newWithSize1(${arg_op_a}_dim0_size));\n""")";
    "Fxn:Template(";
    "Fxn:${arg_op_a}_storage(";
    "Fxn:THLongStorage_newWithSize2(${arg_op_a}_dim0_size,";
    "Fxn:Template(";
    "Fxn:${arg_op_a}_storage(";
    "Fxn:THLongStorage_newWithSize3(${arg_op_a}_dim0_size,";
    "Fxn:getOutPlacePreExpandPostDimTemplate";
    "Fxn:"""THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:self.getNewForExpand(type_op_a)";
    "Fxn:"""expand(LIBRARY_STATE";
    "Fxn:${arg_op_a}_guard.get(),";
    "Fxn:${arg_op_a}_guard.get();"""";
    "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:Template(";
    "Fxn:getInPlacePreExpand1Template";
    "Fxn:"""THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:self.getNewForExpand(type_op_other)";
    "Fxn:"""expand_inplace1(LIBRARY_STATE";
    "Fxn:${arg_op_other}_guard.get(),";
    "Fxn:${arg_op_other}_guard.get();"""";
    "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:getInPlacePreExpand2Template";
    "Fxn:"""(THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:self.getNewForExpand(type_op_other1)";
    "Fxn:self.getNewForExpand(type_op_other2)";
    "Fxn:"""expand_inplace2(LIBRARY_STATE";
    "Fxn:${arg_op_other1}_guard.get(),";
    "Fxn:${arg_op_other2}_guard.get(),";
    "Fxn:${arg_op_other1}_guard.get();";
    "Fxn:${arg_op_other2}_guard.get();"""";
    "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:Template(";
    "Fxn:initialize";
    "Fxn:process_option_code_template";
    "Fxn:arg.get('broadcast').split("";
    "Fxn:arg.get('assign_name',";
    "Fxn:params[0].split(",")";
    "Fxn:ValueError('Broadcast";
    "Fxn:p.startswith("dims:"):";
    "Fxn:assert(raise_errors";
    "Fxn:ValueError("multiple";
    "Fxn:p[len("dims:"):].split(",")";
    "Fxn:dim.split(".")";
    "Fxn:batchdim[1].startswith("dim")";
    "Fxn:batchdim[1][len("dim"):]";
    "Fxn:dims_kvs.append({"op":";
    "Fxn:p.startswith("dims:")";
    "Fxn:p.startswith("types:"):";
    "Fxn:ValueError("invalid";
    "Fxn:{}".format(p))";
    "Fxn:p.startswith("types:"):";
    "Fxn:ValueError("type";
    "Fxn:p[len("types:"):].split(",")";
    "Fxn:assert(len(types)";
    "Fxn:self.getPreArgStringTemplate(type=type_op_b).substitute(op_b_mapping)";
    "Fxn:self.getPreArgStringTemplate(type=type_op_c).substitute(op_c_mapping)";
    "Fxn:self.getInPlacePreExpand2Template(type_op_b,";
    "Fxn:raise_errors_s).substitute(";
    "Fxn:self.getInPlacePreExpand1Template(type_op_b,";
    "Fxn:raise_errors_s).substitute(op_b_mapping)";
    "Fxn:new_code_pre.append(self.IN_PLACE_PRE_TEMPLATE.substitute(";
    "Fxn:new_code_pre.append("")";
    "Fxn:self.POST_TEMPLATE.substitute(op_b_mapping)";
    "Fxn:self.POST_TEMPLATE.substitute(op_c_mapping)";
    "Fxn:new_code_post.append(post_code)";
    "Fxn:new_code_post.append("")";
    "Fxn:self.getPreArgStringTemplate().substitute(arg_op_other=arg_op_a)";
    "Fxn:self.OUT_PLACE_PRE_EXPAND_PRE_DIM_TEMPLATE.substitute(";
    "Fxn:self.OUT_PLACE_PRE_EXPAND1_DIM_TEMPLATE.substitute(";
    "Fxn:self.OUT_PLACE_PRE_EXPAND2_DIM_TEMPLATE.substitute(";
    "Fxn:self.OUT_PLACE_PRE_EXPAND3_DIM_TEMPLATE.substitute(";
    "Fxn:self.getOutPlacePreExpandPostDimTemplate(None,";
    "Fxn:raise_errors_s).substitute(";
    "Fxn:self.POST_TEMPLATE.substitute(arg_op_other=arg_op_a)";
    "Fxn:self.getPreArgStringTemplate().substitute(arg_op_other=arg_op_a)";
    "Fxn:self.getPreArgStringTemplate(type=type_op_b).substitute(op_b_mapping)";
    "Fxn:self.getOutPlacePreExpand3Template(None,";
    "Fxn:expand_template.substitute(";
    "Fxn:self.getOutPlacePreExpand2Template(None,";
    "Fxn:raise_errors_s).substitute(";
    "Fxn:self.POST_TEMPLATE.substitute(arg_op_other=arg_op_a)";
    "Fxn:self.POST_TEMPLATE.substitute(op_b_mapping)";
    "Fxn:self.POST_TEMPLATE.substitute(op_c_mapping)";
    "Fxn:new_code_pre.append(self.OUT_PLACE_PRE_TEMPLATE.substitute(";
    "Fxn:new_code_pre.append("")";
    "Fxn:new_code_post.append(post_code)";
    "Fxn:new_code_post.append("")";
    "/tools/cwrap/plugins/ConstantArguments.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:ConstantArguments(CWrapPlugin):";
    "Fxn:process_declarations";
    "Fxn:get_type_unpack";
    "Fxn:Template('$arg')";
    "Fxn:get_arg_accessor";
    "Fxn:arg.get('default',";
    "/tools/cwrap/plugins/CuDNNPlugin.py";
    "Import:Template";
    "Import:copy";
    "Import:deepcopy";
    "Import:CWrapPlugin";
    "Import:product";
    "class:CuDNNPlugin(CWrapPlugin):";
    "Fxn:__init__";
    "Fxn:get_type_unpack";
    "Fxn:self.TYPE_UNPACK.get(arg['type'],";
    "Fxn:get_type_check";
    "Fxn:self.TYPE_CHECK.get(arg['type'],";
    "Fxn:get_assign_args";
    "Fxn:copy.copy(arg)";
    "Fxn:self.INPUT_ARGUMENT_MAP.get(arg['type'])";
    "Fxn:assign_args.append(arg)";
    "Fxn:get_wrapper_template";
    "Fxn:[self.TYPE_NAMES.get(arg['type'],";
    "Fxn:arg.get('ignore_check',";
    "Fxn:arg_desc.append('({})'.format(',";
    "Fxn:'.join(option_desc)))";
    "Fxn:arg_desc.append('no";
    "Fxn:arg_desc.sort(key=len)";
    "Fxn:'.join(arg_desc)";
    "Fxn:Template(self.WRAPPER_TEMPLATE.safe_substitute(";
    "Fxn:num_options=len(arg_desc),";
    "Fxn:get_return_wrapper";
    "Fxn:self.RETURN_WRAPPER.get(option['return'],";
    "Fxn:get_arg_accessor";
    "Fxn:'getCudnnDataType(tensorClass)'";
    "Fxn:'getCudnnHandle()'";
    "Fxn:process_declarations";
    "Fxn:declaration.setdefault('python_name',";
    "Fxn:'_{}'.format(declaration['name']))";
    "Fxn:'THCUDNN_{}'.format(declaration['name'])";
    "Fxn:self.declarations.append(declaration)";
    "Fxn:self.filter_unique_options(declaration['options'])";
    "Fxn:d.get('only_register',";
    "Fxn:filter_unique_options";
    "Fxn:signature";
    "Fxn:'#'.join(arg['type']";
    "Fxn:signature(option)";
    "Fxn:unique.append(option)";
    "Fxn:seen_signatures.add(sig)";
    "Fxn:preprocessor_guard";
    "Fxn:process_wrapper";
    "Fxn:self.preprocessor_guard(code,";
    "Fxn:process_all_call_arg";
    "Fxn:declare_methods";
    "Fxn:declaration.get('method_flags')";
    "Fxn:declaration.get('only_register'):";
    "Fxn:Template('";
    "Fxn:NULL},\n').substitute(";
    "Fxn:self.preprocessor_guard(entry,";
    "Fxn:self.METHODS_DECLARATION.substitute(methods=methods)";
    "Fxn:process_full_file";
    "Fxn:self.declare_methods()";
    "/tools/cwrap/plugins/GILRelease.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:GILRelease(CWrapPlugin):";
    "Fxn:process_option_code_template";
    "Fxn:option.get('with_gil',";
    "Fxn:template.index('$call')";
    "Fxn:template.insert(call_idx,";
    "Fxn:template.insert(call_idx";
    "/tools/cwrap/plugins/KwargsPlugin.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:KwargsPlugin(CWrapPlugin):";
    "Fxn:process_declarations";
    "Fxn:declaration.get('no_kwargs'):";
    "Fxn:arg.get('kwarg_only'):";
    "Fxn:get_arg_accessor";
    "Fxn:arg.get('no_kwargs'):";
    "Fxn:arg.get('kwarg_only'):";
    "Fxn:self.KWARG_ONLY_ACCESSOR_TEMPLATE.substitute(name=arg['name'])";
    "Fxn:self.ACCESSOR_TEMPLATE.substitute(idx=arg['idx'],";
    "Fxn:process_single_check";
    "Fxn:arg.get('no_kwargs'):";
    "Fxn:arg.get('kwarg_only'):";
    "Fxn:self.KWARG_ONLY_CHECK_TEMPLATE.substitute(name=arg['name'],";
    "Fxn:self.CHECK_TEMPLATE.substitute(idx=arg['idx'],";
    "Fxn:process_wrapper";
    "Fxn:declaration.get('no_kwargs'):";
    "Fxn:arg.get('ignore_check')";
    "Fxn:arg.get('no_kwargs')";
    "Fxn:seen_args.add(name)";
    "Fxn:args.append(name)";
    "Fxn:'.join(['PyObject";
    "Fxn:NULL;'.format(a)";
    "Fxn:'.join(";
    "Fxn:PyDict_GetItemString(kwargs,";
    "Fxn:"{name}");'.format(name=a)";
    "Fxn:code.find('{')";
    "Fxn:self.WRAPPER_TEMPLATE.substitute(declarations=declarations,";
    "/tools/cwrap/plugins/NNExtension.py";
    "Import:string";
    "Import:Template";
    "Import:CWrapPlugin";
    "class:NNExtension(CWrapPlugin):";
    "Fxn:__init__";
    "Fxn:process_full_file";
    "Fxn:self.module_name.split('.')[-1]";
    "Fxn:self.declare_module_methods()";
    "Fxn:MODULE_TAIL.substitute(full_name=self.module_name,";
    "Fxn:process_wrapper";
    "Fxn:self.declarations.append(declaration)";
    "Fxn:declare_module_methods";
    "Fxn:REGISTER_METHOD_TEMPLATE.substitute(name=declaration['name'])";
    "Fxn:MODULE_METHODS_TEMPLATE.substitute(METHODS=module_methods)";
    "Fxn:get_type_unpack";
    "Fxn:self.TYPE_UNPACK.get(arg['type'],";
    "Fxn:get_type_check";
    "Fxn:self.TYPE_CHECK.get(arg['type'],";
    "Fxn:get_wrapper_template";
    "Fxn:describe_arg";
    "Fxn:arg.get('nullable'):";
    "Fxn:None]'.format(desc)";
    "Fxn:[describe_arg(arg)";
    "Fxn:arg.get('ignore_check',";
    "Fxn:arg_desc.append('({})'.format(',";
    "Fxn:'.join(option_desc)))";
    "Fxn:arg_desc.append('no";
    "Fxn:arg_desc.sort(key=len)";
    "Fxn:'.join(arg_desc)";
    "Fxn:Template(self.WRAPPER_TEMPLATE.safe_substitute(expected_args=arg_str))";
    "/tools/cwrap/plugins/NullableArguments.py";
    "Import:CWrapPlugin";
    "class:NullableArguments(CWrapPlugin):";
    "Fxn:process_single_check";
    "Fxn:'({}";
    "Fxn:Py_None)'.format(code,";
    "Fxn:process_single_unpack";
    "Fxn:'({}";
    "Fxn:{})'.format(arg_accessor,";
    "class:UndefinedArguments(CWrapPlugin):";
    "Fxn:process_single_check";
    "Fxn:'({}";
    "Fxn:Py_None)'.format(code,";
    "Fxn:process_single_unpack";
    "Fxn:'({}";
    "Fxn:at::Tensor()";
    "Fxn:{})'.format(arg_accessor,";
    "/tools/cwrap/plugins/OptionalArguments.py";
    "Import:copy";
    "Import:deepcopy";
    "Import:CWrapPlugin";
    "Import:product";
    "Import:cwrap_common";
    "class:OptionalArguments(CWrapPlugin):";
    "Fxn:process_declarations";
    "Fxn:cwrap_common.enumerate_options_due_to_default(";
    "/tools/cwrap/plugins/ProcessorSpecificPlugin.py";
    "Import:deepcopy";
    "Import:CWrapPlugin";
    "Import:yaml";
    "class:ProcessorSpecificPlugin(CWrapPlugin):";
    "Fxn:process_declarations";
    "Fxn:arg_contains_generator";
    "Fxn:split_candidate";
    "Fxn:arg_contains_generator(argument):";
    "Fxn:can_we_handle_the_split";
    "Fxn:generator_split";
    "Fxn:deepcopy(declaration)";
    "Fxn:dec_cpu['backends'].remove('CUDA')";
    "Fxn:dec_cpu.get('backend_type_pairs',";
    "Fxn:option['backends'].remove('CUDA')";
    "Fxn:dec_gpu['backends'].remove('CPU')";
    "Fxn:dec_gpu.get('backend_type_pairs',";
    "Fxn:option['backends'].remove('CPU')";
    "Fxn:arg_contains_generator(arg)])";
    "Fxn:split_candidate(declaration):";
    "Fxn:assert(can_we_handle_the_split(declaration))";
    "Fxn:generator_split(declaration)";
    "Fxn:decs.extend(newdecs)";
    "Fxn:decs.append(declaration)";
    "/tools/cwrap/plugins/ReturnArguments.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:ReturnArguments(CWrapPlugin):";
    "Fxn:initialize";
    "Fxn:get_return_wrapper";
    "Fxn:option['return'].startswith('argument";
    "Fxn:option['return'][len('argument";
    "Fxn:'):].split(',')))";
    "Fxn:[self.cwrap.get_arg_accessor(arg,";
    "Fxn:Template(self.ARGUMENT_RETURN_TEMPLATE.safe_substitute(arg=accessors[0]))";
    "Fxn:Template(self.TUPLE_RETURN_TEMPLATE.safe_substitute(num_args=len(args),";
    "Fxn:'.join(accessors)))";
    "/tools/cwrap/plugins/THPPlugin.py";
    "Import:Template";
    "Import:deepcopy";
    "Import:CWrapPlugin";
    "Import:product,";
    "Import:OrderedDict";
    "class:THPPlugin(CWrapPlugin):";
    "Fxn:_allocate";
    "Fxn:tmpl.safe_substitute(type=typename)";
    "Fxn:code.replace('NewEmpty',";
    "Fxn:'(NewEmpty)')";
    "Fxn:code.replace('THP',";
    "Fxn:cuda_tmpl.substitute(cuda=cuda_code,";
    "Fxn:code.replace('THP',";
    "Fxn:code.replace('THCP',";
    "Fxn:Template(code)";
    "Fxn:_allocate('',";
    "Fxn:_allocate('Long',";
    "Fxn:_allocate('Int',";
    "Fxn:_allocate('Byte',";
    "Fxn:_allocate('Long',";
    "Fxn:_allocate('Int',";
    "Fxn:_allocate('',";
    "Fxn:PyDict_GetItemString(kwargs,";
    "Fxn:__init__";
    "Fxn:substitute_tensor_backend";
    "Fxn:arg['type'].replace('Backend',";
    "Fxn:self.BACKEND_SUBSTITUTIONS.get(option['backends'][0]))";
    "Fxn:arg['type'].replace('Float',";
    "Fxn:get_type_unpack";
    "Fxn:self.substitute_tensor_backend(arg,";
    "Fxn:self.TYPE_UNPACK.get(arg['type'],";
    "Fxn:get_type_check";
    "Fxn:arg.get('long_args',";
    "Fxn:self.substitute_tensor_backend(arg,";
    "Fxn:self.TYPE_CHECK.get(arg['type'],";
    "Fxn:get_wrapper_template";
    "Fxn:OrderedDict()";
    "Fxn:format_arg";
    "Fxn:arg.get('long_args',";
    "Fxn:format_args";
    "Fxn:[format_arg(arg,";
    "Fxn:arg.get('ignore_check',";
    "Fxn:arg.get('output')]";
    "Fxn:a.get('output'),";
    "Fxn:'.join(";
    "Fxn:'({})'.format(',";
    "Fxn:'.join(option_desc))";
    "Fxn:arg_desc[format_args(option['arguments'],";
    "Fxn:arg_desc[format_args(option['arguments'],";
    "Fxn:'.join(arg_desc)";
    "Fxn:'\n'.join(declaration.get('variables',";
    "Fxn:'\n'.join(declaration.get('init',";
    "Fxn:Template(self.WRAPPER_TEMPLATE.safe_substitute(";
    "Fxn:num_options=len(arg_desc),";
    "Fxn:get_return_wrapper";
    "Fxn:self.RETURN_WRAPPER.get(option['return'],";
    "Fxn:get_arg_accessor";
    "Fxn:arg.get('output'):";
    "Fxn:'PyTuple_GET_ITEM(___out,";
    "Fxn:{})'.format(arg['output_idx'])";
    "Fxn:process_docstrings";
    "Fxn:declaration.get('docstring_method')";
    "Fxn:docstr.replace('\n',";
    "Fxn:declaration.get('docstring_stateless')";
    "Fxn:docstr.replace('\n',";
    "Fxn:generate_out_options";
    "Fxn:declaration.setdefault('init',";
    "Fxn:arg.get('output'):";
    "Fxn:out_idx.append(i)";
    "Fxn:new_options.append(option)";
    "Fxn:deepcopy(option)";
    "Fxn:-len(out_idx)";
    "Fxn:new_options.append(option_copy)";
    "Fxn:process_declarations";
    "Fxn:has_arg_type";
    "Fxn:has_long_args";
    "Fxn:has_output_args";
    "Fxn:backends_types_to_defined_if_string";
    "Fxn:declaration.get('types',";
    "Fxn:get_defined_string";
    "Fxn:'CUDA_{0}'.format(real.upper())";
    "Fxn:'defined(TH_REAL_IS_{0})'.format(real.upper())";
    "Fxn:expand_composite_type";
    "Fxn:result.append('half')";
    "Fxn:declaration.get('backend_type_pairs',";
    "Fxn:defineds.extend([get_defined_string(p,";
    "Fxn:expand_composite_type(p,";
    "Fxn:".join(defineds)";
    "Fxn:defineds.append('IS_CUDA'";
    "Fxn:".join(defineds)";
    "Fxn:defineds.extend([get_defined_string(p,";
    "Fxn:expand_composite_type(p,";
    "Fxn:".join(defineds)";
    "Fxn:backends_types_to_defined_if_string(declaration)";
    "Fxn:declaration.get('cpu_half',";
    "Fxn:'!defined(TH_REAL_IS_HALF)'";
    "Fxn:declaration.get('only_register',";
    "Fxn:declaration.setdefault('python_name',";
    "Fxn:declaration.setdefault('variables',";
    "Fxn:has_arg_type(declaration,";
    "Fxn:has_arg_type(declaration,";
    "Fxn:has_output_args(declaration):";
    "Fxn:self.generate_out_options(declaration)";
    "Fxn:has_long_args(declaration):";
    "Fxn:arg.get('long_args',";
    "Fxn:'TH{}Tensor_({})'.format(";
    "Fxn:option.get('sparse',";
    "Fxn:option.get('sparse',";
    "Fxn:option.get('defined_if',";
    "Fxn:declaration.get('variants',";
    "Fxn:self.make_stateless(declaration)";
    "Fxn:new_declarations.append(stateless_declaration)";
    "Fxn:self.stateless_declarations.append(stateless_declaration)";
    "Fxn:self.declarations.append(declaration)";
    "Fxn:'TH{}PTensor_({})'.format(";
    "Fxn:declaration.get('sparse',";
    "Fxn:d.get('only_register',";
    "Fxn:d.get('variants',";
    "Fxn:d.get('only_register',";
    "Fxn:self.declarations.extend(filter(lambda";
    "Fxn:x.get('variants',";
    "Fxn:self.stateless_declarations.extend(filter(lambda";
    "Fxn:x.get('variants',";
    "Fxn:self.process_docstrings()";
    "Fxn:make_stateless";
    "Fxn:deepcopy(declaration)";
    "Fxn:'TH{}PTensor_stateless_({})'.format(";
    "Fxn:declaration.get('sparse',";
    "Fxn:declare_methods";
    "Fxn:declaration.get('sparse',";
    "Fxn:declaration.get('method_flags')";
    "Fxn:declaration.get('only_register'):";
    "Fxn:declaration.get('override_method_flags'):";
    "Fxn:Template('";
    "Fxn:$docstring},\n').substitute(";
    "Fxn:docstring=declaration.get('docstring_var',";
    "Fxn:self.preprocessor_guard(entry,";
    "Fxn:self.TENSOR_METHODS_DECLARATION.substitute(";
    "Fxn:stateless=(''";
    "Fxn:sparse=(''";
    "Fxn:!defined(TH_REAL_IS_HALF)";
    "Fxn:process_full_file";
    "Fxn:code.find('//";
    "Fxn:self.declare_methods(False,";
    "Fxn:self.declare_methods(True,";
    "Fxn:self.declare_methods(False,";
    "Fxn:self.declare_methods(True,";
    "Fxn:preprocessor_guard";
    "Fxn:process_wrapper";
    "Fxn:self.preprocessor_guard(code,";
    "Fxn:process_all_call_arg";
    "Fxn:process_all_checks";
    "Fxn:option.get('has_output'):";
    "Fxn:"PyTuple_Check(___out)";
    "Fxn:"PyTuple_GET_SIZE(___out)";
    "Fxn:&&\n".format(";
    "Fxn:code.replace('__argcount";
    "Fxn:arg.get('no_kwargs',";
    "Fxn:arg.get('ignore_check',";
    "Fxn:process_option_code";
    "Fxn:option.get('defined_if',";
    "Fxn:process_pre_arg_assign";
    "Fxn:option.get('output_provided',";
    "Fxn:arg.get('output'):";
    "Fxn:new_args.append(self.ALLOCATE_TYPE[arg['type']].substitute(name=arg['name']))";
    "Fxn:generate_docstrings_cpp";
    "Fxn:Template('char*";
    "Fxn:'\n\n'.join(";
    "Fxn:template.substitute(name=decl['docstring_var'],";
    "Fxn:chain(self.declarations,";
    "Fxn:generate_docstrings_h";
    "Fxn:Template('extern";
    "Fxn:'\n\n'.join(";
    "Fxn:template.substitute(name=decl['docstring_var'])";
    "Fxn:chain(self.declarations,";
    "/tools/cwrap/plugins/WrapDim.py";
    "Import:CWrapPlugin";
    "Import:Template";
    "class:WrapDim(CWrapPlugin):";
    "Fxn:initialize";
    "Fxn:process_option_code_template";
    "Fxn:arg.get('wrap_dim').split("+")";
    "Fxn:arg.get('assign_name',";
    "Fxn:self.NDIM_TEMPLATE.substitute(arg_tensor=arg_tensor)";
    "Fxn:"+".join(params)";
    "Fxn:new_code.append(self.CODE_TEMPLATE.substitute(";
    "Fxn:new_code.append("")";
    "/tools/cwrap/plugins/__init__.py";
    "class:CWrapPlugin(object):";
    "Fxn:initialize";
    "Fxn:get_type_check";
    "Fxn:Template('(PyObject*)Py_TYPE($arg)";
    "Fxn:Template('PyBool_Check($arg)')";
    "Fxn:get_type_unpack";
    "Fxn:Template('((THPTensor*)$arg)->cdata')";
    "Fxn:Template('PyLong_AsLong($arg)')";
    "Fxn:get_return_wrapper";
    "Fxn:Template('return";
    "Fxn:THPTensor_(New)($result);')";
    "Fxn:Template('return";
    "Fxn:PyBool_FromLong($result);').";
    "Fxn:get_wrapper_template";
    "Fxn:get_assign_args";
    "Fxn:get_arg_accessor";
    "Fxn:process_full_file";
    "Fxn:process_single_check";
    "Fxn:'(PyObject*)Py_TYPE(PyTuple_GET_ITEM(args,";
    "Fxn:process_all_checks";
    "Fxn:CHECK_TYPE(GET_ARG(0))";
    "Fxn:CHECK_TYPE(GET_ARG(1))";
    "Fxn:process_single_unpack";
    "Fxn:PyLong_FromLong(PyTuple_GET_ITEM(args,";
    "Fxn:process_all_call_arg";
    "Fxn:process_option_code";
    "Fxn:process_wrapper";
    "Fxn:process_declarations";
    "Fxn:function(s)";
    "Fxn:process_option_code_template";
    "Fxn:process_pre_arg_assign";
    "Import:NNExtension";
    "Import:NullableArguments";
    "Import:OptionalArguments";
    "Import:ArgcountChecker";
    "Import:ArgumentReferences";
    "Import:BeforeAfterCall";
    "Import:ConstantArguments";
    "Import:ReturnArguments";
    "Import:GILRelease";
    "Import:AutoGPU";
    "Import:CuDNNPlugin";
    "Import:WrapDim";
    "Import:Broadcast";
    "/tools/jit/gen_jit_dispatch.py";
    "Import:import";
    "Import:argparse";
    "Import:count";
    "Import:CodeTemplate,";
    "Import:load_aten_declarations";
    "Fxn:is_magic_method";
    "Fxn:is_jit_op";
    "Fxn:gen_jit_dispatch";
    "Fxn:is_tensor_arg";
    "Fxn:get_invocation";
    "Fxn:emit_decl_variant";
    "Fxn:emit_decl";
    "Fxn:main";
    "/tools/jit/__init__.py";
    "/tools/nnwrap/generate_wrappers.py";
    "Import:import";
    "Import:sys";
    "Import:Template,";
    "Import:cwrap";
    "Import:NNExtension,";
    "Import:import_module";
    "Fxn:wrap_function";
    "Fxn:generate_wrappers";
    "Fxn:wrap_nn";
    "Fxn:wrap_cunn";
    "/tools/nnwrap/__init__.py";
    "Import:generate_wrappers,";
    "/tools/setup_helpers/cuda.py";
    "Import:import";
    "Import:glob";
    "Import:import";
    "Import:ctypes.util";
    "Import:Popen,";
    "Import:IS_WINDOWS,";
    "Fxn:find_nvcc";
    "Fxn:find_cuda_version";
    "/tools/setup_helpers/cudnn.py";
    "Import:import";
    "Import:glob";
    "Import:IS_WINDOWS,";
    "Import:WITH_CUDA,";
    "/tools/setup_helpers/dist_check.py";
    "Import:import";
    "Import:subprocess";
    "Import:glob";
    "Import:IS_CONDA,";
    "Fxn:get_command_path";
    "Fxn:excutable";
    "Fxn:should_build_ib";
    "/tools/setup_helpers/env.py";
    "Import:import";
    "Import:platform";
    "Import:sys";
    "Import:chain";
    "Fxn:check_env_flag";
    "Fxn:gather_paths";
    "/tools/setup_helpers/generate_code.py";
    "Import:import";
    "Import:sys";
    "Fxn:all_generator_source";
    "Fxn:generate_code_ninja";
    "Fxn:generate_code";
    "Import:earlier";
    "Import:gen_autograd";
    "Import:gen_jit_dispatch";
    "Import:generate_wrappers";
    "/tools/setup_helpers/nccl.py";
    "Import:import";
    "Import:glob";
    "Import:warnings";
    "Import:chain";
    "Import:IS_WINDOWS,";
    "Import:WITH_CUDA,";
    "/tools/setup_helpers/ninja_builder.py";
    "Import:import";
    "Import:import";
    "Import:sys";
    "Import:setuptools";
    "Import:distutils";
    "Import:contextmanager";
    "Import:subprocess";
    "class:NinjaBuilder(object):";
    "Fxn:__init__";
    "Fxn:os.path.exists(BUILD_DIR):";
    "Fxn:os.mkdir(BUILD_DIR)";
    "Fxn:os.path.join(ninja.BIN_DIR,";
    "Fxn:os.path.join(BUILD_DIR,";
    "Fxn:'build.{}.ninja'.format(name))";
    "Fxn:ninja.Writer(open(self.filename,";
    "Fxn:self.writer.rule('do_cmd',";
    "Fxn:self.writer.rule('compile',";
    "Fxn:run";
    "Fxn:self.writer.close()";
    "Fxn:subprocess.check_call([self.ninja_program,";
    "Fxn:sys.stderr.write(str(err)";
    "Fxn:sys.exit(1)";
    "Fxn:os.path.join(BUILD_DIR,";
    "Fxn:'{}_compile_commands.json'.format(self.name))";
    "Fxn:subprocess.check_call([self.ninja_program,";
    "Fxn:self.__init__(self.name";
    "Import:ninja";
    "Import:ninja";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):";
    "Fxn:_build_default";
    "Fxn:setuptools.command.build_ext.build_ext.build_extension(self,";
    "Fxn:build_extension";
    "Fxn:NinjaBuilder(ext.name)";
    "Fxn:patch";
    "Fxn:win_compile";
    "Fxn:spawn";
    "Fxn:re.compile('/T(p|c)(.*)')";
    "Fxn:[m.group(2)";
    "Fxn:src_regex.match(elem)";
    "Fxn:re.compile('/Fo(.*)')";
    "Fxn:[m.group(1)";
    "Fxn:obj_regex.match(elem)";
    "Fxn:orig_spawn(cmd)";
    "Fxn:_nt_quote_args(cmd)";
    "Fxn:builder.writer.build(";
    "Fxn:patch(self,";
    "Fxn:orig_compile(self,";
    "Fxn:unix_compile";
    "Fxn:os.path.splitext(obj)[0]";
    "Fxn:spawn";
    "Fxn:builder.writer.build(";
    "Fxn:patch(self,";
    "Fxn:orig_compile(self,";
    "Fxn:link";
    "Fxn:builder.run()";
    "Fxn:orig_link(self,";
    "Fxn:patch(orig_compiler,";
    "Fxn:patch(orig_compiler,";
    "Fxn:patch(self,";
    "Fxn:self._build_default(ext)";
    "Import:distutils.msvccompiler";
    "Import:distutils.msvc9compiler";
    "Import:distutils.unixccompiler";
    "Import:_nt_quote_args";
    "/tools/setup_helpers/nnpack.py";
    "Import:check_env_flag";
    "/tools/setup_helpers/nvtoolext.py";
    "Import:import";
    "Import:platform";
    "Import:ctypes.util";
    "Import:Popen,";
    "Import:WITH_CUDA";
    "/tools/setup_helpers/split_types.py";
    "Import:import";
    "Import:sys";
    "Fxn:get_gen_path_prefix";
    "Fxn:split_types_ninja";
    "Fxn:split_types";
    "/tools/setup_helpers/__init__.py";
    "/tools/shared/cwrap_common.py";
    "/tools/shared/module_loader.py";
    "Import:sys";
    "Fxn:import_module";
    "Import:importlib.util";
    "Import:SourceFileLoader";
    "Import:imp";
    "/tools/shared/__init__.py";
    "Import:import_module";
    "Import:set_declaration_defaults,";
    "/torch/functional.py";
    "Import:torch";
    "Import:mul";
    "Import:reduce";
    "Import:math";
    "Fxn:split";
    "Fxn:btrifact";
    "Fxn:unbind";
    "Fxn:btriunpack";
    "Fxn:hann_window";
    "Fxn:hamming_window";
    "Fxn:bartlett_window";
    "Fxn:isnan";
    "Fxn:unique";
    "/torch/random.py";
    "Import:torch";
    "Import:contextlib";
    "Import:warnings";
    "Import:default_generator";
    "Fxn:set_rng_state";
    "Fxn:get_rng_state";
    "Fxn:manual_seed";
    "Import:torch.cuda";
    "Fxn:initial_seed";
    "Fxn:fork_rng";
    "Import:torch.cuda";
    "/torch/serialization.py";
    "Import:difflib";
    "Import:inspect";
    "Import:import";
    "Import:import";
    "Import:shutil";
    "Import:struct";
    "Import:sys";
    "Import:torch";
    "Import:tarfile";
    "Import:tempfile";
    "Import:warnings";
    "Import:closing,";
    "Import:_import_dotted_name";
    "Import:string_classes";
    "Import:cPickle";
    "Import:pickle";
    "Import:pathlib";
    "class:SourceChangeWarning(Warning):";
    "Fxn:mkdtemp";
    "Fxn:tempfile.mkdtemp()";
    "Fxn:shutil.rmtree(path)";
    "Fxn:register_package";
    "Fxn:_package_registry.append(queue_elem)";
    "Fxn:_package_registry.sort()";
    "Fxn:_cpu_tag";
    "Fxn:_cuda_tag";
    "Fxn:_cpu_deserialize";
    "Fxn:_cuda_deserialize";
    "Fxn:location.startswith('cuda'):";
    "Fxn:obj.cuda(device)";
    "Fxn:register_package(10,";
    "Fxn:register_package(20,";
    "Fxn:location_tag";
    "Fxn:tagger(storage)";
    "Fxn:RuntimeError("don't";
    "Fxn:torch.typename(storage))";
    "Fxn:default_restore_location";
    "Fxn:fn(storage,";
    "Fxn:RuntimeError("don't";
    "Fxn:torch.typename(storage)";
    "Fxn:normalize_storage_type";
    "Fxn:storage_to_tensor_type";
    "Fxn:_import_dotted_name(storage_type.__module__)";
    "Fxn:storage_type.__name__.replace('Storage',";
    "Fxn:_with_file_like";
    "Fxn:body(f)";
    "Fxn:f.close()";
    "Fxn:_is_real_file";
    "Fxn:f.fileno()";
    "Fxn:save";
    "Fxn:StringIO.write()";
    "Fxn:torch.Tensor([0,";
    "Fxn:torch.save(x,";
    "Fxn:io.BytesIO()";
    "Fxn:torch.save(x,";
    "Fxn:_with_file_like(f,";
    "Fxn:_save(obj,";
    "Fxn:_save";
    "Fxn:RuntimeError(msg)";
    "Fxn:persistent_id";
    "Fxn:inspect.getsourcefile(obj)";
    "Fxn:inspect.getsource(obj)";
    "Fxn:warnings.warn("Couldn't";
    "Fxn:torch.is_storage(obj):";
    "Fxn:normalize_storage_type(type(obj))";
    "Fxn:obj._root_storage()";
    "Fxn:location_tag(obj)";
    "Fxn:obj.size())";
    "Fxn:root.size(),";
    "Fxn:type_sizes=dict(";
    "Fxn:pickle_module.dump(MAGIC_NUMBER,";
    "Fxn:pickle_module.dump(PROTOCOL_VERSION,";
    "Fxn:pickle_module.dump(sys_info,";
    "Fxn:pickle_module.Pickler(f,";
    "Fxn:pickler.dump(obj)";
    "Fxn:pickle_module.dump(serialized_storage_keys,";
    "Fxn:f.flush()";
    "Fxn:serialized_storages[key]._write_file(f,";
    "Fxn:_is_real_file(f))";
    "Fxn:load";
    "Fxn:torch.load('tensors.pt')";
    "Fxn:torch.load('tensors.pt',";
    "Fxn:torch.load('tensors.pt',";
    "Fxn:torch.load('tensors.pt',";
    "Fxn:storage.cuda(1))";
    "Fxn:torch.load('tensors.pt',";
    "Fxn:io.BytesIO(f.read())";
    "Fxn:torch.load(buffer)";
    "Fxn:_load(f,";
    "Fxn:f.close()";
    "Fxn:_load";
    "Fxn:restore_location";
    "Fxn:map_location.get(location,";
    "Fxn:default_restore_location(storage,";
    "Fxn:restore_location";
    "Fxn:default_restore_location(storage,";
    "Fxn:restore_location";
    "Fxn:map_location(storage,";
    "Fxn:default_restore_location(storage,";
    "Fxn:_check_container_source";
    "Fxn:inspect.getsource(container_type)";
    "Fxn:warnings.warn("Couldn't";
    "Fxn:difflib.unified_diff(current_source.split('\n'),";
    "Fxn:original_source.split('\n'),";
    "Fxn:'\n'.join(diff)";
    "Fxn:f.seek(0,";
    "Fxn:f.seek(0)";
    "Fxn:f.write(lines)";
    "Fxn:f.read()";
    "Fxn:legacy_load";
    "Fxn:persistent_load";
    "Fxn:_check_container_source(*saved_id)";
    "Fxn:deserialized_objects[int(saved_id)]";
    "Fxn:closing(tarfile.open(fileobj=f,";
    "Fxn:mkdtemp()";
    "Fxn:tar.extract('storages',";
    "Fxn:pickle_module.load(f)";
    "Fxn:pickle_module.load(f)";
    "Fxn:storage_type._new_with_file(f)";
    "Fxn:restore_location(obj,";
    "Fxn:pickle_module.load(f)";
    "Fxn:tar.extract('tensors',";
    "Fxn:pickle_module.load(f)";
    "Fxn:pickle_module.load(f)";
    "Fxn:storage_to_tensor_type(storage)";
    "Fxn:struct.unpack('<i',";
    "Fxn:f.read(4))";
    "Fxn:f.read(4)";
    "Fxn:struct.unpack('<{}q'.format(ndim),";
    "Fxn:f.read(8";
    "Fxn:struct.unpack('<{}q'.format(ndim),";
    "Fxn:f.read(8";
    "Fxn:struct.unpack('<q',";
    "Fxn:f.read(8))";
    "Fxn:tensor_type().set_(storage,";
    "Fxn:tar.extractfile('pickle')";
    "Fxn:pickle_module.Unpickler(pickle_file)";
    "Fxn:unpickler.load()";
    "Fxn:persistent_load";
    "Fxn:_check_container_source(*data)";
    "Fxn:restore_location(";
    "Fxn:data_type(size),";
    "Fxn:RuntimeError("Unknown";
    "Fxn:_is_real_file(f)";
    "Fxn:f.tell()";
    "Fxn:fileno()";
    "Fxn:legacy_load(f)";
    "Fxn:f.seek(0)";
    "Fxn:pickle_module.load(f)";
    "Fxn:RuntimeError("Invalid";
    "Fxn:pickle_module.load(f)";
    "Fxn:RuntimeError("Invalid";
    "Fxn:pickle_module.load(f)";
    "Fxn:pickle_module.Unpickler(f)";
    "Fxn:unpickler.load()";
    "Fxn:pickle_module.load(f)";
    "Fxn:f.tell()";
    "Fxn:deserialized_objects[key]._set_from_file(f,";
    "Import:StringIO";
    "Import:torch.nn";
    "/torch/storage.py";
    "Import:torch";
    "Import:_type,";
    "class:_StorageBase(object):";
    "Fxn:__str__";
    "Fxn:'.join(str(self[i])";
    "Fxn:{}]'.format(torch.typename(self),";
    "Fxn:__repr__";
    "Fxn:__iter__";
    "Fxn:__copy__";
    "Fxn:self.clone()";
    "Fxn:__deepcopy__";
    "Fxn:memo.setdefault('torch',";
    "Fxn:self.clone()";
    "Fxn:__reduce__";
    "Fxn:__sizeof__";
    "Fxn:self).__sizeof__()";
    "Fxn:self.element_size()";
    "Fxn:self.size()";
    "Fxn:clone";
    "Fxn:tolist";
    "Fxn:cpu";
    "Fxn:self.type(getattr(torch,";
    "Fxn:double";
    "Fxn:self.type(type(self).__module__";
    "Fxn:float";
    "Fxn:self.type(type(self).__module__";
    "Fxn:half";
    "Fxn:self.type(type(self).__module__";
    "Fxn:long";
    "Fxn:self.type(type(self).__module__";
    "Fxn:int";
    "Fxn:self.type(type(self).__module__";
    "Fxn:short";
    "Fxn:self.type(type(self).__module__";
    "Fxn:char";
    "Fxn:self.type(type(self).__module__";
    "Fxn:byte";
    "Fxn:self.type(type(self).__module__";
    "Fxn:pin_memory";
    "Fxn:TypeError("cannot";
    "Fxn:.format(self.type()))";
    "Fxn:torch.cuda._host_allocator()";
    "Fxn:allocator=allocator).copy_(self)";
    "Fxn:share_memory_";
    "Fxn:get_sharing_strategy()";
    "Fxn:self._share_filename_()";
    "Fxn:self._share_fd_()";
    "Fxn:_new_shared";
    "Fxn:cls(size)";
    "Fxn:get_sharing_strategy()";
    "Fxn:cls._new_using_filename(size)";
    "Fxn:cls._new_using_fd(size)";
    "Import:torch.cuda";
    "Import:get_sharing_strategy";
    "Import:get_sharing_strategy";
    "/torch/_six.py";
    "Import:itertools";
    "Import:sys";
    "Fxn:with_metaclass";
    "class:metaclass(meta):";
    "Fxn:__new__";
    "Fxn:meta(name,";
    "Fxn:type.__new__(metaclass,";
    "Fxn:exec_";
    "Fxn:sys._getframe(1)";
    "Fxn:exec_("""def";
    "Fxn:raise_from(value,";
    "Fxn:exec_("""def";
    "Fxn:raise_from(value,";
    "Fxn:raise_from";
    "Import:builtins";
    "/torch/_storage_docs.py";
    "Import:torch._C";
    "Import:_add_docstr";
    "Fxn:add_docstr_all";
    "/torch/_tensor_docs.py";
    "Import:torch._C";
    "Import:_add_docstr";
    "Fxn:add_docstr_all";
    "Fxn:callable";
    "/torch/_tensor_str.py";
    "Import:math";
    "Import:torch";
    "Import:reduce";
    "Import:float_info";
    "class:__PrinterOptions(object):";
    "Fxn:set_printoptions";
    "Fxn:_get_min_log_scale";
    "Fxn:math.ceil(math.log(min_positive,";
    "Fxn:_number_format";
    "Fxn:_get_min_log_scale()";
    "Fxn:torch.DoubleTensor(tensor.size()).copy_(tensor).abs_().view(tensor.nelement())";
    "Fxn:tensor.eq(float('inf'))";
    "Fxn:tensor.eq(float('-inf'))";
    "Fxn:tensor.ne(tensor)";
    "Fxn:invalid_value_mask.all():";
    "Fxn:tensor[invalid_value_mask.eq(0)][0]";
    "Fxn:invalid_value_mask.any():";
    "Fxn:math.ceil(value.item()):";
    "Fxn:tensor.min()";
    "Fxn:math.floor(math.log10(exp_min))";
    "Fxn:tensor.max()";
    "Fxn:math.floor(math.log10(exp_max))";
    "Fxn:'{{:11.{}e}}'.format(prec)";
    "Fxn:'{{:{}.{}e}}'.format(sz,";
    "Fxn:math.pow(10,";
    "Fxn:'{{:{}.{}f}}'.format(sz,";
    "Fxn:_tensor_str";
    "Fxn:self.size()[-1]";
    "Fxn:self.size()[-2]";
    "Fxn:_number_format(self,";
    "Fxn:self.numel()";
    "Fxn:self.size()))";
    "Fxn:self.ndimension()";
    "Fxn:torch.LongStorage(counter_dim).fill_(0)";
    "Fxn:counter[counter.size()";
    "Fxn:self.size(i)";
    "Fxn:self.size(i)";
    "Fxn:self.size(i):";
    "Fxn:dot_fmt.format('...')";
    "Fxn:dot_fmt.format('')";
    "Fxn:dot_fmt.format(u'\u22EE'";
    "Fxn:'({},.,.)";
    "Fxn:\n'.format(";
    "Fxn:','.join(dim_fmt.format(i)";
    "Fxn:reduce(lambda";
    "Fxn:t.select(0,";
    "Fxn:_matrix_str(submatrix,";
    "Fxn:__repr_row";
    "Fxn:'.join(fmt.format(val.item()";
    "Fxn:dotfmt.format('...')";
    "Fxn:'.join(fmt.format(val.item()";
    "Fxn:'.join(fmt.format(val.item()";
    "Fxn:_matrix_str";
    "Fxn:self.size(1)";
    "Fxn:self.size(0)";
    "Fxn:_number_format(self,";
    "Fxn:self.size(1):";
    "Fxn:self.size(1)";
    "Fxn:self.size(1):";
    "Fxn:\n{}'.format(";
    "Fxn:SCALE_FORMAT.format(scale)";
    "Fxn:'.join(fmt.format(val.item()";
    "Fxn:SCALE_FORMAT.format(scale)";
    "Fxn:__repr_row(row,";
    "Fxn:'.join([vdotfmt.format('...'),";
    "Fxn:ddotfmt.format(u'\u22F1'),";
    "Fxn:vdotfmt.format('...')])";
    "Fxn:__repr_row(row,";
    "Fxn:__repr_row(row,";
    "Fxn:__repr_row(row,";
    "Fxn:vdotfmt.format(u'\u22EE')";
    "Fxn:__repr_row(row,";
    "Fxn:__repr_row(row,";
    "Fxn:_vector_str";
    "Fxn:_number_format(self)";
    "Fxn:SCALE_FORMAT.format(scale)";
    "Fxn:self.numel()";
    "Fxn:'\n'.join(ident";
    "Fxn:fmt.format(val.item()";
    "Fxn:'\n'.join(ident";
    "Fxn:fmt.format(val.item()";
    "Fxn:dotfmt.format(u"\u22EE"))";
    "Fxn:'\n'.join(ident";
    "Fxn:fmt.format(val.item()";
    "Fxn:_str";
    "Fxn:values:\n{}'.format(";
    "Fxn:self.type(),";
    "Fxn:self._indices(),";
    "Fxn:self._values())";
    "Fxn:self.numel()";
    "Fxn:self.dim()";
    "Fxn:_vector_str(self.unsqueeze(0))";
    "Fxn:_vector_str(self)";
    "Fxn:_matrix_str(self)";
    "Fxn:_tensor_str(self)";
    "Fxn:{})'.format(self.get_device())";
    "Fxn:{}{}]\n'.format(self.type(),";
    "/torch/_torch_docs.py";
    "Import:torch._C";
    "Import:_add_docstr";
    "Import:torch";
    "/torch/_utils.py";
    "Import:torch";
    "Import:importlib";
    "Import:warnings";
    "Import:defaultdict";
    "Fxn:_type";
    "Fxn:_cuda";
    "Fxn:_get_async_or_non_blocking";
    "Fxn:_rebuild_tensor";
    "Fxn:_rebuild_tensor_v2";
    "Fxn:_import_dotted_name";
    "Fxn:_accumulate";
    "Fxn:_flatten_dense_tensors";
    "Fxn:_flatten_sparse_tensors";
    "Fxn:_unflatten_dense_tensors";
    "Fxn:_unflatten_sparse_tensors";
    "Fxn:_reorder_tensors_as";
    "Fxn:_take_tensors";
    "/torch/__init__.py";
    "Import:sys";
    "Import:platform";
    "Import:_import_dotted_name";
    "Import:__version__";
    "Import:string_classes";
    "Import:_dl_flags";
    "Import:numpy";
    "Fxn:get_nvToolsExt_path";
    "Import:DLFCN";
    "Import:torch._dl";
    "Import:torch._nvrtc";
    "Import:__all__";
    "Fxn:typename";
    "Fxn:is_tensor";
    "Fxn:is_storage";
    "Fxn:set_default_tensor_type";
    "Import:set_rng_state,";
    "Import:save,";
    "Import:set_printoptions";
    "Import:_StorageBase";
    "class:DoubleStorage(_C.DoubleStorageBase,";
    "class:FloatStorage(_C.FloatStorageBase,";
    "class:HalfStorage(_C.HalfStorageBase,";
    "class:LongStorage(_C.LongStorageBase,";
    "class:IntStorage(_C.IntStorageBase,";
    "class:ShortStorage(_C.ShortStorageBase,";
    "class:CharStorage(_C.CharStorageBase,";
    "class:ByteStorage(_C.ByteStorageBase,";
    "Fxn:manager_path";
    "Fxn:platform.system()";
    "Fxn:os.path.join(os.path.abspath(os.path.dirname(__file__)),";
    "Fxn:os.path.exists(path):";
    "Fxn:RuntimeError("Unable";
    "Fxn:path.encode('utf-8')";
    "Fxn:_C._initExtension(manager_path())";
    "Fxn:_C._init_names(list(torch._storage_classes))";
    "Import:path";
    "Import:################################################################################";
    "Import:torch.cuda";
    "Import:torch.autograd";
    "Import:torch.nn";
    "Import:torch.optim";
    "Import:torch.multiprocessing";
    "Import:torch.sparse";
    "Import:torch.utils.backcompat";
    "Import:torch.onnx";
    "Import:torch.jit";
    "Import:torch.random";
    "Import:torch.distributions";
    "Import:torch.testing";
    "Import:no_grad,";
    "Import:_torch_docs,";
    "/torch/autograd/function.py";
    "Import:torch";
    "Import:torch._C";
    "Import:torch.utils.hooks";
    "Import:with_metaclass";
    "Import:functools";
    "Import:warnings";
    "Import:OrderedDict";
    "class:_ContextMethodMixin(object):";
    "Fxn:save_for_backward";
    "Fxn:mark_dirty";
    "Fxn:mark_shared_storage";
    "Fxn:warnings.warn(";
    "Fxn:`set_()`";
    "Fxn:mark_non_differentiable";
    "class:_HookMixin(object):";
    "Fxn:_register_hook";
    "Fxn:OrderedDict()";
    "Fxn:hooks.RemovableHandle(backward_hooks)";
    "class:BackwardCFunction(_C._FunctionBase,";
    "Fxn:apply";
    "Fxn:self._forward_cls.backward(self,";
    "class:FunctionMeta(type):";
    "Fxn:__init__";
    "Fxn:cls.mro():";
    "Fxn:super_cls.__dict__.get('forward')";
    "Fxn:cls).__init__(name,";
    "Fxn:cls).__init__(name,";
    "class:Function(with_metaclass(FunctionMeta,";
    "class:Exp(Function):";
    "Fxn:forward";
    "Fxn:i.exp()";
    "Fxn:ctx.save_for_backward(result)";
    "Fxn:backward";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:once_differentiable";
    "Fxn:@functools.wraps(fn)";
    "Fxn:wrapper";
    "Fxn:torch.no_grad():";
    "Fxn:fn(ctx,";
    "Fxn:torch.is_grad_enabled():";
    "Fxn:torch._C._functions.DelayedError(";
    "Fxn:fake_requires_grad";
    "Fxn:var.detach()";
    "Fxn:err_fn(*[fake_requires_grad(v)";
    "Fxn:traceable";
    "Import:Variable";
    "class:InplaceFunction(Function):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_nested_map";
    "Fxn:_map";
    "Fxn:condition(obj):";
    "Fxn:fn(obj)";
    "Fxn:ValueError("Auto";
    "Fxn:torch.typename(obj)";
    "Fxn:_iter_filter";
    "Fxn:_iter";
    "Fxn:condition(obj):";
    "Fxn:_iter(o):";
    "Fxn:ValueError("Auto";
    "Fxn:torch.typename(obj)";
    "Fxn:_unflatten";
    "Fxn:unflatten_helper";
    "Fxn:res.append(e)";
    "Fxn:unflatten_helper(input,";
    "Fxn:res.append(res_e)";
    "Fxn:unflatten_helper(input,";
    "Fxn:_iter_filter(lambda";
    "Fxn:_iter_filter(lambda";
    "Fxn:_iter_filter(lambda";
    "Fxn:_iter_filter(torch.is_tensor,";
    "Fxn:_iter_filter(";
    "Fxn:torch.is_tensor(o)";
    "Fxn:_nested_map(lambda";
    "class:NestedIOFunction(Function):";
    "Fxn:_do_forward";
    "Fxn:self)._do_forward(*flat_input)";
    "Fxn:_unflatten(flat_output,";
    "Fxn:_do_backward";
    "Fxn:self)._do_backward(gradients,";
    "Fxn:backward";
    "Fxn:_unflatten(gradients,";
    "Fxn:self.backward_extended(*nested_gradients)";
    "Fxn:forward";
    "Fxn:_map_variable_tensor(self._nested_input)";
    "Fxn:self.forward_extended(*nested_tensors)";
    "Fxn:save_for_backward";
    "Fxn:saved_tensors";
    "Fxn:_unflatten(flat_tensors,";
    "Fxn:mark_dirty";
    "Fxn:mark_non_differentiable";
    "Fxn:forward_extended";
    "Fxn:backward_extended";
    "/torch/autograd/gradcheck.py";
    "Import:torch";
    "Import:Variable";
    "Import:Iterable";
    "Import:torch.testing";
    "Import:sys";
    "Fxn:iter_variables";
    "Fxn:zero_gradients";
    "Fxn:make_jacobian";
    "Fxn:iter_tensors";
    "Fxn:contiguous";
    "Fxn:get_numerical_jacobian";
    "Fxn:get_analytical_jacobian";
    "Fxn:_as_tuple";
    "Fxn:_differentiable_outputs";
    "Fxn:gradcheck";
    "Fxn:fail_test";
    "Fxn:fn";
    "Fxn:gradgradcheck";
    "Fxn:randn_like";
    "Fxn:new_func";
    "/torch/autograd/grad_mode.py";
    "Import:torch";
    "class:no_grad(object):";
    "Fxn:__init__";
    "Fxn:torch.is_grad_enabled()";
    "Fxn:__enter__";
    "Fxn:torch._C.set_grad_enabled(False)";
    "Fxn:__exit__";
    "Fxn:torch.set_grad_enabled(self.prev)";
    "class:enable_grad(object):";
    "Fxn:__init__";
    "Fxn:torch.is_grad_enabled()";
    "Fxn:__enter__";
    "Fxn:torch._C.set_grad_enabled(True)";
    "Fxn:__exit__";
    "Fxn:torch.set_grad_enabled(self.prev)";
    "class:set_grad_enabled(object):";
    "Fxn:__init__";
    "Fxn:torch.is_grad_enabled()";
    "Fxn:torch._C.set_grad_enabled(mode)";
    "Fxn:__enter__";
    "Fxn:__exit__";
    "Fxn:torch.set_grad_enabled(self.prev)";
    "/torch/autograd/profiler.py";
    "Import:subprocess";
    "Import:import";
    "Import:import";
    "Import:sys";
    "Import:itertools";
    "Import:defaultdict";
    "Import:torch";
    "class:range(object):";
    "Fxn:__init__";
    "Fxn:__enter__";
    "Fxn:torch.autograd._push_range(self.name)";
    "Fxn:__exit__";
    "Fxn:torch.autograd._pop_range()";
    "class:EventList(list):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:__str__";
    "Fxn:self.table()";
    "Fxn:table";
    "Fxn:build_table(self,";
    "Fxn:export_chrome_trace";
    "Fxn:chrome_events.append(dict(";
    "Fxn:dur=evt.cpu_interval.elapsed_us(),";
    "Fxn:chrome_events.append(dict(";
    "Fxn:chrome_events.append(dict(";
    "Fxn:chrome_events.append(dict(";
    "Fxn:dur=k.interval.elapsed_us(),";
    "Fxn:json.dump(chrome_events,";
    "Fxn:key_averages";
    "Fxn:defaultdict(FunctionEventAvg)";
    "Fxn:EventList(stats.values())";
    "Fxn:total_average";
    "Fxn:FunctionEventAvg()";
    "Import:json";
    "class:profile(object):";
    "Fxn:__init__";
    "Fxn:__enter__";
    "Fxn:RuntimeError("autograd";
    "Fxn:torch.autograd._enable_profiler(profiler_kind)";
    "Fxn:__exit__";
    "Fxn:torch.autograd._disable_profiler()";
    "Fxn:EventList(parse_cpu_trace(records))";
    "Fxn:__repr__";
    "Fxn:__str__";
    "Fxn:_check_finish";
    "Fxn:RuntimeError("can't";
    "Fxn:table";
    "Fxn:self._check_finish()";
    "Fxn:self.function_events.table(sort_by)";
    "Fxn:export_chrome_trace";
    "Fxn:self._check_finish()";
    "Fxn:self.function_events.export_chrome_trace(path)";
    "Fxn:key_averages";
    "Fxn:self._check_finish()";
    "Fxn:self.function_events.key_averages()";
    "Fxn:total_average";
    "Fxn:self._check_finish()";
    "Fxn:self.function_events.total_average()";
    "class:emit_nvtx(object):";
    "Fxn:__init__";
    "Fxn:__enter__";
    "Fxn:RuntimeError("NVTX";
    "Fxn:torch.cuda.synchronize()";
    "Fxn:torch.autograd._enable_profiler(torch.autograd.ProfilerState.NVTX)";
    "Fxn:__exit__";
    "Fxn:torch.cuda.synchronize()";
    "Fxn:torch.autograd._disable_profiler()";
    "Fxn:load_nvprof";
    "Fxn:EventList(parse_nvprof_trace(path))";
    "Fxn:format_time";
    "Fxn:'{:.3f}us'.format(time_us)";
    "Fxn:attr_formatter";
    "Fxn:format_time(getattr(self,";
    "class:FormattedTimesMixin(object):";
    "Fxn:cpu_time";
    "Fxn:cuda_time";
    "class:Interval(object):";
    "Fxn:__init__";
    "Fxn:elapsed_us";
    "class:Kernel(object):";
    "Fxn:__init__";
    "class:FunctionEvent(FormattedTimesMixin):";
    "Fxn:__init__";
    "Fxn:Interval(cpu_start,";
    "Fxn:append_kernel";
    "Fxn:self.kernels.append(Kernel(name,";
    "Fxn:Interval(start,";
    "Fxn:cuda_time_total";
    "Fxn:cpu_time_total";
    "Fxn:self.cpu_interval.elapsed_us()";
    "Fxn:key";
    "Fxn:__repr__";
    "Fxn:thread={}>'.format(";
    "class:FunctionEventAvg(FormattedTimesMixin):";
    "Fxn:__init__";
    "Fxn:__iadd__";
    "Fxn:__repr__";
    "Fxn:key={}>'.format(";
    "Fxn:demangle";
    "Fxn:subprocess.check_output(filt_cmd,";
    "Fxn:stderr=devnull).rstrip().decode("ascii")";
    "Fxn:re.search('is";
    "Fxn:\"(.*)"',";
    "Fxn:orig_name).group(1)";
    "class:StringTable(defaultdict):";
    "Fxn:__missing__";
    "Fxn:demangle(key)";
    "Fxn:parse_cpu_trace";
    "Fxn:StringTable()";
    "Fxn:adjusted_time";
    "Fxn:cuda_record.device()";
    "Fxn:cuda_records[cuda_record.device()]";
    "Fxn:cuda_time_0.cuda_elapsed_us(cuda_record)";
    "Fxn:start_record.cpu_elapsed_us(cuda_time_0)";
    "Fxn:itertools.chain(*thread_records):";
    "Fxn:record.name()";
    "Fxn:record.name()";
    "Fxn:record.device()";
    "Fxn:cuda_records[record.device()]";
    "Fxn:itertools.chain(*thread_records):";
    "Fxn:record.kind()";
    "Fxn:record.kind()";
    "Fxn:record_stack.append((next_id,";
    "Fxn:record.kind()";
    "Fxn:record_stack.pop()";
    "Fxn:FunctionEvent(";
    "Fxn:name=string_table[start.name()],";
    "Fxn:thread=start.thread_id(),";
    "Fxn:cpu_start=start_record.cpu_elapsed_us(start),";
    "Fxn:cpu_end=start_record.cpu_elapsed_us(record))";
    "Fxn:start.has_cuda():";
    "Fxn:adjusted_time(start)";
    "Fxn:adjusted_time(record)";
    "Fxn:fe.append_kernel(start.name(),";
    "Fxn:start.device(),";
    "Fxn:functions.append(fe)";
    "Fxn:functions.sort(key=lambda";
    "class:EnforceUnique(object):";
    "Fxn:__init__";
    "Fxn:see";
    "Fxn:RuntimeError('duplicate";
    "Fxn:self.seen.add(key)";
    "Fxn:parse_nvprof_trace";
    "Fxn:sqlite3.connect(path)";
    "Fxn:conn.execute("SELECT";
    "Fxn:demangle(r["value"])";
    "Fxn:EnforceUnique()";
    "Fxn:conn.execute(marker_query):";
    "Fxn:unique.see(row['marker_id'])";
    "Fxn:FunctionEvent(id=row['marker_id'],";
    "Fxn:functions.append(evt)";
    "Fxn:EnforceUnique()";
    "Fxn:conn.execute(kernel_query):";
    "Fxn:unique.see(row['marker_id'],";
    "Fxn:evt.append_kernel(row['kernel_name'],";
    "Fxn:functions.sort(key=lambda";
    "Fxn:build_table";
    "Fxn:append";
    "Fxn:append('='";
    "Fxn:append(header)";
    "Fxn:append(header_sep)";
    "Fxn:append(row_format.format('Name',";
    "Fxn:append(header_sep)";
    "Fxn:append(row_format.format(evt.key,";
    "Import:sqlite3";
    "/torch/autograd/variable.py";
    "Import:sys";
    "Import:torch";
    "Import:torch._C";
    "Import:OrderedDict";
    "Import:torch.sparse";
    "Import:torch.utils.hooks";
    "Import:warnings";
    "Import:weakref";
    "Import:imap";
    "Import:_add_docstr";
    "class:Variable(_C._VariableBase):";
    "Fxn:__deepcopy__";
    "Fxn:RuntimeError("Only";
    "Fxn:"(graph";
    "Fxn:memo[id(self)]";
    "Fxn:torch.no_grad():";
    "Fxn:self.clone()";
    "Fxn:self.storage().__deepcopy__(memo)";
    "Fxn:self.new()";
    "Fxn:new_tensor.set_(new_storage,";
    "Fxn:self.storage_offset(),";
    "Fxn:self.size(),";
    "Fxn:self.stride())";
    "Fxn:memo[id(self)]";
    "Fxn:__reduce_ex__";
    "Fxn:self.storage_offset(),";
    "Fxn:self.stride(),";
    "Fxn:__setstate__";
    "Fxn:RuntimeError('__setstate__";
    "Fxn:__repr__";
    "Fxn:torch._tensor_str._str(self)";
    "Fxn:torch._tensor_str._str(self).encode(";
    "Fxn:torch._tensor_str._str(self).encode('UTF-8',";
    "Fxn:backward";
    "Fxn:torch.autograd.backward(self,";
    "Fxn:register_hook";
    "Fxn:hook(grad)";
    "Fxn:``handle.remove()``";
    "Fxn:Variable(torch.Tensor([0,";
    "Fxn:v.register_hook(lambda";
    "Fxn:v.backward(torch.Tensor([1,";
    "Fxn:h.remove()";
    "Fxn:RuntimeError("cannot";
    "Fxn:OrderedDict()";
    "Fxn:self.grad_fn._register_hook_dict(self)";
    "Fxn:hooks.RemovableHandle(self._backward_hooks)";
    "Fxn:reinforce";
    "Fxn:trim";
    "Fxn:'\n'.join([line.strip()";
    "Fxn:str.split('\n')])";
    "Fxn:RuntimeError(trim(r"""reinforce()";
    "Fxn:policy_network(state)";
    "Fxn:probs.multinomial()";
    "Fxn:env.step(action)";
    "Fxn:action.reinforce(reward)";
    "Fxn:action.backward()";
    "Fxn:policy_network(state)";
    "Fxn:torch.distributions.Categorical(probs)";
    "Fxn:m.sample()";
    "Fxn:env.step(action)";
    "Fxn:-m.log_prob(action)";
    "Fxn:loss.backward()";
    "Fxn:_add_docstr(_C._VariableBase.detach,";
    "Fxn:_add_docstr(_C._VariableBase.detach_,";
    "Fxn:retain_grad";
    "Fxn:RuntimeError("can't";
    "Fxn:weakref.ref(self)";
    "Fxn:retain_grad_hook";
    "Fxn:weak_self()";
    "Fxn:grad.clone()";
    "Fxn:self.register_hook(retain_grad_hook)";
    "Fxn:is_pinned";
    "Fxn:self.storage()";
    "Fxn:storage.is_pinned()";
    "Fxn:is_shared";
    "Fxn:self.storage().is_shared()";
    "Fxn:share_memory_";
    "Fxn:self.storage().share_memory_()";
    "Fxn:view_as";
    "Fxn:self.view(tensor.size())";
    "Fxn:btrifact";
    "Fxn:warnings.warn("info";
    "Fxn:self).btrifact_with_info(pivot=pivot)";
    "Fxn:info.type()";
    "Fxn:_info.type():";
    "Fxn:ValueError('btrifact";
    "Fxn:info.resize_as_(_info).copy_(_info)";
    "Fxn:self).btrifact(pivot=pivot)";
    "Fxn:resize";
    "Fxn:warnings.warn("non-inplace";
    "Fxn:Resize.apply(self,";
    "Fxn:resize_as";
    "Fxn:warnings.warn("non-inplace";
    "Fxn:Resize.apply(self,";
    "Fxn:variable.size())";
    "Fxn:split";
    "Fxn:self).split(split_size,";
    "Fxn:self).split_with_sizes(split_size,";
    "Fxn:index_add";
    "Fxn:self.clone().index_add_(dim,";
    "Fxn:index_copy";
    "Fxn:self.clone().index_copy_(dim,";
    "Fxn:index_fill";
    "Fxn:self.clone().index_fill_(dim,";
    "Fxn:scatter";
    "Fxn:self.clone().scatter_(dim,";
    "Fxn:scatter_add";
    "Fxn:self.clone().scatter_add_(dim,";
    "Fxn:masked_copy";
    "Fxn:warnings.warn("masked_copy";
    "Fxn:self.masked_scatter(mask,";
    "Fxn:masked_copy_";
    "Fxn:warnings.warn("masked_copy_";
    "Fxn:self.masked_scatter_(mask,";
    "Fxn:masked_scatter";
    "Fxn:self.clone().masked_scatter_(mask,";
    "Fxn:masked_fill";
    "Fxn:self.clone().masked_fill_(mask,";
    "Fxn:expand_as";
    "Fxn:self.expand(tensor.size())";
    "Fxn:unique";
    "Fxn:self._unique(";
    "Fxn:__rsub__";
    "Fxn:__rdiv__";
    "Fxn:self.reciprocal()";
    "Fxn:__format__";
    "Fxn:self.dim()";
    "Fxn:self.item().__format__(format_spec)";
    "Fxn:object.__format__(self,";
    "Fxn:__ipow__";
    "Fxn:NotImplementedError("in-place";
    "Fxn:__rpow__";
    "Fxn:self.new([other])";
    "Fxn:__len__";
    "Fxn:self.dim()";
    "Fxn:TypeError("len()";
    "Fxn:__iter__";
    "Fxn:self.dim()";
    "Fxn:TypeError('iteration";
    "Fxn:__hash__";
    "Fxn:__dir__";
    "Fxn:variable_methods.remove('volatile')";
    "Fxn:`numpy.asarray(tensor)";
    "Fxn:__array__";
    "Fxn:self.cpu().numpy()";
    "Fxn:self.cpu().numpy().astype(dtype,";
    "Fxn:`numpy.sin(tensor)";
    "Fxn:`numpy.greater(tensor,";
    "Fxn:__array_wrap__";
    "Fxn:array.astype('uint8')";
    "Fxn:torch.from_numpy(array)";
    "Fxn:ImperativeEngine()";
    "Import:Resize";
    "Import:Resize";
    "Import:_ImperativeEngine";
    "/torch/autograd/__init__.py";
    "Import:torch";
    "Import:warnings";
    "Import:Variable";
    "Import:Function,";
    "Import:gradcheck";
    "Import:no_grad,";
    "Import:profiler";
    "Fxn:_make_grads";
    "Fxn:backward";
    "Fxn:grad";
    "Fxn:variable";
    "/torch/autograd/_functions/tensor.py";
    "Import:reduce";
    "Import:torch";
    "Import:torch._utils";
    "Import:Function";
    "class:Type(Function):";
    "Fxn:forward";
    "Fxn:i.get_device()";
    "Fxn:i.type(dest_type)";
    "Fxn:backward";
    "Fxn:grad_output.type(ctx.input_type),";
    "Fxn:torch.cuda.device(ctx.input_device):";
    "Fxn:grad_output.type(ctx.input_type),";
    "class:Resize(Function):";
    "Fxn:forward";
    "Fxn:reduce(lambda";
    "Fxn:tensor.numel()";
    "Fxn:RuntimeError(("requested";
    "Fxn:").format(";
    "Fxn:'x'.join(map(str,";
    "Fxn:'x'.join(map(str,";
    "Fxn:tensor.size())),";
    "Fxn:tensor.numel()))";
    "Fxn:tensor.size()";
    "Fxn:tensor.is_contiguous():";
    "Fxn:tensor.new(tensor).contiguous().view(*sizes)";
    "Fxn:tensor.contiguous().view(*sizes)";
    "Fxn:backward";
    "Fxn:grad_output.numel()";
    "Fxn:grad_output.contiguous().view(ctx.input_sizes),";
    "/torch/autograd/_functions/utils.py";
    "Import:torch";
    "Import:reduce";
    "Fxn:maybe_view";
    "Fxn:maybe_unexpand";
    "Fxn:prepare_onnx_paddings";
    "Fxn:check_onnx_broadcast";
    "/torch/autograd/_functions/__init__.py";
    "/torch/backends/__init__.py";
    "/torch/backends/cudnn/rnn.py";
    "Import:torch.cuda";
    "Import:torch.backends.cudnn";
    "Fxn:get_cudnn_mode";
    "class:Unserializable(object):";
    "Fxn:__init__";
    "Fxn:get";
    "Fxn:__getstate__";
    "Fxn:__setstate__";
    "Fxn:init_dropout_state";
    "Fxn:Unserializable(";
    "Fxn:torch._C._VariableFunctions._cudnn_init_dropout_state(dropout_p,";
    "Fxn:dropout_state[dropout_desc_name].get()";
    "/torch/backends/cudnn/__init__.py";
    "Import:import";
    "Import:ctypes";
    "Import:sys";
    "Import:torch";
    "Import:warnings";
    "Import:cuda";
    "Import:contextmanager";
    "Import:Popen,";
    "Fxn:find_cudnn_windows_lib";
    "Fxn:_libcudnn";
    "Fxn:version";
    "Fxn:is_acceptable";
    "Fxn:set_flags";
    "Fxn:disable_global_flags";
    "Fxn:flags_frozen";
    "Fxn:__allow_nonbracketed_mutation";
    "Fxn:flags";
    "Fxn:__init__";
    "Fxn:__del__";
    "class:CuDNNError(RuntimeError):";
    "Fxn:__init__";
    "Fxn:{}'.format(status,";
    "Fxn:get_error_string(status))";
    "Fxn:self).__init__(msg)";
    "class:TensorDescriptor(object):";
    "Fxn:__init__";
    "Fxn:ctypes.c_void_p()";
    "Fxn:check_error(lib.cudnnCreateTensorDescriptor(ctypes.byref(ptr)))";
    "Fxn:__del__";
    "Fxn:check_error(lib.cudnnDestroyTensorDescriptor(self._as_parameter_))";
    "Fxn:set";
    "Fxn:tensor.type()";
    "Fxn:tensor.size()";
    "Fxn:tensor.stride()";
    "Fxn:check_error(lib.cudnnSetTensorNdDescriptor(";
    "Fxn:_typemap[tensor.type()],";
    "Fxn:tensor.dim(),";
    "Fxn:int_array(tensor.size()),";
    "Fxn:int_array(tensor.stride())))";
    "Fxn:as_tuple";
    "class:TensorDescriptorArray(object):";
    "Fxn:__init__";
    "Fxn:N)()";
    "Fxn:ctypes.byref(self.ptrs,";
    "Fxn:ctypes.sizeof(ctypes.c_void_p))";
    "Fxn:check_error(lib.cudnnCreateTensorDescriptor(ptr))";
    "Fxn:__del__";
    "Fxn:check_error(lib.cudnnDestroyTensorDescriptor(ctypes.c_void_p(ptr)))";
    "Fxn:__getitem__";
    "Fxn:ctypes.c_void_p(self.ptrs[key])";
    "Fxn:set_all";
    "Fxn:_typemap[tensor.type()]";
    "Fxn:tensor.dim()";
    "Fxn:int_array(tensor.size())";
    "Fxn:int_array(tensor.stride())";
    "Fxn:check_error(lib.cudnnSetTensorNdDescriptor(";
    "Fxn:ctypes.c_void_p(ptr),";
    "Fxn:set_raw";
    "Fxn:check_error(lib.cudnnSetTensorNdDescriptor(";
    "Fxn:ctypes.c_void_p(ptr),";
    "class:FilterDescriptor(object):";
    "Fxn:__init__";
    "Fxn:ctypes.c_void_p()";
    "Fxn:check_error(lib.cudnnCreateFilterDescriptor(ctypes.byref(ptr)))";
    "Fxn:__del__";
    "Fxn:check_error(lib.cudnnDestroyFilterDescriptor(self._as_parameter_))";
    "Fxn:set";
    "Fxn:weight.size()";
    "Fxn:_typemap[weight.type()]";
    "Fxn:check_error(lib.cudnnSetFilterNdDescriptor(";
    "Fxn:weight.ndimension(),";
    "Fxn:int_array(weight.size())))";
    "Fxn:as_tuple";
    "class:DropoutDescriptor(object):";
    "Fxn:__init__";
    "Fxn:ctypes.c_void_p()";
    "Fxn:check_error(lib.cudnnCreateDropoutDescriptor(ctypes.byref(ptr)))";
    "Fxn:self._set(dropout,";
    "Fxn:set_dropout";
    "Fxn:self._set(dropout,";
    "Fxn:_set";
    "Fxn:ctypes.c_long()";
    "Fxn:check_error(lib.cudnnDropoutGetStatesSize(";
    "Fxn:ctypes.byref(dropout_states_size)))";
    "Fxn:torch.cuda.ByteTensor(dropout_states_size.value)";
    "Fxn:self.state.data_ptr()";
    "Fxn:self.state.size(0)";
    "Fxn:check_error(lib.cudnnSetDropoutDescriptor(";
    "Fxn:ctypes.c_float(dropout),";
    "Fxn:ctypes.c_void_p(state_ptr),";
    "Fxn:ctypes.c_size_t(state_size),";
    "Fxn:ctypes.c_ulonglong(seed),";
    "Fxn:__del__";
    "Fxn:check_error(lib.cudnnDestroyDropoutDescriptor(self))";
    "class:RNNDescriptor(object):";
    "Fxn:__init__";
    "Fxn:ctypes.c_void_p()";
    "Fxn:check_error(lib.cudnnCreateRNNDescriptor(ctypes.byref(ptr)))";
    "Fxn:version()";
    "Fxn:check_error(lib.cudnnSetRNNDescriptor_v6(";
    "Fxn:version()";
    "Fxn:torch.cuda.get_device_capability(torch.cuda.current_device())[0]";
    "Fxn:lib.cudnnSetRNNMatrixMathType(self,";
    "Fxn:lib.cudnnSetRNNMatrixMathType(self,";
    "Fxn:check_error(lib.cudnnSetRNNDescriptor(";
    "Fxn:__del__";
    "Fxn:check_error(lib.cudnnDestroyRNNDescriptor(self))";
    "Fxn:check_error";
    "Fxn:CuDNNError(status)";
    "Fxn:get_error_string";
    "Fxn:lib.cudnnGetErrorString(status)";
    "Fxn:get_handle";
    "Fxn:_libcudnn()";
    "Fxn:RuntimeError('cuDNN";
    "Fxn:torch.cuda.current_device()";
    "Fxn:_handles.get(current_device,";
    "Fxn:CuDNNHandle()";
    "Fxn:c_type";
    "Fxn:ValueError("unknown";
    "Fxn:'{}'".format(type(tensor)))";
    "Fxn:int_array";
    "Fxn:array_type(*itr)";
    "Fxn:descriptor";
    "Fxn:tensor.size()";
    "Fxn:tensor.dim()))";
    "Fxn:tensor.view(padded_size)";
    "Fxn:TensorDescriptorArray(N)";
    "Fxn:descriptor.set_all(tensor)";
    "Fxn:TensorDescriptor()";
    "Fxn:descriptor.set(tensor)";
    "Fxn:descriptor_sequence";
    "Fxn:TensorDescriptorArray(len(batch_sizes))";
    "Fxn:_typemap[tensor.type()]";
    "Fxn:tensor.dim())";
    "Fxn:int_array(tensor.size()";
    "Fxn:int_array(tensor.stride()";
    "Fxn:descriptors.set_raw(i,";
    "Fxn:add_tensor";
    "Fxn:check_error(lib.cudnnAddTensor(*args))";
    "class:ContextProp(object):";
    "Fxn:__init__";
    "Fxn:__get__";
    "Fxn:self.getter()";
    "Fxn:__set__";
    "Fxn:flags_frozen():";
    "Fxn:self.setter(val)";
    "Fxn:RuntimeError("not";
    "Fxn:flags()";
    "class:CudnnModule(object):";
    "Fxn:__init__";
    "Fxn:ContextProp(torch._C._get_cudnn_enabled,";
    "Fxn:ContextProp(torch._C._get_cudnn_deterministic,";
    "Fxn:ContextProp(torch._C._get_cudnn_benchmark,";
    "Fxn:CudnnModule(sys.modules[__name__])";
    "/torch/contrib/_graph_vis.py";
    "Import:string";
    "Import:json";
    "Fxn:write";
    "Fxn:add_edge";
    "/torch/contrib/__init__.py";
    "/torch/cuda/comm.py";
    "Import:torch";
    "Import:nccl";
    "Import:_accumulate,";
    "Fxn:broadcast";
    "Fxn:broadcast_coalesced";
    "Fxn:reduce_add";
    "Fxn:reduce_add_coalesced";
    "Fxn:scatter";
    "Fxn:gather";
    "/torch/cuda/error.py";
    "/torch/cuda/nccl.py";
    "Import:warnings";
    "Import:torch.cuda";
    "Fxn:is_available";
    "Fxn:version";
    "Fxn:unique_id";
    "Fxn:init_rank";
    "Fxn:all_reduce";
    "Fxn:reduce";
    "Fxn:broadcast";
    "Fxn:all_gather";
    "Fxn:reduce_scatter";
    "/torch/cuda/nvtx.py";
    "Import:import";
    "Import:glob";
    "Import:ctypes";
    "Import:platform";
    "Fxn:windows_nvToolsExt_lib";
    "Fxn:windows_nvToolsExt_path";
    "Fxn:_libnvToolsExt";
    "Fxn:range_push";
    "Fxn:range_pop";
    "Fxn:mark";
    "/torch/cuda/profiler.py";
    "Import:ctypes";
    "Import:tempfile";
    "Import:contextlib";
    "Import:cudart,";
    "class:cudaOutputMode(object):";
    "Fxn:for_key";
    "Fxn:RuntimeError("supported";
    "Fxn:init";
    "Fxn:cudaOutputMode.for_key(output_mode)";
    "Fxn:tempfile.NamedTemporaryFile(delete=True)";
    "Fxn:f.write(b'\n'.join(map(lambda";
    "Fxn:f.encode('ascii'),";
    "Fxn:f.flush()";
    "Fxn:check_error(cudart().cudaProfilerInitialize(";
    "Fxn:ctypes.c_char_p(f.name.encode('ascii')),";
    "Fxn:ctypes.c_char_p(output_file.encode('ascii')),";
    "Fxn:start";
    "Fxn:check_error(cudart().cudaProfilerStart())";
    "Fxn:stop";
    "Fxn:check_error(cudart().cudaProfilerStop())";
    "Fxn:profile";
    "Fxn:start()";
    "Fxn:stop()";
    "/torch/cuda/random.py";
    "Import:import";
    "Import:_lazy_init,";
    "Fxn:get_rng_state";
    "Fxn:get_rng_state_all";
    "Fxn:set_rng_state";
    "Fxn:cb";
    "Fxn:set_rng_state_all";
    "Fxn:manual_seed";
    "Fxn:manual_seed_all";
    "Fxn:seed";
    "Fxn:seed_all";
    "Fxn:initial_seed";
    "/torch/cuda/sparse.py";
    "/torch/cuda/streams.py";
    "Import:ctypes";
    "Import:torch";
    "Import:cudart,";
    "class:Stream(torch._C._CudaStreamBase):";
    "Fxn:__new__";
    "Fxn:torch.cuda.device(device):";
    "Fxn:cls).__new__(cls,";
    "Fxn:wait_event";
    "Fxn:``cudaStreamWaitEvent()``:";
    "Fxn:check_error(cudart().cudaStreamWaitEvent(self,";
    "Fxn:ctypes.c_int(0)))";
    "Fxn:wait_stream";
    "Fxn:self.wait_event(stream.record_event())";
    "Fxn:record_event";
    "Fxn:Event()";
    "Fxn:check_error(cudart().cudaEventRecord(event,";
    "Fxn:query";
    "Fxn:cudart().cudaStreamQuery(self)";
    "Fxn:check_error(res)";
    "Fxn:synchronize";
    "Fxn:``cudaStreamSynchronize()``:";
    "Fxn:check_error(cudart().cudaStreamSynchronize(self))";
    "Fxn:priority_range";
    "Fxn:ctypes.c_int()";
    "Fxn:ctypes.c_int()";
    "Fxn:check_error(cudart().cudaDeviceGetStreamPriorityRange(";
    "Fxn:ctypes.byref(least_priority),";
    "Fxn:ctypes.byref(greatest_priority)))";
    "Fxn:priority";
    "Fxn:ctypes.c_int()";
    "Fxn:check_error(cudart().cudaStreamGetPriority(self,";
    "Fxn:ctypes.byref(priority)))";
    "Fxn:_as_parameter_";
    "Fxn:ctypes.c_void_p(self.cuda_stream)";
    "Fxn:__eq__";
    "Fxn:__hash__";
    "Fxn:__repr__";
    "Fxn:.format(self.device,";
    "class:EventHandle(ctypes.Structure):";
    "class:Event(object):";
    "Fxn:__init__";
    "Fxn:ctypes.c_void_p()";
    "Fxn:cudart()";
    "Fxn:check_error(self._cudart.cudaIpcOpenEventHandle(ctypes.byref(ptr),";
    "Fxn:check_error(self._cudart.cudaEventCreateWithFlags(ctypes.byref(ptr),";
    "Fxn:ctypes.c_uint(flags)))";
    "Fxn:__del__";
    "Fxn:check_error(self._cudart.cudaEventDestroy(self._as_parameter_))";
    "Fxn:record";
    "Fxn:torch.cuda.current_stream()";
    "Fxn:stream.record_event(self)";
    "Fxn:wait";
    "Fxn:torch.cuda.current_stream()";
    "Fxn:stream.wait_event(self)";
    "Fxn:query";
    "Fxn:cudart().cudaEventQuery(self)";
    "Fxn:check_error(res)";
    "Fxn:elapsed_time";
    "Fxn:ctypes.c_float()";
    "Fxn:check_error(cudart().cudaEventElapsedTime(";
    "Fxn:ctypes.byref(time_ms),";
    "Fxn:synchronize";
    "Fxn:check_error(cudart().cudaEventSynchronize(self))";
    "Fxn:ipc_handle";
    "Fxn:EventHandle()";
    "Fxn:check_error(cudart().cudaIpcGetEventHandle(ctypes.byref(handle),";
    "Fxn:__repr__";
    "Fxn:{0:#x}>'.format(self._as_parameter_.value)";
    "/torch/cuda/__init__.py";
    "Import:it,";
    "Import:contextlib";
    "Import:platform";
    "Import:ctypes";
    "Import:import";
    "Import:torch";
    "Import:traceback";
    "Import:warnings";
    "Import:raise_from";
    "Import:Popen,";
    "Import:register_after_fork";
    "Fxn:find_cuda_windows_lib";
    "Fxn:is_available";
    "Fxn:_sleep";
    "Fxn:_load_cudart";
    "Fxn:_check_driver";
    "Fxn:_check_capability";
    "Fxn:_lazy_call";
    "class:DeferredCudaCallError(Exception):";
    "Fxn:init";
    "Fxn:_lazy_init()";
    "Fxn:_lazy_init";
    "Fxn:RuntimeError(";
    "Fxn:_check_driver()";
    "Fxn:torch._C._cuda_init()";
    "Fxn:_load_cudart()";
    "Fxn:os.getpid()";
    "Fxn:_lazy_init()";
    "Fxn:queued_call()";
    "Fxn:at:\n\n{}").format(str(e),";
    "Fxn:raise_from(DeferredCudaCallError(msg),";
    "Fxn:_after_fork";
    "Fxn:os.getpid():";
    "Fxn:_register_after_fork(_after_fork,";
    "Fxn:cudart";
    "Fxn:_lazy_init()";
    "Import:version_info";
    "class:cudaStatus(object):";
    "class:CudaError(RuntimeError):";
    "Fxn:__init__";
    "Fxn:cudart().cudaGetErrorString(code).decode('utf-8')";
    "Fxn:self).__init__('{0}";
    "Fxn:check_error";
    "Fxn:CudaError(res)";
    "class:device(object):";
    "Fxn:__init__";
    "Fxn:__enter__";
    "Fxn:torch._C._cuda_getDevice()";
    "Fxn:torch._C._cuda_setDevice(self.idx)";
    "Fxn:_lazy_init()";
    "Fxn:__exit__";
    "Fxn:torch._C._cuda_setDevice(self.prev_idx)";
    "class:device_of(device):";
    "Fxn:__init__";
    "Fxn:obj.get_device()";
    "Fxn:self).__init__(idx)";
    "Fxn:set_device";
    "Fxn:torch._C._cuda_setDevice(device)";
    "Fxn:get_device_name";
    "Fxn:torch._C._cuda_getDeviceName(device)";
    "Fxn:get_device_capability";
    "Fxn:torch._C._cuda_getDeviceCapability(device)";
    "Fxn:get_device_properties";
    "Fxn:init()";
    "Fxn:device_count():";
    "Fxn:AssertionError("Invalid";
    "Fxn:_get_device_properties(device)";
    "Fxn:stream";
    "Fxn:current_stream()";
    "Fxn:torch._C._cuda_setStream(stream._cdata)";
    "Fxn:torch._C._cuda_setStream(prev_stream._cdata)";
    "Fxn:device_count";
    "Fxn:is_available():";
    "Fxn:torch._C._cuda_getDeviceCount()";
    "Fxn:current_device";
    "Fxn:_lazy_init()";
    "Fxn:torch._C._cuda_getDevice()";
    "Fxn:synchronize";
    "Fxn:_lazy_init()";
    "Fxn:torch._C._cuda_synchronize()";
    "Fxn:current_stream";
    "Fxn:_lazy_init()";
    "Fxn:torch.cuda.Stream(_cdata=torch._C._cuda_getCurrentStream())";
    "Fxn:current_blas_handle";
    "Fxn:_lazy_init()";
    "Fxn:torch._C._cuda_getCurrentBlasHandle()";
    "Fxn:empty_cache";
    "Fxn:torch._C._cuda_emptyCache()";
    "Fxn:memory_allocated";
    "Fxn:current_device()";
    "Fxn:torch._C._cuda_memoryAllocated(device)";
    "Fxn:max_memory_allocated";
    "Fxn:current_device()";
    "Fxn:torch._C._cuda_maxMemoryAllocated(device)";
    "Fxn:memory_cached";
    "Fxn:current_device()";
    "Fxn:torch._C._cuda_memoryCached(device)";
    "Fxn:max_memory_cached";
    "Fxn:current_device()";
    "Fxn:torch._C._cuda_maxMemoryCached(device)";
    "Fxn:_host_allocator";
    "Fxn:_lazy_init()";
    "Fxn:torch._C._cuda_cudaHostAllocator()";
    "Fxn:_free_mutex";
    "Fxn:torch._C._cuda_lock_mutex()";
    "Fxn:torch._C._cuda_unlock_mutex()";
    "Fxn:_dummy_type";
    "Fxn:init_err";
    "Fxn:RuntimeError(";
    "Import:################################################################################";
    "Import:_StorageBase";
    "class:{}".format(class_name))";
    "Fxn:_lazy_new";
    "Fxn:_lazy_init()";
    "Fxn:cls).__new__(cls,";
    "class:_CudaBase(object):";
    "Fxn:type";
    "Fxn:device(self.get_device()):";
    "Fxn:self).type(*args,";
    "class:DoubleStorage(_CudaBase,";
    "class:FloatStorage(_CudaBase,";
    "class:LongStorage(_CudaBase,";
    "class:IntStorage(_CudaBase,";
    "class:ShortStorage(_CudaBase,";
    "class:CharStorage(_CudaBase,";
    "class:ByteStorage(_CudaBase,";
    "class:HalfStorage(_CudaBase,";
    "Import:sparse";
    "Import:profiler";
    "Import:nvtx";
    "Import:Stream,";
    "/torch/distributed/launch.py";
    "Import:argparse";
    "Import:subprocess";
    "Import:import";
    "Import:socket";
    "Import:ArgumentParser,";
    "Import:torch";
    "Fxn:parse_args";
    "/torch/distributed/remote_types.py";
    "Import:torch";
    "Import:_StorageBase";
    "class:_DistributedBase(object):";
    "class:DoubleStorage(_DistributedBase,";
    "class:FloatStorage(_DistributedBase,";
    "class:LongStorage(_DistributedBase,";
    "class:IntStorage(_DistributedBase,";
    "class:ShortStorage(_DistributedBase,";
    "class:CharStorage(_DistributedBase,";
    "class:ByteStorage(_DistributedBase,";
    "class:HalfStorage(_DistributedBase,";
    "/torch/distributed/__init__.py";
    "Import:torch";
    "Import:atexit";
    "Import:warnings";
    "Import:_flatten_dense_tensors,";
    "Fxn:_extend_scope";
    "Fxn:is_available";
    "Fxn:destroy_process_group";
    "Fxn:is_initialized";
    "Fxn:init_process_group";
    "Fxn:init_master_worker";
    "Import:torch.distributed.collectives";
    "Import:torch.distributed.remote_types";
    "class:reduce_op(object):";
    "class:group(object):";
    "class:_DistributedRequest(object):";
    "Fxn:__init__";
    "Fxn:is_completed";
    "Fxn:torch._C._dist_request_is_completed(self.request)";
    "Fxn:wait";
    "Fxn:torch._C._dist_request_wait(self.request)";
    "Fxn:get_rank";
    "Fxn:torch._C._dist_get_rank()";
    "Fxn:get_world_size";
    "Fxn:torch._C._dist_get_num_processes()";
    "Fxn:isend";
    "Fxn:_DistributedRequest(torch._C._dist_isend(tensor,";
    "Fxn:irecv";
    "Fxn:_DistributedRequest(torch._C._dist_irecv(tensor,";
    "Fxn:send";
    "Fxn:torch._C._dist_send(tensor,";
    "Fxn:recv";
    "Fxn:torch._C._dist_recv_any_source(tensor)";
    "Fxn:torch._C._dist_recv(tensor,";
    "Fxn:broadcast_multigpu";
    "Fxn:torch._C._dist_broadcast_multigpu(tensor_list,";
    "Fxn:broadcast";
    "Fxn:torch._C._dist_broadcast(tensor,";
    "Fxn:all_reduce_multigpu";
    "Fxn:torch._C._dist_all_reduce_multigpu(tensor_list,";
    "Fxn:all_reduce";
    "Fxn:torch._C._dist_all_reduce(tensor,";
    "Fxn:reduce_multigpu";
    "Fxn:torch._C._dist_reduce_multigpu(tensor_list,";
    "Fxn:reduce";
    "Fxn:torch._C._dist_reduce(tensor,";
    "Fxn:all_gather_multigpu";
    "Fxn:tensors(on";
    "Fxn:flatten_tensor_list.append(_flatten_dense_tensors(output_tensor_list))";
    "Fxn:torch._C._dist_all_gather_multigpu(flatten_tensor_list,";
    "Fxn:_unflatten_dense_tensors(flatten_tensor,";
    "Fxn:tensor.copy_(value)";
    "Fxn:all_gather";
    "Fxn:torch._C._dist_all_gather(tensor_list,";
    "Fxn:all_gather_multigpu([tensor_list],";
    "Fxn:gather";
    "Fxn:get_rank()";
    "Fxn:kwargs.pop('dst',";
    "Fxn:kwargs.pop('gather_list',";
    "Fxn:kwargs.pop('group',";
    "Fxn:RuntimeError("got";
    "Fxn:RuntimeError("gather_list";
    "Fxn:torch._C._dist_gather_recv(gather_list,";
    "Fxn:RuntimeError("non-empty";
    "Fxn:torch._C._dist_gather_send(tensor,";
    "Fxn:scatter";
    "Fxn:get_rank()";
    "Fxn:kwargs.pop('src',";
    "Fxn:kwargs.pop('scatter_list',";
    "Fxn:kwargs.pop('group',";
    "Fxn:RuntimeError("got";
    "Fxn:RuntimeError("scatter_list";
    "Fxn:torch._C._dist_scatter_send(scatter_list,";
    "Fxn:RuntimeError("non-empty";
    "Fxn:torch._C._dist_scatter_recv(tensor,";
    "Fxn:barrier";
    "Fxn:torch._C._dist_barrier(group)";
    "Fxn:new_group";
    "Fxn:torch._C._dist_new_group(ranks)";
    "Fxn:_clear_group_cache";
    "Fxn:torch._C._dist_clear_group_cache(group)";
    "Fxn:_register_stream";
    "Fxn:RuntimeError("torch.distributed";
    "Fxn:torch._C._dist_register_stream(stream)";
    "/torch/distributions/bernoulli.py";
    "Import:Number";
    "Import:torch";
    "Import:Variable";
    "Import:constraints";
    "Import:ExponentialFamily";
    "Import:broadcast_all,";
    "Import:binary_cross_entropy_with_logits";
    "class:Bernoulli(ExponentialFamily):";
    "Fxn:__init__";
    "Fxn:ValueError("Either";
    "Fxn:broadcast_all(probs)";
    "Fxn:broadcast_all(logits)";
    "Fxn:torch.Size()";
    "Fxn:self._param.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:_new";
    "Fxn:self._param.new(*args,";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:logits";
    "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs";
    "Fxn:logits_to_probs(self.logits,";
    "Fxn:param_shape";
    "Fxn:self._param.size()";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:torch.no_grad():";
    "Fxn:torch.bernoulli(self.probs.expand(shape))";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:broadcast_all(self.logits,";
    "Fxn:-binary_cross_entropy_with_logits(logits,";
    "Fxn:entropy";
    "Fxn:binary_cross_entropy_with_logits(self.logits,";
    "Fxn:enumerate_support";
    "Fxn:self._new((2,))";
    "Fxn:torch.arange(2,";
    "Fxn:values.view((-1,)";
    "Fxn:values.expand((-1,)";
    "Fxn:_natural_params";
    "Fxn:_log_normalizer";
    "Fxn:torch.log(1";
    "Fxn:torch.exp(x))";
    "/torch/distributions/beta.py";
    "Import:Number";
    "Import:torch";
    "Import:constraints";
    "Import:Dirichlet";
    "Import:ExponentialFamily";
    "Import:broadcast_all";
    "class:Beta(ExponentialFamily):";
    "Fxn:__init__";
    "Fxn:torch.tensor([concentration1,";
    "Fxn:broadcast_all(concentration1,";
    "Fxn:torch.stack([concentration1,";
    "Fxn:Dirichlet(concentration1_concentration0)";
    "Fxn:self).__init__(self._dirichlet._batch_shape,";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:rsample";
    "Fxn:sample_shape=()):";
    "Fxn:self._dirichlet.rsample(sample_shape).select(-1,";
    "Fxn:self._dirichlet.concentration.new([value])";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.stack([value,";
    "Fxn:self._dirichlet.log_prob(heads_tails)";
    "Fxn:entropy";
    "Fxn:self._dirichlet.entropy()";
    "Fxn:concentration1";
    "Fxn:torch.Tensor([result])";
    "Fxn:concentration0";
    "Fxn:torch.Tensor([result])";
    "Fxn:_natural_params";
    "Fxn:_log_normalizer";
    "Fxn:torch.lgamma(x)";
    "Fxn:torch.lgamma(y)";
    "Fxn:torch.lgamma(x";
    "/torch/distributions/binomial.py";
    "Import:Number";
    "Import:torch";
    "Import:math";
    "Import:variable,";
    "Import:constraints";
    "Import:Distribution";
    "Import:broadcast_all,";
    "Import:clamp_probs";
    "class:Binomial(Distribution):";
    "Fxn:__init__";
    "Fxn:NotImplementedError('inhomogeneous";
    "Fxn:ValueError("Either";
    "Fxn:broadcast_all(probs)";
    "Fxn:broadcast_all(logits)";
    "Fxn:torch.Size()";
    "Fxn:self._param.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:_new";
    "Fxn:self._param.new(*args,";
    "Fxn:support";
    "Fxn:constraints.integer_interval(0,";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:logits";
    "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs";
    "Fxn:logits_to_probs(self.logits,";
    "Fxn:param_shape";
    "Fxn:self._param.size()";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:torch.no_grad():";
    "Fxn:torch.bernoulli(self.probs.unsqueeze(-1).expand(shape)).sum(dim=-1)";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:math.lgamma(self.total_count";
    "Fxn:torch.lgamma(value";
    "Fxn:torch.lgamma(self.total_count";
    "Fxn:torch.log1p(-self.probs))";
    "Fxn:torch.log1p((self.logits";
    "Fxn:max_val).exp()))";
    "Fxn:torch.log1p((self.logits";
    "Fxn:max_val).exp()))";
    "Fxn:enumerate_support";
    "Fxn:self._new((self.total_count,))";
    "Fxn:torch.arange(self.total_count,";
    "Fxn:values.view((-1,)";
    "Fxn:values.expand((-1,)";
    "/torch/distributions/categorical.py";
    "Import:torch";
    "Import:Variable,";
    "Import:constraints";
    "Import:Distribution";
    "Import:probs_to_logits,";
    "class:Categorical(Distribution):";
    "Fxn:__init__";
    "Fxn:ValueError("Either";
    "Fxn:probs.sum(-1,";
    "Fxn:log_sum_exp(logits)";
    "Fxn:self._param.size()[-1]";
    "Fxn:self._param.size()[:-1]";
    "Fxn:self._param.ndimension()";
    "Fxn:torch.Size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:_new";
    "Fxn:self._param.new(*args,";
    "Fxn:support";
    "Fxn:constraints.integer_interval(0,";
    "Fxn:logits";
    "Fxn:probs_to_logits(self.probs)";
    "Fxn:probs";
    "Fxn:logits_to_probs(self.logits)";
    "Fxn:param_shape";
    "Fxn:self._param.size()";
    "Fxn:mean";
    "Fxn:self.probs.new_tensor(float('nan')).expand(self._extended_shape())";
    "Fxn:variance";
    "Fxn:self.probs.new_tensor(float('nan')).expand(self._extended_shape())";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:torch.Size((self._num_events,))";
    "Fxn:self.probs.expand(param_shape)";
    "Fxn:self.probs.dim()";
    "Fxn:self.probs.size(0)";
    "Fxn:probs.view(-1,";
    "Fxn:probs.contiguous().view(-1,";
    "Fxn:torch.multinomial(probs_2d,";
    "Fxn:sample_2d.contiguous().view(sample_shape)";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch._C._infer_size(value.size(),";
    "Fxn:value.size()";
    "Fxn:value.expand(value_shape)";
    "Fxn:self.logits.expand(param_shape)";
    "Fxn:log_pmf.gather(-1,";
    "Fxn:value.unsqueeze(-1).long()).squeeze(-1)";
    "Fxn:entropy";
    "Fxn:-p_log_p.sum(-1)";
    "Fxn:enumerate_support";
    "Fxn:torch.arange(num_events).long()";
    "Fxn:values.view((-1,)";
    "Fxn:values.expand((-1,)";
    "Fxn:values.cuda(self._param.get_device())";
    "Fxn:Variable(values)";
    "/torch/distributions/cauchy.py";
    "Import:math";
    "Import:Number";
    "Import:torch";
    "Import:constraints";
    "Import:Distribution";
    "Import:broadcast_all";
    "class:Cauchy(Distribution):";
    "Fxn:__init__";
    "Fxn:broadcast_all(loc,";
    "Fxn:torch.Size()";
    "Fxn:self.loc.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:mean";
    "Fxn:self.loc.new([float('nan')]).expand(self._extended_shape())";
    "Fxn:variance";
    "Fxn:self.loc.new([float('inf')]).expand(self._extended_shape())";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:self.loc.new(shape).cauchy_()";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:-math.log(math.pi)";
    "Fxn:self.scale.log()";
    "Fxn:self.scale)**2).log()";
    "Fxn:cdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.atan((value";
    "Fxn:icdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.tan(math.pi";
    "Fxn:entropy";
    "Fxn:math.log(4";
    "Fxn:self.scale.log()";
    "/torch/distributions/chi2.py";
    "Import:constraints";
    "Import:Gamma";
    "class:Chi2(Gamma):";
    "Fxn:__init__";
    "Fxn:self).__init__(0.5";
    "Fxn:df";
    "/torch/distributions/constraints.py";
    "Import:torch";
    "class:Constraint(object):";
    "Fxn:check";
    "class:_Dependent(Constraint):";
    "Fxn:check";
    "Fxn:ValueError('Cannot";
    "Fxn:is_dependent";
    "class:_DependentProperty(property,";
    "class:Uniform(Distribution):";
    "Fxn:__init__";
    "Fxn:support";
    "Fxn:constraints.interval(self.low,";
    "class:_Boolean(Constraint):";
    "Fxn:check";
    "class:_IntegerInterval(Constraint):";
    "Fxn:__init__";
    "Fxn:check";
    "class:_IntegerLessThan(Constraint):";
    "Fxn:__init__";
    "Fxn:check";
    "class:_IntegerGreaterThan(Constraint):";
    "Fxn:__init__";
    "Fxn:check";
    "class:_Real(Constraint):";
    "Fxn:check";
    "class:_GreaterThan(Constraint):";
    "Fxn:__init__";
    "Fxn:check";
    "class:_LessThan(Constraint):";
    "Fxn:__init__";
    "Fxn:check";
    "class:_Interval(Constraint):";
    "Fxn:__init__";
    "Fxn:check";
    "class:_Simplex(Constraint):";
    "Fxn:check";
    "Fxn:0).all()";
    "Fxn:1).abs()";
    "Fxn:1e-6).all()";
    "class:_LowerTriangular(Constraint):";
    "Fxn:check";
    "Fxn:value).min(-1)[0].min(-1)[0]";
    "class:_LowerCholesky(Constraint):";
    "Fxn:check";
    "Fxn:value.size(-1)";
    "Fxn:torch.eye(n,";
    "Fxn:out=value.new(n,";
    "Fxn:value).min(-1)[0].min(-1)[0]";
    "Fxn:1)).min(-1)[0].min(-1)[0]";
    "Fxn:_Dependent()";
    "Fxn:_Boolean()";
    "Fxn:_IntegerGreaterThan(0)";
    "Fxn:_IntegerGreaterThan(1)";
    "Fxn:_Real()";
    "Fxn:_GreaterThan(0)";
    "Fxn:_Interval(0,";
    "Fxn:_Simplex()";
    "Fxn:_LowerTriangular()";
    "Fxn:_LowerCholesky()";
    "/torch/distributions/constraint_registry.py";
    "Fxn:my_factory";
    "Import:constraints,";
    "class:ConstraintRegistry(object):";
    "Fxn:__init__";
    "Fxn:register";
    "Fxn:@my_registry.register(MyConstraintClass)";
    "Fxn:construct_transform";
    "Fxn:MyTransform(constraint.params)";
    "Fxn:my_registry.register(my_constraint_singleton,";
    "Fxn:MyTransform())";
    "Fxn:self.register(constraint,";
    "Fxn:TypeError('Expected";
    "Fxn:{}'.format(constraint))";
    "Fxn:__call__";
    "Fxn:transform_to(constraint)(torch.zeros(1))";
    "Fxn:transform_to(constraint).inv(scale)";
    "Fxn:self._registry[type(constraint)]";
    "Fxn:NotImplementedError(";
    "Fxn:constraints'.format(type(constraint).__name__))";
    "Fxn:factory(constraint)";
    "Fxn:ConstraintRegistry()";
    "Fxn:ConstraintRegistry()";
    "Fxn:biject_to.register(constraints.real,";
    "Fxn:transform_to.register(constraints.real,";
    "Fxn:biject_to.register(constraints.positive,";
    "Fxn:transforms.ExpTransform())";
    "Fxn:transform_to.register(constraints.positive,";
    "Fxn:transforms.ExpTransform())";
    "Fxn:@biject_to.register(constraints.greater_than)";
    "Fxn:@transform_to.register(constraints.greater_than)";
    "Fxn:_transform_to_greater_than";
    "Fxn:loc.new([1]).expand_as(loc)";
    "Fxn:transforms.ComposeTransform([transforms.ExpTransform(),";
    "Fxn:transforms.AffineTransform(loc,";
    "Fxn:@biject_to.register(constraints.less_than)";
    "Fxn:@transform_to.register(constraints.less_than)";
    "Fxn:_transform_to_less_than";
    "Fxn:loc.new([-1]).expand_as(loc)";
    "Fxn:transforms.ComposeTransform([transforms.ExpTransform(),";
    "Fxn:transforms.AffineTransform(loc,";
    "Fxn:biject_to.register(constraints.unit_interval,";
    "Fxn:transforms.SigmoidTransform())";
    "Fxn:transform_to.register(constraints.unit_interval,";
    "Fxn:transforms.SigmoidTransform())";
    "Fxn:@biject_to.register(constraints.interval)";
    "Fxn:@transform_to.register(constraints.interval)";
    "Fxn:_transform_to_interval";
    "Fxn:transforms.ComposeTransform([transforms.SigmoidTransform(),";
    "Fxn:transforms.AffineTransform(loc,";
    "Fxn:biject_to.register(constraints.simplex,";
    "Fxn:transforms.StickBreakingTransform())";
    "Fxn:transform_to.register(constraints.simplex,";
    "Fxn:transforms.BoltzmannTransform())";
    "Fxn:transform_to.register(constraints.lower_cholesky,";
    "Fxn:transforms.LowerCholeskyTransform())";
    "/torch/distributions/dirichlet.py";
    "Import:Number";
    "Import:torch";
    "Import:Function,";
    "Import:once_differentiable";
    "Import:constraints";
    "Import:ExponentialFamily";
    "Import:_finfo,";
    "Fxn:_dirichlet_sample_nograd";
    "Fxn:_Dirichlet_backward";
    "class:_Dirichlet(Function):";
    "Fxn:forward";
    "Fxn:_dirichlet_sample_nograd(concentration)";
    "Fxn:ctx.save_for_backward(x,";
    "Fxn:backward";
    "Fxn:_Dirichlet_backward(x,";
    "class:Dirichlet(ExponentialFamily):";
    "Fxn:__init__";
    "Fxn:broadcast_all(concentration)";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample";
    "Fxn:sample_shape=()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:self.concentration.expand(shape)";
    "Fxn:_Dirichlet.apply(concentration)";
    "Fxn:_dirichlet_sample_nograd(concentration)";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:1.0)).sum(-1)";
    "Fxn:torch.lgamma(self.concentration.sum(-1))";
    "Fxn:torch.lgamma(self.concentration).sum(-1))";
    "Fxn:mean";
    "Fxn:self.concentration.sum(-1)";
    "Fxn:variance";
    "Fxn:self.concentration.sum(-1)";
    "Fxn:entropy";
    "Fxn:self.concentration.size(-1)";
    "Fxn:self.concentration.sum(-1)";
    "Fxn:torch.lgamma(a0)";
    "Fxn:torch.digamma(a0)";
    "Fxn:torch.digamma(self.concentration)).sum(-1))";
    "Fxn:_natural_params";
    "Fxn:_log_normalizer";
    "Fxn:x.lgamma().sum(-1)";
    "Fxn:torch.lgamma(x.sum(-1))";
    "/torch/distributions/distribution.py";
    "Import:torch";
    "Import:Variable";
    "Import:warnings";
    "Import:constraints";
    "class:Distribution(object):";
    "Fxn:set_default_validate_args";
    "Fxn:__init__";
    "Fxn:batch_shape=torch.Size(),";
    "Fxn:event_shape=torch.Size(),";
    "Fxn:constraints.is_dependent(self.params):";
    "Fxn:self.params.items():";
    "Fxn:constraints.is_dependent(constraint):";
    "Fxn:constraint.check(self.__getattribute__(param)).all():";
    "Fxn:ValueError("The";
    "Fxn:values".format(param))";
    "Fxn:batch_shape";
    "Fxn:event_shape";
    "Fxn:params";
    "Fxn:support";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:stddev";
    "Fxn:self.variance.sqrt()";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:torch.no_grad():";
    "Fxn:self.rsample(sample_shape)";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample_n";
    "Fxn:warnings.warn('sample_n";
    "Fxn:.sample((n,))";
    "Fxn:self.sample(torch.Size((n,)))";
    "Fxn:log_prob";
    "Fxn:cdf";
    "Fxn:icdf";
    "Fxn:enumerate_support";
    "Fxn:`(cardinality,)";
    "Fxn:`itertools.product(m.enumerate_support())`.";
    "Fxn:entropy";
    "Fxn:_extended_shape";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:torch.Size(sample_shape";
    "Fxn:_validate_sample";
    "Fxn:ValueError('The";
    "Fxn:value.size()[event_dim_start:]";
    "Fxn:ValueError('The";
    "Fxn:value.size()";
    "Fxn:ValueError('Value";
    "Fxn:self.support.check(value).all():";
    "Fxn:ValueError('The";
    "Fxn:__repr__";
    "Fxn:'()'";
    "/torch/distributions/exponential.py";
    "Import:Number";
    "Import:torch";
    "Import:constraints";
    "Import:ExponentialFamily";
    "Import:broadcast_all";
    "class:Exponential(ExponentialFamily):";
    "Fxn:mean";
    "Fxn:self.rate.reciprocal()";
    "Fxn:stddev";
    "Fxn:self.rate.reciprocal()";
    "Fxn:variance";
    "Fxn:self.rate.pow(-2)";
    "Fxn:__init__";
    "Fxn:broadcast_all(rate)";
    "Fxn:torch.Size()";
    "Fxn:self.rate.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:self.rate.new(shape).exponential_()";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:self.rate.log()";
    "Fxn:cdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.exp(-self.rate";
    "Fxn:icdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:-torch.log(1";
    "Fxn:entropy";
    "Fxn:torch.log(self.rate)";
    "Fxn:_natural_params";
    "Fxn:_log_normalizer";
    "Fxn:-torch.log(-x)";
    "/torch/distributions/exp_family.py";
    "Import:torch";
    "Import:Distribution";
    "Import:Variable";
    "class:ExponentialFamily(Distribution):";
    "Fxn:_natural_params";
    "Fxn:_log_normalizer";
    "Fxn:_mean_carrier_measure";
    "Fxn:entropy";
    "Fxn:[Variable(p.data,";
    "Fxn:self._log_normalizer(*nparams)";
    "Fxn:torch.autograd.grad(lg_normal.sum(),";
    "Fxn:lg_normal.clone()";
    "/torch/distributions/fishersnedecor.py";
    "Import:Number";
    "Import:torch";
    "Import:math";
    "Import:constraints";
    "Import:Distribution";
    "Import:Gamma";
    "Import:broadcast_all,";
    "class:FisherSnedecor(Distribution):";
    "Fxn:__init__";
    "Fxn:broadcast_all(df1,";
    "Fxn:Gamma(self.df1";
    "Fxn:Gamma(self.df2";
    "Fxn:torch.Size()";
    "Fxn:self.df1.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:mean";
    "Fxn:self.df2.clone()";
    "Fxn:variance";
    "Fxn:self.df2.clone()";
    "Fxn:df2.pow(2)";
    "Fxn:2).pow(2)";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size(())):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:Gamma(df1";
    "Fxn:Gamma(df2";
    "Fxn:F(df1,";
    "Fxn:self._gamma1.rsample(sample_shape).view(shape)";
    "Fxn:self._gamma2.rsample(sample_shape).view(shape)";
    "Fxn:X2.clamp_(min=_finfo(X2).tiny)";
    "Fxn:Y.clamp_(min=_finfo(X2).tiny)";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:ct2).lgamma()";
    "Fxn:ct1.lgamma()";
    "Fxn:ct2.lgamma()";
    "Fxn:ct3.log()";
    "Fxn:torch.log(value)";
    "Fxn:torch.log1p(ct3";
    "/torch/distributions/gamma.py";
    "Import:Number";
    "Import:torch";
    "Import:Function,";
    "Import:once_differentiable";
    "Import:constraints";
    "Import:ExponentialFamily";
    "Import:_finfo,";
    "Fxn:_standard_gamma";
    "class:Gamma(ExponentialFamily):";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:self.rate.pow(2)";
    "Fxn:__init__";
    "Fxn:broadcast_all(concentration,";
    "Fxn:torch.Size()";
    "Fxn:self.concentration.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:_standard_gamma(self.concentration.expand(shape))";
    "Fxn:self.rate.expand(shape)";
    "Fxn:data.clamp_(min=_finfo(value).tiny)";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.log(self.rate)";
    "Fxn:torch.log(value)";
    "Fxn:torch.lgamma(self.concentration))";
    "Fxn:entropy";
    "Fxn:torch.log(self.rate)";
    "Fxn:torch.lgamma(self.concentration)";
    "Fxn:torch.digamma(self.concentration))";
    "Fxn:_natural_params";
    "Fxn:_log_normalizer";
    "Fxn:torch.lgamma(x";
    "Fxn:torch.log(-y.reciprocal())";
    "/torch/distributions/geometric.py";
    "Import:Number";
    "Import:torch";
    "Import:constraints";
    "Import:Distribution";
    "Import:broadcast_all,";
    "Import:binary_cross_entropy_with_logits";
    "class:Geometric(Distribution):";
    "Fxn:__init__";
    "Fxn:ValueError("Either";
    "Fxn:broadcast_all(probs)";
    "Fxn:self.probs.gt(0).all():";
    "Fxn:ValueError('All";
    "Fxn:broadcast_all(logits)";
    "Fxn:torch.Size()";
    "Fxn:probs_or_logits.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:logits";
    "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs";
    "Fxn:logits_to_probs(self.logits,";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:torch.no_grad():";
    "Fxn:self.probs.new(shape).uniform_(_finfo(self.probs).tiny,";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:broadcast_all(value,";
    "Fxn:self.probs.clone())";
    "Fxn:probs[(probs";
    "Fxn:self.probs.log()";
    "Fxn:entropy";
    "Fxn:binary_cross_entropy_with_logits(self.logits,";
    "/torch/distributions/gumbel.py";
    "Import:Number";
    "Import:math";
    "Import:torch";
    "Import:constraints";
    "Import:Uniform";
    "Import:TransformedDistribution";
    "Import:AffineTransform,";
    "Import:_finfo,";
    "class:Gumbel(TransformedDistribution):";
    "Fxn:__init__";
    "Fxn:broadcast_all(loc,";
    "Fxn:_finfo(self.loc)";
    "Fxn:torch.Size()";
    "Fxn:Uniform(finfo.tiny,";
    "Fxn:self.scale.size()";
    "Fxn:Uniform(self.loc.new(self.loc.size()).fill_(finfo.tiny),";
    "Fxn:[ExpTransform().inv,";
    "Fxn:AffineTransform(loc=0,";
    "Fxn:scale=-torch.ones_like(self.scale)),";
    "Fxn:ExpTransform().inv,";
    "Fxn:AffineTransform(loc=loc,";
    "Fxn:self).__init__(base_dist,";
    "Fxn:mean";
    "Fxn:stddev";
    "Fxn:math.sqrt(6))";
    "Fxn:variance";
    "Fxn:self.stddev.pow(2)";
    "Fxn:entropy";
    "Fxn:self.scale.log()";
    "/torch/distributions/kl.py";
    "Import:math";
    "Import:warnings";
    "Import:total_ordering";
    "Import:torch";
    "Import:Bernoulli";
    "Import:Beta";
    "Import:Binomial";
    "Import:Categorical";
    "Import:Dirichlet";
    "Import:Distribution";
    "Import:Exponential";
    "Import:ExponentialFamily";
    "Import:Gamma";
    "Import:Geometric";
    "Import:Gumbel";
    "Import:Laplace";
    "Import:LogNormal";
    "Import:Normal";
    "Import:OneHotCategorical";
    "Import:Pareto";
    "Import:Poisson";
    "Import:TransformedDistribution";
    "Import:Uniform";
    "Import:_sum_rightmost";
    "Import:Variable,";
    "Fxn:register_kl";
    "Fxn:kl_normal_normal";
    "Fxn:kl_version1";
    "Fxn:kl_version2";
    "Fxn:decorator";
    "class:_Match(object):";
    "Fxn:__init__";
    "Fxn:__eq__";
    "Fxn:__le__";
    "Fxn:_dispatch_kl";
    "Fxn:[(super_p,";
    "Fxn:warnings.warn('Ambiguous";
    "Fxn:kl_divergence({},";
    "Fxn:register_kl({},";
    "Fxn:{})'.format(";
    "Fxn:_infinite_like";
    "Fxn:tensor.new_tensor(float('inf')).expand_as(tensor)";
    "Fxn:tensor.new([float('inf')]).expand_as(tensor)";
    "Fxn:_x_log_x";
    "Fxn:tensor.log()";
    "Fxn:kl_divergence";
    "Fxn::math:`KL(p";
    "Fxn:KL(p";
    "Fxn:p(x)";
    "Fxn:{p(x)}";
    "Fxn:{q(x)}";
    "Fxn:_KL_MEMOIZE[type(p),";
    "Fxn:_dispatch_kl(type(p),";
    "Fxn:_KL_MEMOIZE[type(p),";
    "Fxn:fun(p,";
    "Fxn:@register_kl(Bernoulli,";
    "Fxn:_kl_bernoulli_bernoulli";
    "Fxn:q.probs).log()";
    "Fxn:q.probs)).log()";
    "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_beta";
    "Fxn:q.concentration1.lgamma()";
    "Fxn:q.concentration0.lgamma()";
    "Fxn:p.concentration1.lgamma()";
    "Fxn:p.concentration0.lgamma()";
    "Fxn:torch.digamma(p.concentration1)";
    "Fxn:torch.digamma(p.concentration0)";
    "Fxn:torch.digamma(sum_params_p)";
    "Fxn:@register_kl(Binomial,";
    "Fxn:_kl_binomial_binomial";
    "Fxn:_infinite_like(p.probs)";
    "Fxn:NotImplementedError('KL";
    "Fxn:@register_kl(Categorical,";
    "Fxn:_kl_categorical_categorical";
    "Fxn:t.sum(-1)";
    "Fxn:@register_kl(Dirichlet,";
    "Fxn:_kl_dirichlet_dirichlet";
    "Fxn:p.concentration.sum(-1)";
    "Fxn:q.concentration.sum(-1)";
    "Fxn:sum_p_concentration.lgamma()";
    "Fxn:sum_q_concentration.lgamma()";
    "Fxn:q.concentration.lgamma()).sum(-1)";
    "Fxn:p.concentration.digamma()";
    "Fxn:sum_p_concentration.digamma().unsqueeze(-1)";
    "Fxn:t4).sum(-1)";
    "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_exponential";
    "Fxn:-rate_ratio.log()";
    "Fxn:@register_kl(ExponentialFamily,";
    "Fxn:_kl_expfamily_expfamily";
    "Fxn:NotImplementedError("The";
    "Fxn:[Variable(np.data,";
    "Fxn:p._log_normalizer(*p_nparams)";
    "Fxn:torch.autograd.grad(lg_normal.sum(),";
    "Fxn:q._log_normalizer(*q_nparams)";
    "Fxn:lg_normal.clone()";
    "Fxn:_sum_rightmost(term,";
    "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_gamma";
    "Fxn:q.rate).log()";
    "Fxn:torch.lgamma(q.concentration)";
    "Fxn:torch.lgamma(p.concentration)";
    "Fxn:torch.digamma(p.concentration)";
    "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gumbel_gumbel";
    "Fxn:-ct1.log()";
    "Fxn:torch.exp(ct2";
    "Fxn:ct1).lgamma()";
    "Fxn:@register_kl(Geometric,";
    "Fxn:_kl_geometric_geometric";
    "Fxn:-p.entropy()";
    "Fxn:torch.log1p(-q.probs)";
    "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_laplace_laplace";
    "Fxn:q.loc).abs()";
    "Fxn:-scale_ratio.log()";
    "Fxn:torch.exp(-loc_abs_diff";
    "Fxn:@register_kl(Normal,";
    "Fxn:_kl_normal_normal";
    "Fxn:q.scale).pow(2)";
    "Fxn:q.scale).pow(2)";
    "Fxn:var_ratio.log())";
    "Fxn:@register_kl(OneHotCategorical,";
    "Fxn:_kl_onehotcategorical_onehotcategorical";
    "Fxn:_kl_categorical_categorical(p._categorical,";
    "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_pareto";
    "Fxn:scale_ratio.log()";
    "Fxn:-alpha_ratio.log()";
    "Fxn:@register_kl(Poisson,";
    "Fxn:_kl_poisson_poisson";
    "Fxn:q.rate.log())";
    "Fxn:@register_kl(TransformedDistribution,";
    "Fxn:_kl_transformed_transformed";
    "Fxn:kl_divergence(p.base_dist,";
    "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_uniform";
    "Fxn:p.low)).log()";
    "Fxn:result[(q.low";
    "Fxn:@register_kl(Bernoulli,";
    "Fxn:_kl_bernoulli_poisson";
    "Fxn:-p.entropy()";
    "Fxn:q.rate.log()";
    "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_infinity";
    "Fxn:_infinite_like(p.concentration1)";
    "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_exponential";
    "Fxn:-p.entropy()";
    "Fxn:q.rate.log()";
    "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_gamma";
    "Fxn:-p.entropy()";
    "Fxn:q.concentration.lgamma()";
    "Fxn:q.rate.log()";
    "Fxn:p.concentration0).digamma())";
    "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_normal";
    "Fxn:q.scale.pow(2)";
    "Fxn:-p.entropy()";
    "Fxn:math.pi).log()";
    "Fxn:E_beta.pow(2))";
    "Fxn:q.loc.pow(2)";
    "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_uniform";
    "Fxn:-p.entropy()";
    "Fxn:q.low).log()";
    "Fxn:result[(q.low";
    "Fxn:@register_kl(Exponential,";
    "Fxn:@register_kl(Exponential,";
    "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_infinity";
    "Fxn:_infinite_like(p.rate)";
    "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_gamma";
    "Fxn:torch.log(ratio)";
    "Fxn:q.concentration.lgamma()";
    "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_gumbel";
    "Fxn:scale_rate_prod.log()";
    "Fxn:torch.exp(loc_scale_ratio)";
    "Fxn:scale_rate_prod.reciprocal()";
    "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_normal";
    "Fxn:q.scale.pow(2)";
    "Fxn:p.rate.pow(2)";
    "Fxn:torch.log(rate_sqr";
    "Fxn:rate_sqr.reciprocal()";
    "Fxn:q.loc.pow(2)";
    "Fxn:@register_kl(Gamma,";
    "Fxn:@register_kl(Gamma,";
    "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_infinity";
    "Fxn:_infinite_like(p.concentration)";
    "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_exponential";
    "Fxn:-p.entropy()";
    "Fxn:q.rate.log()";
    "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_gumbel";
    "Fxn:p.concentration.digamma()";
    "Fxn:p.concentration.lgamma()";
    "Fxn:beta_scale_prod.log()";
    "Fxn:torch.exp(loc_scale_ratio)";
    "Fxn:beta_scale_prod.reciprocal()).pow(-p.concentration)";
    "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_normal";
    "Fxn:q.scale.pow(2)";
    "Fxn:p.rate.pow(2)";
    "Fxn:torch.log(beta_sqr";
    "Fxn:p.concentration.lgamma()";
    "Fxn:q.loc.pow(2)";
    "Fxn:p.concentration.digamma()";
    "Fxn:@register_kl(Gumbel,";
    "Fxn:@register_kl(Gumbel,";
    "Fxn:@register_kl(Gumbel,";
    "Fxn:@register_kl(Gumbel,";
    "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gumbel_infinity";
    "Fxn:_infinite_like(p.loc)";
    "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gumbel_normal";
    "Fxn:math.sqrt(2";
    "Fxn:math.pi)).log()";
    "Fxn:0.5).pow(2)";
    "Fxn:q.scale).pow(2)";
    "Fxn:@register_kl(Laplace,";
    "Fxn:@register_kl(Laplace,";
    "Fxn:@register_kl(Laplace,";
    "Fxn:@register_kl(Laplace,";
    "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_laplace_infinity";
    "Fxn:_infinite_like(p.loc)";
    "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_laplace_normal";
    "Fxn:q.scale.pow(2)";
    "Fxn:p.scale.pow(2)";
    "Fxn:torch.log(2";
    "Fxn:p.loc.pow(2)";
    "Fxn:q.loc.pow(2)";
    "Fxn:@register_kl(Normal,";
    "Fxn:@register_kl(Normal,";
    "Fxn:@register_kl(Normal,";
    "Fxn:@register_kl(Normal,";
    "Fxn:@register_kl(Normal,";
    "Fxn:_kl_normal_infinity";
    "Fxn:_infinite_like(p.loc)";
    "Fxn:@register_kl(Normal,";
    "Fxn:_kl_normal_gumbel";
    "Fxn:q.scale).pow(2)";
    "Fxn:var_scale_sqr_ratio.log()";
    "Fxn:torch.exp(-mean_scale_ratio";
    "Fxn:math.log(2";
    "Fxn:@register_kl(Pareto,";
    "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_infinity";
    "Fxn:_infinite_like(p.scale)";
    "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_exponential";
    "Fxn:scale_rate_prod).log()";
    "Fxn:p.alpha.reciprocal()";
    "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_gamma";
    "Fxn:p.scale.log()";
    "Fxn:p.alpha.reciprocal()";
    "Fxn:p.alpha.log()";
    "Fxn:q.concentration.lgamma()";
    "Fxn:q.rate.log()";
    "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_normal";
    "Fxn:q.scale.pow(2)";
    "Fxn:p.scale).log()";
    "Fxn:p.alpha.reciprocal()";
    "Fxn:common_term.pow(2)";
    "Fxn:q.loc).pow(2)";
    "Fxn:@register_kl(Poisson,";
    "Fxn:@register_kl(Poisson,";
    "Fxn:_kl_poisson_infinity";
    "Fxn:_infinite_like(p.rate)";
    "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_beta";
    "Fxn:torch.log(common_term)";
    "Fxn:_x_log_x(p.low)";
    "Fxn:_x_log_x((1";
    "Fxn:q.concentration1.lgamma()";
    "Fxn:q.concentration0.lgamma()";
    "Fxn:q.concentration0).lgamma()";
    "Fxn:result[(p.high";
    "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_exponetial";
    "Fxn:q.rate).log()";
    "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_gamma";
    "Fxn:common_term.log()";
    "Fxn:q.concentration.lgamma()";
    "Fxn:q.rate.log()";
    "Fxn:_x_log_x(p.low)";
    "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_gumbel";
    "Fxn:common_term.log()";
    "Fxn:torch.exp(-low_loc_diff))";
    "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_normal";
    "Fxn:common_term).log()";
    "Fxn:2).pow(2)";
    "Fxn:q.scale.pow(2)";
    "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_pareto";
    "Fxn:q.scale.pow(q.alpha)";
    "Fxn:_x_log_x(p.low)";
    "/torch/distributions/laplace.py";
    "Import:Number";
    "Import:torch";
    "Import:constraints";
    "Import:Distribution";
    "Import:_finfo,";
    "class:Laplace(Distribution):";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:self.scale.pow(2)";
    "Fxn:stddev";
    "Fxn:__init__";
    "Fxn:broadcast_all(loc,";
    "Fxn:torch.Size()";
    "Fxn:self.loc.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:self.loc.new(shape).uniform_(_finfo(self.loc).eps";
    "Fxn:self.loc.new(shape).uniform_(self.loc.nextafter(-.5,";
    "Fxn:u.sign()";
    "Fxn:torch.log1p(-u.abs())";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:-torch.log(2";
    "Fxn:torch.abs(value";
    "Fxn:cdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:self.loc).sign()";
    "Fxn:torch.expm1(-(value";
    "Fxn:self.loc).abs()";
    "Fxn:icdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.log1p(-2";
    "Fxn:term.abs())";
    "Fxn:entropy";
    "Fxn:torch.log(2";
    "/torch/distributions/log_normal.py";
    "Import:constraints";
    "Import:ExpTransform";
    "Import:Normal";
    "Import:TransformedDistribution";
    "class:LogNormal(TransformedDistribution):";
    "Fxn:__init__";
    "Fxn:self).__init__(Normal(loc,";
    "Fxn:ExpTransform(),";
    "Fxn:loc";
    "Fxn:scale";
    "Fxn:mean";
    "Fxn:self.scale.pow(2)";
    "Fxn:2).exp()";
    "Fxn:variance";
    "Fxn:self.scale.pow(2)).exp()";
    "Fxn:entropy";
    "Fxn:self.base_dist.entropy()";
    "/torch/distributions/multinomial.py";
    "Import:torch";
    "Import:Distribution";
    "Import:Variable";
    "Import:Categorical";
    "Import:Number";
    "Import:constraints";
    "Import:broadcast_all";
    "class:Multinomial(Distribution):";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:__init__";
    "Fxn:NotImplementedError('inhomogeneous";
    "Fxn:Categorical(probs=probs,";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:_new";
    "Fxn:self._categorical._new(*args,";
    "Fxn:support";
    "Fxn:constraints.integer_interval(0,";
    "Fxn:logits";
    "Fxn:probs";
    "Fxn:param_shape";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:torch.Size(sample_shape)";
    "Fxn:self._categorical.sample(torch.Size((self.total_count,))";
    "Fxn:shifted_idx.append(shifted_idx.pop(0))";
    "Fxn:samples.permute(*shifted_idx)";
    "Fxn:samples.new(self._extended_shape(sample_shape)).zero_()";
    "Fxn:counts.scatter_add_(-1,";
    "Fxn:torch.ones_like(samples))";
    "Fxn:counts.type_as(self.probs)";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:broadcast_all(self.logits.clone(),";
    "Fxn:torch.lgamma(value.sum(-1)";
    "Fxn:torch.lgamma(value";
    "Fxn:1).sum(-1)";
    "Fxn:logits[(value";
    "Fxn:-float('inf'))]";
    "Fxn:value).sum(-1)";
    "/torch/distributions/normal.py";
    "Import:math";
    "Import:Number";
    "Import:torch";
    "Import:constraints";
    "Import:ExponentialFamily";
    "Import:broadcast_all";
    "class:Normal(ExponentialFamily):";
    "Fxn:mean";
    "Fxn:stddev";
    "Fxn:variance";
    "Fxn:self.stddev.pow(2)";
    "Fxn:__init__";
    "Fxn:broadcast_all(loc,";
    "Fxn:torch.Size()";
    "Fxn:self.loc.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:torch.no_grad():";
    "Fxn:torch.normal(self.loc.expand(shape),";
    "Fxn:self.scale.expand(shape))";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:self.loc.new(shape).normal_()";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:math.log(self.scale)";
    "Fxn:self.scale.log()";
    "Fxn:-((value";
    "Fxn:math.log(math.sqrt(2";
    "Fxn:cdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.erf((value";
    "Fxn:self.scale.reciprocal()";
    "Fxn:math.sqrt(2)))";
    "Fxn:icdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:torch.erfinv(2";
    "Fxn:math.sqrt(2)";
    "Fxn:entropy";
    "Fxn:math.log(2";
    "Fxn:torch.log(self.scale)";
    "Fxn:_natural_params";
    "Fxn:self.scale.pow(2),";
    "Fxn:self.scale.pow(2).reciprocal())";
    "Fxn:_log_normalizer";
    "Fxn:x.pow(2)";
    "Fxn:torch.log(-math.pi";
    "/torch/distributions/one_hot_categorical.py";
    "Import:torch";
    "Import:Variable";
    "Import:constraints";
    "Import:Categorical";
    "Import:Distribution";
    "class:OneHotCategorical(Distribution):";
    "Fxn:__init__";
    "Fxn:Categorical(probs,";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:_new";
    "Fxn:self._categorical._new(*args,";
    "Fxn:probs";
    "Fxn:logits";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:param_shape";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:torch.Size(sample_shape)";
    "Fxn:probs.new(self._extended_shape(sample_shape)).zero_()";
    "Fxn:self._categorical.sample(sample_shape)";
    "Fxn:indices.dim()";
    "Fxn:one_hot.dim():";
    "Fxn:indices.unsqueeze(-1)";
    "Fxn:one_hot.scatter_(-1,";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:value.max(-1)[1]";
    "Fxn:self._categorical.log_prob(indices)";
    "Fxn:entropy";
    "Fxn:self._categorical.entropy()";
    "Fxn:enumerate_support";
    "Fxn:self._new((n,";
    "Fxn:torch.eye(n,";
    "Fxn:values.view((n,)";
    "Fxn:values.expand((n,)";
    "/torch/distributions/pareto.py";
    "Import:Number";
    "Import:math";
    "Import:torch";
    "Import:constraints";
    "Import:Exponential";
    "Import:TransformedDistribution";
    "Import:AffineTransform,";
    "Import:broadcast_all";
    "class:Pareto(TransformedDistribution):";
    "Fxn:__init__";
    "Fxn:broadcast_all(scale,";
    "Fxn:Exponential(self.alpha)";
    "Fxn:[ExpTransform(),";
    "Fxn:AffineTransform(loc=0,";
    "Fxn:self).__init__(base_dist,";
    "Fxn:mean";
    "Fxn:self.alpha.clone().clamp(min=1)";
    "Fxn:variance";
    "Fxn:self.alpha.clone().clamp(min=2)";
    "Fxn:self.scale.pow(2)";
    "Fxn:1).pow(2)";
    "Fxn:support";
    "Fxn:constraints.greater_than(self.scale)";
    "Fxn:entropy";
    "Fxn:self.alpha).log()";
    "Fxn:self.alpha.reciprocal()))";
    "/torch/distributions/poisson.py";
    "Import:Number";
    "Import:torch";
    "Import:Variable";
    "Import:constraints";
    "Import:ExponentialFamily";
    "Import:broadcast_all";
    "class:Poisson(ExponentialFamily):";
    "Fxn:mean";
    "Fxn:variance";
    "Fxn:__init__";
    "Fxn:broadcast_all(rate)";
    "Fxn:torch.Size()";
    "Fxn:self.rate.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:torch.no_grad():";
    "Fxn:torch.poisson(self.rate.expand(shape))";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:broadcast_all(self.rate,";
    "Fxn:1).lgamma()";
    "Fxn:_natural_params";
    "Fxn:_log_normalizer";
    "Fxn:torch.exp(x)";
    "/torch/distributions/relaxed_bernoulli.py";
    "Import:torch";
    "Import:Number";
    "Import:Variable";
    "Import:constraints";
    "Import:Distribution";
    "Import:TransformedDistribution";
    "Import:SigmoidTransform";
    "Import:broadcast_all,";
    "class:LogitRelaxedBernoulli(Distribution):";
    "Fxn:__init__";
    "Fxn:ValueError("Either";
    "Fxn:broadcast_all(probs)";
    "Fxn:broadcast_all(logits)";
    "Fxn:torch.Size()";
    "Fxn:self._param.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:_new";
    "Fxn:self._param.new(*args,";
    "Fxn:logits";
    "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs";
    "Fxn:logits_to_probs(self.logits,";
    "Fxn:param_shape";
    "Fxn:self._param.size()";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:clamp_probs(self.probs.expand(shape))";
    "Fxn:clamp_probs(self.probs.new(shape).uniform_())";
    "Fxn:probs.log()";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:broadcast_all(self.logits,";
    "Fxn:value.mul(self.temperature)";
    "Fxn:self.temperature.log()";
    "Fxn:diff.exp().log1p()";
    "class:RelaxedBernoulli(TransformedDistribution):";
    "Fxn:__init__";
    "Fxn:self).__init__(LogitRelaxedBernoulli(temperature,";
    "Fxn:SigmoidTransform(),";
    "Fxn:temperature";
    "Fxn:logits";
    "Fxn:probs";
    "/torch/distributions/relaxed_categorical.py";
    "Import:torch";
    "Import:Variable";
    "Import:constraints";
    "Import:Categorical";
    "Import:clamp_probs,";
    "Import:Distribution";
    "Import:TransformedDistribution";
    "Import:ExpTransform";
    "class:ExpRelaxedCategorical(Distribution):";
    "Fxn:__init__";
    "Fxn:Categorical(probs,";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:_new";
    "Fxn:self._categorical._new(*args,";
    "Fxn:param_shape";
    "Fxn:logits";
    "Fxn:probs";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:torch.Size(sample_shape)";
    "Fxn:clamp_probs(self.logits.new(self._extended_shape(sample_shape)).uniform_())";
    "Fxn:-((-(uniforms.log())).log())";
    "Fxn:log_sum_exp(scores)";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:broadcast_all(self.logits,";
    "Fxn:self.temperature.log().mul(-(K";
    "Fxn:value.mul(self.temperature)";
    "Fxn:log_sum_exp(score)).sum(-1)";
    "class:RelaxedOneHotCategorical(TransformedDistribution):";
    "Fxn:__init__";
    "Fxn:self).__init__(ExpRelaxedCategorical(temperature,";
    "Fxn:ExpTransform(),";
    "Fxn:temperature";
    "Fxn:logits";
    "Fxn:probs";
    "/torch/distributions/studentT.py";
    "Import:Number";
    "Import:torch";
    "Import:math";
    "Import:constraints";
    "Import:Distribution";
    "Import:Chi2";
    "Import:broadcast_all";
    "class:StudentT(Distribution):";
    "Fxn:mean";
    "Fxn:self.loc.clone()";
    "Fxn:variance";
    "Fxn:self.df.clone()";
    "Fxn:2].pow(2)";
    "Fxn:m[(self.df";
    "Fxn:__init__";
    "Fxn:broadcast_all(df,";
    "Fxn:Chi2(df)";
    "Fxn:torch.Size()";
    "Fxn:self.df.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:Normal(0,";
    "Fxn:Chi2(df)";
    "Fxn:StudentT(df)";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:self.df.new(shape).normal_()";
    "Fxn:self._chi2.rsample(sample_shape)";
    "Fxn:torch.rsqrt(Z";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:self.df.log()";
    "Fxn:math.log(math.pi)";
    "Fxn:torch.lgamma(0.5";
    "Fxn:torch.lgamma(0.5";
    "Fxn:torch.log1p(y**2.";
    "Fxn:entropy";
    "Fxn:torch.lgamma(0.5";
    "Fxn:math.lgamma(0.5)";
    "Fxn:torch.lgamma(0.5";
    "Fxn:torch.digamma(0.5";
    "Fxn:self.df.log()";
    "/torch/distributions/transformed_distribution.py";
    "Import:torch";
    "Import:constraints";
    "Import:Distribution";
    "Import:Transform";
    "Import:_sum_rightmost";
    "class:TransformedDistribution(Distribution):";
    "Fxn:__init__";
    "Fxn:ValueError("transforms";
    "Fxn:ValueError("transforms";
    "Fxn:{}".format(transforms))";
    "Fxn:shape[:len(shape)";
    "Fxn:shape[len(shape)";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:params";
    "Fxn:support";
    "Fxn:has_rsample";
    "Fxn:sample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:`transform()`";
    "Fxn:torch.no_grad():";
    "Fxn:self.base_dist.sample(sample_shape)";
    "Fxn:transform(x)";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:`transform()`";
    "Fxn:self.base_dist.rsample(sample_shape)";
    "Fxn:transform(x)";
    "Fxn:log_prob";
    "Fxn:transform(s)";
    "Fxn:transform.inv(y)";
    "Fxn:_sum_rightmost(transform.log_abs_det_jacobian(x,";
    "Fxn:_sum_rightmost(self.base_dist.log_prob(y),";
    "Fxn:_monotonize_cdf";
    "Fxn:cdf";
    "Fxn:transform(s)";
    "Fxn:transform.inv(value)";
    "Fxn:self.base_dist._validate_sample(value)";
    "Fxn:self.base_dist.cdf(value)";
    "Fxn:self._monotonize_cdf(value)";
    "Fxn:icdf";
    "Fxn:transform(s)";
    "Fxn:self._monotonize_cdf(value)";
    "Fxn:self.base_dist._validate_sample(value)";
    "Fxn:self.base_dist.icdf(value)";
    "Fxn:transform(value)";
    "/torch/distributions/transforms.py";
    "Import:weakref";
    "Import:torch";
    "Import:Variable";
    "Import:constraints";
    "Import:(_sum_rightmost,";
    "Import:sigmoid";
    "class:Transform(object):";
    "Fxn:__init__";
    "Fxn:ValueError('cache_size";
    "Fxn:inv";
    "Fxn:self._inv()";
    "Fxn:_InverseTransform(self)";
    "Fxn:weakref.ref(inv)";
    "Fxn:sign";
    "Fxn:__eq__";
    "Fxn:__ne__";
    "Fxn:self.__eq__(other)";
    "Fxn:__call__";
    "Fxn:self._call(x)";
    "Fxn:self._call(x)";
    "Fxn:_inv_call";
    "Fxn:self._inverse(y)";
    "Fxn:self._inverse(y)";
    "Fxn:_call";
    "Fxn:_inverse";
    "Fxn:log_abs_det_jacobian";
    "class:_InverseTransform(Transform):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:domain";
    "Fxn:codomain";
    "Fxn:bijective";
    "Fxn:sign";
    "Fxn:event_dim";
    "Fxn:inv";
    "Fxn:__eq__";
    "Fxn:__call__";
    "Fxn:self._inv._inv_call(x)";
    "Fxn:log_abs_det_jacobian";
    "Fxn:-self._inv.log_abs_det_jacobian(y,";
    "class:ComposeTransform(Transform):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:__eq__";
    "Fxn:domain";
    "Fxn:codomain";
    "Fxn:bijective";
    "Fxn:sign";
    "Fxn:event_dim";
    "Fxn:inv";
    "Fxn:self._inv()";
    "Fxn:ComposeTransform([p.inv";
    "Fxn:weakref.ref(inv)";
    "Fxn:weakref.ref(self)";
    "Fxn:__call__";
    "Fxn:part(x)";
    "Fxn:log_abs_det_jacobian";
    "Fxn:x.new([0]).expand_as(x)";
    "Fxn:part(x)";
    "Fxn:_sum_rightmost(part.log_abs_det_jacobian(x,";
    "Fxn:ComposeTransform([])";
    "class:ExpTransform(Transform):";
    "Fxn:__eq__";
    "Fxn:_call";
    "Fxn:x.exp()";
    "Fxn:_inverse";
    "Fxn:y.log()";
    "Fxn:log_abs_det_jacobian";
    "class:SigmoidTransform(Transform):";
    "Fxn:__eq__";
    "Fxn:_call";
    "Fxn:sigmoid(x)";
    "Fxn:_inverse";
    "Fxn:y.log()";
    "Fxn:log_abs_det_jacobian";
    "Fxn:-(y.reciprocal()";
    "Fxn:y).reciprocal()).log()";
    "class:AbsTransform(Transform):";
    "Fxn:__eq__";
    "Fxn:_call";
    "Fxn:x.abs()";
    "Fxn:_inverse";
    "class:AffineTransform(Transform):";
    "Fxn:__init__";
    "Fxn:self).__init__(cache_size=cache_size)";
    "Fxn:broadcast_all(loc,";
    "Fxn:__eq__";
    "Fxn:self.loc.eq(other.loc).all()";
    "Fxn:self.scale.eq(other.scale).all()";
    "Fxn:result.data.view(-1)[0]";
    "Fxn:sign";
    "Fxn:self.scale.sign()";
    "Fxn:_call";
    "Fxn:_inverse";
    "Fxn:log_abs_det_jacobian";
    "Fxn:torch.abs(self.scale).log()";
    "Fxn:result.size()[:-self.event_dim]";
    "Fxn:result.view(result_size).sum(-1)";
    "Fxn:result.expand(shape)";
    "class:BoltzmannTransform(Transform):";
    "Fxn:__eq__";
    "Fxn:_call";
    "Fxn:logprobs.max(-1,";
    "Fxn:True)[0]).exp()";
    "Fxn:probs.sum(-1,";
    "Fxn:_inverse";
    "Fxn:probs.log()";
    "class:StickBreakingTransform(Transform):";
    "Fxn:__eq__";
    "Fxn:_call";
    "Fxn:x.new([1]).expand(x.shape[:-1]";
    "Fxn:sigmoid(x)";
    "Fxn:numer).cumprod(-1)";
    "Fxn:torch.cat([numer,";
    "Fxn:torch.cat([one,";
    "Fxn:_inverse";
    "Fxn:pmf.cumsum(-1)";
    "Fxn:units.log()";
    "Fxn:.log_abs_det_jacobian()";
    "class:LowerCholeskyTransform(Transform):";
    "Fxn:__eq__";
    "Fxn:_call";
    "Fxn:x.dim()";
    "Fxn:x.tril(-1)";
    "Fxn:x.diag().exp().diag()";
    "Fxn:_inverse";
    "Fxn:y.dim()";
    "Fxn:y.tril(-1)";
    "Fxn:y.diag().log().diag()";
    "/torch/distributions/uniform.py";
    "Import:math";
    "Import:Number";
    "Import:torch";
    "Import:Variable";
    "Import:constraints";
    "Import:Distribution";
    "Import:broadcast_all";
    "class:Uniform(Distribution):";
    "Fxn:mean";
    "Fxn:stddev";
    "Fxn:variance";
    "Fxn:self.low).pow(2)";
    "Fxn:__init__";
    "Fxn:broadcast_all(low,";
    "Fxn:torch.Size()";
    "Fxn:self.low.size()";
    "Fxn:self).__init__(batch_shape,";
    "Fxn:torch.lt(self.low,";
    "Fxn:self.high).all():";
    "Fxn:ValueError("Uniform";
    "Fxn:support";
    "Fxn:constraints.interval(self.low,";
    "Fxn:rsample";
    "Fxn:sample_shape=torch.Size()):";
    "Fxn:self._extended_shape(sample_shape)";
    "Fxn:self.low.new(shape).uniform_()";
    "Fxn:log_prob";
    "Fxn:self._validate_sample(value)";
    "Fxn:value.ge(self.low).type_as(self.low)";
    "Fxn:value.lt(self.high).type_as(self.low)";
    "Fxn:torch.log(lb.mul(ub))";
    "Fxn:torch.log(self.high";
    "Fxn:cdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:icdf";
    "Fxn:self._validate_sample(value)";
    "Fxn:entropy";
    "Fxn:torch.log(self.high";
    "/torch/distributions/utils.py";
    "Import:namedtuple";
    "Import:update_wrapper";
    "Import:Number";
    "Import:math";
    "Import:torch";
    "Import:torch.nn.functional";
    "Import:Variable";
    "Fxn:_finfo";
    "Fxn:expand_n";
    "Fxn:_broadcast_shape";
    "Fxn:broadcast_all";
    "Fxn:_sum_rightmost";
    "Fxn:softmax";
    "Fxn:log_sum_exp";
    "Fxn:logits_to_probs";
    "Fxn:clamp_probs";
    "Fxn:probs_to_logits";
    "class:lazy_property(object):";
    "Fxn:__init__";
    "Fxn:update_wrapper(self,";
    "Fxn:__get__";
    "Fxn:self.wrapped(instance)";
    "/torch/distributions/__init__.py";
    "Import:Bernoulli";
    "Import:Beta";
    "Import:.binomial";
    "Import:Binomial";
    "Import:Categorical";
    "Import:Cauchy";
    "Import:Chi2";
    "Import:biject_to,";
    "Import:Dirichlet";
    "Import:Distribution";
    "Import:Exponential";
    "Import:ExponentialFamily";
    "Import:FisherSnedecor";
    "Import:Gamma";
    "Import:Geometric";
    "Import:Gumbel";
    "Import:kl_divergence,";
    "Import:Laplace";
    "Import:LogNormal";
    "Import:Multinomial";
    "Import:Normal";
    "Import:OneHotCategorical";
    "Import:Pareto";
    "Import:Poisson";
    "Import:RelaxedBernoulli";
    "Import:RelaxedOneHotCategorical";
    "Import:StudentT";
    "Import:TransformedDistribution";
    "Import:Uniform";
    "/torch/for_onnx/__init__.py";
    "/torch/jit/frontend.py";
    "Import:torch";
    "Import:sys";
    "Import:ast";
    "Import:inspect";
    "Import:string";
    "Import:dedent";
    "Import:partial";
    "Import:namedtuple";
    "Import:PY2";
    "Fxn:is_reserved_name";
    "class:FrontendError(Exception):";
    "Fxn:__init__";
    "Fxn:__str__";
    "Fxn:self.source_range.highlight()";
    "class:NotSupportedError(FrontendError):";
    "class:UnsupportedNodeError(NotSupportedError):";
    "Fxn:__init__";
    "Fxn:ctx.make_range(offending_node.lineno,";
    "Fxn:pretty_node_names.get(node_type,";
    "Fxn:supported".format(feature_name)";
    "Fxn:self).__init__(source_range,";
    "class:FrontendTypeError(FrontendError):";
    "Fxn:get_jit_ast";
    "Fxn:dedent(inspect.getsource(fn))";
    "Fxn:ast.parse(source)";
    "Fxn:RuntimeError("expected";
    "Fxn:build_def(SourceRangeFactory(source),";
    "class:Builder(object):";
    "Fxn:__call__";
    "Fxn:UnsupportedNodeError(ctx,";
    "Fxn:method(ctx,";
    "Fxn:build_def";
    "Fxn:ctx.make_range(py_def.lineno,";
    "Fxn:Def(Ident(r,";
    "Fxn:build_param_list(ctx,";
    "Fxn:[build_stmt(ctx,";
    "Fxn:build_param_list";
    "Fxn:ValueError(_vararg_kwarg_err)";
    "Fxn:ValueError(_vararg_kwarg_err)";
    "Fxn:[build_param(ctx,";
    "Fxn:build_param";
    "Fxn:ValueError("Compiled";
    "Fxn:ctx.make_range(py_arg.lineno,";
    "Fxn:Param(TensorType(r),";
    "Fxn:Ident(r,";
    "class:StmtBuilder(Builder):";
    "Fxn:build_Expr";
    "Fxn:ExprStmt(build_expr(ctx,";
    "Fxn:get_assign_ident";
    "Fxn:build_expr(ctx,";
    "Fxn:NotSupportedError(var.range(),";
    "Fxn:build_Assign";
    "Fxn:build_expr(ctx,";
    "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:NotSupportedError(ctx.make_raw_range(start_point.start,";
    "Fxn:rhs.range().end),";
    "Fxn:Assign([StmtBuilder.get_assign_ident(ctx,";
    "Fxn:build_Return";
    "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:Return(r,";
    "Fxn:[build_expr(ctx,";
    "Fxn:build_AugAssign";
    "Fxn:[StmtBuilder.get_assign_ident(ctx,";
    "Fxn:build_expr(ctx,";
    "Fxn:NotSupportedError(";
    "Fxn:find_before(ctx,";
    "Fxn:rhs.range().start,";
    "Fxn:offsets=(-1,";
    "Fxn:Assign(lhs,";
    "Fxn:build_While";
    "Fxn:NotSupportedError(None,";
    "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:While(r,";
    "Fxn:build_expr(ctx,";
    "Fxn:[build_stmt(ctx,";
    "Fxn:build_If";
    "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:If(r,";
    "Fxn:build_expr(ctx,";
    "Fxn:[build_stmt(ctx,";
    "Fxn:[build_stmt(ctx,";
    "Fxn:build_Print";
    "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:NotSupportedError(r,";
    "Fxn:[build_expr(ctx,";
    "Fxn:ExprStmt(Apply(Var(Ident(r,";
    "class:ExprBuilder(Builder):";
    "Fxn:build_Attribute";
    "Fxn:build_expr(ctx,";
    "Fxn:find_after(ctx,";
    "Fxn:value.range().end,";
    "Fxn:ctx.make_raw_range(start_pos,";
    "Fxn:Select(value,";
    "Fxn:Ident(name_range,";
    "Fxn:build_Call";
    "Fxn:build_expr(ctx,";
    "Fxn:[build_expr(ctx,";
    "Fxn:build_expr(ctx,";
    "Fxn:kwargs.append(Attribute(Ident(kw_expr.range(),";
    "Fxn:Apply(func,";
    "Fxn:build_Name";
    "Fxn:ctx.make_range(expr.lineno,";
    "Fxn:expr.id.startswith(_reserved_prefix):";
    "Fxn:NotSupportedError(r,";
    "Fxn:Var(Ident(r,";
    "Fxn:build_BinOp";
    "Fxn:build_expr(ctx,";
    "Fxn:build_expr(ctx,";
    "Fxn:ExprBuilder.binop_map.get(op)";
    "Fxn:ctx.make_range(lhs.range().end,";
    "Fxn:rhs.range().start)";
    "Fxn:NotSupportedError(err_range,";
    "Fxn:BinOp(op_token,";
    "Fxn:build_UnaryOp";
    "Fxn:build_expr(ctx,";
    "Fxn:ExprBuilder.unop_map.get(op)";
    "Fxn:ctx.make_range(expr.lineno,";
    "Fxn:ctx.make_raw_range(r.start,";
    "Fxn:sub_expr.range().end)";
    "Fxn:NotSupportedError(err_range,";
    "Fxn:UnaryOp(r,";
    "Fxn:build_BoolOp";
    "Fxn:AssertionError("expected";
    "Fxn:[build_expr(ctx,";
    "Fxn:ExprBuilder.boolop_map.get(op)";
    "Fxn:ctx.make_raw_range(sub_exprs[0].range().end,";
    "Fxn:sub_exprs[1].range().start)";
    "Fxn:NotSupportedError(err_range,";
    "Fxn:BinOp(op_token,";
    "Fxn:build_IfExp";
    "Fxn:TernaryIf(build_expr(ctx,";
    "Fxn:build_expr(ctx,";
    "Fxn:build_expr(ctx,";
    "Fxn:build_Compare";
    "Fxn:[build_expr(ctx,";
    "Fxn:ExprBuilder.cmpop_map.get(op)";
    "Fxn:ctx.make_raw_range(lhs.range().end,";
    "Fxn:rhs.range().start)";
    "Fxn:NotSupportedError(err_range,";
    "Fxn:BinOp(op_token,";
    "Fxn:BinOp('and',";
    "Fxn:build_Num";
    "Fxn:ctx.make_range(expr.lineno,";
    "Fxn:NotSupportedError(err_range,";
    "Fxn:ExprBuilder()";
    "Fxn:StmtBuilder()";
    "Fxn:find_after";
    "Fxn:offsets=(0,";
    "Fxn:ctx.source[pos:].index(substr)";
    "Fxn:ctx.make_raw_range(new_pos";
    "Fxn:find_before";
    "Fxn:offsets=(0,";
    "Fxn:ctx.source[:pos].rindex(substr)";
    "Fxn:ctx.make_raw_range(new_pos";
    "/torch/jit/__init__.py";
    "Import:torch._C";
    "Import:Tensor";
    "Import:Variable,";
    "Import:Module,";
    "Import:get_jit_ast";
    "Import:raise_from,";
    "Import:defaultdict,";
    "Import:sys";
    "Import:warnings";
    "Import:itertools";
    "Import:weakref";
    "Import:types";
    "Import:contextlib";
    "Import:import";
    "Import:functools";
    "Import:inspect";
    "Import:copy";
    "Fxn:get_tracing_state";
    "Fxn:scope";
    "Fxn:compile";
    "class:MyModel(nn.Module):";
    "class:MyModel(nn.Module):";
    "Fxn:f";
    "Fxn:_compile";
    "Fxn:inspect.isclass(arg):";
    "class:Foo(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "class:(unrelated";
    "Fxn:__init__";
    "Fxn:torch._C.CompiledFunction.__init__(self,";
    "Fxn:old_init(self,";
    "Fxn:get_trace_graph";
    "Fxn:args=tuple(),";
    "Fxn:`backward()`";
    "Fxn:jit.trace(nn.LSTMCell(),";
    "Fxn:jit.trace(nn.LSTMCell(),";
    "Fxn:out.sum().backward()";
    "Fxn:LegacyTracedModule(f,";
    "Fxn:nderivs=nderivs)(*args,";
    "Fxn:_unique_state_dict";
    "Fxn:module.state_dict(keep_vars=keep_vars)";
    "Fxn:state_dict.items():";
    "Fxn:seen_ids.add(id(v))";
    "class:LegacyTracedModule(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:_flatten(args)";
    "Fxn:keep_vars=True).values())";
    "Fxn:torch._C._tracer_enter(in_vars";
    "Fxn:_unflatten(all_trace_inputs[:len(in_vars)],";
    "Fxn:self.inner(*trace_inputs)";
    "Fxn:_flatten(out)";
    "Fxn:torch._C._tracer_exit(out_vars)";
    "Fxn:_clone_inputs";
    "Fxn:clone_input";
    "Fxn:Variable(a.data.clone(),";
    "Fxn:clone_input(v.grad)";
    "Fxn:a.clone()";
    "Fxn:function._nested_map(lambda";
    "Fxn:torch.is_tensor(o),";
    "Fxn:condition_msg="Variables")(args)";
    "Fxn:os.environ.get('PYTORCH_JIT_DUMP',";
    "Fxn:os.environ.get('PYTORCH_JIT_TIME',";
    "Fxn:os.environ.get('PYTORCH_JIT_DISABLE',";
    "Fxn:os.environ.get('PYTORCH_JIT_STATS',";
    "Fxn:_dump_trace";
    "Fxn:"{}_{}".format(trace_name,";
    "Fxn:f.write("Input";
    "Fxn:{}\n\n{}".format(input_key,";
    "Fxn:graph_vis.write(trace.graph(),";
    "Fxn:_time";
    "Fxn:torch.cuda.is_available():";
    "Fxn:torch.cuda.current_stream()";
    "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:stream.record_event(start)";
    "Fxn:stream.record_event(end)";
    "Fxn:end.synchronize()";
    "Fxn:ms".format(trace_name,";
    "Fxn:start.elapsed_time(end)))";
    "Fxn:verify";
    "Fxn:TypeError("Cannot";
    "Fxn:_clone_inputs(args)";
    "Fxn:copy.deepcopy(model.state_dict())";
    "Fxn:run_fwd_bwd";
    "Fxn:_flatten((args,";
    "Fxn:compiled_fn.clear_cache()";
    "Fxn:model(*args)";
    "Fxn:RuntimeError("failed";
    "Fxn:ValueError(("Model";
    "Fxn:"(torch.sum)";
    "Fxn:output").format(len(out)))";
    "Fxn:_flatten(out)";
    "Fxn:[v.data.clone()";
    "Fxn:loss_fn(*out)";
    "Fxn:torch.autograd.grad([loss],";
    "Fxn:[v.data.clone()";
    "Fxn:torch.random.fork_rng(devices,";
    "Fxn:run_fwd_bwd(args,";
    "Fxn:model.has_trace_for(*args)";
    "Fxn:model.load_state_dict(saved_state)";
    "Fxn:run_fwd_bwd(args,";
    "Fxn:_verify_equal(uncompiled_outs,";
    "Fxn:_verify_equal(uncompiled_grads,";
    "Fxn:_verify_equal";
    "Fxn:x.sub(y).abs().max()";
    "Fxn:RuntimeError("JIT";
    "Fxn:trace";
    "Fxn:@jit.trace(torch.autograd.Variable(torch.rand(1)))";
    "Fxn:f";
    "Fxn:wrapper";
    "Fxn:kwargs.pop(name,";
    "Fxn:ValueError("TracedModules";
    "Fxn:torch._C.GraphExecutor(func,";
    "Fxn:TracedModule(func,";
    "Fxn:torch._C.GraphExecutor(func,";
    "Import:torch.contrib._graph_vis";
    "class:TracedModuleBase(torch.nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:orig._parameters.items():";
    "Fxn:orig._buffers.items():";
    "Fxn:ValueError("Modules";
    "Fxn:_freeze";
    "Fxn:__setattr__";
    "Fxn:self).__setattr__(name,";
    "Fxn:self).__setattr__(name,";
    "Fxn:self._recompute_captures()";
    "Fxn:RuntimeError("Only";
    "Fxn:__delattr__";
    "Fxn:RuntimeError("Deleting";
    "Fxn:__getstate__";
    "Fxn:RuntimeError("TracedModules";
    "Fxn:_recompute_captures";
    "Fxn:NotImplementedError()";
    "Fxn:register_parameter";
    "Fxn:RuntimeError("Can't";
    "Fxn:RuntimeError("Can't";
    "Fxn:self).register_parameter(name,";
    "Fxn:load_state_dict";
    "Fxn:self).load_state_dict(state)";
    "Fxn:self._recompute_captures()";
    "Fxn:_get_name";
    "class:TracedSubmodule(TracedModuleBase):";
    "Fxn:__init__";
    "Fxn:self).__init__(orig)";
    "Fxn:orig._modules.items():";
    "Fxn:TracedSubmodule(submodule,";
    "Fxn:weakref.ref(root)";
    "Fxn:self._freeze()";
    "Fxn:_recompute_captures";
    "Fxn:self._root()";
    "Fxn:RuntimeError("Submodules";
    "Fxn:root._recompute_captures()";
    "Fxn:__call__";
    "Fxn:RuntimeError("Only";
    "class:TracedModule(TracedModuleBase):";
    "Fxn:__init__";
    "Fxn:self).__init__(orig)";
    "Fxn:orig._modules.items():";
    "Fxn:TracedSubmodule(submodule,";
    "Fxn:self._recompute_captures()";
    "Fxn:self._freeze()";
    "Fxn:__call__";
    "Fxn:self._executor(*args)";
    "Fxn:_recompute_captures";
    "Fxn:self._executor.set_captures(*self.state_dict().values())";
    "Fxn:_apply";
    "Fxn:itertools.chain((self,),";
    "Fxn:self.modules()):";
    "Fxn:module._parameters.values():";
    "Fxn:fn(param.data)";
    "Fxn:fn(param._grad.data)";
    "Fxn:module._buffers.items():";
    "Fxn:fn(buf)";
    "Fxn:self._recompute_captures()";
    "Fxn:_get_methods";
    "Fxn:inspect.getmembers(cls,";
    "Fxn:inspect.isfunction(x)";
    "Fxn:inspect.ismethod(x))";
    "Fxn:_make_fail";
    "Fxn:fail";
    "Fxn:RuntimeError(name";
    "Fxn:_get_methods(torch.nn.Module):";
    "Fxn:name.startswith('__'):";
    "Fxn:_make_fail(name))";
    "Fxn:createResolutionCallback";
    "Fxn:bar";
    "Fxn:createResolutionCallback()";
    "Fxn:baz";
    "Fxn:bar()";
    "Fxn:baz()";
    "Fxn:inspect.stack()[frame_id][0]";
    "Fxn:env";
    "Import:inspect";
    "class:CompilationUnit(object):";
    "Fxn:__init__";
    "Fxn:torch._C.ScriptModule(optimize)";
    "Fxn:self.define(lang,";
    "Fxn:define";
    "Fxn:createResolutionCallback(frame_id)";
    "Fxn:self.module._define(lang,";
    "Fxn:__getattr__";
    "Fxn:self.module._get_method(attr)";
    "Fxn:script";
    "Fxn:createResolutionCallback()";
    "Fxn:get_jit_ast(fn)";
    "Fxn:_jit_script_compile(ast,";
    "Fxn:torch._C.GraphExecutor(graph,";
    "Fxn:namedtuple('ScriptMethodStub',";
    "Fxn:script_method";
    "Fxn:ScriptMethodStub(createResolutionCallback(),";
    "Fxn:get_jit_ast(fn))";
    "class:ScriptMeta(type(torch._C.ScriptModule)):";
    "Fxn:__init__";
    "Fxn:methods.append(v)";
    "Fxn:init_then_register";
    "Fxn:original_init(self,";
    "Fxn:self._create_method(m.ast,";
    "Fxn:cls).__init__(name,";
    "class:ScriptModule(with_metaclass(ScriptMeta,";
    "Fxn:__setattr__";
    "Fxn:self._register_or_set_parameter(name,";
    "Fxn:self._register_module(name,";
    "Fxn:__getattr__";
    "Fxn:self._get_attribute(attr)";
    "Fxn:AttributeError("'{}'";
    "Fxn:'{}'".format(self.__class__.__name__,";
    "Fxn:define";
    "Fxn:createResolutionCallback()";
    "Fxn:self._define(lang,";
    "Fxn:torch._C._jit_init():";
    "Fxn:RuntimeError("JIT";
    "/torch/legacy/__init__.py";
    "/torch/legacy/nn/Abs.py";
    "Import:torch";
    "Import:Module";
    "class:Abs(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.Abs_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.Abs_updateGradInput(";
    "/torch/legacy/nn/AbsCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:AbsCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(1)";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:self._backend.AbsCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.AbsCriterion_updateGradInput(";
    "/torch/legacy/nn/Add.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:Add(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(size)";
    "Fxn:torch.Tensor(size)";
    "Fxn:torch.Tensor((1,))";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.bias.size(0))";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:self.output.add_(self.bias[0])";
    "Fxn:input.size(0)";
    "Fxn:self._ones.size(0)";
    "Fxn:self._ones.resize_(batchSize).fill_(1)";
    "Fxn:self.bias.view(-1)";
    "Fxn:self.output.view(batchSize,";
    "Fxn:output.addr_(self._ones,";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:accGradParameters";
    "Fxn:self.gradBias.size(0)";
    "Fxn:gradOutput.sum()";
    "Fxn:input.is_same_size(self.bias):";
    "Fxn:self.gradBias.add_(scale,";
    "Fxn:gradOutput.contiguous().view(input.size(0),";
    "Fxn:self.gradBias.view(-1).addmv_(scale,";
    "Fxn:gradOutput.t(),";
    "/torch/legacy/nn/AddConstant.py";
    "Import:torch";
    "Import:Module";
    "class:AddConstant(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.add_(self.constant_scalar)";
    "Fxn:self.output.set_(input)";
    "Fxn:self.output.resize_as_(input)";
    "Fxn:self.output.copy_(input)";
    "Fxn:self.output.add_(self.constant_scalar)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.set_(gradOutput)";
    "Fxn:input.add_(-self.constant_scalar)";
    "Fxn:self.gradInput.resize_as_(gradOutput)";
    "Fxn:self.gradInput.copy_(gradOutput)";
    "/torch/legacy/nn/BatchNormalization.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:BatchNormalization(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.zeros(nOutput)";
    "Fxn:torch.ones(nOutput)";
    "Fxn:torch.Tensor(nOutput)";
    "Fxn:torch.Tensor(nOutput)";
    "Fxn:torch.Tensor(nOutput)";
    "Fxn:torch.Tensor(nOutput)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:self.weight.uniform_()";
    "Fxn:self.bias.zero_()";
    "Fxn:self.running_mean.zero_()";
    "Fxn:self.running_var.fill_(1)";
    "Fxn:_checkInputDim";
    "Fxn:input.dim()";
    "Fxn:RuntimeError(";
    "Fxn:instead'.format(self.nDim,";
    "Fxn:input.dim()))";
    "Fxn:input.size(1)";
    "Fxn:self.running_mean.nelement():";
    "Fxn:RuntimeError('got";
    "Fxn:{}'.format(input.size(1),";
    "Fxn:self.running_mean.nelement()))";
    "Fxn:_makeContiguous";
    "Fxn:input.is_contiguous():";
    "Fxn:input.new()";
    "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateOutput";
    "Fxn:self._checkInputDim(input)";
    "Fxn:self._makeContiguous(input)[0]";
    "Fxn:self.output.resize_as_(input)";
    "Fxn:input.new()";
    "Fxn:self.save_mean.resize_as_(self.running_mean)";
    "Fxn:input.new()";
    "Fxn:self.save_std.resize_as_(self.running_var)";
    "Fxn:self._backend.BatchNormalization_updateOutput(";
    "Fxn:_backward";
    "Fxn:self._checkInputDim(input)";
    "Fxn:self._checkInputDim(gradOutput)";
    "Fxn:RuntimeError('you";
    "Fxn:updateOutput()";
    "Fxn:backward()')";
    "Fxn:self._makeContiguous(input,";
    "Fxn:gradInput.resize_as_(gradOutput)";
    "Fxn:self._backend.BatchNormalization_backward(";
    "Fxn:backward";
    "Fxn:self._backward(input,";
    "Fxn:updateGradInput";
    "Fxn:self._backward(input,";
    "Fxn:accGradParameters";
    "Fxn:self._backward(input,";
    "Fxn:read";
    "Fxn:self).read(self,";
    "Fxn:self.running_std.pow_(-2).add_(-self.eps)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/BCECriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:BCECriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:weights.dim()";
    "Fxn:ValueError("weights";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:log(input)";
    "Fxn:log(1";
    "Fxn:input.nelement()";
    "Fxn:target.nelement():";
    "Fxn:RuntimeError("input";
    "Fxn:input.new()";
    "Fxn:buffer.resize_as_(input)";
    "Fxn:target.dim()";
    "Fxn:self.weights.view(1,";
    "Fxn:target.size(1)).expand_as(target)";
    "Fxn:log(input)";
    "Fxn:torch.add(input,";
    "Fxn:out=buffer).log_()";
    "Fxn:buffer.mul_(weights)";
    "Fxn:target.contiguous().view(-1)";
    "Fxn:torch.dot(target_1d,";
    "Fxn:buffer.contiguous().view(-1))";
    "Fxn:log(1";
    "Fxn:torch.mul(input,";
    "Fxn:out=buffer).add_(1";
    "Fxn:self.eps).log_()";
    "Fxn:buffer.mul_(weights)";
    "Fxn:torch.sum(buffer)";
    "Fxn:torch.dot(target_1d,";
    "Fxn:buffer.contiguous().view(-1))";
    "Fxn:input.nelement()";
    "Fxn:output.item()";
    "Fxn:updateGradInput";
    "Fxn:input.nelement()";
    "Fxn:target.nelement():";
    "Fxn:RuntimeError("input";
    "Fxn:input.new()";
    "Fxn:target.dim()";
    "Fxn:self.weights.view(1,";
    "Fxn:target.size(1)).expand_as(target)";
    "Fxn:buffer.resize_as_(input)";
    "Fxn:torch.add(input,";
    "Fxn:out=buffer).add_(-self.eps).mul_(input).add_(-self.eps)";
    "Fxn:gradInput.resize_as_(input)";
    "Fxn:torch.add(target,";
    "Fxn:gradInput.div_(buffer)";
    "Fxn:gradInput.mul_(weights)";
    "Fxn:gradInput.div_(target.nelement())";
    "/torch/legacy/nn/Bilinear.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Bilinear(Module):";
    "Fxn:_assertInput";
    "Fxn:torch.is_tensor(input[0])";
    "Fxn:torch.is_tensor(input[1]):";
    "Fxn:RuntimeError('input";
    "Fxn:input[0].ndimension()";
    "Fxn:input[1].ndimension()";
    "Fxn:RuntimeError('input";
    "Fxn:input[0].size(0)";
    "Fxn:input[1].size(0):";
    "Fxn:RuntimeError('input";
    "Fxn:input[0].size(1)";
    "Fxn:self.weight.size(1):";
    "Fxn:RuntimeError('dimensionality";
    "Fxn:input[1].size(1)";
    "Fxn:self.weight.size(2):";
    "Fxn:RuntimeError('dimensionality";
    "Fxn:_assertInputGradOutput";
    "Fxn:input[0].size(0)";
    "Fxn:gradOutput.size(0):";
    "Fxn:RuntimeError('number";
    "Fxn:gradOutput.size(1)";
    "Fxn:self.weight.size(0):";
    "Fxn:RuntimeError('number";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(outputSize,";
    "Fxn:torch.Tensor(outputSize,";
    "Fxn:torch.Tensor(outputSize)";
    "Fxn:torch.Tensor(outputSize)";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self._assertInput(input)";
    "Fxn:input[0].new()";
    "Fxn:self.buff2.resize_as_(input[1])";
    "Fxn:self.output.resize_(input[0].size(0),";
    "Fxn:self.weight.size(0))";
    "Fxn:torch.mm(input[0],";
    "Fxn:self.buff2.mul_(input[1])";
    "Fxn:torch.sum(self.buff2,";
    "Fxn:out=self.output.narrow(1,";
    "Fxn:self.output.add_(self.bias.view(1,";
    "Fxn:self.bias.nelement()).expand_as(self.output))";
    "Fxn:updateGradInput";
    "Fxn:self._assertInputGradOutput(input,";
    "Fxn:self.gradInput[0].resize_as_(input[0]).fill_(0)";
    "Fxn:self.gradInput[1].resize_as_(input[1]).fill_(0)";
    "Fxn:self.gradInput[0].addmm_(input[1],";
    "Fxn:self.weight[0].t())";
    "Fxn:self.gradInput[0].mul_(gradOutput.narrow(1,";
    "Fxn:1).expand(self.gradInput[0].size(0),";
    "Fxn:self.gradInput[0].size(1)))";
    "Fxn:self.gradInput[1].addmm_(input[0],";
    "Fxn:self.gradInput[1].mul_(gradOutput.narrow(1,";
    "Fxn:1).expand(self.gradInput[1].size(0),";
    "Fxn:self.gradInput[1].size(1)))";
    "Fxn:self.weight.size(0)";
    "Fxn:input[0].new()";
    "Fxn:self.buff1.resize_as_(input[0])";
    "Fxn:self.weight.size(0)):";
    "Fxn:torch.mm(input[1],";
    "Fxn:self.weight[k].t(),";
    "Fxn:self.buff1.mul_(gradOutput.narrow(1,";
    "Fxn:1).expand(self.gradInput[0].size(0),";
    "Fxn:self.gradInput[0].size(1)))";
    "Fxn:self.gradInput[0].add_(self.buff1)";
    "Fxn:torch.mm(input[0],";
    "Fxn:self.buff2.mul_(gradOutput.narrow(1,";
    "Fxn:1).expand(self.gradInput[1].size(0),";
    "Fxn:self.gradInput[1].size(1)))";
    "Fxn:self.gradInput[1].add_(self.buff2)";
    "Fxn:accGradParameters";
    "Fxn:self._assertInputGradOutput(input,";
    "Fxn:input[0].new()";
    "Fxn:self.buff1.resize_as_(input[0])";
    "Fxn:torch.mul(input[0],";
    "Fxn:gradOutput.narrow(1,";
    "Fxn:1).expand_as(input[0]),";
    "Fxn:self.gradWeight[k].addmm_(self.buff1.t(),";
    "Fxn:self.gradBias.add_(scale,";
    "Fxn:gradOutput.sum(0,";
    "Fxn:__repr__";
    "Fxn:'({}x{}";
    "Fxn:{}'.format(";
    "Fxn:self.weight.size(1),";
    "Fxn:self.weight.size(2),";
    "Fxn:self.weight.size(0),";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/CAddTable.py";
    "Import:torch";
    "Import:Module";
    "class:CAddTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self.output.set_(input[0])";
    "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:self.output.add_(input[i])";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:self.gradInput[i].set_(gradOutput)";
    "Fxn:self.gradInput[i].resize_as_(input[i]).copy_(gradOutput)";
    "Fxn:self.gradInput[len(input):]";
    "/torch/legacy/nn/CDivTable.py";
    "Import:torch";
    "Import:Module";
    "class:CDivTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:self.output.div_(input[1])";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:gradOutput.contiguous().view_as(input[0])";
    "Fxn:self.gradInput[0].resize_as_(input[0]).copy_(gradOutput).div_(input[1])";
    "Fxn:self.gradInput[1].resize_as_(input[1]).zero_().addcdiv_(-1,";
    "Fxn:input[1]).mul_(input[0])";
    "Fxn:self.gradInput[len(input):]";
    "/torch/legacy/nn/Clamp.py";
    "Import:torch";
    "Import:HardTanh";
    "class:Clamp(HardTanh):";
    "Fxn:__init__";
    "Fxn:self,).__init__(min_value,";
    "/torch/legacy/nn/ClassNLLCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:ClassNLLCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:weights.dim()";
    "Fxn:torch.zeros(1)";
    "Fxn:torch.ones(1)";
    "Fxn:updateOutput";
    "Fxn:target.long()";
    "Fxn:self._backend.ClassNLLCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:target.long()";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.ClassNLLCriterion_updateGradInput(";
    "/torch/legacy/nn/ClassSimplexCriterion.py";
    "Import:math";
    "Import:torch";
    "Import:MSECriterion";
    "class:ClassSimplexCriterion(MSECriterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:self._regsplex(nClasses";
    "Fxn:torch.cat((simp,";
    "Fxn:torch.zeros(simp.size(0),";
    "Fxn:simp.size(1))),";
    "Fxn:torch.Tensor(nClasses)";
    "Fxn:_regsplex";
    "Fxn:torch.zeros(n";
    "Fxn:math.sqrt(1";
    "Fxn:1].norm()";
    "Fxn:1].fill_(c)";
    "Fxn:_transformTarget";
    "Fxn:target.dim()";
    "Fxn:target.size(0)";
    "Fxn:self._target.resize_(nSamples,";
    "Fxn:self._target[i].copy_(self.simplex[int(target[i])])";
    "Fxn:updateOutput";
    "Fxn:self._transformTarget(target)";
    "Fxn:input.nelement()";
    "Fxn:self._target.nelement()";
    "Fxn:input.new(1)";
    "Fxn:self._backend.MSECriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:input.nelement()";
    "Fxn:self._target.nelement()";
    "Fxn:torch.Tensor([1]).type(input.type())";
    "Fxn:self._backend.MSECriterion_updateGradInput(";
    "Fxn:getPredictions";
    "Fxn:torch.mm(input,";
    "Fxn:self.simplex.t())";
    "Fxn:getTopPrediction";
    "Fxn:self.getPredictions(input)";
    "Fxn:prod.max(prod.ndimension()";
    "Fxn:maxs.view(-1)";
    "/torch/legacy/nn/CMul.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear,";
    "class:CMul(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Size(args)";
    "Fxn:torch.Tensor(self.size)";
    "Fxn:torch.Tensor(self.size)";
    "Fxn:self.output.resize_(self.size)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.weight.nelement())";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:input.size(0)";
    "Fxn:self.output.view(batchSize,";
    "Fxn:self.weight.view(1,";
    "Fxn:self._weight.expand_as(self._output)";
    "Fxn:torch.typename(input)";
    "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:self._output.mul_(self._repeat)";
    "Fxn:self._output.mul_(self._expand)";
    "Fxn:updateGradInput";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:input.size(0)";
    "Fxn:contiguousView(self._gradOutput,";
    "Fxn:contiguousView(self._gradInput,";
    "Fxn:self.weight.view(1,";
    "Fxn:self._weight.expand_as(self._gradOutput)";
    "Fxn:torch.typename(input)";
    "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:self._gradInput.addcmul_(1,";
    "Fxn:self._gradInput.addcmul_(1,";
    "Fxn:accGradParameters";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:input.size(0)";
    "Fxn:contiguousView(self._input,";
    "Fxn:contiguousView(self._gradOutput,";
    "Fxn:self.gradWeight.view(1,";
    "Fxn:torch.mul(self._input,";
    "Fxn:torch.sum(self._repeat,";
    "Fxn:self._gradWeight.add_(scale,";
    "Fxn:type";
    "Fxn:self.clearState()";
    "Fxn:self).type(type,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/CMulTable.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:CMulTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:self.output.mul_(input[i])";
    "Fxn:updateGradInput_efficient";
    "Fxn:input[0].new()";
    "Fxn:self.tout.resize_as_(self.output)";
    "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:self.gradInput[i].resize_as_(input[i]).copy_(gradOutput)";
    "Fxn:self.tout.copy_(self.output).div_(input[i])";
    "Fxn:self.gradInput[i].mul_(self.tout)";
    "Fxn:self.gradInput[:len(input)]";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:self.gradInput[i].resize_as_(input[i]).copy_(gradOutput)";
    "Fxn:self.gradInput[i].mul_(input[j])";
    "Fxn:self.gradInput[:len(input)]";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Concat.py";
    "Import:torch";
    "Import:Container";
    "class:Concat(Container):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Size()";
    "Fxn:updateOutput";
    "Fxn:self.modules[i].updateOutput(input)";
    "Fxn:outs.append(currentOutput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:torch.Size(size)";
    "Fxn:self.output.resize_(self.outputSize)";
    "Fxn:self.output.narrow(self.dimension,";
    "Fxn:currentOutput.size(self.dimension)).copy_(currentOutput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:module.updateGradInput(input,";
    "Fxn:gradOutput.narrow(";
    "Fxn:currentOutput.size(self.dimension)))";
    "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accGradParameters";
    "Fxn:module.accGradParameters(";
    "Fxn:gradOutput.narrow(self.dimension,";
    "Fxn:currentOutput.size(self.dimension)),";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:backward";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:module.backward(input,";
    "Fxn:gradOutput.narrow(";
    "Fxn:currentOutput.size(self.dimension)),";
    "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accUpdateGradParameters";
    "Fxn:module.accUpdateGradParameters(";
    "Fxn:gradOutput.narrow(self.dimension,";
    "Fxn:currentOutput.size(self.dimension)),";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:__tostring__";
    "Fxn:torch.type(self)";
    "Fxn:'('";
    "Fxn:'('";
    "/torch/legacy/nn/ConcatTable.py";
    "Import:torch";
    "Import:Container";
    "class:ConcatTable(Container):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:[module.updateOutput(input)";
    "Fxn:_map_list";
    "Fxn:self._map_list(l1[i]";
    "Fxn:l1.append(res)";
    "Fxn:f(l1,";
    "Fxn:_backward";
    "Fxn:module.updateGradInput(input,";
    "Fxn:module.backward(input,";
    "Fxn:RuntimeError("currentGradInput";
    "Fxn:RuntimeError("table";
    "Fxn:fn";
    "Fxn:l.append(v.clone())";
    "Fxn:l[i].resize_as_(v)";
    "Fxn:l[i].copy_(v)";
    "Fxn:self._map_list(self.gradInput,";
    "Fxn:fn";
    "Fxn:l[i].add_(v)";
    "Fxn:l.append(v.clone())";
    "Fxn:self._map_list(self.gradInput,";
    "Fxn:input.clone()";
    "Fxn:module.updateGradInput(input,";
    "Fxn:module.backward(input,";
    "Fxn:self.gradInput.resize_as_(currentGradInput).copy_(currentGradInput)";
    "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:updateGradInput";
    "Fxn:self._backward('updateGradInput',";
    "Fxn:backward";
    "Fxn:self._backward('backward',";
    "Fxn:accGradParameters";
    "Fxn:ipairs(self.modules):";
    "Fxn:self.rethrowErrors(module,";
    "Fxn:accUpdateGradParameters";
    "Fxn:ipairs(self.modules):";
    "Fxn:self.rethrowErrors(module,";
    "Fxn:__repr__";
    "Fxn:torch.typename(self)";
    "Fxn:'('";
    "Fxn:'('";
    "/torch/legacy/nn/Container.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "Import:wraps";
    "Import:sys";
    "class:Container(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args)";
    "Fxn:add";
    "Fxn:self.modules.append(module)";
    "Fxn:get";
    "Fxn:size";
    "Fxn:applyToModules";
    "Fxn:func(module)";
    "Fxn:zeroGradParameters";
    "Fxn:self.applyToModules(lambda";
    "Fxn:m.zeroGradParameters())";
    "Fxn:updateParameters";
    "Fxn:self.applyToModules(lambda";
    "Fxn:m.updateParameters(learningRate))";
    "Fxn:training";
    "Fxn:self.applyToModules(lambda";
    "Fxn:m.training())";
    "Fxn:self).training()";
    "Fxn:evaluate";
    "Fxn:self.applyToModules(lambda";
    "Fxn:m.evaluate())";
    "Fxn:self).evaluate()";
    "Fxn:share";
    "Fxn:module.share(other_module,";
    "Fxn:reset";
    "Fxn:self.applyToModules(lambda";
    "Fxn:m.reset(stdv))";
    "Fxn:parameters";
    "Fxn:module.parameters()";
    "Fxn:w.extend(mparam[0])";
    "Fxn:gw.extend(mparam[1])";
    "Fxn:clearState";
    "Fxn:clear('output')";
    "Fxn:clear('gradInput')";
    "Fxn:module.clearState()";
    "/torch/legacy/nn/Contiguous.py";
    "Import:torch";
    "Import:Module";
    "class:Contiguous(Module):";
    "Fxn:updateOutput";
    "Fxn:input.is_contiguous():";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:self.output.set_(input)";
    "Fxn:updateGradInput";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self.gradInput.set_(gradOutput)";
    "/torch/legacy/nn/Copy.py";
    "Import:torch";
    "Import:Module";
    "class:Copy(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:intype()";
    "Fxn:outtype()";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_(input.size()).copy_(input)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_(gradOutput.size()).copy_(gradOutput)";
    "Fxn:type";
    "Fxn:self).type(self,";
    "/torch/legacy/nn/Cosine.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Cosine(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(outputSize,";
    "Fxn:torch.Tensor(outputSize,";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.weight.size(0))";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:self.weight.size(1)";
    "Fxn:self.weight.size(0)";
    "Fxn:self.weight.new()";
    "Fxn:self.weight.new()";
    "Fxn:torch.norm(self.weight,";
    "Fxn:keepdim=True).add_(1e-12)";
    "Fxn:input.size(0)";
    "Fxn:self.output.nelement()";
    "Fxn:self.output.resize_(batchSize,";
    "Fxn:self.output.nelement()";
    "Fxn:self.output.zero_()";
    "Fxn:self.output.addmm_(0.,";
    "Fxn:self.weight.t())";
    "Fxn:torch.norm(input,";
    "Fxn:keepdim=True).add_(1e-12)";
    "Fxn:self.output.div_(self._weightNorm.view(1,";
    "Fxn:outputSize).expand_as(self.output))";
    "Fxn:self.output.div_(self._inputNorm.expand_as(self.output))";
    "Fxn:updateGradInput";
    "Fxn:input.dim()";
    "Fxn:self.weight.size(1)";
    "Fxn:self.weight.size(0)";
    "Fxn:self.gradInput.nelement()";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.gradInput.nelement()";
    "Fxn:self.gradInput.zero_()";
    "Fxn:self._inputNorm.expand_as(input)";
    "Fxn:self._weightNorm.view(1,";
    "Fxn:outputSize).expand_as(gradOutput)";
    "Fxn:gradOutput.new()";
    "Fxn:input.new()";
    "Fxn:self.gradInput.copy_(input).div_(inputNorm)";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self._gradOutput.mul_(self.output)";
    "Fxn:torch.sum(self._gradOutput,";
    "Fxn:self.gradInput.mul_(self._sum.expand_as(input))";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self._gradOutput.div_(weightNorm)";
    "Fxn:self.gradInput.addmm_(-1,";
    "Fxn:self.gradInput.div_(inputNorm)";
    "Fxn:accGradParameters";
    "Fxn:input.dim()";
    "Fxn:self.weight.size(1)";
    "Fxn:self.weight.size(0)";
    "Fxn:self.weight.new()";
    "Fxn:input.new()";
    "Fxn:self._weight.resize_as_(self.weight).copy_(self.weight)";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self._gradOutput.mul_(self.output)";
    "Fxn:torch.sum(self._gradOutput,";
    "Fxn:grad.div_(self._weightNorm.select(1,";
    "Fxn:self._weight.mul_(grad.view(outputSize,";
    "Fxn:1).expand_as(self._weight))";
    "Fxn:input_.resize_as_(input).copy_(input)";
    "Fxn:input_.div_(self._inputNorm.expand_as(input))";
    "Fxn:self._weight.addmm_(-1,";
    "Fxn:gradOutput.t(),";
    "Fxn:self._weight.div_(self._weightNorm.expand_as(self._weight))";
    "Fxn:self.gradWeight.add_(self._weight)";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/CosineDistance.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:CosineDistance(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:_makeContiguous";
    "Fxn:input1.is_contiguous():";
    "Fxn:input1.new()";
    "Fxn:self._input1.resize_as_(input1).copy_(input1)";
    "Fxn:input2.is_contiguous():";
    "Fxn:input2.new()";
    "Fxn:self._input2.resize_as_(input2).copy_(input2)";
    "Fxn:updateOutput";
    "Fxn:self._makeContiguous(input1,";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:torch.mul(input1,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:torch.mul(input1,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:self.w22.reciprocal_()";
    "Fxn:self.w.resize_as_(self.w22).copy_(self.w22)";
    "Fxn:torch.mul(input2,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:self.w32.reciprocal_()";
    "Fxn:self.w.mul_(self.w32)";
    "Fxn:self.w.sqrt_()";
    "Fxn:torch.mul(self.w1,";
    "Fxn:self.output.resize_(input1.size(0))";
    "Fxn:updateGradInput";
    "Fxn:self._makeContiguous(v1,";
    "Fxn:v1.new()";
    "Fxn:v1.new()";
    "Fxn:gw1.resize_as_(v1).copy_(v2)";
    "Fxn:gw2.resize_as_(v1).copy_(v1)";
    "Fxn:torch.mul(self.w1,";
    "Fxn:gw1.addcmul_(-1,";
    "Fxn:self.buffer.expand_as(v1),";
    "Fxn:gw1.mul_(self.w.expand_as(v1))";
    "Fxn:torch.mul(self.w1,";
    "Fxn:gw2.addcmul_(-1,";
    "Fxn:self.buffer.expand_as(v1),";
    "Fxn:gw2.mul_(self.w.expand_as(v1))";
    "Fxn:gradOutput.contiguous().view(-1,";
    "Fxn:1).expand_as(v1)";
    "Fxn:gw1.mul_(go)";
    "Fxn:gw2.mul_(go)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/CosineEmbeddingCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:CosineEmbeddingCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:updateOutput";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.new()";
    "Fxn:input1.type()";
    "Fxn:torch.cuda.ByteTensor()";
    "Fxn:torch.ByteTensor()";
    "Fxn:torch.mul(input1,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:torch.mul(input1,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:self._outputs.resize_as_(self.w22).fill_(1)";
    "Fxn:torch.div(self._outputs,";
    "Fxn:self.w.resize_as_(self.w22).copy_(self.w22)";
    "Fxn:torch.mul(input2,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:torch.div(self._outputs,";
    "Fxn:self.w.mul_(self.w32)";
    "Fxn:self.w.sqrt_()";
    "Fxn:torch.mul(self.w1,";
    "Fxn:self._outputs.select(1,";
    "Fxn:torch.eq(y,";
    "Fxn:self._outputs[self._idx].add_(-self.margin).clamp_(min=0)";
    "Fxn:torch.eq(y,";
    "Fxn:self._outputs[self._idx].mul_(-1).add_(1)";
    "Fxn:self._outputs.sum().item()";
    "Fxn:y.size(0)";
    "Fxn:updateGradInput";
    "Fxn:gw1.resize_as_(v1).copy_(v2)";
    "Fxn:gw2.resize_as_(v1).copy_(v1)";
    "Fxn:torch.mul(self.w1,";
    "Fxn:gw1.addcmul_(-1,";
    "Fxn:self.buffer.expand_as(v1),";
    "Fxn:gw1.mul_(self.w.expand_as(v1))";
    "Fxn:torch.mul(self.w1,";
    "Fxn:gw2.addcmul_(-1,";
    "Fxn:self.buffer.expand_as(v1),";
    "Fxn:gw2.mul_(self.w.expand_as(v1))";
    "Fxn:torch.le(self._outputs,";
    "Fxn:self._idx.view(-1,";
    "Fxn:1).expand(gw1.size())";
    "Fxn:torch.eq(y,";
    "Fxn:self._idx.view(-1,";
    "Fxn:1).expand(gw2.size())";
    "Fxn:gw1[self._idx].mul_(-1)";
    "Fxn:gw2[self._idx].mul_(-1)";
    "Fxn:gw1.div_(y.size(0))";
    "Fxn:gw2.div_(y.size(0))";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:torch.cuda.ByteTensor()";
    "Fxn:torch.ByteTensor()";
    "/torch/legacy/nn/Criterion.py";
    "Import:torch";
    "Import:Module";
    "Import:recursiveType";
    "Import:torch._thnn";
    "class:Criterion(object):";
    "Fxn:__init__";
    "Fxn:torch.Tensor()";
    "Fxn:torch._thnn.type2backend[self.gradInput.type()]";
    "Fxn:updateOutput";
    "Fxn:forward";
    "Fxn:self.updateOutput(input,";
    "Fxn:backward";
    "Fxn:self.updateGradInput(input,";
    "Fxn:updateGradInput";
    "Fxn:clone";
    "Fxn:type";
    "Fxn:self.__dict__.items():";
    "Fxn:recursiveType(param,";
    "Fxn:float";
    "Fxn:self.type('torch.FloatTensor')";
    "Fxn:double";
    "Fxn:self.type('torch.DoubleTensor')";
    "Fxn:cuda";
    "Fxn:self.type('torch.cuda.FloatTensor')";
    "/torch/legacy/nn/CriterionTable.py";
    "Import:torch";
    "Import:Module";
    "class:CriterionTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self.criterion.updateOutput(*input)";
    "Fxn:updateGradInput";
    "Fxn:self.criterion.updateGradInput(*input)";
    "/torch/legacy/nn/CrossEntropyCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "Import:LogSoftMax";
    "Import:ClassNLLCriterion";
    "class:CrossEntropyCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:LogSoftMax()";
    "Fxn:ClassNLLCriterion(weights)";
    "Fxn:updateOutput";
    "Fxn:input.squeeze()";
    "Fxn:target.squeeze()";
    "Fxn:self.lsm.updateOutput(input)";
    "Fxn:self.nll.updateOutput(self.lsm.output,";
    "Fxn:updateGradInput";
    "Fxn:input.size()";
    "Fxn:input.squeeze()";
    "Fxn:target.squeeze()";
    "Fxn:self.nll.updateGradInput(self.lsm.output,";
    "Fxn:self.lsm.updateGradInput(input,";
    "Fxn:self.lsm.gradInput.view(size)";
    "/torch/legacy/nn/CSubTable.py";
    "Import:torch";
    "Import:Module";
    "class:CSubTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:self.output.add_(-1,";
    "Fxn:updateGradInput";
    "Fxn:input[0].new()";
    "Fxn:input[1].new()";
    "Fxn:self.gradInput[0].resize_as_(input[0]).copy_(gradOutput)";
    "Fxn:self.gradInput[1].resize_as_(input[1]).copy_(gradOutput).mul_(-1)";
    "/torch/legacy/nn/DepthConcat.py";
    "Import:math";
    "Import:torch";
    "Import:Concat";
    "class:DepthConcat(Concat):";
    "Fxn:windowNarrow";
    "Fxn:output.narrow(self.dimension,";
    "Fxn:currentOutput.size(self.dimension))";
    "Fxn:currentOutput.size(dim)";
    "Fxn:[(5-3)/2]";
    "Fxn:[(9-5)/2]";
    "Fxn:[(9-4)/2]";
    "Fxn:outputWindow.narrow(dim,";
    "Fxn:updateOutput";
    "Fxn:self.modules[i].updateOutput(input)";
    "Fxn:outs.append(currentOutput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:currentOutput.size(dim))";
    "Fxn:torch.Size(size)";
    "Fxn:self.output.resize_(self.outputSize).zero_()";
    "Fxn:self.windowNarrow(self.output,";
    "Fxn:outputWindow.copy_(currentOutput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:module.updateGradInput(input,";
    "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accGradParameters";
    "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:module.accGradParameters(input,";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:backward";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:module.backward(input,";
    "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accUpdateGradParameters";
    "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:module.accUpdateGradParameters(input,";
    "Fxn:currentOutput.size(self.dimension)";
    "/torch/legacy/nn/DistKLDivCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:DistKLDivCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(1)";
    "Fxn:updateOutput";
    "Fxn:input.is_same_size(target)";
    "Fxn:input.new(1)";
    "Fxn:self._backend.DistKLDivCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:input.is_same_size(target)";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.DistKLDivCriterion_updateGradInput(";
    "/torch/legacy/nn/DotProduct.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:DotProduct(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:updateOutput";
    "Fxn:input1.new()";
    "Fxn:torch.mul(input1,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:self.output.resize_(input1.size(0))";
    "Fxn:updateGradInput";
    "Fxn:input[0].new()";
    "Fxn:input[1].new()";
    "Fxn:gw1.resize_as_(v1).copy_(v2)";
    "Fxn:gw2.resize_as_(v2).copy_(v1)";
    "Fxn:gradOutput.contiguous().view(-1,";
    "Fxn:1).expand_as(v1)";
    "Fxn:gw1.mul_(go)";
    "Fxn:gw2.mul_(go)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Dropout.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Dropout(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor()";
    "Fxn:updateOutput";
    "Fxn:self.output.set_(input)";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:self.noise.resize_as_(input)";
    "Fxn:self.noise.bernoulli_(1";
    "Fxn:self.noise.div_(1";
    "Fxn:self.output.mul_(self.noise)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.set_(gradOutput)";
    "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self.gradInput.mul_(self.noise)";
    "Fxn:setp";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({:.4f})'.format(self.p)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/ELU.py";
    "Import:torch";
    "Import:Module";
    "class:ELU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.ELU_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.ELU_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:'{}(alpha={:.3f})'.format(str(type(self)),";
    "/torch/legacy/nn/Euclidean.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Euclidean(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(inputSize,";
    "Fxn:torch.Tensor(inputSize,";
    "Fxn:self.gradInput.resize_(inputSize)";
    "Fxn:self.output.resize_(outputSize)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.weight.size(0))";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:_view";
    "Fxn:src.is_contiguous():";
    "Fxn:res.set_(src.view(*args))";
    "Fxn:res.set_(src.contiguous().view(*args))";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.weight.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.weight.size(0),";
    "Fxn:self.weight.size(1)";
    "Fxn:input.dim()";
    "Fxn:input.size(0)";
    "Fxn:self._view(self._input,";
    "Fxn:self._input.expand(batchSize,";
    "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:self.weight.view(1,";
    "Fxn:self._weight.expand_as(self._repeat)";
    "Fxn:torch.typename(input)";
    "Fxn:self._repeat2.resize_as_(self._expand2).copy_(self._expand2)";
    "Fxn:self._repeat.add_(-1,";
    "Fxn:self._repeat.add_(-1,";
    "Fxn:torch.norm(self._repeat,";
    "Fxn:self.output.resize_(batchSize,";
    "Fxn:updateGradInput";
    "Fxn:input.new()";
    "Fxn:self.output.new()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self.updateOutput(input)";
    "Fxn:self.weight.size(0),";
    "Fxn:self.weight.size(1)";
    "Fxn:self._output.resize_as_(self.output).copy_(self.output).add_(0.0000001)";
    "Fxn:self._view(self._gradOutput,";
    "Fxn:gradOutput.size())";
    "Fxn:torch.div(gradOutput,";
    "Fxn:input.dim()";
    "Fxn:input.size(0)";
    "Fxn:self._div.resize_(batchSize,";
    "Fxn:self._div.expand(batchSize,";
    "Fxn:torch.typename(input)";
    "Fxn:self._repeat2.resize_as_(self._expand3).copy_(self._expand3)";
    "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:torch.mul(self._repeat,";
    "Fxn:torch.sum(self._repeat2,";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:accGradParameters";
    "Fxn:self.weight.size(0),";
    "Fxn:self.weight.size(1)";
    "Fxn:input.dim()";
    "Fxn:input.new()";
    "Fxn:torch.sum(self._repeat2,";
    "Fxn:self._sum.resize_(inputSize,";
    "Fxn:self.gradWeight.add_(-scale,";
    "Fxn:type";
    "Fxn:self.clearState()";
    "Fxn:self).type(type,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Exp.py";
    "Import:torch";
    "Import:Module";
    "class:Exp(Module):";
    "Fxn:updateOutput";
    "Fxn:torch.exp(input,";
    "Fxn:updateGradInput";
    "Fxn:torch.mul(self.output,";
    "/torch/legacy/nn/FlattenTable.py";
    "Import:torch";
    "Import:Module";
    "class:FlattenTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_flatten";
    "Fxn:input_map.append(self._flatten(output,";
    "Fxn:output.append(input)";
    "Fxn:_checkMapping";
    "Fxn:self._checkMapping(output,";
    "Fxn:_inverseFlatten";
    "Fxn:gradInput.append(self._inverseFlatten(gradOutput,";
    "Fxn:updateOutput";
    "Fxn:self._checkMapping(self.output,";
    "Fxn:self._flatten(self.output,";
    "Fxn:updateGradInput";
    "Fxn:self._checkMapping(gradOutput,";
    "Fxn:self._inverseFlatten(gradOutput,";
    "Fxn:type";
    "Fxn:self.clearState()";
    "Fxn:clearState";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/GradientReversal.py";
    "Import:torch";
    "Import:Module";
    "class:GradientReversal(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:setLambda";
    "Fxn:updateOutput";
    "Fxn:self.output.set_(input)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(gradOutput)";
    "Fxn:self.gradInput.copy_(gradOutput)";
    "Fxn:self.gradInput.mul_(-self.lambd)";
    "/torch/legacy/nn/HardShrink.py";
    "Import:torch";
    "Import:Module";
    "class:HardShrink(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.HardShrink_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.HardShrink_updateGradInput(";
    "/torch/legacy/nn/HardTanh.py";
    "Import:torch";
    "Import:Module";
    "class:HardTanh(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.HardTanh_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.HardTanh_updateGradInput(";
    "/torch/legacy/nn/HingeEmbeddingCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:HingeEmbeddingCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.buffer.resize_as_(input).copy_(input)";
    "Fxn:self.buffer[torch.eq(y,";
    "Fxn:self.buffer.sum().item()";
    "Fxn:self.buffer.fill_(self.margin).add_(-1,";
    "Fxn:self.buffer.clamp_(min=0)";
    "Fxn:self.buffer[torch.eq(y,";
    "Fxn:self.buffer.sum().item()";
    "Fxn:input.nelement()";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).copy_(y)";
    "Fxn:self.gradInput[torch.mul(torch.eq(y,";
    "Fxn:torch.gt(input,";
    "Fxn:self.gradInput.mul_(1.";
    "Fxn:input.nelement())";
    "/torch/legacy/nn/Identity.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Identity(Module):";
    "Fxn:updateOutput";
    "Fxn:updateGradInput";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "/torch/legacy/nn/Index.py";
    "Import:torch";
    "Import:Module";
    "class:Index(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:torch.index_select(t,";
    "Fxn:updateGradInput";
    "Fxn:gradInput.resize_as_(t).zero_()";
    "Fxn:gradInput.index_add_(self.dimension,";
    "/torch/legacy/nn/JoinTable.py";
    "Import:torch";
    "Import:Module";
    "class:JoinTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Size()";
    "Fxn:_getPositiveDimension";
    "Fxn:input[0].dim()";
    "Fxn:updateOutput";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:currentOutput.size(dim)";
    "Fxn:torch.Size(size)";
    "Fxn:self.output.resize_(self.size)";
    "Fxn:self.output.narrow(dim,";
    "Fxn:currentOutput.size(dim)).copy_(currentOutput)";
    "Fxn:currentOutput.size(dim)";
    "Fxn:updateGradInput";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:self.gradInput.append(input[i].new())";
    "Fxn:self.gradInput[i].resize_as_(input[i])";
    "Fxn:self.gradInput[:len(input)]";
    "Fxn:gradOutput.narrow(dim,";
    "Fxn:currentOutput.size(dim))";
    "Fxn:self.gradInput[i].copy_(currentGradInput)";
    "Fxn:currentOutput.size(dim)";
    "Fxn:type";
    "Fxn:self).type(type,";
    "/torch/legacy/nn/L1Cost.py";
    "Import:torch";
    "Import:Criterion";
    "Import:clear";
    "class:L1Cost(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(1)";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:self._backend.L1Cost_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:self._backend.L1Cost_updateGradInput(";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/L1HingeEmbeddingCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:L1HingeEmbeddingCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:updateOutput";
    "Fxn:_mathsign";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput[0].resize_as_(input[0])";
    "Fxn:self.gradInput[1].resize_as_(input[1])";
    "Fxn:self.gradInput[0].copy_(input[0])";
    "Fxn:self.gradInput[0].add_(-1,";
    "Fxn:self.gradInput[0].norm(1)";
    "Fxn:self.gradInput[0].sign_()";
    "Fxn:self.gradInput[0].zero_()";
    "Fxn:self.gradInput[0].mul_(-1)";
    "Fxn:self.gradInput[1].zero_().add_(-1,";
    "/torch/legacy/nn/L1Penalty.py";
    "Import:torch";
    "Import:Module";
    "class:L1Penalty(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.nelement()";
    "Fxn:input.norm(1)";
    "Fxn:updateGradInput";
    "Fxn:input.nelement()";
    "Fxn:self.gradInput.resize_as_(input).copy_(input).sign_().mul_(m)";
    "Fxn:self.gradInput.add_(gradOutput)";
    "/torch/legacy/nn/LeakyReLU.py";
    "Import:torch";
    "Import:Module";
    "class:LeakyReLU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.LeakyReLU_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.LeakyReLU_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:'({:.4f})'.format(self.negval)";
    "/torch/legacy/nn/Linear.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Linear(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(outputSize,";
    "Fxn:torch.Tensor(outputSize,";
    "Fxn:torch.Tensor(outputSize)";
    "Fxn:torch.Tensor(outputSize)";
    "Fxn:self.reset()";
    "Fxn:noBias";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_updateAddBuffer";
    "Fxn:input.size(0)";
    "Fxn:input.new()";
    "Fxn:self.addBuffer.nelement()";
    "Fxn:self.addBuffer.resize_(nframe).fill_(1)";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:input.size(0)";
    "Fxn:self.output.nelement()";
    "Fxn:self.output.resize_(nframe,";
    "Fxn:self.weight.size(0))";
    "Fxn:self.output.nelement()";
    "Fxn:self.output.zero_()";
    "Fxn:self._updateAddBuffer(input)";
    "Fxn:self.output.addmm_(0,";
    "Fxn:self.weight.t())";
    "Fxn:self.output.addr_(self.addBuffer,";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.nelement()";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.gradInput.nelement()";
    "Fxn:self.gradInput.zero_()";
    "Fxn:input.dim()";
    "Fxn:self.gradInput.addmm_(0,";
    "Fxn:accGradParameters";
    "Fxn:input.dim()";
    "Fxn:self.gradWeight.addmm_(scale,";
    "Fxn:gradOutput.t(),";
    "Fxn:self._updateAddBuffer(input)";
    "Fxn:self.gradBias.addmv_(scale,";
    "Fxn:gradOutput.t(),";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{})'.format(self.weight.size(1),";
    "Fxn:self.weight.size(0))";
    "/torch/legacy/nn/Log.py";
    "Import:torch";
    "Import:Module";
    "class:Log(Module):";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input)";
    "Fxn:self.output.copy_(input)";
    "Fxn:self.output.log_()";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.gradInput.fill_(1)";
    "Fxn:self.gradInput.div_(input)";
    "Fxn:self.gradInput.mul_(gradOutput)";
    "/torch/legacy/nn/LogSigmoid.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:LogSigmoid(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self._backend.LogSigmoid_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.LogSigmoid_updateGradInput(";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/LogSoftMax.py";
    "Import:torch";
    "Import:Module";
    "class:LogSoftMax(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_get_dim";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "Fxn:updateOutput";
    "Fxn:self._backend.LogSoftMax_updateOutput(";
    "Fxn:self._get_dim(input)";
    "Fxn:updateGradInput";
    "Fxn:self._backend.LogSoftMax_updateGradInput(";
    "Fxn:self._get_dim(input)";
    "/torch/legacy/nn/LookupTable.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:LookupTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(nIndex,";
    "Fxn:torch.Tensor(nIndex,";
    "Fxn:nOutput).zero_()";
    "Fxn:torch.IntTensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:self.reset()";
    "Fxn:accUpdateOnly";
    "Fxn:setPadding";
    "Fxn:setMaxNorm";
    "Fxn:setNormType";
    "Fxn:scaleGradByFreq";
    "Fxn:reset";
    "Fxn:self.weight.normal_(0,";
    "Fxn:_makeInputContiguous";
    "Fxn:input.is_contiguous()";
    "Fxn:input.type()";
    "Fxn:self._input.type():";
    "Fxn:self._input.resize_(input.size()).copy_(input)";
    "Fxn:updateOutput";
    "Fxn:self.renorm(input)";
    "Fxn:self._makeInputContiguous(input)";
    "Fxn:input.dim()";
    "Fxn:torch.index_select(self.weight,";
    "Fxn:input.dim()";
    "Fxn:torch.index_select(self.weight,";
    "Fxn:input.view(-1),";
    "Fxn:self.output.view(input.size(0),";
    "Fxn:input.size(1),";
    "Fxn:self.weight.size(1))";
    "Fxn:RuntimeError("input";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.type()";
    "Fxn:input.type():";
    "Fxn:input.new()";
    "Fxn:self.gradInput.is_same_size(input):";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:accGradParameters";
    "Fxn:input.dim()";
    "Fxn:input.view(-1)";
    "Fxn:input.dim()";
    "Fxn:RuntimeError("input";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self._backend.LookupTable_accGradParameters(";
    "Fxn:renorm";
    "Fxn:self._input.resize_(input.size()).copy_(input)";
    "Fxn:row_idx.dim()";
    "Fxn:row_idx.view(-1)";
    "Fxn:row_idx.dim()";
    "Fxn:RuntimeError("input";
    "Fxn:self._backend.LookupTable_renorm(";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:torch.cuda.LongTensor()";
    "Fxn:torch.cuda.LongTensor()";
    "Fxn:torch.cuda.LongTensor()";
    "Fxn:torch.cuda.LongTensor()";
    "Fxn:torch.IntTensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/MarginCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:MarginCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:self._backend.MarginCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:self._backend.MarginCriterion_updateGradInput(";
    "/torch/legacy/nn/MarginRankingCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:MarginRankingCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:updateOutput";
    "Fxn:input[0].size(0)";
    "Fxn:input[0].clone()";
    "Fxn:self._output.resize_as_(input[0])";
    "Fxn:self._output.copy_(input[0])";
    "Fxn:self._output.add_(-1,";
    "Fxn:self._output.mul_(-1).mul_(y)";
    "Fxn:self._output.add_(self.margin)";
    "Fxn:self._output.clamp_(min=0)";
    "Fxn:self._output.sum().item()";
    "Fxn:y.size(0)";
    "Fxn:updateGradInput";
    "Fxn:input[0].size(0)";
    "Fxn:input[0].new()";
    "Fxn:self.dist.resize_as_(input[0]).copy_(input[0])";
    "Fxn:dist.add_(-1,";
    "Fxn:dist.mul_(-1).mul_(y)";
    "Fxn:dist.add_(self.margin)";
    "Fxn:torch.ge(dist,";
    "Fxn:self.gradInput[0].resize_(dist.size())";
    "Fxn:self.gradInput[1].resize_(dist.size())";
    "Fxn:self.gradInput[0].copy_(mask)";
    "Fxn:self.gradInput[0].mul_(-1).mul_(y)";
    "Fxn:self.gradInput[1].copy_(mask)";
    "Fxn:self.gradInput[1].mul_(y)";
    "Fxn:self.gradInput[0].div_(y.size(0))";
    "Fxn:self.gradInput[1].div_(y.size(0))";
    "/torch/legacy/nn/MaskedSelect.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:MaskedSelect(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.FloatTensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.ByteTensor()";
    "Fxn:updateOutput";
    "Fxn:torch.masked_select(input,";
    "Fxn:updateGradInput";
    "Fxn:input.type()";
    "Fxn:torch.arange(0,";
    "Fxn:mask.nelement(),";
    "Fxn:out=self._maskIndexBufferCPU).resize_(mask.size())";
    "Fxn:self._maskIndexBuffer.resize_(self._maskIndexBufferCPU.size()).copy_(self._maskIndexBufferCPU)";
    "Fxn:torch.arange(0,";
    "Fxn:mask.nelement(),";
    "Fxn:out=self._maskIndexBuffer).resize_(mask.size())";
    "Fxn:torch.masked_select(self._maskIndexBuffer,";
    "Fxn:self._gradBuffer.resize_(input.nelement()).zero_()";
    "Fxn:self._gradBuffer.scatter_(0,";
    "Fxn:self._gradBuffer.resize_(input.size())";
    "Fxn:self._gradMask.resize_(mask.size()).fill_(0)]";
    "Fxn:type";
    "Fxn:self._gradBuffer.type(type)";
    "Fxn:self.gradInput.type(type)";
    "Fxn:self.output.type(type)";
    "Fxn:self._maskIndexBuffer.long()";
    "Fxn:self._maskIndices.long()";
    "Fxn:self._gradMask.byte()";
    "Fxn:self._maskIndexBuffer.cuda()";
    "Fxn:self._maskIndices.cuda()";
    "Fxn:self._gradMask.cuda()";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "/torch/legacy/nn/Max.py";
    "Import:torch";
    "Import:Module";
    "Import:clear,";
    "class:Max(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension";
    "Fxn:input.dim()";
    "Fxn:_lazyInit";
    "Fxn:self.output.new()";
    "Fxn:torch.LongTensor())";
    "Fxn:updateOutput";
    "Fxn:self._lazyInit()";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:torch.max(input,";
    "Fxn:out=(self._output,";
    "Fxn:input.dim()";
    "Fxn:self.output.set_(self._output.select(dimension,";
    "Fxn:self.output.set_(self._output)";
    "Fxn:updateGradInput";
    "Fxn:self._lazyInit()";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:input.dim()";
    "Fxn:addSingletondimension(gradOutput,";
    "Fxn:self.gradInput.resize_as_(input).zero_().scatter_(dimension,";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:indices.type('torch.cuda.LongTensor')";
    "Fxn:self).type(type,";
    "Fxn:indices.long()";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Mean.py";
    "Import:torch";
    "Import:Sum";
    "class:Mean(Sum):";
    "Fxn:__init__";
    "Fxn:self).__init__(dimension,";
    "/torch/legacy/nn/Min.py";
    "Import:torch";
    "Import:Module";
    "Import:clear,";
    "class:Min(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension";
    "Fxn:input.dim()";
    "Fxn:_lazyInit";
    "Fxn:self.output.new()";
    "Fxn:self.output.type()";
    "Fxn:torch.LongTensor())";
    "Fxn:updateOutput";
    "Fxn:self._lazyInit()";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:torch.min(input,";
    "Fxn:out=(self._output,";
    "Fxn:input.dim()";
    "Fxn:self.output.set_(self._output.select(dimension,";
    "Fxn:self.output.set_(self._output)";
    "Fxn:updateGradInput";
    "Fxn:self._lazyInit()";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:input.dim()";
    "Fxn:addSingletondimension(gradOutput,";
    "Fxn:self.gradInput.resize_as_(input).zero_().scatter_(dimension,";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:indices.type('torch.cuda.LongTensor')";
    "Fxn:self).type(type,";
    "Fxn:indices.long()";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/MixtureTable.py";
    "Import:torch";
    "Import:Module";
    "Import:clear,";
    "class:MixtureTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Size()";
    "Fxn:torch.Size()";
    "Fxn:updateOutput";
    "Fxn:input[0].new()";
    "Fxn:input[0].new()";
    "Fxn:input[0].new()";
    "Fxn:gaterInput.size(0)";
    "Fxn:gaterInput.size(self.dimG)";
    "Fxn:RuntimeError("Should";
    "Fxn:gaterInput.size(0)";
    "Fxn:gaterInput.size(self.dimG)";
    "Fxn:torch.Size(size)";
    "Fxn:self.output.resize_as_(expertInput)";
    "Fxn:gaterInput.view(self.size)";
    "Fxn:self.output.zero_()";
    "Fxn:self._gaterView.select(self.dim,";
    "Fxn:i).expand_as(expertInput)";
    "Fxn:self.output.addcmul_(expertInput,";
    "Fxn:expertInputs.dim()";
    "Fxn:gaterInput.size(0)";
    "Fxn:gaterInput.size(self.dimG)";
    "Fxn:torch.Size(size)";
    "Fxn:self.output.resize_as_(expertInputs.select(self.dim,";
    "Fxn:gaterInput.view(self.size)";
    "Fxn:torch.mul(self._gaterView.expand_as(expertInputs),";
    "Fxn:torch.sum(self._expert,";
    "Fxn:self.output.resize_as_(expertInputs.select(self.dim,";
    "Fxn:updateGradInput";
    "Fxn:recursiveResizeAs(self.gradInput,";
    "Fxn:input[0].new()";
    "Fxn:input[0].new()";
    "Fxn:input[0].new()";
    "Fxn:expertInput.clone()";
    "Fxn:expertGradInput.resize_as_(expertInput)";
    "Fxn:gaterGradInput.resize_as_(gaterInput)";
    "Fxn:torch.mul(gradOutput,";
    "Fxn:self._expert.view(-1)";
    "Fxn:self._expert.view(gradOutput.size(0),";
    "Fxn:torch.sum(self._expertView,";
    "Fxn:self._sum.select(self.dimG,";
    "Fxn:gaterGradInput.select(self.dimG,";
    "Fxn:i).copy_(self._sum.select(self.dimG,";
    "Fxn:self._gaterView.select(self.dim,";
    "Fxn:i).expand_as(expertGradInput)";
    "Fxn:expertGradInput.mul_(gate,";
    "Fxn:torch.Size(size2)";
    "Fxn:gaterGradInput.resize_as_(gaterInput)";
    "Fxn:gradOutput.contiguous().view(torch.Size(self.size2))";
    "Fxn:self._expertView.expand_as(expertInputs)";
    "Fxn:torch.mul(gradOutput,";
    "Fxn:self._expert.transpose(self.dim,";
    "Fxn:expert.is_contiguous():";
    "Fxn:self._expert2.resize_as_(expert)";
    "Fxn:self._expert2.copy_(expert)";
    "Fxn:expert.view(gaterInput.size(0),";
    "Fxn:expert.view(gaterInput.size(0),";
    "Fxn:gaterInput.size(1),";
    "Fxn:torch.sum(self._expertView2,";
    "Fxn:gaterGradInput.resize_as_(gaterInput)";
    "Fxn:torch.mul(self._gaterView.expand_as(expertInputs),";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/MM.py";
    "Import:torch";
    "Import:Module";
    "class:MM(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:updateOutput";
    "Fxn:a.ndimension()";
    "Fxn:a.ndimension()";
    "Fxn:a.dim()";
    "Fxn:b.dim()";
    "Fxn:a.ndimension()";
    "Fxn:a.t()";
    "Fxn:b.t()";
    "Fxn:self.output.resize_(a.size(0),";
    "Fxn:b.size(1))";
    "Fxn:torch.mm(a,";
    "Fxn:a.transpose(1,";
    "Fxn:b.transpose(1,";
    "Fxn:self.output.resize_(a.size(0),";
    "Fxn:a.size(1),";
    "Fxn:b.size(2))";
    "Fxn:torch.bmm(a,";
    "Fxn:updateGradInput";
    "Fxn:input[0].new()";
    "Fxn:input[1].new()";
    "Fxn:self.gradInput[0].resize_as_(a)";
    "Fxn:self.gradInput[1].resize_as_(b)";
    "Fxn:gradOutput.ndimension()";
    "Fxn:gradOutput.ndimension()";
    "Fxn:a.dim()";
    "Fxn:b.dim()";
    "Fxn:gradOutput.dim()";
    "Fxn:gradOutput.ndimension()";
    "Fxn:a.transpose(h_dim,";
    "Fxn:b.transpose(h_dim,";
    "Fxn:f)(b,";
    "Fxn:gradOutput.transpose(h_dim,";
    "Fxn:f)(gradOutput,";
    "Fxn:f)(gradOutput.transpose(h_dim,";
    "Fxn:f)(a,";
    "/torch/legacy/nn/Module.py";
    "Import:torch";
    "Import:torch._thnn";
    "Import:clear,";
    "class:Module(object):";
    "Fxn:__init__";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:self.output.type()";
    "Fxn:torch._thnn.type2backend[self.output.type()]";
    "Fxn:__repr__";
    "Fxn:parameters";
    "Fxn:updateOutput";
    "Fxn:forward";
    "Fxn:self.updateOutput(input)";
    "Fxn:backward";
    "Fxn:self.updateGradInput(input,";
    "Fxn:self.accGradParameters(input,";
    "Fxn:backwardUpdate";
    "Fxn:self.updateGradInput(input,";
    "Fxn:self.accUpdateGradParameters(input,";
    "Fxn:updateGradInput";
    "Fxn:accGradParameters";
    "Fxn:accUpdateGradParameters";
    "Fxn:self.accGradParameters(input,";
    "Fxn:sharedAccUpdateGradParameters";
    "Fxn:self.parameters():";
    "Fxn:self.zeroGradParameters()";
    "Fxn:self.accGradParameters(input,";
    "Fxn:self.updateParameters(lr)";
    "Fxn:zeroGradParameters";
    "Fxn:self.parameters()";
    "Fxn:grad.zero_()";
    "Fxn:updateParameters";
    "Fxn:self.parameters()";
    "Fxn:self.parameters()";
    "Fxn:p.add_(-learningRate,";
    "Fxn:training";
    "Fxn:evaluate";
    "Fxn:share";
    "Fxn:clone";
    "Fxn:type";
    "Fxn:self.__dict__.items():";
    "Fxn:recursiveType(param,";
    "Fxn:float";
    "Fxn:self.type('torch.FloatTensor',";
    "Fxn:double";
    "Fxn:self.type('torch.DoubleTensor',";
    "Fxn:cuda";
    "Fxn:self.type('torch.cuda.FloatTensor',";
    "Fxn:reset";
    "Fxn:write";
    "Fxn:read";
    "Fxn:for_each()";
    "Fxn:_flatten";
    "Fxn:isCompact";
    "Fxn:size.cumprod(0)?";
    "Fxn:torch.sort(torch.LongTensor(tensor.stride()),";
    "Fxn:torch.LongTensor(list(tensor.size())).index_select(0,";
    "Fxn:1).sum())";
    "Fxn:sortedStride.narrow(0,";
    "Fxn:nRealDim).clone()";
    "Fxn:sortedSize.narrow(0,";
    "Fxn:nRealDim).clone()";
    "Fxn:tensor.new().set_(tensor.storage(),";
    "Fxn:t.is_contiguous()";
    "Fxn:torch.Tensor()";
    "Fxn:Module._flattenTensorBuffer.get(type(parameters[0]),";
    "Fxn:param.storage()";
    "Fxn:storage.size()";
    "Fxn:parameterMeta.append({";
    "Fxn:param.storage_offset()";
    "Fxn:param.size(),";
    "Fxn:param.stride()";
    "Fxn:BufferTensor(num_parameters).zero_()";
    "Fxn:BufferTensor().set_(flatParameters.storage(),";
    "Fxn:tmp.fill_(1)";
    "Fxn:isCompact(tmp)";
    "Fxn:flatParameters.byte().clone()";
    "Fxn:flatParameters.long().cumsum(0)";
    "Fxn:storages.values():";
    "Fxn:flatParameters[slice(offset,";
    "Fxn:storage.size())].copy_(Tensor().set_(storage))";
    "Fxn:param.set_()";
    "Fxn:BufferTensor(used_parameters).copy_(";
    "Fxn:flatParameters.masked_select(maskParameters))";
    "Fxn:Tensor(flatParameters.nelement()).copy_(flatParameters)";
    "Fxn:param.set_(flatParameters.storage(),";
    "Fxn:flattenParameters";
    "Fxn:self.parameters()";
    "Fxn:self._flatten(parameters),";
    "Fxn:self._flatten(gradParameters)";
    "Fxn:p.nelement()";
    "Fxn:g.nelement()";
    "Fxn:param.storage_offset()";
    "Fxn:grad.storage_offset()";
    "Fxn:apply";
    "Fxn:callback(self)";
    "Fxn:module.apply(callback)";
    "Fxn:findModules";
    "Fxn:nodes.append(self)";
    "Fxn:containers.append(container)";
    "Fxn:child.findModules(cls,";
    "Fxn:nodes.extend(child_nodes)";
    "Fxn:containers.extend(child_containers)";
    "Fxn:listModules";
    "Fxn:modules.extend(child.listModules())";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:replace";
    "Fxn:callback(self)";
    "Fxn:module.replace(callback)";
    "/torch/legacy/nn/MSECriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:MSECriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:self._backend.MSECriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:torch.Tensor([1]).type(input.type())";
    "Fxn:self._backend.MSECriterion_updateGradInput(";
    "/torch/legacy/nn/Mul.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:Mul(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(1)";
    "Fxn:torch.Tensor(1)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.weight.size(0))";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:self.output.mul_(self.weight[0])";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:self.gradInput.add_(self.weight[0],";
    "Fxn:accGradParameters";
    "Fxn:input.contiguous().view(-1).dot(gradOutput.contiguous().view(-1)))";
    "/torch/legacy/nn/MulConstant.py";
    "Import:torch";
    "Import:Module";
    "class:MulConstant(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.mul_(self.constant_scalar)";
    "Fxn:self.output.set_(input)";
    "Fxn:self.output.resize_as_(input)";
    "Fxn:self.output.copy_(input)";
    "Fxn:self.output.mul_(self.constant_scalar)";
    "Fxn:updateGradInput";
    "Fxn:gradOutput.mul_(self.constant_scalar)";
    "Fxn:self.gradInput.set_(gradOutput)";
    "Fxn:input.div_(self.constant_scalar)";
    "Fxn:self.gradInput.resize_as_(gradOutput)";
    "Fxn:self.gradInput.copy_(gradOutput)";
    "Fxn:self.gradInput.mul_(self.constant_scalar)";
    "/torch/legacy/nn/MultiCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "Import:recursiveResizeAs,";
    "class:MultiCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.DoubleStorage()";
    "Fxn:add";
    "Fxn:self.criterions.append(criterion)";
    "Fxn:torch.DoubleStorage(len(self.criterions))";
    "Fxn:new_weights[len(self.criterions)";
    "Fxn:updateOutput";
    "Fxn:self.criterions[i].updateOutput(input,";
    "Fxn:updateGradInput";
    "Fxn:recursiveResizeAs(self.gradInput,";
    "Fxn:recursiveFill(self.gradInput,";
    "Fxn:recursiveAdd(self.gradInput,";
    "Fxn:self.criterions[i].updateGradInput(input,";
    "Fxn:type";
    "Fxn:criterion.type(type)";
    "Fxn:self).type(type)";
    "/torch/legacy/nn/MultiLabelMarginCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:MultiLabelMarginCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor()";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:target.long()";
    "Fxn:self._backend.MultiLabelMarginCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:target.long()";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.MultiLabelMarginCriterion_updateGradInput(";
    "/torch/legacy/nn/MultiLabelSoftMarginCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "Import:Sigmoid";
    "Import:BCECriterion";
    "class:MultiLabelSoftMarginCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Sigmoid()";
    "Fxn:BCECriterion(weights)";
    "Fxn:updateOutput";
    "Fxn:input.nelement()";
    "Fxn:input.squeeze()";
    "Fxn:target.nelement()";
    "Fxn:target.squeeze()";
    "Fxn:self.lsm.updateOutput(input)";
    "Fxn:self.nll.updateOutput(self.lsm.output,";
    "Fxn:updateGradInput";
    "Fxn:input.size()";
    "Fxn:input.nelement()";
    "Fxn:input.squeeze()";
    "Fxn:target.nelement()";
    "Fxn:target.squeeze()";
    "Fxn:self.nll.updateGradInput(self.lsm.output,";
    "Fxn:self.lsm.updateGradInput(input,";
    "Fxn:self.lsm.gradInput.view(size)";
    "/torch/legacy/nn/MultiMarginCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:MultiMarginCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError("only";
    "Fxn:weights.dim()";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:target.long()";
    "Fxn:self._backend.MultiMarginCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:target.long()";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.MultiMarginCriterion_updateGradInput(";
    "/torch/legacy/nn/MV.py";
    "Import:torch";
    "Import:Module";
    "class:MV(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:[torch.Tensor(),";
    "Fxn:torch.Tensor()]";
    "Fxn:updateOutput";
    "Fxn:M.ndimension()";
    "Fxn:M.ndimension()";
    "Fxn:M.ndimension()";
    "Fxn:v.ndimension()";
    "Fxn:M.transpose(0,";
    "Fxn:self.output.resize_(M.size(0))";
    "Fxn:torch.mv(M,";
    "Fxn:v.ndimension()";
    "Fxn:M.transpose(1,";
    "Fxn:self.output.resize_(M.size(0),";
    "Fxn:M.size(1),";
    "Fxn:torch.bmm(M,";
    "Fxn:v.view(v.size(0),";
    "Fxn:v.size(1),";
    "Fxn:out=self.output).resize_(M.size(0),";
    "Fxn:M.size(1))";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput[0].resize_as_(M)";
    "Fxn:self.gradInput[1].resize_as_(v)";
    "Fxn:gradOutput.contiguous()";
    "Fxn:gradOutput.ndimension()";
    "Fxn:gradOutput.ndimension()";
    "Fxn:gradOutput.ndimension()";
    "Fxn:M.ndimension()";
    "Fxn:v.ndimension()";
    "Fxn:M.size(0)";
    "Fxn:M.size(1)";
    "Fxn:M.size(2)";
    "Fxn:torch.bmm(v.view(bdim,";
    "Fxn:gradOutput.view(bdim,";
    "Fxn:torch.bmm(M,";
    "Fxn:gradOutput.view(bdim,";
    "Fxn:out=self.gradInput[1].view(bdim,";
    "Fxn:torch.bmm(gradOutput.view(bdim,";
    "Fxn:v.view(bdim,";
    "Fxn:torch.bmm(M.transpose(1,";
    "Fxn:gradOutput.view(bdim,";
    "Fxn:out=self.gradInput[1].view(bdim,";
    "Fxn:M.ndimension()";
    "Fxn:v.ndimension()";
    "Fxn:torch.ger(v,";
    "Fxn:torch.ger(gradOutput,";
    "Fxn:M.t()";
    "/torch/legacy/nn/Narrow.py";
    "Import:torch";
    "Import:Module";
    "class:Narrow(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.size(self.dimension)";
    "Fxn:input.narrow(self.dimension,";
    "Fxn:self.output.type_as(output)";
    "Fxn:self.output.resize_as_(output).copy_(output)";
    "Fxn:updateGradInput";
    "Fxn:input.size(self.dimension)";
    "Fxn:self.gradInput.type_as(input)";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:self.gradInput.narrow(self.dimension,";
    "Fxn:length).copy_(gradOutput)";
    "/torch/legacy/nn/NarrowTable.py";
    "Import:torch";
    "Import:Module";
    "Import:clear,";
    "class:NarrowTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:updateGradInput";
    "Fxn:input[i].new()";
    "Fxn:recursiveResizeAs(gi,";
    "Fxn:recursiveFill(self.gradInput[i],";
    "Fxn:type";
    "Fxn:clear(self,";
    "Fxn:self).type(self,";
    "/torch/legacy/nn/Normalize.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Normalize(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:input.size()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self._output.resize_as_(input)";
    "Fxn:torch.cuda.FloatTensor()";
    "Fxn:torch.typename(self.output)";
    "Fxn:torch.LongTensor()";
    "Fxn:torch.abs(input,";
    "Fxn:torch.max(self._indices,";
    "Fxn:self.norm.add_(self.eps)";
    "Fxn:input.new()";
    "Fxn:torch.abs(input,";
    "Fxn:out=self.buffer).pow_(self.p)";
    "Fxn:torch.pow(input,";
    "Fxn:torch.sum(self.buffer,";
    "Fxn:keepdim=True).add_(self.eps)";
    "Fxn:torch.pow(self.normp,";
    "Fxn:torch.div(input,";
    "Fxn:self.norm.view(-1,";
    "Fxn:1).expand_as(input),";
    "Fxn:self._output.view(input_size)";
    "Fxn:updateGradInput";
    "Fxn:input.dim()";
    "Fxn:gradOutput.dim()";
    "Fxn:input.size()";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self._gradInput.resize_(n,";
    "Fxn:torch.mul(self.norm.view(n,";
    "Fxn:1).expand(n,";
    "Fxn:self.buffer.resize_as_(input).zero_()";
    "Fxn:self.cross.resize_(n,";
    "Fxn:torch.gather(input,";
    "Fxn:self.cross.div_(self.norm)";
    "Fxn:self.buffer.scatter_(1,";
    "Fxn:torch.mul(self.normp.view(n,";
    "Fxn:1).expand(n,";
    "Fxn:input*|input|^(p-2)";
    "Fxn:torch.abs(input,";
    "Fxn:out=self.buffer).add_(self.eps).pow_(self.p";
    "Fxn:2).mul_(input)";
    "Fxn:torch.abs(input,";
    "Fxn:out=self.buffer).pow_(self.p";
    "Fxn:2).mul_(input)";
    "Fxn:self.buffer.copy_(input)";
    "Fxn:torch.pow(input,";
    "Fxn:out=self.buffer).mul_(input)";
    "Fxn:self.cross.resize_(n,";
    "Fxn:b1*(b2*gradOutput).";
    "Fxn:input.new()";
    "Fxn:torch.mul(input,";
    "Fxn:torch.sum(self.buffer2,";
    "Fxn:self.buffer.mul_(self.cross.expand_as(self.buffer))";
    "Fxn:self._gradInput.add_(-1,";
    "Fxn:torch.mul(self.norm,";
    "Fxn:torch.mul(self.normp,";
    "Fxn:self._gradInput.div_(self.cross.expand(n,";
    "Fxn:self._gradInput.view(input_size)";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({})'.format(self.p)";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:self).type(type,";
    "Fxn:indices.long()";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Padding.py";
    "Import:torch";
    "Import:Module";
    "class:Padding(Module):";
    "Fxn:__init__";
    "Fxn:torch.Size()";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:torch.Size(outputSize)";
    "Fxn:self.output.resize_(self.outputSize)";
    "Fxn:self.output.fill_(self.value)";
    "Fxn:input.size(dim)";
    "Fxn:self.output.narrow(dim,";
    "Fxn:input.size(dim)).copy_(input)";
    "Fxn:input.size(dim):";
    "Fxn:self.output.narrow(dim,";
    "Fxn:input.size(dim)).copy_(input)";
    "Fxn:self.output.narrow(dim,";
    "Fxn:index).copy_(input.narrow(dim,";
    "Fxn:self.output.narrow(dim,";
    "Fxn:input.size(dim)";
    "Fxn:index).copy_(input.narrow(dim,";
    "Fxn:input.size(dim)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:input.dim()";
    "Fxn:input.size(dim)";
    "Fxn:self.gradInput.copy_(gradOutput.narrow(dim,";
    "Fxn:input.size(dim)))";
    "Fxn:input.size(dim):";
    "Fxn:self.gradInput.copy_(gradOutput.narrow(dim,";
    "Fxn:input.size(dim)))";
    "Fxn:self.gradInput.narrow(dim,";
    "Fxn:index).copy_(gradOutput.narrow(dim,";
    "Fxn:self.gradInput.narrow(dim,";
    "Fxn:input.size(";
    "Fxn:index).copy_(gradOutput.narrow(dim,";
    "Fxn:input.size(dim)";
    "/torch/legacy/nn/PairwiseDistance.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:PairwiseDistance(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor()";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_(1)";
    "Fxn:input[0].dim()";
    "Fxn:input[0].new()";
    "Fxn:torch.add(input[0],";
    "Fxn:out=self.diff).abs_()";
    "Fxn:self.output.resize_(input[0].size(0))";
    "Fxn:self.output.zero_()";
    "Fxn:self.output.add_(self.diff.pow_(self.norm).sum(1,";
    "Fxn:self.output.pow_(1.";
    "Fxn:updateGradInput";
    "Fxn:input[0].dim()";
    "Fxn:input[0].new()";
    "Fxn:self.gradInput[0].resize_(input[0].size())";
    "Fxn:input[1].new()";
    "Fxn:self.gradInput[1].resize_(input[1].size())";
    "Fxn:self.gradInput[0].copy_(input[0])";
    "Fxn:self.gradInput[0].add_(-1,";
    "Fxn:self.gradInput[0].sign_()";
    "Fxn:d/dx_k(||x||_p)";
    "Fxn:self.gradInput[0].mul_(self.gradInput[0].abs().pow_(self.norm";
    "Fxn:self.output.new()";
    "Fxn:self.outExpand.resize_(self.output.size(0),";
    "Fxn:self.outExpand.copy_(self.output.view(self.output.size(0),";
    "Fxn:self.outExpand.add_(1e-6)";
    "Fxn:self.outExpand.pow_(-(self.norm";
    "Fxn:self.gradInput[0].mul_(self.outExpand.expand(self.gradInput[0].size(0),";
    "Fxn:self.gradInput[0].size(1)))";
    "Fxn:gradOutput.new()";
    "Fxn:gradOutput.new()";
    "Fxn:self.grad.resize_as_(input[0]).zero_()";
    "Fxn:self.ones.resize_(input[0].size(1)).fill_(1)";
    "Fxn:self.grad.addr_(gradOutput,";
    "Fxn:self.gradInput[0].mul_(self.grad)";
    "Fxn:self.gradInput[1].zero_().add_(-1,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Parallel.py";
    "Import:torch";
    "Import:Container";
    "class:Parallel(Container):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.size(self.inputDimension)";
    "Fxn:input.select(self.inputDimension,";
    "Fxn:self.modules[i].updateOutput(currentInput)";
    "Fxn:outputs.append(currentOutput)";
    "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:torch.Size(totalOutputSize)";
    "Fxn:self.output.resize_(self.totalOutputSize)";
    "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:self.output.narrow(self.outputDimension,";
    "Fxn:outputSize).copy_(currentOutput)";
    "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:updateGradInput";
    "Fxn:input.size(self.inputDimension)";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:input.select(self.inputDimension,";
    "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:gradOutput.narrow(self.outputDimension,";
    "Fxn:module.updateGradInput(currentInput,";
    "Fxn:self.gradInput.select(self.inputDimension,";
    "Fxn:i).copy_(currentGradInput)";
    "Fxn:accGradParameters";
    "Fxn:input.size(self.inputDimension)";
    "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:module.accGradParameters(";
    "Fxn:input.select(self.inputDimension,";
    "Fxn:gradOutput.narrow(self.outputDimension,";
    "Fxn:accUpdateGradParameters";
    "Fxn:input.size(self.inputDimension)";
    "Fxn:module.accupdateGradParameters(";
    "Fxn:input.select(self.inputDimension,";
    "Fxn:gradOutput.narrow(self.outputDimension,";
    "Fxn:currentOutput.size(self.outputDimension)),";
    "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:__repr__";
    "Fxn:torch.typename(self)";
    "Fxn:'('";
    "Fxn:'('";
    "/torch/legacy/nn/ParallelCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "Import:recursiveResizeAs,";
    "class:ParallelCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:add";
    "Fxn:self.criterions.append(criterion)";
    "Fxn:self.weights.append(weight)";
    "Fxn:updateOutput";
    "Fxn:criterion.updateOutput(input[i],";
    "Fxn:updateGradInput";
    "Fxn:recursiveResizeAs(self.gradInput,";
    "Fxn:recursiveFill(self.gradInput,";
    "Fxn:recursiveAdd(self.gradInput[i],";
    "Fxn:criterion.updateGradInput(input[i],";
    "Fxn:type";
    "Fxn:self).type(type,";
    "/torch/legacy/nn/ParallelTable.py";
    "Import:torch";
    "Import:Container";
    "class:ParallelTable(Container):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self.modules[i].updateOutput(input[i])";
    "Fxn:self.output.append(tmp)";
    "Fxn:updateGradInput";
    "Fxn:module.updateGradInput(input[i],";
    "Fxn:self.gradInput.append(tmp)";
    "Fxn:accGradParameters";
    "Fxn:module.accGradParameters(input[i],";
    "Fxn:accUpdateGradParameters";
    "Fxn:module.accUpdateGradParameters(input[i],";
    "Fxn:__repr__";
    "Fxn:torch.typename(self)";
    "Fxn:'('";
    "Fxn:'('";
    "/torch/legacy/nn/PartialLinear.py";
    "Import:torch";
    "Import:Module";
    "Import:Identity";
    "Import:LookupTable";
    "Import:Sequential";
    "Import:ParallelTable";
    "Import:class";
    "class:PartialLinear(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ParallelTable()";
    "Fxn:pt.add(Identity()).add(LookupTable(outputsize,";
    "Fxn:Sequential().add(pt).add(MM(False,";
    "Fxn:torch.zeros(1,";
    "Fxn:torch.zeros(1,";
    "Fxn:torch.arange(0,";
    "Fxn:self.outputsize).long()";
    "Fxn:self.resetPartition()";
    "Fxn:setPartition";
    "Fxn:indices.type(self.allcolumns.type())";
    "Fxn:resetPartition";
    "Fxn:parameters";
    "Fxn:[self.network.get(0).get(1).weight,";
    "Fxn:[self.network.get(0).get(1).gradWeight,";
    "Fxn:updateOutput";
    "Fxn:self.output.set_(self.network.forward([input,";
    "Fxn:self.output.add_(torch.index_select(self.bias,";
    "Fxn:self.partition).expand_as(self.output))";
    "Fxn:input.new()";
    "Fxn:self.addBuffer.nelement()";
    "Fxn:input.size(0):";
    "Fxn:self.addBuffer.resize_(input.size(0)).fill_(1)";
    "Fxn:updateGradInput";
    "Fxn:self.network.updateGradInput([input,";
    "Fxn:self.gradInput.set_(self.network.gradInput[0])";
    "Fxn:accGradParameters";
    "Fxn:self.network.accGradParameters([input,";
    "Fxn:input.new()";
    "Fxn:self.buffer.resize_(gradOutput.size(1))";
    "Fxn:torch.mv(gradOutput.t(),";
    "Fxn:out=self.buffer).mul_(scale)";
    "Fxn:self.gradBias.index_add_(";
    "Fxn:self.buffer.view(1,";
    "Fxn:self.buffer.nelement())";
    "Fxn:accUpdateGradParameters";
    "Fxn:self.network.get(0).get(1).gradWeight";
    "Fxn:self.network.get(0).get(1).gradWeight";
    "Fxn:self.network.get(0).get(1).weight";
    "Fxn:self.accGradParameters(input,";
    "Fxn:self.network.get(0).get(1).gradWeight";
    "Fxn:zeroGradParameters";
    "Fxn:self.network.zeroGradParameters()";
    "Fxn:self.gradBias.zero_()";
    "Fxn:updateParameters";
    "Fxn:self.network.updateParameters(learningRate)";
    "Fxn:self.bias._add(-learningRate,";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:self.partition.long()";
    "Fxn:self.allcolumns.long()";
    "Fxn:self.allcolumns.cuda()";
    "Fxn:self.partition.cuda()";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{})'.format(self.inputsize,";
    "/torch/legacy/nn/Power.py";
    "Import:torch";
    "Import:Module";
    "class:Power(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:self.output.pow_(self.pow)";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).copy_(input)";
    "Fxn:self.gradInput.pow_(self.pow";
    "Fxn:self.gradInput.mul_(gradOutput).mul_(self.pow)";
    "/torch/legacy/nn/PReLU.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:PReLU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(nOutputPlane";
    "Fxn:1).fill_(0.25)";
    "Fxn:torch.Tensor(nOutputPlane";
    "Fxn:updateOutput";
    "Fxn:self._backend.PReLU_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.PReLU_updateGradInput(";
    "Fxn:accGradParameters";
    "Fxn:self._backend.PReLU_accGradParameters(";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/ReLU.py";
    "Import:torch";
    "Import:Threshold";
    "class:ReLU(Threshold):";
    "Fxn:__init__";
    "Fxn:self).__init__(0,";
    "/torch/legacy/nn/ReLU6.py";
    "Import:torch";
    "Import:Module";
    "class:ReLU6(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.HardTanh_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.HardTanh_updateGradInput(";
    "/torch/legacy/nn/Replicate.py";
    "Import:torch";
    "Import:Module";
    "class:Replicate(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:size.insert(self.dim,";
    "Fxn:stride.insert(self.dim,";
    "Fxn:self.output.set_(input.storage(),";
    "Fxn:input.storage_offset(),";
    "Fxn:torch.Size(size),";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:size.insert(self.dim,";
    "Fxn:self.gradInput.view(*size)";
    "Fxn:torch.sum(gradOutput,";
    "/torch/legacy/nn/Reshape.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Reshape(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Size(args)";
    "Fxn:updateOutput";
    "Fxn:input.is_contiguous():";
    "Fxn:input.new()";
    "Fxn:self._input.resize_as_(input)";
    "Fxn:self._input.copy_(input)";
    "Fxn:[input.size(0)]";
    "Fxn:input.view(torch.Size(batchsize))";
    "Fxn:updateGradInput";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput)";
    "Fxn:self._gradOutput.copy_(gradOutput)";
    "Fxn:gradOutput.view_as(input)";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({})'.format('x'.join(map(lambda";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/RReLU.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:RReLU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor()";
    "Fxn:updateOutput";
    "Fxn:self._backend.RReLU_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.RReLU_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({:.4f},";
    "Fxn:{:.4f})'.format(self.lower,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Select.py";
    "Import:torch";
    "Import:Module";
    "class:Select(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.size(self.dimension)";
    "Fxn:input.select(self.dimension,";
    "Fxn:self.output.resize_as_(output)";
    "Fxn:self.output.copy_(output)";
    "Fxn:updateGradInput";
    "Fxn:input.size(self.dimension)";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.gradInput.zero_()";
    "Fxn:self.gradInput.select(self.dimension,";
    "Fxn:index).copy_(gradOutput)";
    "/torch/legacy/nn/SelectTable.py";
    "Import:torch";
    "Import:Module";
    "Import:recursiveCopy,";
    "class:SelectTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.size(self.dimension)";
    "Fxn:_zeroTableCopy";
    "Fxn:self._zeroTableCopy(l1[i],";
    "Fxn:l1.append(self._zeroTableCopy([],";
    "Fxn:l1.append(v.new().resize_as_(v).zero_())";
    "Fxn:l1[i].resize_as_(v)";
    "Fxn:l1[i].zero_()";
    "Fxn:l1[len(l2):]";
    "Fxn:updateGradInput";
    "Fxn:self._zeroTableCopy(self.gradInput,";
    "Fxn:input.size(self.dimension)";
    "Fxn:recursiveCopy(self.gradInput[index],";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({})'.format(self.index)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "/torch/legacy/nn/Sequential.py";
    "Import:torch";
    "Import:Container";
    "class:Sequential(Container):";
    "Fxn:__len__";
    "Fxn:add";
    "Fxn:self.modules.append(module)";
    "Fxn:insert";
    "Fxn:self.modules.insert(module,";
    "Fxn:remove";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:updateOutput";
    "Fxn:module.updateOutput(currentOutput)";
    "Fxn:_iter_with_prev";
    "Fxn:updateGradInput";
    "Fxn:self._iter_with_prev():";
    "Fxn:current.updateGradInput(prev.output,";
    "Fxn:self.modules[0].updateGradInput(input,";
    "Fxn:accGradParameters";
    "Fxn:self._iter_with_prev():";
    "Fxn:current.accGradParameters(prev.output,";
    "Fxn:self.modules[0].accGradParameters(input,";
    "Fxn:backward";
    "Fxn:self._iter_with_prev():";
    "Fxn:current.backward(prev.output,";
    "Fxn:self.modules[0].backward(input,";
    "Fxn:accUpdateGradParameters";
    "Fxn:self._iter_with_prev():";
    "Fxn:current.accUpdateGradParameters(prev.output,";
    "Fxn:self.modules[0].accUpdateGradParameters(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "Fxn:'('";
    "/torch/legacy/nn/Sigmoid.py";
    "Import:torch";
    "Import:Module";
    "class:Sigmoid(Module):";
    "Fxn:updateOutput";
    "Fxn:self._backend.Sigmoid_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.Sigmoid_updateGradInput(";
    "/torch/legacy/nn/SmoothL1Criterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:SmoothL1Criterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:self._backend.SmoothL1Criterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.SmoothL1Criterion_updateGradInput(";
    "/torch/legacy/nn/SoftMarginCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:SoftMarginCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new(1)";
    "Fxn:self._backend.SoftMarginCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.SoftMarginCriterion_updateGradInput(";
    "/torch/legacy/nn/SoftMax.py";
    "Import:torch";
    "Import:Module";
    "class:SoftMax(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_get_dim";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "Fxn:updateOutput";
    "Fxn:self._backend.SoftMax_updateOutput(";
    "Fxn:self._get_dim(input)";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SoftMax_updateGradInput(";
    "Fxn:self._get_dim(input)";
    "/torch/legacy/nn/SoftMin.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SoftMin(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_get_dim";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.mininput.resize_as_(input).copy_(input).mul_(-1)";
    "Fxn:self._backend.SoftMax_updateOutput(";
    "Fxn:self._get_dim(input)";
    "Fxn:updateGradInput";
    "Fxn:input.new()";
    "Fxn:self.mininput.resize_as_(input).copy_(input).mul_(-1)";
    "Fxn:self._backend.SoftMax_updateGradInput(";
    "Fxn:self._get_dim(input)";
    "Fxn:self.gradInput.mul_(-1)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SoftPlus.py";
    "Import:torch";
    "Import:Module";
    "class:SoftPlus(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:exp(x),";
    "Fxn:updateOutput";
    "Fxn:f(x)";
    "Fxn:log(1";
    "Fxn:exp(beta";
    "Fxn:self._backend.SoftPlus_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:d/dx[log(1+exp(k*x))/k]";
    "Fxn:exp(kx)";
    "Fxn:d/dx(f(x))";
    "Fxn:exp(k*y)";
    "Fxn:self._backend.SoftPlus_updateGradInput(";
    "/torch/legacy/nn/SoftShrink.py";
    "Import:torch";
    "Import:Module";
    "class:SoftShrink(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.SoftShrink_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SoftShrink_updateGradInput(";
    "/torch/legacy/nn/SoftSign.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SoftSign(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.temp.resize_as_(input).copy_(input).abs_().add_(1)";
    "Fxn:self.output.resize_as_(input).copy_(input).div_(self.temp)";
    "Fxn:updateGradInput";
    "Fxn:input.new()";
    "Fxn:self.tempgrad.resize_as_(self.output).copy_(input).abs_().add_(1).mul_(self.tempgrad)";
    "Fxn:self.gradInput.resize_as_(input).copy_(gradOutput).div_(self.tempgrad)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialAdaptiveMaxPooling.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SpatialAdaptiveMaxPooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.indices.long()";
    "Fxn:self._backend.SpatialAdaptiveMaxPooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SpatialAdaptiveMaxPooling_updateGradInput(";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialAveragePooling.py";
    "Import:torch";
    "Import:Module";
    "class:SpatialAveragePooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ceil";
    "Fxn:floor";
    "Fxn:setCountIncludePad";
    "Fxn:setCountExcludePad";
    "Fxn:updateOutput";
    "Fxn:self._backend.SpatialAveragePooling_updateOutput(";
    "Fxn:self.output.mul_(self.kW";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SpatialAveragePooling_updateGradInput(";
    "Fxn:self.gradInput.mul_(self.kW";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}x{},";
    "Fxn:{}'.format(self.kW,";
    "Fxn:{}'.format(self.padW,";
    "/torch/legacy/nn/SpatialBatchNormalization.py";
    "Import:torch";
    "Import:BatchNormalization";
    "class:SpatialBatchNormalization(BatchNormalization):";
    "/torch/legacy/nn/SpatialClassNLLCriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:SpatialClassNLLCriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:weights.dim()";
    "Fxn:self).__init__()";
    "Fxn:torch.zeros(1)";
    "Fxn:torch.ones(1)";
    "Fxn:updateOutput";
    "Fxn:self._backend.SpatialClassNLLCriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:torch.ones(1).type_as(input)";
    "Fxn:self._backend.SpatialClassNLLCriterion_updateGradInput(";
    "/torch/legacy/nn/SpatialContrastiveNormalization.py";
    "Import:torch";
    "Import:Module";
    "Import:Sequential";
    "Import:SpatialSubtractiveNormalization";
    "Import:SpatialDivisiveNormalization";
    "class:SpatialContrastiveNormalization(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(9,";
    "Fxn:9).fill_(1)";
    "Fxn:self.kernel.ndimension()";
    "Fxn:ValueError('SpatialContrastiveNormalization";
    "Fxn:self.kernel.size(0)";
    "Fxn:ValueError('SpatialContrastiveNormalization";
    "Fxn:Sequential()";
    "Fxn:self.normalizer.add(SpatialSubtractiveNormalization(self.nInputPlane,";
    "Fxn:self.normalizer.add(SpatialDivisiveNormalization(self.nInputPlane,";
    "Fxn:updateOutput";
    "Fxn:self.normalizer.forward(input)";
    "Fxn:updateGradInput";
    "Fxn:self.normalizer.backward(input,";
    "/torch/legacy/nn/SpatialConvolution.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SpatialConvolution(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:self.reset()";
    "Fxn:noBias";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.kW";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous";
    "Fxn:input.is_contiguous():";
    "Fxn:input.new()";
    "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_init";
    "Fxn:self.weight.new()";
    "Fxn:self.weight.new()";
    "Fxn:_viewWeight";
    "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:self.gradWeight.dim()";
    "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:_unviewWeight";
    "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:self.gradWeight.dim()";
    "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:updateOutput";
    "Fxn:self._init()";
    "Fxn:self._viewWeight()";
    "Fxn:self._makeContiguous(input)";
    "Fxn:self._backend.SpatialConvolutionMM_updateOutput(";
    "Fxn:self._unviewWeight()";
    "Fxn:updateGradInput";
    "Fxn:self._init()";
    "Fxn:self._viewWeight()";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self._backend.SpatialConvolutionMM_updateGradInput(";
    "Fxn:self._unviewWeight()";
    "Fxn:accGradParameters";
    "Fxn:self._init()";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self._viewWeight()";
    "Fxn:self._backend.SpatialConvolutionMM_accGradParameters(";
    "Fxn:self._unviewWeight()";
    "Fxn:type";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:self).type(type,";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:{}'.format(self.dW,";
    "Fxn:{}'.format(self.padW,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialConvolutionLocal.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SpatialConvolutionLocal(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(self.oH,";
    "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:torch.Tensor().resize_as_(self.weight)";
    "Fxn:torch.Tensor().resize_as_(self.bias)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.kW";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous";
    "Fxn:input.is_contiguous():";
    "Fxn:input.new()";
    "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_viewWeight";
    "Fxn:self.weight.view(self.oH";
    "Fxn:self.gradWeight.dim()";
    "Fxn:self.gradWeight.view(";
    "Fxn:_unviewWeight";
    "Fxn:self.weight.view(self.oH,";
    "Fxn:self.gradWeight.dim()";
    "Fxn:self.gradWeight.view(";
    "Fxn:_checkInputSize";
    "Fxn:input.ndimension()";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:input.size(1)";
    "Fxn:RuntimeError(";
    "Fxn:input.size(0),";
    "Fxn:input.size(1),";
    "Fxn:input.size(2),";
    "Fxn:input.ndimension()";
    "Fxn:input.size(1)";
    "Fxn:input.size(2)";
    "Fxn:input.size(3)";
    "Fxn:RuntimeError(";
    "Fxn:input.size(0),";
    "Fxn:input.size(1),";
    "Fxn:input.size(2),";
    "Fxn:input.size(3),";
    "Fxn:RuntimeError('3D";
    "Fxn:_checkOutputSize";
    "Fxn:output.ndimension()";
    "Fxn:input.ndimension():";
    "Fxn:RuntimeError('inconsistent";
    "Fxn:output.ndimension()";
    "Fxn:output.size(0)";
    "Fxn:output.size(1)";
    "Fxn:output.size(2)";
    "Fxn:RuntimeError(";
    "Fxn:output.size(0),";
    "Fxn:output.size(1),";
    "Fxn:output.size(2),";
    "Fxn:output.ndimension()";
    "Fxn:output.size(1)";
    "Fxn:output.size(2)";
    "Fxn:output.size(3)";
    "Fxn:RuntimeError('Given";
    "Fxn:'(batchsize";
    "Fxn:x{}x{}x{}).'.format(";
    "Fxn:output.size(0),";
    "Fxn:output.size(1),";
    "Fxn:output.size(2),";
    "Fxn:output.size(3),";
    "Fxn:RuntimeError('3D";
    "Fxn:4D(batch";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self._checkInputSize(input)";
    "Fxn:self._viewWeight()";
    "Fxn:self._makeContiguous(input)";
    "Fxn:self._backend.SpatialConvolutionLocal_updateOutput(";
    "Fxn:self._unviewWeight()";
    "Fxn:updateGradInput";
    "Fxn:self._checkInputSize(input)";
    "Fxn:self._checkOutputSize(input,";
    "Fxn:self._viewWeight()";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self._backend.SpatialConvolutionLocal_updateGradInput(";
    "Fxn:self._unviewWeight()";
    "Fxn:accGradParameters";
    "Fxn:self._checkInputSize(input)";
    "Fxn:self._checkOutputSize(input,";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self._viewWeight()";
    "Fxn:self._backend.SpatialConvolutionLocal_accGradParameters(";
    "Fxn:self._unviewWeight()";
    "Fxn:type";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:self).type(type,";
    "Fxn:__tostring__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:{}'.format(self.dW,";
    "Fxn:{}'.format(self.padW,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialConvolutionMap.py";
    "Import:random";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:SpatialConvolutionMap(Module):";
    "class:maps(object):";
    "Fxn:full";
    "Fxn:torch.Tensor(nin";
    "Fxn:oneToOne";
    "Fxn:torch.Tensor(nfeat,";
    "Fxn:random";
    "Fxn:torch.Tensor(nker,";
    "Fxn:torch.randperm(nin)";
    "Fxn:math.floor(nin";
    "Fxn:tbl.select(1,";
    "Fxn:tbl.select(1,";
    "Fxn:fi.narrow(0,";
    "Fxn:frtbl.unfold(0,";
    "Fxn:totbl.unfold(0,";
    "Fxn:fitbl.unfold(0,";
    "Fxn:ufrtbl.select(0,";
    "Fxn:i).copy_(ufitbl.select(0,";
    "Fxn:fi.copy_(torch.randperm(nin))";
    "Fxn:utotbl.select(0,";
    "Fxn:tocntr).fill_(tocntr)";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:0).max())";
    "Fxn:1).max())";
    "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:torch.Tensor(self.nOutputPlane).zero_()";
    "Fxn:math.sqrt(self.kW";
    "Fxn:self.weight.select(0,";
    "Fxn:k).uniform_(-stdv,";
    "Fxn:math.sqrt(self.kW";
    "Fxn:random.uniform(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self._backend.SpatialConvolutionMap_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SpatialConvolutionMap_updateGradInput(";
    "Fxn:accGradParameters";
    "Fxn:self._backend.SpatialConvolutionMap_accGradParameters(";
    "/torch/legacy/nn/SpatialCrossMapLRN.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SpatialCrossMapLRN(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:input.new()";
    "Fxn:input.type()";
    "Fxn:self._backend.SpatialCrossMapLRN_updateOutput(";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:input.size(2)";
    "Fxn:input.size(3)";
    "Fxn:self.output.resize_as_(input)";
    "Fxn:self.scale.resize_as_(input)";
    "Fxn:torch.pow(input,";
    "Fxn:self.scale.select(1,";
    "Fxn:scaleFirst.zero_()";
    "Fxn:scaleFirst.add_(inputSquare.select(1,";
    "Fxn:self.scale.select(1,";
    "Fxn:self.scale.select(1,";
    "Fxn:scaleCurrent.copy_(scalePrevious)";
    "Fxn:inputSquare.select(1,";
    "Fxn:scaleCurrent.add_(1,";
    "Fxn:inputSquare.select(1,";
    "Fxn:scaleCurrent.add_(-1,";
    "Fxn:self.scale.mul_(self.alpha";
    "Fxn:self.size).add_(self.k)";
    "Fxn:torch.pow(self.scale,";
    "Fxn:self.output.mul_(input)";
    "Fxn:updateGradInput";
    "Fxn:input.dim()";
    "Fxn:input.type()";
    "Fxn:self._backend.SpatialCrossMapLRN_updateGradInput(";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:input.size(2)";
    "Fxn:input.size(3)";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self.paddedRatio.resize_(channels";
    "Fxn:self.accumRatio.resize_(inputHeight,";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:torch.pow(self.scale,";
    "Fxn:out=self.gradInput).mul_(gradOutput)";
    "Fxn:self.paddedRatio.zero_()";
    "Fxn:self.paddedRatio.narrow(0,";
    "Fxn:torch.mul(gradOutput[n],";
    "Fxn:paddedRatioCenter.div_(self.scale[n])";
    "Fxn:torch.sum(self.paddedRatio.narrow(0,";
    "Fxn:self.accumRatio.add_(self.paddedRatio[c";
    "Fxn:self.gradInput[n][c].addcmul_(-cacheRatioValue,";
    "Fxn:self.accumRatio.add_(-1,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialDilatedConvolution.py";
    "Import:torch";
    "Import:SpatialConvolution";
    "class:SpatialDilatedConvolution(SpatialConvolution):";
    "Fxn:__init__";
    "Fxn:self).__init__(nInputPlane,";
    "Fxn:updateOutput";
    "Fxn:self.weight.new()";
    "Fxn:self.weight.new()";
    "Fxn:self._makeContiguous(input)";
    "Fxn:self._backend.SpatialDilatedConvolution_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self.weight.new()";
    "Fxn:self._backend.SpatialDilatedConvolution_updateGradInput(";
    "Fxn:accGradParameters";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self.weight.new()";
    "Fxn:self._backend.SpatialDilatedConvolution_accGradParameters(";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:{}'.format(self.dW,";
    "Fxn:{}'.format(self.padW,";
    "Fxn:{}'.format(self.dilationW,";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:Sequential";
    "Import:SpatialZeroPadding";
    "Import:SpatialConvolution";
    "Import:SpatialConvolutionMap";
    "Import:Replicate";
    "Import:Square";
    "Import:Sqrt";
    "Import:CDivTable";
    "Import:Threshold";
    "Import:clear";
    "class:SpatialDivisiveNormalization(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(9,";
    "Fxn:9).fill_(1)";
    "Fxn:self.kernel.ndimension()";
    "Fxn:ValueError('SpatialDivisiveNormalization";
    "Fxn:ValueError('SpatialDivisiveNormalization";
    "Fxn:Sequential()";
    "Fxn:self.meanestimator.add(SpatialZeroPadding(padW,";
    "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:self.kernel.size(1),";
    "Fxn:self.kernel.size(0)))";
    "Fxn:self.meanestimator.add(SpatialConvolutionMap(";
    "Fxn:SpatialConvolutionMap.maps.oneToOne(self.nInputPlane),";
    "Fxn:self.kernel.size(0),";
    "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:self.kernel.size(0)))";
    "Fxn:self.meanestimator.add(Replicate(self.nInputPlane,";
    "Fxn:Sequential()";
    "Fxn:self.stdestimator.add(Square())";
    "Fxn:self.stdestimator.add(SpatialZeroPadding(padW,";
    "Fxn:self.stdestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:self.kernel.size(1),";
    "Fxn:self.kernel.size(0)))";
    "Fxn:self.stdestimator.add(SpatialConvolutionMap(";
    "Fxn:SpatialConvolutionMap.maps.oneToOne(self.nInputPlane),";
    "Fxn:self.kernel.size(0),";
    "Fxn:self.stdestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:self.kernel.size(0)))";
    "Fxn:self.stdestimator.add(Replicate(self.nInputPlane,";
    "Fxn:self.stdestimator.add(Sqrt())";
    "Fxn:self.kernel.div_(self.kernel.sum()";
    "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:self.stdestimator.modules[2].bias.zero_()";
    "Fxn:self.kernel.div_(self.kernel.sum()";
    "Fxn:math.sqrt(self.nInputPlane))";
    "Fxn:self.meanestimator.modules[1].weight[i].copy_(self.kernel)";
    "Fxn:self.meanestimator.modules[2].weight[0][i].copy_(self.kernel)";
    "Fxn:self.stdestimator.modules[2].weight[i].copy_(self.kernel)";
    "Fxn:self.stdestimator.modules[3].weight[0][i].copy_(self.kernel)";
    "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:self.meanestimator.modules[2].bias.zero_()";
    "Fxn:self.stdestimator.modules[2].bias.zero_()";
    "Fxn:self.stdestimator.modules[3].bias.zero_()";
    "Fxn:CDivTable()";
    "Fxn:CDivTable()";
    "Fxn:Threshold(self.threshold,";
    "Fxn:torch.Tensor(1,";
    "Fxn:updateOutput";
    "Fxn:self.stdestimator.updateOutput(input)";
    "Fxn:input.dim()";
    "Fxn:self.coef.dim()";
    "Fxn:self.coef.size(dim";
    "Fxn:self.coef.size(dim";
    "Fxn:input.new()";
    "Fxn:self.ones.resize_as_(input[0:1]).fill_(1)";
    "Fxn:self.meanestimator.updateOutput(self.ones).squeeze(0)";
    "Fxn:input.new()";
    "Fxn:self._coef.resize_as_(coef).copy_(coef)";
    "Fxn:self._coef.view(1,";
    "Fxn:*self._coef.size()).expand_as(self.localstds)";
    "Fxn:self.divider.updateOutput([self.localstds,";
    "Fxn:self.coef.contiguous().view_as(self.localstds)])";
    "Fxn:self.thresholder.updateOutput(self.adjustedstds)";
    "Fxn:self.normalizer.updateOutput([input,";
    "Fxn:self.thresholdedstds.contiguous().view_as(input)])";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:self.thresholdedstds.contiguous().view_as(input)],";
    "Fxn:self.thresholder.updateGradInput(self.adjustedstds,";
    "Fxn:self.coef.contiguous().view_as(self.localstds)],";
    "Fxn:self.gradInput.add_(self.stdestimator.updateGradInput(input,";
    "Fxn:self.gradInput.add_(gradnorm[0])";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self.meanestimator.clearState()";
    "Fxn:self.stdestimator.clearState()";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialDropout.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SpatialDropout(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor()";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:input.dim()";
    "Fxn:self.noise.resize_(input.size(0),";
    "Fxn:input.size(1),";
    "Fxn:RuntimeError('Input";
    "Fxn:self.noise.bernoulli_(1";
    "Fxn:self.output.mul_(self.noise.expand_as(input))";
    "Fxn:self.output.mul_(1";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self.gradInput.mul_(self.noise.expand_as(input))";
    "Fxn:RuntimeError('backprop";
    "Fxn:setp";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialFractionalMaxPooling.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:SpatialFractionalMaxPooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:.fixPoolingRegions().";
    "Fxn:_getBufferSize";
    "Fxn:input.ndimension()";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:torch.Size([batchSize,";
    "Fxn:_initSampleBuffer";
    "Fxn:self._getBufferSize(input)";
    "Fxn:input.new().resize_(sampleBufferSize).uniform_()";
    "Fxn:self.randomSamples.size(0)";
    "Fxn:self.randomSamples.size(1)";
    "Fxn:self.randomSamples.resize_(sampleBufferSize).uniform_()";
    "Fxn:self.randomSamples.uniform_()";
    "Fxn:_getOutputSizes";
    "Fxn:input.ndimension()";
    "Fxn:fixPoolingRegions";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.indices.long()";
    "Fxn:self._initSampleBuffer(input)";
    "Fxn:self._getOutputSizes(input)";
    "Fxn:self._backend.SpatialFractionalMaxPooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._getOutputSizes(input)";
    "Fxn:self._backend.SpatialFractionalMaxPooling_updateGradInput(";
    "Fxn:empty";
    "Fxn:self.clearState()";
    "Fxn:clearState";
    "Fxn:self).clearState()";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}x{},";
    "Fxn:{})'.format(self.outW";
    "/torch/legacy/nn/SpatialFullConvolution.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SpatialFullConvolution(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError('adjW";
    "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:torch.Tensor()";
    "Fxn:self.reset()";
    "Fxn:noBias";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(kW";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous";
    "Fxn:input.is_contiguous():";
    "Fxn:input.new()";
    "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_calculateAdj";
    "Fxn:updateOutput";
    "Fxn:targetTensor.dim()";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:self._calculateAdj(tW,";
    "Fxn:self._calculateAdj(tH,";
    "Fxn:input[0].new()";
    "Fxn:input[0].new()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self._makeContiguous(inputTensor)";
    "Fxn:self._backend.SpatialFullConvolution_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:targetTensor.dim()";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:self._calculateAdj(tW,";
    "Fxn:self._calculateAdj(tH,";
    "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:self._backend.SpatialFullConvolution_updateGradInput(";
    "Fxn:input[1].new(1).zero_()";
    "Fxn:self.ones.resize_(input[1].dim()).fill_(1)";
    "Fxn:self.zeroScalar.view_as(self.ones).expand_as(input[1])";
    "Fxn:accGradParameters";
    "Fxn:targetTensor.dim()";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:calculateAdj(tW,";
    "Fxn:calculateAdj(tH,";
    "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:self._backend.SpatialFullConvolution_accGradParameters(";
    "Fxn:type";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:self).type(type,";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:{}'.format(self.dW,";
    "Fxn:{}'.format(self.padW,";
    "Fxn:{}'.format(self.adjW,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialFullConvolutionMap.py";
    "Import:random";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:SpatialFullConvolutionMap(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:0).max())";
    "Fxn:1).max())";
    "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:torch.Tensor(self.nOutputPlane).zero_()";
    "Fxn:math.sqrt(self.kW";
    "Fxn:self.weight[k].uniform_(-stdv,";
    "Fxn:math.sqrt(self.kW";
    "Fxn:random.uniform(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self._backend.SpatialFullConvolutionMap_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SpatialFullConvolutionMap_updateGradInput(";
    "Fxn:accGradParameters";
    "Fxn:self._backend.SpatialFullConvolutionMap_accGradParameters(";
    "/torch/legacy/nn/SpatialLPPooling.py";
    "Import:torch";
    "Import:Module";
    "Import:Sequential";
    "Import:Square";
    "Import:Power";
    "Import:SpatialAveragePooling";
    "Import:MulConstant";
    "Import:Sqrt";
    "class:SpatialLPPooling(Sequential):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:self.add(Square())";
    "Fxn:self.add(Power(pnorm))";
    "Fxn:self.add(SpatialAveragePooling(kW,";
    "Fxn:self.add(MulConstant(kW";
    "Fxn:self.add(Sqrt())";
    "Fxn:self.add(Power(1.";
    "Fxn:reset";
    "Fxn:accGradParameters";
    "Fxn:accUpdateGradParameters";
    "Fxn:zeroGradParameters";
    "Fxn:updateParameters";
    "/torch/legacy/nn/SpatialMaxPooling.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:SpatialMaxPooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.LongTensor()";
    "Fxn:ceil";
    "Fxn:floor";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.indices.long()";
    "Fxn:input.dim()";
    "Fxn:input.size(dims";
    "Fxn:input.size(dims";
    "Fxn:self._backend.SpatialMaxPooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SpatialMaxPooling_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}x{},";
    "Fxn:{}'.format(self.kW,";
    "Fxn:{}'.format(self.padW,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialMaxUnpooling.py";
    "Import:torch";
    "Import:Module";
    "Import:SpatialMaxPooling";
    "class:SpatialMaxUnpooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_setParams";
    "Fxn:updateOutput";
    "Fxn:self._setParams()";
    "Fxn:self._backend.SpatialMaxUnpooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._setParams()";
    "Fxn:self._backend.SpatialMaxUnpooling_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self.pooling.__repr__()";
    "/torch/legacy/nn/SpatialReflectionPadding.py";
    "Import:torch";
    "Import:Module";
    "class:SpatialReflectionPadding(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:self._backend.SpatialReflectionPadding_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:input.dim()";
    "Fxn:gradOutput.dim()";
    "Fxn:input.size(0)";
    "Fxn:gradOutput.size(0)";
    "Fxn:input.size(1)";
    "Fxn:gradOutput.size(1)";
    "Fxn:input.size(2)";
    "Fxn:gradOutput.size(2)";
    "Fxn:input.size(3)";
    "Fxn:gradOutput.size(3)";
    "Fxn:self._backend.SpatialReflectionPadding_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({},";
    "Fxn:{})'.format(self.pad_l,";
    "/torch/legacy/nn/SpatialReplicationPadding.py";
    "Import:torch";
    "Import:Module";
    "class:SpatialReplicationPadding(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:self._backend.SpatialReplicationPadding_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:input.dim()";
    "Fxn:gradOutput.dim()";
    "Fxn:input.size(0)";
    "Fxn:gradOutput.size(0)";
    "Fxn:input.size(1)";
    "Fxn:gradOutput.size(1)";
    "Fxn:input.size(2)";
    "Fxn:gradOutput.size(2)";
    "Fxn:input.size(3)";
    "Fxn:gradOutput.size(3)";
    "Fxn:self._backend.SpatialReplicationPadding_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({},";
    "Fxn:{})'.format(self.pad_l,";
    "/torch/legacy/nn/SpatialSoftMax.py";
    "Import:torch";
    "Import:Module";
    "class:SpatialSoftMax(Module):";
    "Fxn:updateOutput";
    "Fxn:self._backend.SoftMax_updateOutput(";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SoftMax_updateGradInput(";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "/torch/legacy/nn/SpatialSubSampling.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:SpatialSubSampling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.kW";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self._backend.SpatialSubSampling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.SpatialSubSampling_updateGradInput(";
    "Fxn:accGradParameters";
    "Fxn:self._backend.SpatialSubSampling_accGradParameters(";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:Sequential";
    "Import:SpatialZeroPadding";
    "Import:SpatialConvolution";
    "Import:SpatialConvolutionMap";
    "Import:Replicate";
    "Import:CSubTable";
    "Import:CDivTable";
    "Import:clear";
    "Import:warnings";
    "class:SpatialSubtractiveNormalization(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(9,";
    "Fxn:9).fill_(1)";
    "Fxn:self.kernel.ndimension()";
    "Fxn:ValueError('SpatialSubtractiveNormalization";
    "Fxn:ValueError('SpatialSubtractiveNormalization";
    "Fxn:self.kernel.div_(self.kernel.sum()";
    "Fxn:Sequential()";
    "Fxn:self.meanestimator.add(SpatialZeroPadding(padW,";
    "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:self.kernel.size(1),";
    "Fxn:self.kernel.size(0)))";
    "Fxn:self.meanestimator.add(SpatialConvolutionMap(";
    "Fxn:SpatialConvolutionMap.maps.oneToOne(self.nInputPlane),";
    "Fxn:self.kernel.size(0),";
    "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:self.kernel.size(0)))";
    "Fxn:self.meanestimator.add(Replicate(self.nInputPlane,";
    "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:self.kernel.unsqueeze(0)";
    "Fxn:self.kernel.unsqueeze(1)";
    "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:self.meanestimator.modules[2].bias.zero_()";
    "Fxn:CSubTable()";
    "Fxn:CDivTable()";
    "Fxn:torch.Tensor(1,";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:self.coef.dim()";
    "Fxn:self.coef.size(dim";
    "Fxn:self.coef.size(dim";
    "Fxn:input.new()";
    "Fxn:self.coef.new()";
    "Fxn:self.ones.resize_as_(input[0:1]).fill_(1)";
    "Fxn:self.meanestimator.updateOutput(self.ones).squeeze(0)";
    "Fxn:self._coef.resize_as_(coef).copy_(coef)";
    "Fxn:[input.size(0)]";
    "Fxn:self._coef.view(1,";
    "Fxn:*self._coef.size()).expand(*size)";
    "Fxn:self.meanestimator.updateOutput(input)";
    "Fxn:self.coef.contiguous().view_as(self.localsums)]))";
    "Fxn:self.subtractor.updateOutput([input,";
    "Fxn:self.adjustedsums.contiguous().view_as(input)])";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:self.subtractor.updateGradInput([input,";
    "Fxn:self.adjustedsums.contiguous().view_as(input)],";
    "Fxn:self.coef.contiguous().view_as(self.localsums)],";
    "Fxn:self.meanestimator.updateGradInput(input,";
    "Fxn:graddiv[0]).size()";
    "Fxn:self.gradInput.add_(self.meanestimator.updateGradInput(input,";
    "Fxn:self.gradInput.add_(gradsub[0])";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self.meanestimator.clearState()";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialUpSamplingNearest.py";
    "Import:torch";
    "Import:Module";
    "class:SpatialUpSamplingNearest(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError('scale_factor";
    "Fxn:ValueError('scale_factor";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "Fxn:self.output.resize_(*outputSize)";
    "Fxn:self._backend.SpatialUpSamplingNearest_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self._backend.SpatialUpSamplingNearest_updateGradInput(";
    "/torch/legacy/nn/SpatialZeroPadding.py";
    "Import:torch";
    "Import:Module";
    "class:SpatialZeroPadding(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:input.size(2)";
    "Fxn:input.size(3)";
    "Fxn:RuntimeError('input";
    "Fxn:{}x{})'.format(h,";
    "Fxn:self.output.resize_(input.size(0),";
    "Fxn:input.size(1),";
    "Fxn:self.output.zero_()";
    "Fxn:c_input.narrow(2,";
    "Fxn:c_input.size(2)";
    "Fxn:c_input.narrow(2,";
    "Fxn:c_input.size(2)";
    "Fxn:c_input.narrow(3,";
    "Fxn:c_input.size(3)";
    "Fxn:c_input.narrow(3,";
    "Fxn:c_input.size(3)";
    "Fxn:c_output.narrow(2,";
    "Fxn:c_output.size(2)";
    "Fxn:c_output.narrow(2,";
    "Fxn:c_output.size(2)";
    "Fxn:c_output.narrow(3,";
    "Fxn:c_output.size(3)";
    "Fxn:c_output.narrow(3,";
    "Fxn:c_output.size(3)";
    "Fxn:c_output.copy_(c_input)";
    "Fxn:updateGradInput";
    "Fxn:input.dim()";
    "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:cg_input.narrow(2,";
    "Fxn:cg_input.size(2)";
    "Fxn:cg_input.narrow(2,";
    "Fxn:cg_input.size(2)";
    "Fxn:cg_input.narrow(3,";
    "Fxn:cg_input.size(3)";
    "Fxn:cg_input.narrow(3,";
    "Fxn:cg_input.size(3)";
    "Fxn:cg_output.narrow(2,";
    "Fxn:cg_output.size(2)";
    "Fxn:cg_output.narrow(2,";
    "Fxn:cg_output.size(2)";
    "Fxn:cg_output.narrow(3,";
    "Fxn:cg_output.size(3)";
    "Fxn:cg_output.narrow(3,";
    "Fxn:cg_output.size(3)";
    "Fxn:cg_input.copy_(cg_output)";
    "Fxn:__tostring__";
    "Fxn:self).__repr__()";
    "Fxn:'({},";
    "Fxn:{})'.foramat(self.pad_l,";
    "/torch/legacy/nn/SplitTable.py";
    "Import:torch";
    "Import:Module";
    "class:SplitTable(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension";
    "Fxn:input.dim()";
    "Fxn:updateOutput";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:input.size(dimension)";
    "Fxn:currentOutput.append(input.select(dimension,";
    "Fxn:updateGradInput";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:input.size(dimension)";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.gradInput.select(dimension,";
    "Fxn:i).copy_(gradOutput[i])";
    "/torch/legacy/nn/Sqrt.py";
    "Import:torch";
    "Import:Module";
    "class:Sqrt(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self._backend.Sqrt_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.Sqrt_updateGradInput(";
    "/torch/legacy/nn/Square.py";
    "Import:torch";
    "Import:Module";
    "class:Square(Module):";
    "Fxn:updateOutput";
    "Fxn:self._backend.Square_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.Square_updateGradInput(";
    "/torch/legacy/nn/Squeeze.py";
    "Import:torch";
    "Import:Module";
    "class:Squeeze(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:self.output.set_(input.squeeze(dim)";
    "Fxn:input.squeeze())";
    "Fxn:updateGradInput";
    "Fxn:input.nelement()";
    "Fxn:gradOutput.nelement()";
    "Fxn:self.gradInput.set_(gradOutput.contiguous().view_as(input))";
    "/torch/legacy/nn/Sum.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:Sum(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension";
    "Fxn:input.dim()";
    "Fxn:updateOutput";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:torch.sum(input,";
    "Fxn:self.output.div_(input.size(dimension))";
    "Fxn:self.output.dim()";
    "Fxn:self.output.set_(self.output.select(dimension,";
    "Fxn:updateGradInput";
    "Fxn:self._getPositiveDimension(input)";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:gradOutput.view(*size)";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:self.gradInput.copy_(gradOutput.expand_as(input))";
    "Fxn:self.gradInput.div_(input.size(dimension))";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/Tanh.py";
    "Import:torch";
    "Import:Module";
    "class:Tanh(Module):";
    "Fxn:updateOutput";
    "Fxn:self._backend.Tanh_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.Tanh_updateGradInput(";
    "/torch/legacy/nn/TanhShrink.py";
    "Import:torch";
    "Import:Module";
    "Import:Tanh";
    "class:TanhShrink(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Tanh()";
    "Fxn:updateOutput";
    "Fxn:self.tanh.updateOutput(input)";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:self.output.add_(-1,";
    "Fxn:updateGradInput";
    "Fxn:self.tanh.updateGradInput(input,";
    "Fxn:self.gradInput.resize_as_(input).copy_(gradOutput)";
    "Fxn:self.gradInput.add_(-1,";
    "/torch/legacy/nn/TemporalConvolution.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:TemporalConvolution(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(outputFrameSize,";
    "Fxn:torch.Tensor(outputFrameSize)";
    "Fxn:torch.Tensor(outputFrameSize,";
    "Fxn:torch.Tensor(outputFrameSize)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.kW";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self._backend.TemporalConvolution_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.TemporalConvolution_updateGradInput(";
    "Fxn:accGradParameters";
    "Fxn:self._backend.TemporalConvolution_accGradParameters(";
    "/torch/legacy/nn/TemporalMaxPooling.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:TemporalMaxPooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self._backend.TemporalMaxPooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.TemporalMaxPooling_updateGradInput(";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/TemporalSubSampling.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:TemporalSubSampling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.kW)";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput";
    "Fxn:self._backend.TemporalSubSampling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.TemporalSubSampling_updateGradInput(";
    "Fxn:accGradParameters";
    "Fxn:self._backend.TemporalSubSampling_accGradParameters(";
    "/torch/legacy/nn/Threshold.py";
    "Import:torch";
    "Import:Module";
    "class:Threshold(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:self.validateParameters()";
    "Fxn:updateOutput";
    "Fxn:self.validateParameters()";
    "Fxn:self._backend.Threshold_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self.validateParameters()";
    "Fxn:self._backend.Threshold_updateGradInput(";
    "Fxn:validateParameters";
    "Fxn:RuntimeError('in-place";
    "/torch/legacy/nn/Transpose.py";
    "Import:torch";
    "Import:Module";
    "class:Transpose(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.transpose(*perm)";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateGradInput";
    "Fxn:gradOutput.transpose(*perm)";
    "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "/torch/legacy/nn/Unsqueeze.py";
    "Import:torch";
    "Import:Module";
    "Import:addSingletondimension";
    "class:Unsqueeze(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:addSingletondimension(self.output,";
    "Fxn:updateGradInput";
    "Fxn:input.nelement()";
    "Fxn:gradOutput.nelement()";
    "Fxn:gradOutput.contiguous().view(input.size())";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({})'.format(self.dim)";
    "/torch/legacy/nn/utils.py";
    "Import:torch";
    "Fxn:recursiveType";
    "Import:Criterion";
    "Import:Module";
    "Fxn:recursiveResizeAs";
    "Fxn:recursiveFill";
    "Fxn:recursiveAdd";
    "Fxn:recursiveCopy";
    "Fxn:addSingletondimension";
    "Fxn:contiguousView";
    "Fxn:clear";
    "Fxn:_clear";
    "/torch/legacy/nn/View.py";
    "Import:torch";
    "Import:Module";
    "class:View(Module):";
    "Fxn:resetSize";
    "Fxn:torch.Size(args)";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:self.resetSize(*args)";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:input.view(self.size)";
    "Fxn:updateGradInput";
    "Fxn:gradOutput.new()";
    "Fxn:gradOutput.contiguous().view(input.size())";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({})'.format(',";
    "Fxn:'.join(map(str,";
    "/torch/legacy/nn/VolumetricAveragePooling.py";
    "Import:torch";
    "Import:Module";
    "class:VolumetricAveragePooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:__setstate__";
    "Fxn:self.__dict__.update(d)";
    "Fxn:self.__dict__.setdefault('padT',";
    "Fxn:self.__dict__.setdefault('padH',";
    "Fxn:self.__dict__.setdefault('padW',";
    "Fxn:self.__dict__.setdefault('ceil_mode',";
    "Fxn:self.__dict__.setdefault('count_include_pad',";
    "Fxn:updateOutput";
    "Fxn:self._backend.VolumetricAveragePooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.VolumetricAveragePooling_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}x{}x{},";
    "Fxn:{}'.format(";
    "/torch/legacy/nn/VolumetricBatchNormalization.py";
    "Import:torch";
    "Import:Module";
    "Import:BatchNormalization";
    "class:VolumetricBatchNormalization(BatchNormalization):";
    "/torch/legacy/nn/VolumetricConvolution.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:VolumetricConvolution(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.kT";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous";
    "Fxn:input.is_contiguous():";
    "Fxn:input.new()";
    "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_viewWeight";
    "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:self.gradWeight.dim()";
    "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:_unviewWeight";
    "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:self.gradWeight.dim()";
    "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:input.type()";
    "Fxn:self._backend.VolumetricConvolution_updateOutput(";
    "Fxn:self._viewWeight()";
    "Fxn:self._makeContiguous(input)";
    "Fxn:self._backend.VolumetricConvolutionMM_updateOutput(";
    "Fxn:self._unviewWeight()";
    "Fxn:updateGradInput";
    "Fxn:input.type()";
    "Fxn:self._backend.VolumetricConvolution_updateGradInput(";
    "Fxn:self._viewWeight()";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self._backend.VolumetricConvolutionMM_updateGradInput(";
    "Fxn:self._unviewWeight()";
    "Fxn:accGradParameters";
    "Fxn:input.type()";
    "Fxn:self._backend.VolumetricConvolution_accGradParameters(";
    "Fxn:self._makeContiguous(input,";
    "Fxn:self._viewWeight()";
    "Fxn:self._backend.VolumetricConvolutionMM_accGradParameters(";
    "Fxn:self._unviewWeight()";
    "Fxn:type";
    "Fxn:clear(self,";
    "Fxn:self).type(type,";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{}x{}x{}'.format(self.nInputPlane,";
    "Fxn:{}'.format(self.dT,";
    "Fxn:{}'.format(self.padT,";
    "/torch/legacy/nn/VolumetricDropout.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:VolumetricDropout(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor()";
    "Fxn:updateOutput";
    "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:input.dim()";
    "Fxn:self.noise.resize_(input.size(0),";
    "Fxn:input.size(1),";
    "Fxn:self.noise.bernoulli_(1";
    "Fxn:self.output.mul_(self.noise.expand_as(input))";
    "Fxn:self.output.mul_(1";
    "Fxn:updateGradInput";
    "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:self.gradInput.mul_(self.noise.expand_as(input))";
    "Fxn:RuntimeError('backprop";
    "Fxn:setp";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({:.4f})'.format(self.p)";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "/torch/legacy/nn/VolumetricFullConvolution.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:VolumetricFullConvolution(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:RuntimeError('adjW,";
    "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:self.reset()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(kW";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous";
    "Fxn:input.is_contiguous():";
    "Fxn:input.new()";
    "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:gradOutput.is_contiguous():";
    "Fxn:gradOutput.new()";
    "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_calculateAdj";
    "Fxn:updateOutput";
    "Fxn:targetTensor.dim()";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:self._calculateAdj(tT,";
    "Fxn:self._calculateAdj(tW,";
    "Fxn:self._calculateAdj(tH,";
    "Fxn:self._makeContiguous(inputTensor)";
    "Fxn:self._backend.VolumetricFullConvolution_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:targetTensor.dim()";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:self._calculateAdj(tT,";
    "Fxn:self._calculateAdj(tW,";
    "Fxn:self._calculateAdj(tH,";
    "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:self._backend.VolumetricFullConvolution_updateGradInput(";
    "Fxn:input[1].new(1).zero_()";
    "Fxn:self.ones.resize_(input[1].dim()).fill_(1)";
    "Fxn:self.zeroScalar.view(self.ones.tolist()).expand_as(input[1])";
    "Fxn:accGradParameters";
    "Fxn:targetTensor.dim()";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:targetTensor.size(tDims";
    "Fxn:self._calculateAdj(tT,";
    "Fxn:self._calculateAdj(tW,";
    "Fxn:self._calculateAdj(tH,";
    "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:self._backend.VolumetricFullConvolution_accGradParameters(";
    "Fxn:type";
    "Fxn:torch.Tensor()";
    "Fxn:torch.Tensor()";
    "Fxn:self).type(type,";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}";
    "Fxn:{}x{}x{}'.format(self.nInputPlane,";
    "Fxn:{}'.format(self.dT,";
    "Fxn:{}'.format(self.padT,";
    "Fxn:{}'.format(self.adjT,";
    "/torch/legacy/nn/VolumetricMaxPooling.py";
    "Import:torch";
    "Import:Module";
    "Import:clear";
    "class:VolumetricMaxPooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.LongTensor()";
    "Fxn:ceil";
    "Fxn:floor";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:input.size(dims";
    "Fxn:input.size(dims";
    "Fxn:input.size(dims";
    "Fxn:input.new()";
    "Fxn:self.indices.long()";
    "Fxn:self._backend.VolumetricMaxPooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._backend.VolumetricMaxPooling_updateGradInput(";
    "Fxn:clearState";
    "Fxn:clear(self,";
    "Fxn:self).clearState()";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({}x{}x{},";
    "Fxn:{}'.format(self.kT,";
    "Fxn:{}'.format(self.padT,";
    "/torch/legacy/nn/VolumetricMaxUnpooling.py";
    "Import:torch";
    "Import:Module";
    "Import:VolumetricMaxPooling";
    "class:VolumetricMaxUnpooling(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_setParams";
    "Fxn:updateOutput";
    "Fxn:self._setParams()";
    "Fxn:self._backend.VolumetricMaxUnpooling_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:self._setParams()";
    "Fxn:self._backend.VolumetricMaxUnpooling_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self.pooling.__repr__()";
    "/torch/legacy/nn/VolumetricReplicationPadding.py";
    "Import:torch";
    "Import:Module";
    "class:VolumetricReplicationPadding(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:updateOutput";
    "Fxn:input.dim()";
    "Fxn:self._backend.VolumetricReplicationPadding_updateOutput(";
    "Fxn:updateGradInput";
    "Fxn:input.dim()";
    "Fxn:gradOutput.dim()";
    "Fxn:input.size(0)";
    "Fxn:gradOutput.size(0)";
    "Fxn:input.size(1)";
    "Fxn:gradOutput.size(1)";
    "Fxn:input.size(2)";
    "Fxn:gradOutput.size(2)";
    "Fxn:input.size(3)";
    "Fxn:gradOutput.size(3)";
    "Fxn:input.size(4)";
    "Fxn:gradOutput.size(4)";
    "Fxn:self._backend.VolumetricReplicationPadding_updateGradInput(";
    "Fxn:__repr__";
    "Fxn:self).__repr__()";
    "Fxn:'({},";
    "Fxn:{})'.format(self.pleft,";
    "/torch/legacy/nn/WeightedEuclidean.py";
    "Import:math";
    "Import:torch";
    "Import:Module";
    "class:WeightedEuclidean(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Tensor(inputSize,";
    "Fxn:torch.Tensor(inputSize,";
    "Fxn:torch.Tensor(inputSize,";
    "Fxn:torch.Tensor(inputSize,";
    "Fxn:self.reset()";
    "Fxn:self.output.new()";
    "Fxn:reset";
    "Fxn:math.sqrt(3)";
    "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:self.diagCov.fill_(1)";
    "Fxn:_view";
    "Fxn:src.is_contiguous():";
    "Fxn:res.set_(src.view(*args))";
    "Fxn:res.set_(src.contiguous().view(*args))";
    "Fxn:updateOutput";
    "Fxn:self.output.new()";
    "Fxn:input.new()";
    "Fxn:self.weight.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.output.new()";
    "Fxn:self.weight.size(0),";
    "Fxn:self.weight.size(1)";
    "Fxn:input.dim()";
    "Fxn:self._view(self._input,";
    "Fxn:self._expand.expand_as(self._input,";
    "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:self._repeat.add_(-1,";
    "Fxn:self._repeat.mul_(self.diagCov)";
    "Fxn:torch.norm(self._repeat,";
    "Fxn:self.output.resize_(outputSize)";
    "Fxn:input.dim()";
    "Fxn:input.size(0)";
    "Fxn:self._view(self._input,";
    "Fxn:self._input.expand(batchSize,";
    "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:self.weight.view(1,";
    "Fxn:self._weight.expand_as(self._repeat)";
    "Fxn:self.diagCov.view(1,";
    "Fxn:self._diagCov.expand_as(self._repeat)";
    "Fxn:input.type()";
    "Fxn:self._repeat2.resize_as_(self._expand2).copy_(self._expand2)";
    "Fxn:self._repeat.add_(-1,";
    "Fxn:self._repeat3.resize_as_(self._expand3).copy_(self._expand3)";
    "Fxn:self._repeat.mul_(self._repeat3)";
    "Fxn:self._repeat.add_(-1,";
    "Fxn:self._repeat.mul_(self._expand3)";
    "Fxn:torch.norm(self._repeat,";
    "Fxn:self.output.resize_(batchSize,";
    "Fxn:RuntimeError("1D";
    "Fxn:updateGradInput";
    "Fxn:input.new()";
    "Fxn:self.output.new()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:self.updateOutput(input)";
    "Fxn:self.weight.size(0),";
    "Fxn:self.weight.size(1)";
    "Fxn:self._output.resize_as_(self.output).copy_(self.output).add_(1e-7)";
    "Fxn:self._view(self._gradOutput,";
    "Fxn:gradOutput.size())";
    "Fxn:torch.div(gradOutput,";
    "Fxn:input.dim()";
    "Fxn:self._div.resize_(1,";
    "Fxn:self._div.expand_as(self.weight)";
    "Fxn:torch.type(input)";
    "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:self._repeat2.mul_(self._repeat,";
    "Fxn:self._repeat2.mul_(self.diagCov)";
    "Fxn:torch.sum(self._repeat2,";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:input.dim()";
    "Fxn:input.size(0)";
    "Fxn:self._div.resize_(batchSize,";
    "Fxn:self._div.expand(batchSize,";
    "Fxn:input.type()";
    "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:self._repeat2.mul_(self._repeat3)";
    "Fxn:torch.mul(self._repeat,";
    "Fxn:self._repeat2.mul_(self._expand3)";
    "Fxn:torch.sum(self._repeat2,";
    "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:RuntimeError("1D";
    "Fxn:accGradParameters";
    "Fxn:self.weight.size(0),";
    "Fxn:self.weight.size(1)";
    "Fxn:input.dim()";
    "Fxn:self.gradWeight.add_(-scale,";
    "Fxn:self._repeat.div_(self.diagCov)";
    "Fxn:self._repeat.mul_(self._repeat)";
    "Fxn:self._repeat.mul_(self.diagCov)";
    "Fxn:torch.type(input)";
    "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:torch.mul(self._repeat,";
    "Fxn:self.gradDiagCov.add_(self._repeat2)";
    "Fxn:input.dim()";
    "Fxn:input.new()";
    "Fxn:torch.sum(self._repeat2,";
    "Fxn:self._sum.resize_(inputSize,";
    "Fxn:self.gradWeight.add_(-scale,";
    "Fxn:input.type()";
    "Fxn:self._repeat.div_(self._repeat3)";
    "Fxn:self._repeat.mul_(self._repeat)";
    "Fxn:self._repeat.mul_(self._repeat3)";
    "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:self._repeat.mul_(self._repeat2)";
    "Fxn:self._repeat.div_(self._expand3)";
    "Fxn:self._repeat.mul_(self._repeat)";
    "Fxn:self._repeat.mul_(self._expand3)";
    "Fxn:self._repeat.mul_(self._expand4)";
    "Fxn:torch.sum(self._repeat,";
    "Fxn:self._sum.resize_(inputSize,";
    "Fxn:self.gradDiagCov.add_(scale,";
    "Fxn:RuntimeError("1D";
    "Fxn:type";
    "Fxn:self).type(type,";
    "Fxn:parameters";
    "Fxn:accUpdateGradParameters";
    "Fxn:self.accGradParameters(input,";
    "/torch/legacy/nn/WeightedMSECriterion.py";
    "Import:torch";
    "Import:Criterion";
    "class:WeightedMSECriterion(Criterion):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:weight.clone()";
    "Fxn:updateOutput";
    "Fxn:input.new()";
    "Fxn:self.buffer.resize_as_(input).copy_(target)";
    "Fxn:input.dim()";
    "Fxn:self.weight.dim():";
    "Fxn:self.buffer[i].mul_(self.weight)";
    "Fxn:self.buffer.mul_(self.weight)";
    "Fxn:input.new(1)";
    "Fxn:self._backend.MSECriterion_updateOutput(";
    "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput";
    "Fxn:self.buffer.resize_as_(input).copy_(target)";
    "Fxn:input.dim()";
    "Fxn:self.weight.dim():";
    "Fxn:self.buffer[i].mul_(self.weight)";
    "Fxn:self.buffer.mul_(self.weight)";
    "Fxn:torch.Tensor([1]).type(input.type())";
    "Fxn:self._backend.MSECriterion_updateGradInput(";
    "/torch/legacy/nn/__init__.py";
    "Import:type2backend";
    "Import:utils";
    "Import:Module";
    "Import:Criterion";
    "Import:Container";
    "Import:Sequential";
    "Import:Parallel";
    "Import:Concat";
    "Import:DepthConcat";
    "Import:ConcatTable";
    "Import:JoinTable";
    "Import:ParallelTable";
    "Import:Abs";
    "Import:AbsCriterion";
    "Import:Add";
    "Import:AddConstant";
    "Import:BCECriterion";
    "Import:BatchNormalization";
    "Import:Bilinear";
    "Import:CAddTable";
    "Import:CDivTable";
    "Import:CMul";
    "Import:CMulTable";
    "Import:CSubTable";
    "Import:ClassNLLCriterion";
    "Import:Contiguous";
    "Import:Copy";
    "Import:Cosine";
    "Import:CosineDistance";
    "Import:CosineEmbeddingCriterion";
    "Import:CriterionTable";
    "Import:CrossEntropyCriterion";
    "Import:DistKLDivCriterion";
    "Import:DotProduct";
    "Import:Dropout";
    "Import:ELU";
    "Import:Euclidean";
    "Import:Exp";
    "Import:FlattenTable";
    "Import:GradientReversal";
    "Import:HardShrink";
    "Import:HardTanh";
    "Import:HingeEmbeddingCriterion";
    "Import:Identity";
    "Import:Index";
    "Import:L1Cost";
    "Import:L1HingeEmbeddingCriterion";
    "Import:L1Penalty";
    "Import:LeakyReLU";
    "Import:Linear";
    "Import:Log";
    "Import:LogSigmoid";
    "Import:LogSoftMax";
    "Import:LookupTable";
    "Import:.MSECriterion";
    "Import:MSECriterion";
    "Import:MarginCriterion";
    "Import:MarginRankingCriterion";
    "Import:MaskedSelect";
    "Import:Max";
    "Import:Min";
    "Import:MixtureTable";
    "Import:Mul";
    "Import:MulConstant";
    "Import:MultiCriterion";
    "Import:.MultiLabelMarginCriterion";
    "Import:MultiLabelMarginCriterion";
    "Import:MultiLabelSoftMarginCriterion";
    "Import:MultiMarginCriterion";
    "Import:Narrow";
    "Import:NarrowTable";
    "Import:Normalize";
    "Import:PReLU";
    "Import:Padding";
    "Import:PairwiseDistance";
    "Import:ParallelCriterion";
    "Import:PartialLinear";
    "Import:Power";
    "Import:RReLU";
    "Import:ReLU6";
    "Import:Replicate";
    "Import:Reshape";
    "Import:Select";
    "Import:SelectTable";
    "Import:Sigmoid";
    "Import:SmoothL1Criterion";
    "Import:SoftMarginCriterion";
    "Import:SoftMax";
    "Import:SoftMin";
    "Import:SoftPlus";
    "Import:SoftShrink";
    "Import:SoftSign";
    "Import:SpatialAdaptiveMaxPooling";
    "Import:SpatialAveragePooling";
    "Import:SpatialBatchNormalization";
    "Import:SpatialClassNLLCriterion";
    "Import:SpatialContrastiveNormalization";
    "Import:SpatialConvolution";
    "Import:SpatialConvolutionLocal";
    "Import:SpatialConvolutionMap";
    "Import:SpatialCrossMapLRN";
    "Import:SpatialDilatedConvolution";
    "Import:SpatialDivisiveNormalization";
    "Import:SpatialDropout";
    "Import:SpatialFractionalMaxPooling";
    "Import:SpatialFullConvolution";
    "Import:SpatialFullConvolutionMap";
    "Import:SpatialLPPooling";
    "Import:SpatialMaxPooling";
    "Import:SpatialMaxUnpooling";
    "Import:SpatialReflectionPadding";
    "Import:SpatialReplicationPadding";
    "Import:SpatialSoftMax";
    "Import:SpatialSubSampling";
    "Import:SpatialSubtractiveNormalization";
    "Import:SpatialUpSamplingNearest";
    "Import:SpatialZeroPadding";
    "Import:SplitTable";
    "Import:Sqrt";
    "Import:Square";
    "Import:Squeeze";
    "Import:Sum";
    "Import:Tanh";
    "Import:TanhShrink";
    "Import:Threshold";
    "Import:Transpose";
    "Import:Unsqueeze";
    "Import:View";
    "Import:WeightedEuclidean";
    "Import:WeightedMSECriterion";
    "Import:TemporalConvolution";
    "Import:TemporalMaxPooling";
    "Import:TemporalSubSampling";
    "Import:VolumetricAveragePooling";
    "Import:VolumetricBatchNormalization";
    "Import:VolumetricConvolution";
    "Import:VolumetricDropout";
    "Import:VolumetricFullConvolution";
    "Import:VolumetricMaxPooling";
    "Import:VolumetricMaxUnpooling";
    "Import:VolumetricReplicationPadding";
    "Import:Clamp";
    "Import:ClassSimplexCriterion";
    "Import:ReLU";
    "Import:Mean";
    "/torch/legacy/optim/adadelta.py";
    "Fxn:adadelta";
    "/torch/legacy/optim/adagrad.py";
    "Fxn:adagrad";
    "/torch/legacy/optim/adam.py";
    "Import:math";
    "Fxn:adam";
    "/torch/legacy/optim/adamax.py";
    "Import:torch";
    "Fxn:adamax";
    "/torch/legacy/optim/asgd.py";
    "Import:math";
    "Fxn:asgd";
    "/torch/legacy/optim/cg.py";
    "Import:math";
    "Fxn:sqrt_nothrow";
    "Fxn:cg";
    "/torch/legacy/optim/lbfgs.py";
    "Import:torch";
    "Fxn:lbfgs";
    "Fxn:verbose";
    "Fxn:verbose";
    "/torch/legacy/optim/nag.py";
    "Fxn:nag";
    "/torch/legacy/optim/rmsprop.py";
    "Import:torch";
    "Fxn:rmsprop";
    "/torch/legacy/optim/rprop.py";
    "Import:torch";
    "Fxn:rprop";
    "/torch/legacy/optim/sgd.py";
    "Import:torch";
    "Fxn:sgd";
    "/torch/legacy/optim/__init__.py";
    "Import:adadelta";
    "Import:adagrad";
    "Import:adam";
    "Import:adamax";
    "Import:asgd";
    "Import:.nag";
    "Import:nag";
    "Import:rmsprop";
    "Import:rprop";
    "Import:sgd";
    "Import:lbfgs";
    "/torch/lib/THD/benchmark/benchmark.py";
    "Import:argparse";
    "Import:timeit";
    "Import:default_timer";
    "Import:torch";
    "Import:torch.distributed";
    "Fxn:print_header";
    "Fxn:print_stats";
    "/torch/multiprocessing/pool.py";
    "Import:multiprocessing";
    "Import:multiprocessing.pool";
    "Import:multiprocessing.util";
    "Import:SimpleQueue";
    "Fxn:clean_worker";
    "Import:multiprocessing.pool.worker(*args,";
    "class:Pool(multiprocessing.pool.Pool):";
    "Fxn:_setup_queues";
    "Fxn:SimpleQueue()";
    "Fxn:SimpleQueue()";
    "Fxn:_repopulate_pool";
    "Fxn:self.Process(target=clean_worker,";
    "Fxn:self._pool.append(w)";
    "Fxn:w.name.replace('Process',";
    "Fxn:w.start()";
    "Fxn:util.debug('added";
    "/torch/multiprocessing/queue.py";
    "Import:import";
    "Import:multiprocessing";
    "Import:multiprocessing.queues";
    "Import:ForkingPickler";
    "Import:pickle";
    "class:ConnectionWrapper(object):";
    "Fxn:__init__";
    "Fxn:send";
    "Fxn:io.BytesIO()";
    "Fxn:ForkingPickler(buf,";
    "Fxn:pickle.HIGHEST_PROTOCOL).dump(obj)";
    "Fxn:self.send_bytes(buf.getvalue())";
    "Fxn:recv";
    "Fxn:self.recv_bytes()";
    "Fxn:pickle.loads(buf)";
    "Fxn:__getattr__";
    "Fxn:AttributeError("'{}'";
    "Fxn:'{}'".format(";
    "class:Queue(multiprocessing.queues.Queue):";
    "Fxn:__init__";
    "Fxn:self).__init__(*args,";
    "Fxn:ConnectionWrapper(self._reader)";
    "Fxn:ConnectionWrapper(self._writer)";
    "class:SimpleQueue(multiprocessing.queues.SimpleQueue):";
    "Fxn:_make_methods";
    "Fxn:ConnectionWrapper(self._reader)";
    "Fxn:ConnectionWrapper(self._writer)";
    "Fxn:self)._make_methods()";
    "/torch/multiprocessing/reductions.py";
    "Import:torch";
    "Import:import";
    "Import:weakref";
    "Import:multiprocessing";
    "Import:ForkingPickler";
    "Import:sys";
    "Import:multiprocessing.resource_sharer";
    "class:StorageRef(object):";
    "Fxn:__init__";
    "Fxn:weakref.WeakValueDictionary()";
    "Fxn:rebuild_event";
    "Fxn:torch.cuda.Event(_handle=handle)";
    "Fxn:reduce_event";
    "Fxn:rebuild_tensor";
    "Fxn:cls()";
    "Fxn:new_tensor.set_(storage,";
    "Fxn:reduce_tensor";
    "Fxn:tensor.size(),";
    "Fxn:tensor.stride())";
    "Fxn:tensor.storage()";
    "Fxn:fd_id";
    "Fxn:os.fstat(fd)";
    "Fxn:storage_from_cache";
    "Fxn:shared_cache.get(key)";
    "Fxn:cls._new_with_weak_ptr(storage_ref)";
    "Fxn:rebuild_storage_fd";
    "Fxn:multiprocessing.reduction.rebuild_handle(df)";
    "Fxn:df.detach()";
    "Fxn:storage_from_cache(cls,";
    "Fxn:fd_id(fd))";
    "Fxn:cls._new_shared_fd(fd,";
    "Fxn:shared_cache[fd_id(fd)]";
    "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:os.close(fd)";
    "Fxn:rebuild_storage_filename";
    "Fxn:storage_from_cache(cls,";
    "Fxn:storage._shared_decref()";
    "Fxn:cls._new_shared_filename(manager,";
    "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:storage._shared_decref()";
    "Fxn:rebuild_storage_cuda";
    "Fxn:storage_from_cache(cls,";
    "Fxn:storage._new_view(offset,";
    "Fxn:torch.cuda._lazy_init()";
    "Fxn:cls._new_shared_cuda(device,";
    "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:reduce_storage";
    "Fxn:storage._share_cuda_()";
    "Fxn:get_sharing_strategy()";
    "Fxn:storage._share_filename_()";
    "Fxn:storage._shared_incref()";
    "Fxn:storage._share_fd_()";
    "Fxn:multiprocessing.reduction.reduce_handle(fd)";
    "Fxn:multiprocessing.reduction.DupFd(fd)";
    "Fxn:fd_id(fd)";
    "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:init_reductions";
    "Fxn:ForkingPickler.register(torch.cuda.Event,";
    "Fxn:ForkingPickler.register(t,";
    "Fxn:ForkingPickler.register(t,";
    "Import:get_sharing_strategy";
    "/torch/multiprocessing/__init__.py";
    "Import:sys";
    "Import:init_reductions";
    "Import:multiprocessing";
    "Import:__all__";
    "Import:Queue,";
    "Import:Pool";
    "Fxn:set_sharing_strategy";
    "Fxn:get_sharing_strategy";
    "Fxn:get_all_sharing_strategies";
    "/torch/nn/functional.py";
    "Import:warnings";
    "Import:math";
    "Import:mul";
    "Import:reduce";
    "Import:torch";
    "Import:_infer_size,";
    "Import:_functions";
    "Import:utils";
    "Import:Bilinear";
    "Import:ConstantPadNd";
    "Import:vision";
    "Import:Col2Im,";
    "Import:Variable";
    "Import:_single,";
    "Fxn:conv_tbc";
    "Fxn:avg_pool1d";
    "Fxn:fractional_max_pool2d";
    "Fxn:max_pool1d";
    "Fxn:max_pool2d";
    "Fxn:max_pool3d";
    "Fxn:_unpool_output_size";
    "Fxn:max_unpool1d";
    "Fxn:max_unpool2d";
    "Fxn:max_unpool3d";
    "Fxn:lp_pool2d";
    "Fxn:lp_pool1d";
    "Fxn:adaptive_max_pool1d";
    "Fxn:adaptive_max_pool2d";
    "Fxn:adaptive_max_pool3d";
    "Fxn:dropout";
    "Fxn:alpha_dropout";
    "Fxn:dropout2d";
    "Fxn:dropout3d";
    "Fxn:threshold";
    "Fxn:relu";
    "Fxn:glu";
    "Fxn:hardtanh";
    "Fxn:relu6";
    "Fxn:elu";
    "Fxn:selu";
    "Fxn:leaky_relu";
    "Fxn:rrelu";
    "Fxn:tanhshrink";
    "Fxn:softsign";
    "Fxn:_get_softmax_dim";
    "Fxn:softmin";
    "Fxn:softmax";
    "Fxn:_sample_gumbel";
    "Fxn:_gumbel_softmax_sample";
    "Fxn:gumbel_softmax";
    "Fxn:log_softmax";
    "Fxn:tanh";
    "Fxn:sigmoid";
    "Fxn:linear";
    "Fxn:bilinear";
    "Fxn:embedding";
    "Fxn:embedding_bag";
    "Fxn:batch_norm";
    "Fxn:instance_norm";
    "Import:torch.onnx.symbolic";
    "Fxn:_instance_norm";
    "Fxn:layer_norm";
    "Fxn:local_response_norm";
    "Fxn:nll_loss";
    "Fxn:poisson_nll_loss";
    "Fxn:cross_entropy";
    "Fxn:binary_cross_entropy";
    "Fxn:binary_cross_entropy_with_logits";
    "Fxn:_pointwise_loss";
    "Fxn:l1_loss";
    "Fxn:mse_loss";
    "Fxn:margin_ranking_loss";
    "Fxn:hinge_embedding_loss";
    "Fxn:multilabel_soft_margin_loss";
    "Fxn:cosine_embedding_loss";
    "Fxn:multi_margin_loss";
    "Fxn:pixel_shuffle";
    "Fxn:upsample";
    "Import:Integral";
    "Import:_ntuple";
    "Fxn:_check_size_scale_factor";
    "Fxn:_scale_factor";
    "Fxn:_output_size";
    "Fxn:upsample_nearest";
    "Fxn:upsample_bilinear";
    "Fxn:grid_sample";
    "Fxn:affine_grid";
    "Fxn:pad";
    "Fxn:pairwise_distance";
    "Fxn:cosine_similarity";
    "Fxn:triplet_margin_loss";
    "Fxn:normalize";
    "Fxn:assert_int_or_pair";
    "Fxn:unfold";
    "Fxn:fold";
    "/torch/nn/init.py";
    "Import:math";
    "Import:random";
    "Import:torch";
    "Fxn:calculate_gain";
    "Fxn:uniform";
    "Fxn:normal";
    "Fxn:constant";
    "Fxn:eye";
    "Fxn:dirac";
    "Fxn:_calculate_fan_in_and_fan_out";
    "Fxn:xavier_uniform";
    "Fxn:xavier_normal";
    "Fxn:_calculate_correct_fan";
    "Fxn:kaiming_uniform";
    "Fxn:kaiming_normal";
    "Fxn:orthogonal";
    "Fxn:sparse";
    "/torch/nn/parameter.py";
    "Import:Variable";
    "class:Parameter(Variable):";
    "Fxn:__new__";
    "Fxn:cls).__new__(cls,";
    "Fxn:__repr__";
    "Fxn:self).__repr__().replace('Variable',";
    "/torch/nn/__init__.py";
    "Import:.parameter";
    "Import:Parameter";
    "Import:DataParallel";
    "Import:init";
    "Import:utils";
    "/torch/nn/backends/backend.py";
    "class:FunctionBackend(object):";
    "Fxn:__init__";
    "Fxn:__getattr__";
    "Fxn:self.function_classes.get(name)";
    "Fxn:register_function";
    "Fxn:self.function_classes.get(name):";
    "Fxn:RuntimeError("Trying";
    "/torch/nn/backends/thnn.py";
    "Import:FunctionBackend";
    "class:THNNFunctionBackend(FunctionBackend):";
    "Fxn:__reduce__";
    "Fxn:__deepcopy__";
    "Fxn:memo[id(self)]";
    "Fxn:__copy__";
    "Fxn:_get_thnn_function_backend";
    "Fxn:_initialize_backend";
    "Fxn:backend.register_function('RNN',";
    "Fxn:backend.register_function('RNNTanhCell',";
    "Fxn:backend.register_function('RNNReLUCell',";
    "Fxn:backend.register_function('LSTMCell',";
    "Fxn:backend.register_function('GRUCell',";
    "Fxn:backend.register_function('Dropout',";
    "Fxn:backend.register_function('Dropout2d',";
    "Fxn:backend.register_function('Dropout3d',";
    "Fxn:backend.register_function('MarginRankingLoss',";
    "Fxn:backend.register_function(name,";
    "Fxn:THNNFunctionBackend()";
    "Fxn:_initialize_backend()";
    "Import:_all_functions";
    "Import:RNN,";
    "Import:Dropout,";
    "Import:MarginRankingLoss";
    "/torch/nn/backends/__init__.py";
    "/torch/nn/modules/activation.py";
    "Import:warnings";
    "Import:torch";
    "Import:Parameter";
    "Import:Module";
    "Import:functional";
    "class:Threshold(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.threshold(input,";
    "Fxn:__repr__";
    "class:ReLU(Threshold):";
    "Fxn:__init__";
    "Fxn:self).__init__(0,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:RReLU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.rrelu(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:Hardtanh(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:warnings.warn("keyword";
    "Fxn:warnings.warn("keyword";
    "Fxn:forward";
    "Fxn:F.hardtanh(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ReLU6(Hardtanh):";
    "Fxn:__init__";
    "Fxn:self).__init__(0,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:Sigmoid(Module):";
    "Fxn:forward";
    "Fxn:torch.sigmoid(input)";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:Tanh(Module):";
    "Fxn:forward";
    "Fxn:torch.tanh(input)";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:ELU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.elu(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:SELU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.selu(input,";
    "Fxn:__repr__";
    "Fxn:'(inplace)'";
    "class:GLU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.glu(input,";
    "Fxn:__repr__";
    "Fxn:'{}(dim={})'.format(self.__class__.__name__,";
    "class:Hardshrink(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.hardshrink(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:LeakyReLU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.leaky_relu(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:LogSigmoid(Module):";
    "Fxn:forward";
    "Fxn:F.logsigmoid(input)";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:Softplus(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.softplus(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:Softshrink(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.softshrink(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:PReLU(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(num_parameters).fill_(init))";
    "Fxn:forward";
    "Fxn:F.prelu(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:Softsign(Module):";
    "Fxn:forward";
    "Fxn:F.softsign(input)";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:Tanhshrink(Module):";
    "Fxn:forward";
    "Fxn:F.tanhshrink(input)";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:Softmin(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.softmin(input,";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:Softmax(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:__setstate__";
    "Fxn:self.__dict__.update(state)";
    "Fxn:forward";
    "Fxn:F.softmax(input,";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:Softmax2d(Module):";
    "Fxn:forward";
    "Fxn:input.dim()";
    "Fxn:F.softmax(input,";
    "Fxn:__repr__";
    "Fxn:'()'";
    "class:LogSoftmax(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:__setstate__";
    "Fxn:self.__dict__.update(state)";
    "Fxn:forward";
    "Fxn:F.log_softmax(input,";
    "Fxn:__repr__";
    "Fxn:'()'";
    "/torch/nn/modules/batchnorm.py";
    "Import:torch";
    "Import:Module";
    "Import:Parameter";
    "Import:functional";
    "class:_BatchNorm(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(num_features))";
    "Fxn:Parameter(torch.Tensor(num_features))";
    "Fxn:self.register_parameter('weight',";
    "Fxn:self.register_parameter('bias',";
    "Fxn:self.register_buffer('running_mean',";
    "Fxn:torch.zeros(num_features))";
    "Fxn:self.register_buffer('running_var',";
    "Fxn:torch.ones(num_features))";
    "Fxn:self.register_parameter('running_mean',";
    "Fxn:self.register_parameter('running_var',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:self.running_mean.zero_()";
    "Fxn:self.running_var.fill_(1)";
    "Fxn:self.weight.data.uniform_()";
    "Fxn:self.bias.data.zero_()";
    "Fxn:_check_input_dim";
    "Fxn:forward";
    "Fxn:self._check_input_dim(input)";
    "Fxn:F.batch_norm(";
    "Fxn:__repr__";
    "Fxn:.format(name=self.__class__.__name__,";
    "class:BatchNorm1d(_BatchNorm):";
    "Fxn:_check_input_dim";
    "Fxn:input.dim()";
    "Fxn:input.dim()";
    "Fxn:ValueError('expected";
    "Fxn:.format(input.dim()))";
    "class:BatchNorm2d(_BatchNorm):";
    "Fxn:_check_input_dim";
    "Fxn:input.dim()";
    "Fxn:ValueError('expected";
    "Fxn:.format(input.dim()))";
    "class:BatchNorm3d(_BatchNorm):";
    "Fxn:_check_input_dim";
    "Fxn:input.dim()";
    "Fxn:ValueError('expected";
    "Fxn:.format(input.dim()))";
    "/torch/nn/modules/container.py";
    "Import:warnings";
    "Import:OrderedDict,";
    "Import:islice";
    "Import:operator";
    "Import:torch";
    "Import:Module";
    "class:Container(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:warnings.warn("nn.Container";
    "Fxn:kwargs.items():";
    "Fxn:self.add_module(key,";
    "class:Sequential(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:args[0].items():";
    "Fxn:self.add_module(key,";
    "Fxn:self.add_module(str(idx),";
    "Fxn:_get_item_by_idx";
    "Fxn:operator.index(idx)";
    "Fxn:IndexError('index";
    "Fxn:range'.format(idx))";
    "Fxn:__getitem__";
    "Fxn:Sequential(OrderedDict(list(self._modules.items())[idx]))";
    "Fxn:self._get_item_by_idx(self._modules.values(),";
    "Fxn:__setitem__";
    "Fxn:self._get_item_by_idx(self._modules.keys(),";
    "Fxn:__delitem__";
    "Fxn:self._get_item_by_idx(self._modules.keys(),";
    "Fxn:__len__";
    "Fxn:__dir__";
    "Fxn:self).__dir__()";
    "Fxn:key.isdigit()]";
    "Fxn:forward";
    "Fxn:self._modules.values():";
    "Fxn:module(input)";
    "class:ModuleList(Module):";
    "class:MyModule(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.ModuleList([nn.Linear(10,";
    "Fxn:forward";
    "Fxn:2](x)";
    "Fxn:l(x)";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_get_abs_string_index";
    "Fxn:operator.index(idx)";
    "Fxn:IndexError('index";
    "Fxn:range'.format(idx))";
    "Fxn:__getitem__";
    "Fxn:ModuleList(list(self._modules.values())[idx])";
    "Fxn:self._modules[self._get_abs_string_index(idx)]";
    "Fxn:__setitem__";
    "Fxn:operator.index(idx)";
    "Fxn:__delitem__";
    "Fxn:self._get_abs_string_index(idx))";
    "Fxn:[str(i)";
    "Fxn:OrderedDict(list(zip(str_indices,";
    "Fxn:self._modules.values())))";
    "Fxn:__len__";
    "Fxn:__iter__";
    "Fxn:__iadd__";
    "Fxn:self.extend(modules)";
    "Fxn:__dir__";
    "Fxn:self).__dir__()";
    "Fxn:key.isdigit()]";
    "Fxn:append";
    "Fxn:self.add_module(str(len(self)),";
    "Fxn:extend";
    "Fxn:TypeError("ModuleList.extend";
    "Fxn:self.add_module(str(offset";
    "class:ParameterList(Module):";
    "class:MyModule(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.ParameterList([nn.Parameter(torch.randn(10,";
    "Fxn:forward";
    "Fxn:2].mm(x)";
    "Fxn:p.mm(x)";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:__getitem__";
    "Fxn:ParameterList(list(self._parameters.values())[idx])";
    "Fxn:operator.index(idx)";
    "Fxn:IndexError('index";
    "Fxn:range'.format(idx))";
    "Fxn:self._parameters[str(idx)]";
    "Fxn:__setitem__";
    "Fxn:operator.index(idx)";
    "Fxn:self.register_parameter(str(idx),";
    "Fxn:__len__";
    "Fxn:__iter__";
    "Fxn:__iadd__";
    "Fxn:self.extend(parameters)";
    "Fxn:__dir__";
    "Fxn:self).__dir__()";
    "Fxn:key.isdigit()]";
    "Fxn:append";
    "Fxn:self.register_parameter(str(len(self)),";
    "Fxn:extend";
    "Fxn:TypeError("ParameterList.extend";
    "Fxn:self.register_parameter(str(offset";
    "Fxn:__repr__";
    "Fxn:'(\n'";
    "Fxn:self._parameters.items():";
    "Fxn:'x'.join(str(size)";
    "Fxn:p.size())";
    "Fxn:{})'.format(p.get_device())";
    "Fxn:{}{}]'.format(";
    "Fxn:torch.typename(p.data),";
    "/torch/nn/modules/conv.py";
    "Import:math";
    "Import:torch";
    "Import:Parameter";
    "Import:functional";
    "Import:Module";
    "Import:_single,";
    "class:_ConvNd(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError('in_channels";
    "Fxn:ValueError('out_channels";
    "Fxn:Parameter(torch.Tensor(";
    "Fxn:Parameter(torch.Tensor(";
    "Fxn:Parameter(torch.Tensor(out_channels))";
    "Fxn:self.register_parameter('bias',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:math.sqrt(n)";
    "Fxn:self.weight.data.uniform_(-stdv,";
    "Fxn:self.bias.data.uniform_(-stdv,";
    "Fxn:__repr__";
    "Fxn:s.format(name=self.__class__.__name__,";
    "class:Conv1d(_ConvNd):";
    "Fxn:__init__";
    "Fxn:_single(kernel_size)";
    "Fxn:_single(stride)";
    "Fxn:_single(padding)";
    "Fxn:_single(dilation)";
    "Fxn:self).__init__(";
    "Fxn:_single(0),";
    "Fxn:forward";
    "Fxn:F.conv1d(input,";
    "class:Conv2d(_ConvNd):";
    "Fxn:__init__";
    "Fxn:_pair(kernel_size)";
    "Fxn:_pair(stride)";
    "Fxn:_pair(padding)";
    "Fxn:_pair(dilation)";
    "Fxn:self).__init__(";
    "Fxn:_pair(0),";
    "Fxn:forward";
    "Fxn:F.conv2d(input,";
    "class:Conv3d(_ConvNd):";
    "Fxn:__init__";
    "Fxn:_triple(kernel_size)";
    "Fxn:_triple(stride)";
    "Fxn:_triple(padding)";
    "Fxn:_triple(dilation)";
    "Fxn:self).__init__(";
    "Fxn:_triple(0),";
    "Fxn:forward";
    "Fxn:F.conv3d(input,";
    "class:_ConvTransposeMixin(object):";
    "Fxn:forward";
    "Fxn:self._output_padding(input,";
    "Fxn:self._backend.ConvNd(";
    "Fxn:func(input,";
    "Fxn:func(input,";
    "Fxn:_output_padding";
    "Fxn:input.dim()";
    "Fxn:ValueError(";
    "Fxn:.format(k,";
    "Fxn:dim_size";
    "Fxn:[dim_size(d)";
    "Fxn:ValueError((";
    "Fxn:{})").format(";
    "Fxn:input.size()[2:]))";
    "class:ConvTranspose1d(_ConvTransposeMixin,";
    "Fxn:__init__";
    "Fxn:_single(kernel_size)";
    "Fxn:_single(stride)";
    "Fxn:_single(padding)";
    "Fxn:_single(dilation)";
    "Fxn:_single(output_padding)";
    "Fxn:self).__init__(";
    "Fxn:forward";
    "Fxn:self._output_padding(input,";
    "Fxn:F.conv_transpose1d(";
    "class:ConvTranspose2d(_ConvTransposeMixin,";
    "Fxn:__init__";
    "Fxn:_pair(kernel_size)";
    "Fxn:_pair(stride)";
    "Fxn:_pair(padding)";
    "Fxn:_pair(dilation)";
    "Fxn:_pair(output_padding)";
    "Fxn:self).__init__(";
    "Fxn:forward";
    "Fxn:self._output_padding(input,";
    "Fxn:F.conv_transpose2d(";
    "class:ConvTranspose3d(_ConvTransposeMixin,";
    "Fxn:__init__";
    "Fxn:_triple(kernel_size)";
    "Fxn:_triple(stride)";
    "Fxn:_triple(padding)";
    "Fxn:_triple(dilation)";
    "Fxn:_triple(output_padding)";
    "Fxn:self).__init__(";
    "Fxn:forward";
    "Fxn:self._output_padding(input,";
    "Fxn:F.conv_transpose3d(";
    "/torch/nn/modules/distance.py";
    "Import:torch";
    "Import:Module";
    "Import:functional";
    "class:PairwiseDistance(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.pairwise_distance(x1,";
    "class:CosineSimilarity(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.cosine_similarity(x1,";
    "/torch/nn/modules/dropout.py";
    "Import:Module";
    "Import:functional";
    "class:Dropout(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError("dropout";
    "Fxn:{}".format(p))";
    "Fxn:forward";
    "Fxn:F.dropout(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:Dropout2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError("dropout";
    "Fxn:{}".format(p))";
    "Fxn:forward";
    "Fxn:F.dropout2d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:Dropout3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError("dropout";
    "Fxn:{}".format(p))";
    "Fxn:forward";
    "Fxn:F.dropout3d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AlphaDropout(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:ValueError("dropout";
    "Fxn:{}".format(p))";
    "Fxn:forward";
    "Fxn:F.alpha_dropout(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "/torch/nn/modules/fold.py";
    "Import:Module";
    "Import:functional";
    "class:Fold(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.fold(input,";
    "Fxn:__repr__";
    "class:Unfold(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.unfold(input,";
    "Fxn:__repr__";
    "/torch/nn/modules/instancenorm.py";
    "Import:_BatchNorm";
    "Import:functional";
    "class:_InstanceNorm(_BatchNorm):";
    "Fxn:__init__";
    "Fxn:self).__init__(";
    "Fxn:_check_input_dim";
    "Fxn:forward";
    "Fxn:self._check_input_dim(input)";
    "Fxn:F.instance_norm(";
    "class:InstanceNorm1d(_InstanceNorm):";
    "Fxn:_check_input_dim";
    "Fxn:input.dim()";
    "Fxn:ValueError('expected";
    "Fxn:.format(input.dim()))";
    "class:InstanceNorm2d(_InstanceNorm):";
    "Fxn:_check_input_dim";
    "Fxn:input.dim()";
    "Fxn:ValueError('expected";
    "Fxn:.format(input.dim()))";
    "class:InstanceNorm3d(_InstanceNorm):";
    "Fxn:_check_input_dim";
    "Fxn:input.dim()";
    "Fxn:ValueError('expected";
    "Fxn:.format(input.dim()))";
    "/torch/nn/modules/linear.py";
    "Import:math";
    "Import:torch";
    "Import:Parameter";
    "Import:functional";
    "Import:Module";
    "class:Linear(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(out_features,";
    "Fxn:Parameter(torch.Tensor(out_features))";
    "Fxn:self.register_parameter('bias',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:self.weight.data.uniform_(-stdv,";
    "Fxn:self.bias.data.uniform_(-stdv,";
    "Fxn:forward";
    "Fxn:F.linear(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:Bilinear(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(out_features,";
    "Fxn:Parameter(torch.Tensor(out_features))";
    "Fxn:self.register_parameter('bias',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:self.weight.data.uniform_(-stdv,";
    "Fxn:self.bias.data.uniform_(-stdv,";
    "Fxn:forward";
    "Fxn:F.bilinear(input1,";
    "Fxn:__repr__";
    "Fxn:'('";
    "/torch/nn/modules/loss.py";
    "Import:warnings";
    "Import:Variable";
    "Import:torch";
    "Import:Module";
    "Import:Sequential";
    "Import:LogSoftmax";
    "Import:functional";
    "Fxn:_assert_no_grad";
    "class:_Loss(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "class:_WeightedLoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:self.register_buffer('weight',";
    "class:L1Loss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.l1_loss(input,";
    "class:NLLLoss(_WeightedLoss):";
    "Fxn:__init__";
    "Fxn:self).__init__(weight,";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.nll_loss(input,";
    "class:NLLLoss2d(NLLLoss):";
    "Fxn:__init__";
    "Fxn:warnings.warn("NLLLoss2d";
    "Fxn:self).__init__(weight,";
    "class:PoissonNLLLoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.poisson_nll_loss(log_input,";
    "class:KLDivLoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.kl_div(input,";
    "class:MSELoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.mse_loss(input,";
    "class:BCELoss(_WeightedLoss):";
    "Fxn:__init__";
    "Fxn:self).__init__(weight,";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.binary_cross_entropy(input,";
    "class:BCEWithLogitsLoss(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:self.register_buffer('weight',";
    "Fxn:forward";
    "Fxn:Variable(self.weight)";
    "Fxn:F.binary_cross_entropy_with_logits(input,";
    "Fxn:F.binary_cross_entropy_with_logits(input,";
    "class:HingeEmbeddingLoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:F.hinge_embedding_loss(input,";
    "class:MultiLabelMarginLoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.multilabel_margin_loss(input,";
    "class:SmoothL1Loss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.smooth_l1_loss(input,";
    "class:SoftMarginLoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.soft_margin_loss(input,";
    "class:CrossEntropyLoss(_WeightedLoss):";
    "Fxn:__init__";
    "Fxn:self).__init__(weight,";
    "Fxn:forward";
    "Fxn:_assert_no_grad(target)";
    "Fxn:F.cross_entropy(input,";
    "class:MultiLabelSoftMarginLoss(_WeightedLoss):";
    "Fxn:__init__";
    "Fxn:self).__init__(weight,";
    "Fxn:forward";
    "Fxn:F.multilabel_soft_margin_loss(input,";
    "class:CosineEmbeddingLoss(_Loss):";
    "Fxn:__init__";
    "Fxn:self).__init__(size_average)";
    "Fxn:forward";
    "Fxn:F.cosine_embedding_loss(input1,";
    "class:MarginRankingLoss(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.margin_ranking_loss(input1,";
    "class:MultiMarginLoss(_WeightedLoss):";
    "Fxn:__init__";
    "Fxn:self).__init__(weight,";
    "Fxn:ValueError("only";
    "Fxn:weight.dim()";
    "Fxn:forward";
    "Fxn:F.multi_margin_loss(input,";
    "class:TripletMarginLoss(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.triplet_margin_loss(anchor,";
    "/torch/nn/modules/module.py";
    "Import:OrderedDict";
    "Import:functools";
    "Import:torch";
    "Import:backend";
    "Import:Parameter";
    "Import:Variable";
    "Import:torch.utils.hooks";
    "Fxn:_addindent";
    "class:Module(object):";
    "Import:torch.nn";
    "Import:torch.nn.functional";
    "class:Model(nn.Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:nn.Conv2d(1,";
    "Fxn:nn.Conv2d(20,";
    "Fxn:forward";
    "Fxn:F.relu(self.conv1(x))";
    "Fxn:F.relu(self.conv2(x))";
    "Fxn:`.cuda()`,";
    "Fxn:__init__";
    "Fxn:OrderedDict()";
    "Fxn:OrderedDict()";
    "Fxn:OrderedDict()";
    "Fxn:OrderedDict()";
    "Fxn:OrderedDict()";
    "Fxn:OrderedDict()";
    "Fxn:forward";
    "Fxn:register_buffer";
    "Fxn:self.register_buffer('running_mean',";
    "Fxn:torch.zeros(num_features))";
    "Fxn:KeyError("attribute";
    "Fxn:exists".format(name))";
    "Fxn:TypeError("cannot";
    "Fxn:"(torch";
    "Fxn:.format(torch.typename(tensor),";
    "Fxn:register_parameter";
    "Fxn:AttributeError(";
    "Fxn:Module.__init__()";
    "Fxn:KeyError("attribute";
    "Fxn:exists".format(name))";
    "Fxn:TypeError("cannot";
    "Fxn:"(torch.nn.Parameter";
    "Fxn:.format(torch.typename(param),";
    "Fxn:ValueError(";
    "Fxn:forward()";
    "Fxn:method.".format(name))";
    "Fxn:add_module";
    "Fxn:TypeError("{}";
    "Fxn:subclass".format(";
    "Fxn:torch.typename(module)))";
    "Fxn:KeyError("attribute";
    "Fxn:exists".format(name))";
    "Fxn:_apply";
    "Fxn:self.children():";
    "Fxn:module._apply(fn)";
    "Fxn:self._parameters.values():";
    "Fxn:fn(param.data)";
    "Fxn:fn(param._grad.data)";
    "Fxn:self._buffers.items():";
    "Fxn:fn(buf)";
    "Fxn:apply";
    "Fxn:``.children()``)";
    "Fxn:init_weights";
    "Fxn:m.weight.data.fill_(1.0)";
    "Fxn:nn.Sequential(nn.Linear(2,";
    "Fxn:nn.Linear(2,";
    "Fxn:net.apply(init_weights)";
    "Fxn:Linear(in_features=2,";
    "Fxn:Linear(in_features=2,";
    "Fxn:Sequential(";
    "Fxn:Linear(in_features=2,";
    "Fxn:Linear(in_features=2,";
    "Fxn:Sequential(";
    "Fxn:Linear(in_features=2,";
    "Fxn:Linear(in_features=2,";
    "Fxn:self.children():";
    "Fxn:module.apply(fn)";
    "Fxn:fn(self)";
    "Fxn:cuda";
    "Fxn:self._apply(lambda";
    "Fxn:t.cuda(device))";
    "Fxn:cpu";
    "Fxn:self._apply(lambda";
    "Fxn:t.cpu())";
    "Fxn:type";
    "Fxn:self._apply(lambda";
    "Fxn:t.type(dst_type))";
    "Fxn:float";
    "Fxn:self._apply(lambda";
    "Fxn:t.float()";
    "Fxn:t.is_floating_point()";
    "Fxn:double";
    "Fxn:self._apply(lambda";
    "Fxn:t.double()";
    "Fxn:t.is_floating_point()";
    "Fxn:half";
    "Fxn:self._apply(lambda";
    "Fxn:t.half()";
    "Fxn:t.is_floating_point()";
    "Fxn:register_backward_hook";
    "Fxn:hook(module,";
    "Fxn:``handle.remove()``";
    "Fxn:hooks.RemovableHandle(self._backward_hooks)";
    "Fxn:register_forward_pre_hook";
    "Fxn:hook(module,";
    "Fxn:``handle.remove()``";
    "Fxn:hooks.RemovableHandle(self._forward_pre_hooks)";
    "Fxn:register_forward_hook";
    "Fxn:hook(module,";
    "Fxn:``handle.remove()``";
    "Fxn:hooks.RemovableHandle(self._forward_hooks)";
    "Fxn:_tracing_name";
    "Fxn:module.named_children():";
    "Fxn:_slow_forward";
    "Fxn:torch.jit.get_tracing_state(input_vars)";
    "Fxn:self.forward(*input,";
    "Fxn:self._tracing_name(tracing_state)";
    "Fxn:tracing_state.push_scope('%s[%s]'";
    "Fxn:tracing_state.push_scope(self.__class__.__name__)";
    "Fxn:tracing_state._traced_module_stack.append(self)";
    "Fxn:self.forward(*input,";
    "Fxn:tracing_state.pop_scope()";
    "Fxn:tracing_state._traced_module_stack.pop()";
    "Fxn:__call__";
    "Fxn:self._forward_pre_hooks.values():";
    "Fxn:hook(self,";
    "Fxn:self._slow_forward(*input,";
    "Fxn:self.forward(*input,";
    "Fxn:self._forward_hooks.values():";
    "Fxn:hook(self,";
    "Fxn:RuntimeError(";
    "Fxn:None".format(hook))";
    "Fxn:var.values()";
    "Fxn:self._backward_hooks.values():";
    "Fxn:functools.partial(hook,";
    "Fxn:functools.update_wrapper(wrapper,";
    "Fxn:grad_fn.register_hook(wrapper)";
    "Fxn:__setstate__";
    "Fxn:self.__dict__.update(state)";
    "Fxn:OrderedDict()";
    "Fxn:__getattr__";
    "Fxn:AttributeError("'{}'";
    "Fxn:'{}'".format(";
    "Fxn:__setattr__";
    "Fxn:remove_from";
    "Fxn:self.__dict__.get('_parameters')";
    "Fxn:AttributeError(";
    "Fxn:Module.__init__()";
    "Fxn:remove_from(self.__dict__,";
    "Fxn:self.register_parameter(name,";
    "Fxn:TypeError("cannot";
    "Fxn:"(torch.nn.Parameter";
    "Fxn:.format(torch.typename(value),";
    "Fxn:self.register_parameter(name,";
    "Fxn:self.__dict__.get('_modules')";
    "Fxn:AttributeError(";
    "Fxn:Module.__init__()";
    "Fxn:remove_from(self.__dict__,";
    "Fxn:TypeError("cannot";
    "Fxn:"(torch.nn.Module";
    "Fxn:.format(torch.typename(value),";
    "Fxn:self.__dict__.get('_buffers')";
    "Fxn:torch.is_tensor(value):";
    "Fxn:TypeError("cannot";
    "Fxn:"(torch.Tensor";
    "Fxn:.format(torch.typename(value),";
    "Fxn:object.__setattr__(self,";
    "Fxn:__delattr__";
    "Fxn:object.__delattr__(self,";
    "Fxn:state_dict";
    "Fxn:module.state_dict().keys()";
    "Fxn:OrderedDict()";
    "Fxn:self._parameters.items():";
    "Fxn:self._buffers.items():";
    "Fxn:self._modules.items():";
    "Fxn:module.state_dict(destination,";
    "Fxn:load_state_dict";
    "Fxn::func:`state_dict()`";
    "Fxn:`:func:`state_dict()`";
    "Fxn:self.state_dict()";
    "Fxn:state_dict.items():";
    "Fxn:own_state[name].copy_(param)";
    "Fxn:RuntimeError('While";
    "Fxn:.format(name,";
    "Fxn:own_state[name].size(),";
    "Fxn:param.size()))";
    "Fxn:KeyError('unexpected";
    "Fxn:.format(name))";
    "Fxn:KeyError('missing";
    "Fxn:"{}"'.format(missing))";
    "Fxn:parameters";
    "Fxn:model.parameters():";
    "Fxn:param.size())";
    "Fxn:self.named_parameters():";
    "Fxn:named_parameters";
    "Fxn:self.named_parameters():";
    "Fxn:self._parameters.items():";
    "Fxn:memo.add(p)";
    "Fxn:self.named_children():";
    "Fxn:module.named_parameters(memo,";
    "Fxn:_all_buffers";
    "Fxn:self._buffers.items():";
    "Fxn:memo.add(b)";
    "Fxn:self.children():";
    "Fxn:module._all_buffers(memo):";
    "Fxn:children";
    "Fxn:self.named_children():";
    "Fxn:named_children";
    "Fxn:model.named_children():";
    "Fxn:self._modules.items():";
    "Fxn:memo.add(module)";
    "Fxn:modules";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Sequential(l,";
    "Fxn:self.named_modules():";
    "Fxn:named_modules";
    "Fxn:nn.Linear(2,";
    "Fxn:nn.Sequential(l,";
    "Fxn:memo.add(self)";
    "Fxn:self._modules.items():";
    "Fxn:module.named_modules(memo,";
    "Fxn:train";
    "Fxn:self.children():";
    "Fxn:module.train(mode)";
    "Fxn:eval";
    "Fxn:self.train(False)";
    "Fxn:zero_grad";
    "Fxn:self.parameters():";
    "Fxn:p.grad.detach_()";
    "Fxn:p.grad.zero_()";
    "Fxn:share_memory";
    "Fxn:self._apply(lambda";
    "Fxn:t.share_memory_())";
    "Fxn:_get_name";
    "Fxn:__repr__";
    "Fxn:self._get_name()";
    "Fxn:'(\n'";
    "Fxn:self._modules.items():";
    "Fxn:module.__repr__()";
    "Fxn:_addindent(modstr,";
    "Fxn:__dir__";
    "Fxn:key[0].isdigit()]";
    "/torch/nn/modules/normalization.py";
    "Import:torch";
    "Import:numbers";
    "Import:Parameter";
    "Import:Module";
    "Import:_BatchNorm";
    "Import:functional";
    "class:LocalResponseNorm(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.local_response_norm(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:CrossMapLRN2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:self._backend.CrossMapLRN2d(self.size,";
    "Fxn:self.k)(input)";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:LayerNorm(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.Size(normalized_shape)";
    "Fxn:Parameter(torch.Tensor(*normalized_shape))";
    "Fxn:Parameter(torch.Tensor(*normalized_shape))";
    "Fxn:self.register_parameter('weight',";
    "Fxn:self.register_parameter('bias',";
    "Fxn:self.register_buffer('running_mean',";
    "Fxn:torch.zeros(1))";
    "Fxn:self.register_buffer('running_var',";
    "Fxn:torch.ones(1))";
    "Fxn:self.register_parameter('running_mean',";
    "Fxn:self.register_parameter('running_var',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:self.running_mean.zero_()";
    "Fxn:self.running_var.fill_(1)";
    "Fxn:self.weight.data.fill_(1)";
    "Fxn:self.bias.data.zero_()";
    "Fxn:forward";
    "Fxn:F.layer_norm(";
    "Fxn:__repr__";
    "Fxn:.format(name=self.__class__.__name__,";
    "/torch/nn/modules/padding.py";
    "Import:Module";
    "Import:_pair,";
    "Import:functional";
    "class:ConstantPad1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_pair(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ConstantPad2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_quadruple(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ConstantPad3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_ntuple(6)(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ReflectionPad1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_pair(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ReflectionPad2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_quadruple(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ReplicationPad1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_pair(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ReplicationPad2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_quadruple(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ReplicationPad3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_ntuple(6)(padding)";
    "Fxn:forward";
    "Fxn:F.pad(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:ZeroPad2d(ConstantPad2d):";
    "Fxn:__init__";
    "Fxn:self).__init__(padding,";
    "/torch/nn/modules/pixelshuffle.py";
    "Import:Module";
    "Import:functional";
    "class:PixelShuffle(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.pixel_shuffle(input,";
    "Fxn:__repr__";
    "Fxn:'(upscale_factor='";
    "/torch/nn/modules/pooling.py";
    "Import:torch";
    "Import:Variable";
    "Import:Module";
    "Import:_single,";
    "Import:functional";
    "class:MaxPool1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.max_pool1d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:MaxPool2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.max_pool2d(input,";
    "Fxn:__repr__";
    "Fxn:_pair(self.kernel_size)";
    "Fxn:_pair(self.stride)";
    "Fxn:_pair(self.padding)";
    "Fxn:_pair(self.dilation)";
    "Fxn:padding=('";
    "Fxn:dilation=('";
    "Fxn:'('";
    "Fxn:'kernel_size=('";
    "Fxn:stride=('";
    "class:MaxUnpool1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_single(kernel_size)";
    "Fxn:_single(stride";
    "Fxn:_single(padding)";
    "Fxn:forward";
    "Fxn:F.max_unpool1d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:MaxUnpool2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_pair(kernel_size)";
    "Fxn:_pair(stride";
    "Fxn:_pair(padding)";
    "Fxn:forward";
    "Fxn:F.max_unpool2d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:MaxUnpool3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_triple(kernel_size)";
    "Fxn:_triple(stride";
    "Fxn:_triple(padding)";
    "Fxn:forward";
    "Fxn:F.max_unpool3d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AvgPool1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_single(kernel_size)";
    "Fxn:_single(stride";
    "Fxn:_single(padding)";
    "Fxn:forward";
    "Fxn:F.avg_pool1d(";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AvgPool2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.avg_pool2d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:MaxPool3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.max_pool3d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AvgPool3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.avg_pool3d(input,";
    "Fxn:__setstate__";
    "Fxn:self).__setstate__(d)";
    "Fxn:self.__dict__.setdefault('padding',";
    "Fxn:self.__dict__.setdefault('ceil_mode',";
    "Fxn:self.__dict__.setdefault('count_include_pad',";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:FractionalMaxPool2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:_pair(kernel_size)";
    "Fxn:self.register_buffer('_random_samples',";
    "Fxn:_pair(output_size)";
    "Fxn:_pair(output_ratio)";
    "Fxn:ValueError("FractionalMaxPool2d";
    "Fxn:ValueError("only";
    "Fxn:ValueError("output_ratio";
    "Fxn:.format(output_ratio))";
    "Fxn:forward";
    "Fxn:F.fractional_max_pool2d(";
    "class:LPPool2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.lp_pool2d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:LPPool1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.lp_pool1d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AdaptiveMaxPool1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.adaptive_max_pool1d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AdaptiveMaxPool2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.adaptive_max_pool2d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AdaptiveMaxPool3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.adaptive_max_pool3d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AdaptiveAvgPool1d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.adaptive_avg_pool1d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AdaptiveAvgPool2d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.adaptive_avg_pool2d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:AdaptiveAvgPool3d(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.adaptive_avg_pool3d(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "/torch/nn/modules/rnn.py";
    "Import:math";
    "Import:torch";
    "Import:warnings";
    "Import:itertools";
    "Import:Module";
    "Import:Parameter";
    "Import:PackedSequence";
    "class:RNNBase(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(gate_size,";
    "Fxn:Parameter(torch.Tensor(gate_size,";
    "Fxn:Parameter(torch.Tensor(gate_size))";
    "Fxn:Parameter(torch.Tensor(gate_size))";
    "Fxn:[x.format(layer,";
    "Fxn:self._all_weights.append(param_names)";
    "Fxn:self.flatten_parameters()";
    "Fxn:self.reset_parameters()";
    "Fxn:flatten_parameters";
    "Fxn:torch.backends.cudnn.is_acceptable(any_param):";
    "Fxn:Module.named_parameters().";
    "Fxn:torch.cuda.device_of(any_param):";
    "Fxn:torch.no_grad():";
    "Fxn:no_grad()";
    "Fxn:torch._cudnn_rnn_flatten_weight(";
    "Fxn:rnn.get_cudnn_mode(self.mode),";
    "Fxn:weight_buf.size(0)";
    "Fxn:self.parameters())";
    "Fxn:_apply";
    "Fxn:self)._apply(fn)";
    "Fxn:self.flatten_parameters()";
    "Fxn:reset_parameters";
    "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:self.parameters():";
    "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:check_forward_args";
    "Fxn:input.dim()";
    "Fxn:RuntimeError(";
    "Fxn:{}'.format(";
    "Fxn:input.dim()))";
    "Fxn:input.size(-1):";
    "Fxn:RuntimeError(";
    "Fxn:'input.size(-1)";
    "Fxn:{}'.format(";
    "Fxn:input.size(-1)))";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:check_hidden_size";
    "Fxn:RuntimeError(msg.format(expected_hidden_size,";
    "Fxn:check_hidden_size(hidden[0],";
    "Fxn:check_hidden_size(hidden[1],";
    "Fxn:check_hidden_size(hidden,";
    "Fxn:forward";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:torch.autograd.Variable(input.data.new(self.num_layers";
    "Fxn:self.hidden_size).zero_(),";
    "Fxn:self.parameters())";
    "Fxn:first_data.storage().size()";
    "Fxn:first_data.new().set_(first_data.storage(),";
    "Fxn:torch.Size([self._param_buf_size]))";
    "Fxn:self.check_forward_args(input,";
    "Fxn:self._backend.RNN(";
    "Fxn:func(input,";
    "Fxn:PackedSequence(output,";
    "Fxn:__repr__";
    "Fxn:'{name}({input_size},";
    "Fxn:s.format(name=self.__class__.__name__,";
    "Fxn:__setstate__";
    "Fxn:self).__setstate__(d)";
    "Fxn:self.__dict__.setdefault('_data_ptrs',";
    "Fxn:[x.format(layer,";
    "Fxn:all_weights";
    "Fxn:[[getattr(self,";
    "Import:torch.backends.cudnn.rnn";
    "class:RNN(RNNBase):";
    "Fxn:__init__";
    "Fxn:ValueError("Unknown";
    "Fxn:'{}'".format(";
    "Fxn:self).__init__(mode,";
    "class:LSTM(RNNBase):";
    "Fxn:__init__";
    "Fxn:self).__init__('LSTM',";
    "class:GRU(RNNBase):";
    "Fxn:__init__";
    "Fxn:self).__init__('GRU',";
    "class:RNNCellBase(Module):";
    "Fxn:__repr__";
    "Fxn:'{name}({input_size},";
    "Fxn:s.format(name=self.__class__.__name__,";
    "Fxn:check_forward_input";
    "Fxn:input.size(1)";
    "Fxn:RuntimeError(";
    "Fxn:{}".format(";
    "Fxn:input.size(1),";
    "Fxn:check_forward_hidden";
    "Fxn:input.size(0)";
    "Fxn:hx.size(0):";
    "Fxn:RuntimeError(";
    "Fxn:{}".format(";
    "Fxn:input.size(0),";
    "Fxn:hx.size(0)))";
    "Fxn:hx.size(1)";
    "Fxn:RuntimeError(";
    "Fxn:{}".format(";
    "Fxn:hx.size(1),";
    "class:RNNCell(RNNCellBase):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(hidden_size,";
    "Fxn:Parameter(torch.Tensor(hidden_size,";
    "Fxn:Parameter(torch.Tensor(hidden_size))";
    "Fxn:Parameter(torch.Tensor(hidden_size))";
    "Fxn:self.register_parameter('bias_ih',";
    "Fxn:self.register_parameter('bias_hh',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:self.parameters():";
    "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:forward";
    "Fxn:self.check_forward_input(input)";
    "Fxn:self.check_forward_hidden(input,";
    "Fxn:RuntimeError(";
    "Fxn:{}".format(self.nonlinearity))";
    "Fxn:func(";
    "class:LSTMCell(RNNCellBase):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(4";
    "Fxn:Parameter(torch.Tensor(4";
    "Fxn:Parameter(torch.Tensor(4";
    "Fxn:Parameter(torch.Tensor(4";
    "Fxn:self.register_parameter('bias_ih',";
    "Fxn:self.register_parameter('bias_hh',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:self.parameters():";
    "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:forward";
    "Fxn:self.check_forward_input(input)";
    "Fxn:self.check_forward_hidden(input,";
    "Fxn:self.check_forward_hidden(input,";
    "Fxn:self._backend.LSTMCell(";
    "class:GRUCell(RNNCellBase):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(3";
    "Fxn:Parameter(torch.Tensor(3";
    "Fxn:Parameter(torch.Tensor(3";
    "Fxn:Parameter(torch.Tensor(3";
    "Fxn:self.register_parameter('bias_ih',";
    "Fxn:self.register_parameter('bias_hh',";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:self.parameters():";
    "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:forward";
    "Fxn:self.check_forward_input(input)";
    "Fxn:self.check_forward_hidden(input,";
    "Fxn:self._backend.GRUCell(";
    "/torch/nn/modules/sparse.py";
    "Import:torch";
    "Import:Variable";
    "Import:Parameter";
    "Import:Module";
    "Import:functional";
    "class:Embedding(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(num_embeddings,";
    "Fxn:self.reset_parameters()";
    "Fxn:Parameter(_weight)";
    "Fxn:reset_parameters";
    "Fxn:self.weight.data.normal_(0,";
    "Fxn:self.weight.data[self.padding_idx].fill_(0)";
    "Fxn:forward";
    "Fxn:F.embedding(";
    "Fxn:__repr__";
    "Fxn:'{name}({num_embeddings},";
    "Fxn:s.format(name=self.__class__.__name__,";
    "Fxn:from_pretrained";
    "Fxn:torch.FloatTensor([[1,";
    "Fxn:nn.Embedding.from_pretrained(weight)";
    "Fxn:torch.LongTensor([1])";
    "Fxn:embedding(input)";
    "Fxn:embeddings.dim()";
    "Fxn:cls(num_embeddings=rows,";
    "class:EmbeddingBag(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:Parameter(torch.Tensor(num_embeddings,";
    "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters";
    "Fxn:self.weight.data.normal_(0,";
    "Fxn:forward";
    "Fxn:F.embedding_bag(self.weight,";
    "Fxn:__repr__";
    "Fxn:'{name}({num_embeddings},";
    "Fxn:s.format(name=self.__class__.__name__,";
    "/torch/nn/modules/upsampling.py";
    "Import:Integral";
    "Import:warnings";
    "Import:Module";
    "Import:functional";
    "class:Upsample(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:F.upsample(input,";
    "Fxn:__repr__";
    "Fxn:'('";
    "class:UpsamplingNearest2d(Upsample):";
    "Fxn:__init__";
    "Fxn:self).__init__(size,";
    "Fxn:forward";
    "Fxn:warnings.warn("nn.UpsamplingNearest2d";
    "Fxn:self).forward(input)";
    "class:UpsamplingBilinear2d(Upsample):";
    "Fxn:__init__";
    "Fxn:self).__init__(size,";
    "Fxn:forward";
    "Fxn:warnings.warn("nn.UpsamplingBilinear2d";
    "Fxn:self).forward(input)";
    "/torch/nn/modules/utils.py";
    "Import:collections";
    "Import:repeat";
    "Fxn:_ntuple";
    "Fxn:parse";
    "/torch/nn/modules/__init__.py";
    "Import:Module";
    "Import:Linear,";
    "Import:Conv1d,";
    "Import:Threshold,";
    "Import:L1Loss,";
    "Import:Container,";
    "Import:AvgPool1d,";
    "Import:BatchNorm1d,";
    "Import:InstanceNorm1d,";
    "Import:LocalResponseNorm,";
    "Import:Dropout,";
    "Import:ReflectionPad1d,";
    "Import:Embedding,";
    "Import:RNNBase,";
    "Import:PixelShuffle";
    "Import:UpsamplingNearest2d,";
    "Import:PairwiseDistance,";
    "Import:Fold,";
    "/torch/nn/parallel/data_parallel.py";
    "Import:operator";
    "Import:torch";
    "Import:warnings";
    "Import:Module";
    "Import:scatter_kwargs,";
    "Import:replicate";
    "Import:parallel_apply";
    "Fxn:_check_balance";
    "Fxn:warn_imbalance";
    "class:DataParallel(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:torch.cuda.is_available():";
    "Fxn:_check_balance(self.device_ids)";
    "Fxn:self.module.cuda(device_ids[0])";
    "Fxn:forward";
    "Fxn:self.module(*inputs,";
    "Fxn:self.scatter(inputs,";
    "Fxn:self.module(*inputs[0],";
    "Fxn:self.replicate(self.module,";
    "Fxn:self.device_ids[:len(inputs)])";
    "Fxn:self.parallel_apply(replicas,";
    "Fxn:self.gather(outputs,";
    "Fxn:replicate";
    "Fxn:replicate(module,";
    "Fxn:scatter";
    "Fxn:scatter_kwargs(inputs,";
    "Fxn:parallel_apply";
    "Fxn:parallel_apply(replicas,";
    "Fxn:self.device_ids[:len(replicas)])";
    "Fxn:gather";
    "Fxn:gather(outputs,";
    "Fxn:data_parallel";
    "Fxn:module(input)";
    "Fxn:module(input)";
    "Fxn:scatter_kwargs(inputs,";
    "Fxn:module(*inputs[0],";
    "Fxn:device_ids[:len(inputs)]";
    "Fxn:replicate(module,";
    "Fxn:parallel_apply(replicas,";
    "Fxn:gather(outputs,";
    "/torch/nn/parallel/distributed.py";
    "Import:sys";
    "Import:math";
    "Import:threading";
    "Import:copy";
    "Import:torch";
    "Import:Variable";
    "Import:_flatten_dense_tensors,";
    "Import:broadcast_coalesced";
    "Import:nccl";
    "Import:torch.distributed";
    "Import:Module";
    "Import:replicate";
    "Import:scatter_kwargs,";
    "Import:parallel_apply";
    "Import:queue";
    "Import:Queue";
    "class:DistributedDataParallel(Module):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:self._dist_broadcast_coalesced(module_states,";
    "Fxn:replicate(self.module,";
    "Fxn:module_copy.parameters()):";
    "Fxn:self._register_nccl_grad_hook()";
    "Fxn:param_buckets.append(list(_take_tensors(module.parameters(),";
    "Fxn:self.bucket_sizes.append(0)";
    "Fxn:param_tuple[0].type()";
    "Fxn:RuntimeError("DistributedDataParallel";
    "Fxn:self._register_grad_hooks()";
    "Fxn:threading.Lock()";
    "Fxn:self._start_reduction_threads()";
    "Fxn:__getstate__";
    "Fxn:copy.copy(self.__dict__)";
    "Fxn:__setstate__";
    "Fxn:self).__setstate__(state)";
    "Fxn:self._register_nccl_grad_hook()";
    "Fxn:self._register_grad_hooks()";
    "Fxn:self._start_reduction_threads()";
    "Fxn:forward";
    "Fxn:self.scatter(inputs,";
    "Fxn:self._sync_params()";
    "Fxn:self.module(*inputs[0],";
    "Fxn:self.parallel_apply(self._module_copies,";
    "Fxn:self.gather(outputs,";
    "Fxn:scatter";
    "Fxn:scatter_kwargs(inputs,";
    "Fxn:parallel_apply";
    "Fxn:parallel_apply(replicas,";
    "Fxn:self.device_ids[:len(replicas)])";
    "Fxn:gather";
    "Fxn:gather(outputs,";
    "Fxn:train";
    "Fxn:self).train(mode)";
    "Fxn:module.train(mode)";
    "Fxn:_dist_broadcast_coalesced";
    "Fxn:_take_tensors(tensors,";
    "Fxn:_flatten_dense_tensors(tensors)";
    "Fxn:dist.broadcast(flat_tensors,";
    "Fxn:_unflatten_dense_tensors(flat_tensors,";
    "Fxn:tensor.copy_(synced)";
    "Fxn:_sync_params";
    "Fxn:self.module.parameters()]";
    "Fxn:broadcast_coalesced(params,";
    "Fxn:module.parameters()):";
    "Fxn:param.data.set_(tensor)";
    "Fxn:self._dist_broadcast_coalesced(buffers,";
    "Fxn:broadcast_coalesced(buffers,";
    "Fxn:module._all_buffers()):";
    "Fxn:buf.set_(tensor)";
    "Fxn:_register_grad_hooks";
    "Fxn:module.parameters():";
    "Fxn:p.expand_as(p)";
    "Fxn:grad_acc.register_hook(self._make_param_hook(p,";
    "Fxn:self._grad_accs.append(grad_acc)";
    "Fxn:_register_nccl_grad_hook";
    "Fxn:dist.new_group()";
    "Fxn:reduction_fn_nccl";
    "Fxn:module.parameters():";
    "Fxn:RuntimeError("DistributedDataParallel";
    "Fxn:all_grads[dev_idx].append(param.grad.data)";
    "Fxn:_take_tensors(all_grads[dev_idx],";
    "Fxn:all_grads_buckets_iters.append(dev_grads_buckets)";
    "Fxn:torch.cuda.device(dev_id):";
    "Fxn:_flatten_dense_tensors(dev_grads_batch)";
    "Fxn:grads_batch_coalesced.append(dev_grads_batch_coalesced)";
    "Fxn:dist.all_reduce_multigpu(grads_batch_coalesced,";
    "Fxn:dist.get_world_size()";
    "Fxn:_unflatten_dense_tensors(grads_batch_coalesced[0],";
    "Fxn:grad.copy_(reduced)";
    "Fxn:module.parameters():";
    "Fxn:param.data.set_()";
    "Fxn:self.module.parameters():";
    "Fxn:allreduce_hook";
    "Fxn:Variable._execution_engine.queue_callback(reduction_fn_nccl)";
    "Fxn:p.register_hook(allreduce_hook)";
    "Fxn:_make_param_hook";
    "Fxn:distributed_data_parallel_hook";
    "Fxn:RuntimeError("DistributedDataParallel";
    "Fxn:bucket.append(param.grad.data)";
    "Fxn:param.data.set_()";
    "Fxn:torch.cuda.device(self.device_ids[device_idx]):";
    "Fxn:torch.cuda.Event()";
    "Fxn:event.record()";
    "Fxn:self._queue_reduction(bucket_idx)";
    "Fxn:_queue_reduction";
    "Fxn:threading.Event()";
    "Fxn:self._reduction_queues[bucket_idx].put((dev_buckets,";
    "Fxn:Variable._execution_engine.queue_callback(lambda:";
    "Fxn:event.wait())";
    "Fxn:sync_reduction_streams";
    "Fxn:torch.cuda.device(dev_id):";
    "Fxn:default_stream.wait_stream(reduction_stream)";
    "Fxn:Variable._execution_engine.queue_callback(sync_reduction_streams)";
    "Fxn:_start_reduction_threads";
    "Fxn:[queue.Queue()";
    "Fxn:torch.cuda.device(dev_id):";
    "Fxn:self._default_streams.append(torch.cuda.current_stream())";
    "Fxn:self._nccl_streams.append(torch.cuda.Stream())";
    "Fxn:torch.cuda.device(dev_id):";
    "Fxn:reduction_streams.append(torch.cuda.Stream())";
    "Fxn:dist._register_stream(reduction_streams[0])";
    "Fxn:dist.new_group()";
    "Fxn:self._reduction_threads.append(threading.Thread(";
    "Fxn:args=(reduction_queue,";
    "Fxn:self._reduction_threads[-1].start()";
    "Fxn:_reduction_thread_fn";
    "Fxn:_process_batch";
    "Fxn:queue.get()";
    "Fxn:torch.cuda.device(dev_id),";
    "Fxn:torch.cuda.stream(stream):";
    "Fxn:stream.wait_event(event)";
    "Fxn:_flatten_dense_tensors(grad_batch)";
    "Fxn:dev_coalesced.append(coalesced)";
    "Fxn:stream.synchronize()";
    "Fxn:nccl.reduce(dev_coalesced,";
    "Fxn:torch.cuda.stream(reduce_stream):";
    "Fxn:reduce_stream.wait_stream(nccl_streams[0])";
    "Fxn:dist.get_world_size()";
    "Fxn:dist.all_reduce(coalesced,";
    "Fxn:_unflatten_dense_tensors(coalesced,";
    "Fxn:grad.copy_(reduced)";
    "Fxn:job_event.set()";
    "Fxn:torch.cuda.device(device_ids[0]):";
    "Fxn:_process_batch()";
    "/torch/nn/parallel/parallel_apply.py";
    "Import:threading";
    "Import:torch";
    "Import:Variable";
    "Fxn:get_a_var";
    "Fxn:parallel_apply";
    "Fxn:_worker";
    "/torch/nn/parallel/replicate.py";
    "Import:torch.cuda.comm";
    "Fxn:replicate";
    "Import:Broadcast";
    "/torch/nn/parallel/scatter_gather.py";
    "Import:torch";
    "Import:Variable";
    "Import:Scatter,";
    "Fxn:scatter";
    "Fxn:scatter_map";
    "Fxn:scatter_kwargs";
    "Fxn:gather";
    "Fxn:gather_map";
    "/torch/nn/parallel/_functions.py";
    "Import:torch";
    "Import:torch.cuda.comm";
    "Import:Function";
    "class:Broadcast(Function):";
    "Fxn:forward";
    "Fxn:TypeError('Broadcast";
    "Fxn:inputs[0].get_device()";
    "Fxn:comm.broadcast_coalesced(inputs,";
    "Fxn:non_differentiables.append(output[idx])";
    "Fxn:ctx.mark_non_differentiable(*non_differentiables)";
    "Fxn:backward";
    "Fxn:ReduceAddCoalesced.apply(ctx.input_device,";
    "class:ReduceAddCoalesced(Function):";
    "Fxn:forward";
    "Fxn:[grads[i].get_device()";
    "Fxn:comm.reduce_add_coalesced(grads,";
    "Fxn:backward";
    "Fxn:Broadcast.apply(ctx.target_gpus,";
    "class:Gather(Function):";
    "Fxn:forward";
    "Fxn:i.get_device(),";
    "Fxn:i.size(ctx.dim),";
    "Fxn:comm.gather(inputs,";
    "Fxn:backward";
    "Fxn:Scatter.apply(ctx.input_gpus,";
    "class:Scatter(Function):";
    "Fxn:forward";
    "Fxn:input.get_device()";
    "Fxn:[_get_stream(device)";
    "Fxn:comm.scatter(input,";
    "Fxn:torch.cuda.device(ctx.target_gpus[i]):";
    "Fxn:torch.cuda.current_stream()";
    "Fxn:main_stream.wait_stream(streams[i])";
    "Fxn:output.record_stream(main_stream)";
    "Fxn:backward";
    "Fxn:Gather.apply(ctx.input_device,";
    "Fxn:_get_stream";
    "Fxn:torch.cuda.device_count()";
    "Fxn:torch.cuda.Stream(device)";
    "/torch/nn/parallel/__init__.py";
    "Import:parallel_apply";
    "Import:replicate";
    "Import:DataParallel,";
    "Import:scatter,";
    "Import:DistributedDataParallel";
    "/torch/nn/utils/clip_grad.py";
    "Fxn:clip_grad_norm";
    "/torch/nn/utils/convert_parameters.py";
    "Import:torch";
    "Import:Variable";
    "Fxn:parameters_to_vector";
    "Fxn:vector_to_parameters";
    "Fxn:_check_param_device";
    "/torch/nn/utils/rnn.py";
    "Import:namedtuple";
    "Import:torch";
    "Import:Variable";
    "Import:torch.onnx";
    "Import:PackPadded";
    "class:PackedSequence(PackedSequence_):";
    "Fxn:__new__";
    "Fxn:`PackedSequence(data,";
    "Fxn:cls).__new__(cls,";
    "Fxn:`PackedSequence((data,";
    "Fxn:cls).__new__(cls,";
    "Fxn:cuda";
    "Fxn:cpu";
    "Fxn:double";
    "Fxn:float";
    "Fxn:half";
    "Fxn:long";
    "Fxn:int";
    "Fxn:short";
    "Fxn:char";
    "Fxn:byte";
    "Fxn:is_cuda";
    "Fxn:_symbolic_pack_padded_sequence";
    "Fxn:g.op('Transpose',";
    "Fxn:g.op("PackPadded",";
    "Fxn:@torch.onnx.symbolic_override_first_arg_based(_symbolic_pack_padded_sequence)";
    "Fxn:pack_padded_sequence";
    "Fxn:Variable(torch.LongTensor(lengths))";
    "Fxn:PackPadded.apply(input,";
    "Fxn:PackedSequence(data,";
    "Fxn:_symbolic_pad_packed_sequence";
    "Fxn:g.op("PadPacked",";
    "Fxn:g.op('Transpose',";
    "Fxn:@torch.onnx.symbolic_override_packed_sequence_based(_symbolic_pad_packed_sequence)";
    "Fxn:pad_packed_sequence";
    "Fxn:var_data.data.new(len(batch_sizes),";
    "Fxn:*var_data.size()[1:]).fill_(padding_value)";
    "Fxn:Variable(output)";
    "Fxn:tmp.view(i";
    "Fxn:*tmp.size()[1:])";
    "Fxn:lengths.extend((i,)";
    "Fxn:lengths.reverse()";
    "Fxn:output.transpose(0,";
    "Fxn:Variable(torch.LongTensor(lengths))";
    "Fxn:pad_sequence";
    "Fxn:Variable(torch.ones(25,";
    "Fxn:Variable(torch.ones(22,";
    "Fxn:Variable(torch.ones(15,";
    "Fxn:pad_sequence([a,";
    "Fxn:c]).size()";
    "Fxn:torch.Size([25,";
    "Fxn:sequences[0].size()";
    "Fxn:Variable(sequences[0].data.new(*out_dims).fill_(padding_value))";
    "Fxn:variable.size(0)";
    "Fxn:ValueError("lengths";
    "Fxn:pack_sequence";
    "Fxn:Variable(torch.Tensor([1,2,3]))";
    "Fxn:Variable(torch.Tensor([4,5]))";
    "Fxn:Variable(torch.Tensor([6]))";
    "Fxn:pack_sequence([a,";
    "Fxn:PackedSequence(data=";
    "Fxn:pack_padded_sequence(pad_sequence(sequences),";
    "Fxn:[v.size(0)";
    "Import:pad_sequence";
    "Import:pack_sequence";
    "/torch/nn/utils/weight_norm.py";
    "Import:Parameter";
    "Fxn:_norm";
    "class:WeightNorm(object):";
    "Fxn:__init__";
    "Fxn:compute_weight";
    "Fxn:_norm(v,";
    "Fxn:apply";
    "Fxn:WeightNorm(name,";
    "Fxn:module.register_parameter(name";
    "Fxn:Parameter(_norm(weight,";
    "Fxn:module.register_parameter(name";
    "Fxn:Parameter(weight.data))";
    "Fxn:fn.compute_weight(module))";
    "Fxn:forward()";
    "Fxn:module.register_forward_pre_hook(fn)";
    "Fxn:remove";
    "Fxn:self.compute_weight(module)";
    "Fxn:module.register_parameter(self.name,";
    "Fxn:Parameter(weight.data))";
    "Fxn:__call__";
    "Fxn:self.compute_weight(module))";
    "Fxn:weight_norm";
    "Fxn:weight_norm(nn.Linear(20,";
    "Fxn:m.weight_g.size()";
    "Fxn:torch.Size([40,";
    "Fxn:m.weight_v.size()";
    "Fxn:torch.Size([40,";
    "Fxn:WeightNorm.apply(module,";
    "Fxn:remove_weight_norm";
    "Fxn:weight_norm(nn.Linear(20,";
    "Fxn:remove_weight_norm(m)";
    "Fxn:module._forward_pre_hooks.items():";
    "Fxn:hook.remove(module)";
    "Fxn:ValueError("weight_norm";
    "Fxn:.format(name,";
    "/torch/nn/utils/__init__.py";
    "Import:rnn";
    "Import:clip_grad_norm";
    "Import:weight_norm,";
    "Import:parameters_to_vector,";
    "/torch/nn/_functions/dropout.py";
    "Import:torch";
    "Import:InplaceFunction";
    "Import:Variable";
    "Import:repeat";
    "class:Dropout(InplaceFunction):";
    "Fxn:_make_noise";
    "Fxn:input.new().resize_as_(input)";
    "Fxn:symbolic";
    "Fxn:g.op("Dropout",";
    "Fxn:forward";
    "Fxn:ValueError("dropout";
    "Fxn:{}".format(p))";
    "Fxn:ctx.mark_dirty(input)";
    "Fxn:input.clone()";
    "Fxn:cls._make_noise(input)";
    "Fxn:ctx.noise.fill_(0)";
    "Fxn:ctx.noise.bernoulli_(1";
    "Fxn:ctx.p).div_(1";
    "Fxn:ctx.noise.expand_as(input)";
    "Fxn:output.mul_(ctx.noise)";
    "Fxn:backward";
    "class:FeatureDropout(Dropout):";
    "Fxn:symbolic";
    "Fxn:_unimplemented("FeatureDropout",";
    "Fxn:_make_noise";
    "Fxn:input.new().resize_(input.size(0),";
    "Fxn:input.size(1),";
    "Fxn:*repeat(1,";
    "Fxn:input.dim()";
    "Import:_unimplemented";
    "/torch/nn/_functions/linear.py";
    "Import:torch";
    "Import:Function,";
    "class:Bilinear(Function):";
    "Fxn:forward";
    "Fxn:ctx.save_for_backward(input1,";
    "Fxn:input1.new(input1.size(0),";
    "Fxn:weight.size(0))";
    "Fxn:input1.new()";
    "Fxn:torch.mm(input1,";
    "Fxn:buff.mul_(input2)";
    "Fxn:torch.sum(buff,";
    "Fxn:out=output.narrow(1,";
    "Fxn:output.add_(bias.expand_as(output))";
    "Fxn:backward";
    "Fxn:Variable(input1.data.new())";
    "Fxn:torch.mm(input2,";
    "Fxn:weight[0].t())";
    "Fxn:grad_input1.mul(grad_output.narrow(1,";
    "Fxn:1).expand(grad_input1.size()))";
    "Fxn:torch.mm(input1,";
    "Fxn:grad_input2.mul(grad_output.narrow(1,";
    "Fxn:1).expand(grad_input2.size()))";
    "Fxn:weight.size(0)):";
    "Fxn:input2.mm(weight[k].t())";
    "Fxn:buff.mul(grad_output.narrow(1,";
    "Fxn:1).expand(grad_input1.size()))";
    "Fxn:grad_input1.add_(buff)";
    "Fxn:input1.mm(weight[k])";
    "Fxn:buff.mul(grad_output.narrow(1,";
    "Fxn:1).expand(grad_input2.size()))";
    "Fxn:grad_input2.add_(buff)";
    "Fxn:Variable(weight.data.new(weight.size()))";
    "Fxn:input1.mul(grad_output.narrow(1,";
    "Fxn:1).expand_as(input1))";
    "Fxn:torch.mm(buff.t(),";
    "Fxn:grad_output.sum(0,";
    "/torch/nn/_functions/loss.py";
    "Import:torch";
    "Import:Function,";
    "Import:once_differentiable";
    "class:MarginRankingLoss(Function):";
    "Fxn:forward";
    "Fxn:input1.clone()";
    "Fxn:_output.add_(-1,";
    "Fxn:_output.mul_(-1).mul_(y)";
    "Fxn:_output.add_(ctx.margin)";
    "Fxn:_output.clamp_(min=0)";
    "Fxn:_output.sum()";
    "Fxn:y.size(0)";
    "Fxn:ctx.save_for_backward(input1,";
    "Fxn:backward";
    "Fxn:Variable(input1.data.new(input1.size()).zero_())";
    "Fxn:Variable(input1.data.new(input1.size()).zero_())";
    "Fxn:input2).mul_(-1)";
    "Fxn:y).add_(ctx.margin)";
    "Fxn:dist.ge(0)";
    "Fxn:grad_input1.masked_fill_(mask,";
    "Fxn:grad_input1.mul_(-1)";
    "Fxn:grad_input2.masked_fill_(mask,";
    "Fxn:grad_input1.div_(y.size(0))";
    "Fxn:grad_input2.div_(y.size(0))";
    "/torch/nn/_functions/packing.py";
    "Import:torch";
    "Import:Function";
    "class:PackPadded(Function):";
    "Fxn:forward";
    "Fxn:input.transpose(0,";
    "Fxn:ValueError("Length";
    "Fxn:input.size(1)";
    "Fxn:ValueError("Expected";
    "Fxn:`len(lengths)`";
    "Fxn:steps.append(input[prev_l:l,";
    "Fxn::c_batch_size].contiguous().view(-1,";
    "Fxn:*input.size()[2:]))";
    "Fxn:batch_sizes.extend([c_batch_size]";
    "Fxn:ValueError("'lengths'";
    "Fxn:input.size()";
    "Fxn:torch.cat(steps),";
    "Fxn:torch.LongTensor(batch_sizes)";
    "Fxn:backward";
    "Fxn:grad_steps.new(*ctx.input_size).zero_()";
    "Fxn:grad_input.transpose(0,";
    "/torch/nn/_functions/padding.py";
    "Import:Function,";
    "Import:prepare_onnx_paddings";
    "class:ConstantPadNd(Function):";
    "Fxn:symbolic";
    "Fxn:prepare_onnx_paddings(len(input.type().sizes()),";
    "Fxn:g.op("Pad",";
    "Fxn:forward";
    "Fxn:input.size()";
    "Fxn:input.new(input.size()[:(ctx.l_diff)]";
    "Fxn:new_dim).fill_(ctx.value)";
    "Fxn:c_input.narrow(i,";
    "Fxn:c_input.size(i)";
    "Fxn:c_input.narrow(i,";
    "Fxn:c_input.size(i)";
    "Fxn:c_output.narrow(i,";
    "Fxn:c_output.size(i)";
    "Fxn:c_output.narrow(i,";
    "Fxn:c_output.size(i)";
    "Fxn:c_output.copy_(c_input)";
    "Fxn:backward";
    "Fxn:Variable(grad_output.data.new(ctx.input_size).zero_())";
    "Fxn:[slice(0,";
    "Fxn:narrow_slice";
    "Fxn:slice_length";
    "Fxn:narrow_slice(i,";
    "Fxn:slice_length(i)";
    "Fxn:narrow_slice(i,";
    "Fxn:slice_length(i)";
    "Fxn:cg_output.narrow(i_s,";
    "Fxn:cg_output.size(i_s)";
    "Fxn:cg_output.narrow(i_s,";
    "Fxn:cg_output.size(i_s)";
    "/torch/nn/_functions/rnn.py";
    "Import:warnings";
    "Import:NestedIOFunction,";
    "Import:torch.backends.cudnn";
    "Import:functional";
    "Import:rnnFusedPointwise";
    "Import:itertools";
    "Import:torch.backends.cudnn.rnn";
    "Fxn:RNNReLUCell";
    "Fxn:RNNTanhCell";
    "Fxn:LSTMCell";
    "Fxn:GRUCell";
    "Fxn:StackedRNN";
    "Fxn:forward";
    "Fxn:Recurrent";
    "Fxn:forward";
    "Fxn:variable_recurrent_factory";
    "Fxn:VariableRecurrent";
    "Fxn:forward";
    "Fxn:VariableRecurrentReverse";
    "Fxn:forward";
    "Fxn:AutogradRNN";
    "Fxn:forward";
    "Fxn:CudnnRNN";
    "Fxn:forward";
    "Fxn:RNN";
    "Fxn:forward";
    "Import:torch";
    "Import:torch.onnx.symbolic";
    "/torch/nn/_functions/vision.py";
    "Import:torch";
    "Import:Function";
    "Import:once_differentiable";
    "Import:type2backend";
    "Import:function_by_name";
    "Import:torch.backends.cudnn";
    "Fxn:grid_sampler";
    "Fxn:affine_grid_generator";
    "class:GridSampler(Function):";
    "Fxn:forward";
    "Fxn:ctx.save_for_backward(input,";
    "Fxn:ValueError("padding_mode";
    "Fxn:{}".format(padding_mode))";
    "Fxn:grid.size()";
    "Fxn:type2backend[input.type()]";
    "Fxn:input.dim()";
    "Fxn:input.new(grid_sz[0],";
    "Fxn:input.size(1),";
    "Fxn:backend.SpatialGridSamplerBilinear_updateOutput(backend.library_state,";
    "Fxn:input.dim()";
    "Fxn:input.new(grid_sz[0],";
    "Fxn:input.size(1),";
    "Fxn:backend.VolumetricGridSamplerBilinear_updateOutput(backend.library_state,";
    "Fxn:ValueError("input";
    "Fxn:{}".format(input.shape))";
    "Fxn:backward";
    "Fxn:type2backend[input.type()]";
    "Fxn:input.new(input.size())";
    "Fxn:grid.new(grid.size())";
    "Fxn:input.dim()";
    "Fxn:backend.SpatialGridSamplerBilinear_updateGradInput(";
    "Fxn:input.dim()";
    "Fxn:backend.VolumetricGridSamplerBilinear_updateGradInput(";
    "Fxn:ValueError("input";
    "Fxn:{}".format(input.shape))";
    "class:AffineGridGenerator(Function):";
    "Fxn:_enforce_cudnn";
    "Fxn:RuntimeError("AffineGridGenerator";
    "Fxn:cudnn.is_acceptable(input)";
    "Fxn:forward";
    "Fxn:AffineGridGenerator._enforce_cudnn(theta)";
    "Fxn:theta.new(N,";
    "Fxn:torch.linspace(-1,";
    "Fxn:torch.Tensor([-1])";
    "Fxn:torch.ger(torch.ones(H),";
    "Fxn:linear_points).expand_as(base_grid[:,";
    "Fxn:torch.linspace(-1,";
    "Fxn:torch.Tensor([-1])";
    "Fxn:torch.ger(linear_points,";
    "Fxn:torch.ones(W)).expand_as(base_grid[:,";
    "Fxn:torch.bmm(base_grid.view(N,";
    "Fxn:theta.transpose(1,";
    "Fxn:grid.view(N,";
    "Fxn:backward";
    "Fxn:grad_grid.size()";
    "Fxn:torch.Size([N,";
    "Fxn:AffineGridGenerator._enforce_cudnn(grad_grid)";
    "Fxn:torch.bmm(";
    "Fxn:base_grid.view(N,";
    "Fxn:3).transpose(1,";
    "Fxn:grad_grid.view(N,";
    "Fxn:grad_theta.transpose(1,";
    "/torch/nn/_functions/__init__.py";
    "/torch/nn/_functions/thnn/auto.py";
    "Import:repeat";
    "Import:defaultdict";
    "Import:torch";
    "Import:parse_header,";
    "Import:Variable";
    "Import:Function,";
    "Import:type2backend";
    "Import:double_backwards_fns";
    "Import:symbolic_fns";
    "Import:_all_functions";
    "Fxn:_make_function_class_criterion";
    "Fxn:symbolic";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:backward_cls_forward";
    "Fxn:backward_cls_backward";
    "Fxn:_find_buffers";
    "Fxn:_make_function_class";
    "Fxn:has_argument";
    "Fxn:_initialize_buffers";
    "Fxn:symbolic";
    "Fxn:forward";
    "Fxn:backward";
    "Fxn:backward_cls_forward";
    "Fxn:backward_cls_backward";
    "Fxn:_generate_function_classes";
    "Fxn:make_default_double_backwards_fn";
    "Fxn:default_double_backwards_fn";
    "/torch/nn/_functions/thnn/auto_double_backwards.py";
    "Import:Variable";
    "Import:torch";
    "Fxn:elu_double_backwards";
    "Fxn:gatedlinear_double_backwards";
    "Fxn:hardshrink_double_backwards";
    "Fxn:hardtanh_double_backwards";
    "Fxn:leakyrelu_double_backwards";
    "Fxn:logsigmoid_double_backwards";
    "Fxn:softplus_double_backwards";
    "Fxn:softshrink_double_backwards";
    "Fxn:threshold_double_backwards";
    "Fxn:klddivloss_double_backwards";
    "Fxn:l1loss_double_backwards";
    "Fxn:mseloss_double_backwards";
    "Fxn:nllloss_double_backwards";
    "Fxn:smoothl1loss_double_backwards";
    "Fxn:softmarginloss_double_backwards";
    "/torch/nn/_functions/thnn/auto_symbolic.py";
    "Import:prepare_onnx_paddings";
    "Fxn:reflectionpad_symbolic";
    "Fxn:replicationpad_symbolic";
    "/torch/nn/_functions/thnn/fold.py";
    "Import:Function,";
    "Import:type2backend";
    "Import:_all_functions";
    "class:Col2Im(Function):";
    "Fxn:forward";
    "Fxn:type2backend[input.type()]";
    "Fxn:input.new()";
    "Fxn:ctx._backend.Col2Im_updateOutput(ctx._backend.library_state,";
    "Fxn:backward";
    "Fxn:grad_output.new()";
    "Fxn:ctx._backend.Col2Im_updateGradInput(ctx._backend.library_state,";
    "class:Im2Col(Function):";
    "Fxn:forward";
    "Fxn:input.dim()";
    "Fxn:input.size(3))";
    "Fxn:type2backend[input.type()]";
    "Fxn:input.new()";
    "Fxn:ctx._backend.Im2Col_updateOutput(ctx._backend.library_state,";
    "Fxn:backward";
    "Fxn:grad_output.new()";
    "Fxn:ctx._backend.Im2Col_updateGradInput(ctx._backend.library_state,";
    "/torch/nn/_functions/thnn/normalization.py";
    "Import:torch";
    "Import:Function";
    "Import:type2backend";
    "Import:_all_functions";
    "class:CrossMapLRN2d(Function):";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:forward";
    "Fxn:input.dim()";
    "Fxn:input.new()";
    "Fxn:input.new()";
    "Fxn:type2backend[input.type()]";
    "Fxn:self._backend.SpatialCrossMapLRN_updateOutput(";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:input.size(2)";
    "Fxn:input.size(3)";
    "Fxn:output.resize_as_(input)";
    "Fxn:self.scale.resize_as_(input)";
    "Fxn:torch.pow(input,";
    "Fxn:self.scale.select(1,";
    "Fxn:scale_first.zero_()";
    "Fxn:scale_first.add_(input_square.select(1,";
    "Fxn:self.scale.select(1,";
    "Fxn:self.scale.select(1,";
    "Fxn:scale_current.copy_(scale_previous)";
    "Fxn:input_square.select(1,";
    "Fxn:scale_current.add_(1,";
    "Fxn:input_square.select(1,";
    "Fxn:scale_current.add_(-1,";
    "Fxn:self.scale.mul_(self.alpha";
    "Fxn:self.size).add_(self.k)";
    "Fxn:torch.pow(self.scale,";
    "Fxn:output.mul_(input)";
    "Fxn:self.save_for_backward(input,";
    "Fxn:backward";
    "Fxn:grad_output.new()";
    "Fxn:self._backend.SpatialCrossMapLRN_updateGradInput(";
    "Fxn:input.size(0)";
    "Fxn:input.size(1)";
    "Fxn:input.size(2)";
    "Fxn:input.size(3)";
    "Fxn:input.new(channels";
    "Fxn:input.new(input_height,";
    "Fxn:grad_input.resize_as_(input)";
    "Fxn:torch.pow(self.scale,";
    "Fxn:out=grad_input).mul_(grad_output)";
    "Fxn:paddded_ratio.zero_()";
    "Fxn:paddded_ratio.narrow(0,";
    "Fxn:torch.mul(grad_output[n],";
    "Fxn:padded_ratio_center.div_(self.scale[n])";
    "Fxn:torch.sum(";
    "Fxn:paddded_ratio.narrow(0,";
    "Fxn:accum_ratio.add_(paddded_ratio[c";
    "Fxn:grad_input[n][c].addcmul_(-cache_ratio_value,";
    "Fxn:accum_ratio.add_(-1,";
    "Fxn:_all_functions.append(CrossMapLRN2d)";
    "/torch/nn/_functions/thnn/rnnFusedPointwise.py";
    "Import:torch";
    "Import:Function,";
    "Import:type2backend";
    "class:GRUFused(Function):";
    "Fxn:forward";
    "Fxn:type2backend[input_gate.type()]";
    "Fxn:input_gate.new()";
    "Fxn:input_gate.new(hx.numel()";
    "Fxn:ibias.dim()";
    "Fxn:ibias.unsqueeze(0)";
    "Fxn:hbias.dim()";
    "Fxn:hbias.unsqueeze(0)";
    "Fxn:ctx.backend.GRUFused_updateOutput(";
    "Fxn:input_gate.size()";
    "Fxn:hidden_gate.size()";
    "Fxn:backward";
    "Fxn:type2backend[gradOutput.type()]";
    "Fxn:gradOutput.new()";
    "Fxn:gradOutput.new(*ctx.igate_size)";
    "Fxn:gradOutput.new(*ctx.hgate_size)";
    "Fxn:ctx.backend.GRUFused_updateGradInput(";
    "Fxn:gradInInput.sum(0,";
    "Fxn:gradInHidden.sum(0,";
    "class:LSTMFused(Function):";
    "Fxn:forward";
    "Fxn:type2backend[input_gate.type()]";
    "Fxn:input_gate.new()";
    "Fxn:input_gate.new()";
    "Fxn:ibias.dim()";
    "Fxn:ibias.unsqueeze(0)";
    "Fxn:hbias.dim()";
    "Fxn:hbias.unsqueeze(0)";
    "Fxn:ctx.backend.LSTMFused_updateOutput(";
    "Fxn:hidden_gate.size()";
    "Fxn:ctx.save_for_backward(input_gate,";
    "Fxn:backward";
    "Fxn:type2backend[gradOutput[0].type()]";
    "Fxn:gradOutput[0].new()";
    "Fxn:gradOutput[0].new(*ctx.hgate_size)";
    "Fxn:ctx.backend.LSTMFused_updateGradInput(";
    "Fxn:gradInGates.sum(0,";
    "Fxn:gradInGates.sum(0,";
    "/torch/nn/_functions/thnn/sparse.py";
    "Import:torch";
    "Import:Function";
    "Import:type2backend";
    "Import:once_differentiable";
    "Import:_all_functions";
    "class:EmbeddingBag(Function):";
    "Fxn:_renorm";
    "Fxn:ctx._backend.LookupTable_renorm(";
    "Fxn:indices.clone().view(-1),";
    "Fxn:forward";
    "Fxn:ValueError("mode";
    "Fxn:.format(mode))";
    "Fxn:indices.dim()";
    "Fxn:offsets.dim()";
    "Fxn:ValueError("offsets";
    "Fxn:ValueError("offsets[0]";
    "Fxn:{}".format(offsets[0]))";
    "Fxn:indices.size(0):";
    "Fxn:ValueError("offsets[-1]";
    "Fxn:.format(indices.size(0),";
    "Fxn:type2backend[weight.type()]";
    "Fxn:weight.size()";
    "Fxn:offsets.new()";
    "Fxn:ctx.save_for_backward(indices)";
    "Fxn:indices.contiguous().view(-1)";
    "Fxn:weight.new()";
    "Fxn:cls._renorm(ctx,";
    "Fxn:offsets.new().resize_(offsets.size())";
    "Fxn:ctx._backend.LookupTableBag_updateOutput(";
    "Fxn:torch.index_select(weight,";
    "Fxn:ctx._offset2bag.resize_(indices.size(0)).zero_()";
    "Fxn:ctx._offset2bag.index_fill_(0,";
    "Fxn:ctx._offset2bag.cumsum(0)";
    "Fxn:output.resize_(offsets.size(0),";
    "Fxn:weight.size(1)).zero_()";
    "Fxn:output.index_add_(0,";
    "Fxn:offsets.size(0)";
    "Fxn:indices.size(0)";
    "Fxn:weight.new().resize_(offsets.size())";
    "Fxn:indices.size(0)";
    "Fxn:None].expand_as(output)";
    "Fxn:backward";
    "Fxn:indices.contiguous().view(-1)";
    "Fxn:grad_output.contiguous()";
    "Fxn:torch.cuda.device_of(grad_output):";
    "Fxn:torch.cuda.LongTensor()";
    "Fxn:torch.cuda.LongTensor()";
    "Fxn:torch.cuda.LongTensor()";
    "Fxn:torch.IntTensor()";
    "Fxn:grad_output.new(ctx._weight_size).zero_()";
    "Fxn:ctx._backend.LookupTableBag_accGradParameters(";
    "Fxn:grad_output.index_select(0,";
    "Fxn:ctx._backend.LookupTable_accGradParameters(";
    "Fxn:_all_functions.append(EmbeddingBag)";
    "/torch/nn/_functions/thnn/__init__.py";
    "Import:.normalization";
    "Import:.fold";
    "Import:.sparse";
    "Import:.rnnFusedPointwise";
    "/torch/onnx/symbolic.py";
    "Import:torch";
    "Import:_single,";
    "Import:PackedSequence";
    "Import:warnings";
    "Import:torch.onnx";
    "Import:partial";
    "Fxn:_scalar";
    "Fxn:_if_scalar_type_as";
    "Fxn:_broadcast_if_scalar";
    "Fxn:_unimplemented";
    "Fxn:unused";
    "Fxn:Constant";
    "Fxn:add";
    "Fxn:sub";
    "Fxn:mul";
    "Fxn:div";
    "Fxn:cat";
    "Fxn:mm";
    "Fxn:bmm";
    "Fxn:matmul";
    "Fxn:addmm";
    "Fxn:neg";
    "Fxn:sqrt";
    "Fxn:tanh";
    "Fxn:sigmoid";
    "Fxn:mean";
    "Fxn:sum";
    "Fxn:cumsum";
    "Fxn:prod";
    "Fxn:t";
    "Fxn:expand";
    "Fxn:embedding";
    "Fxn:embedding_bag";
    "Fxn:transpose";
    "Fxn:permute";
    "Fxn:view";
    "Fxn:split";
    "Fxn:chunk";
    "Fxn:select";
    "Fxn:squeeze";
    "Fxn:prelu";
    "Fxn:relu";
    "Fxn:threshold";
    "Fxn:leaky_relu";
    "Fxn:glu";
    "Fxn:softmax";
    "Fxn:softplus";
    "Fxn:max_pool1d";
    "Fxn:max_pool2d";
    "Fxn:avg_pool2d";
    "Fxn:avg_pool3d";
    "Fxn:reflection_pad";
    "Import:prepare_onnx_paddings";
    "Fxn:replication_pad";
    "Import:prepare_onnx_paddings";
    "Fxn:upsample_nearest2d";
    "Fxn:upsample_bilinear2d";
    "Fxn:gt";
    "Fxn:lt";
    "Fxn:log_softmax";
    "Fxn:_convolution";
    "Fxn:batch_norm";
    "Fxn:unfold";
    "Fxn:elu";
    "Fxn:selu";
    "Fxn:index_select";
    "Fxn:type_as";
    "Fxn:clone";
    "Fxn:abs";
    "Fxn:pow";
    "Fxn:clamp";
    "Fxn:max";
    "Fxn:min";
    "Fxn:eq";
    "Fxn:exp";
    "Fxn:conv_tbc";
    "Fxn:_cast_func_template";
    "Fxn:slice";
    "Fxn:alias";
    "Fxn:unsqueeze";
    "Fxn:topk";
    "Fxn:instance_norm";
    "Fxn:RNN_symbolic_builder";
    "Fxn:reform_weights";
    "Fxn:Elman_RNN_symbolic_builder";
    "Fxn:symbolic";
    "Fxn:LSTM_symbolic_builder";
    "Fxn:symbolic";
    "Fxn:GRU_symbolic_builder";
    "Fxn:symbolic";
    "/torch/onnx/utils.py";
    "Import:torch";
    "Import:torch.jit";
    "Import:torch.autograd";
    "Import:torch.serialization";
    "Import:import";
    "Import:collections";
    "Import:contextlib";
    "Import:numbers";
    "Import:warnings";
    "Import:functools";
    "Import:types";
    "Import:string_classes";
    "Import:Function,";
    "Import:_unique_state_dict";
    "Fxn:set_training";
    "Fxn:export";
    "Fxn:_optimize_trace";
    "Fxn:_trace";
    "Fxn:_export";
    "Import:_onnx_opset_version";
    "Fxn:_set_input_and_output_names";
    "Fxn:set_names";
    "Fxn:_run_symbolic_method";
    "Fxn:_is_onnx_list";
    "Fxn:_add_attribute";
    "Fxn:_scalar";
    "Fxn:_newNode";
    "Fxn:_graph_op";
    "Fxn:const_if_tensor";
    "Fxn:_run_symbolic_function";
    "Import:torch.onnx.symbolic";
    "Fxn:_graph_at";
    "Fxn:_graph_constant";
    "Fxn:_node_getitem";
    "/torch/onnx/__init__.py";
    "Import:functools";
    "Import:types";
    "Fxn:_export";
    "Import:utils";
    "Fxn:export";
    "Import:utils";
    "Fxn:_optimize_trace";
    "Import:utils";
    "Fxn:set_training";
    "Import:utils";
    "Fxn:_run_symbolic_function";
    "Import:utils";
    "Fxn:_run_symbolic_method";
    "Import:utils";
    "Fxn:_symbolic_override_wrapper_maker";
    "Fxn:wrapper";
    "Import:torch";
    "Import:torch.jit";
    "Import:Function,";
    "Fxn:symbolic_override";
    "Fxn:symb";
    "Fxn:foo";
    "Fxn:symbolic_override_first_arg_based";
    "Fxn:might_trace";
    "Import:torch";
    "Fxn:symbolic_override_packed_sequence_based";
    "Fxn:might_trace";
    "Import:torch";
    "/torch/optim/adadelta.py";
    "Import:torch";
    "Import:Optimizer";
    "class:Adadelta(Optimizer):";
    "Fxn:__init__";
    "Fxn:self).__init__(params,";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError('Adadelta";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:grad.add(group['weight_decay'],";
    "Fxn:square_avg.mul_(rho).addcmul_(1";
    "Fxn:square_avg.add(eps).sqrt_()";
    "Fxn:acc_delta.add(eps).sqrt_().div_(std).mul_(grad)";
    "Fxn:p.data.add_(-group['lr'],";
    "Fxn:acc_delta.mul_(rho).addcmul_(1";
    "/torch/optim/adagrad.py";
    "Import:torch";
    "Import:Optimizer";
    "class:Adagrad(Optimizer):";
    "Fxn:__init__";
    "Fxn:self).__init__(params,";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:share_memory";
    "Fxn:state['sum'].share_memory_()";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError("weight_decay";
    "Fxn:grad.add(group['weight_decay'],";
    "Fxn:grad.coalesce()";
    "Fxn:grad._indices()";
    "Fxn:grad._values()";
    "Fxn:grad.size()";
    "Fxn:make_sparse";
    "Fxn:grad_indices.dim()";
    "Fxn:values.dim()";
    "Fxn:constructor().resize_as_(grad)";
    "Fxn:constructor(grad_indices,";
    "Fxn:state['sum'].add_(make_sparse(grad_values.pow(2)))";
    "Fxn:state['sum']._sparse_mask(grad)";
    "Fxn:std._values().sqrt_().add_(1e-10)";
    "Fxn:p.data.add_(-clr,";
    "Fxn:make_sparse(grad_values";
    "Fxn:state['sum'].addcmul_(1,";
    "Fxn:state['sum'].sqrt().add_(1e-10)";
    "Fxn:p.data.addcdiv_(-clr,";
    "/torch/optim/adam.py";
    "Import:math";
    "Import:torch";
    "Import:Optimizer";
    "class:Adam(Optimizer):";
    "Fxn:__init__";
    "Fxn:betas=(0.9,";
    "Fxn:ValueError("Invalid";
    "Fxn:{}".format(betas[0]))";
    "Fxn:ValueError("Invalid";
    "Fxn:{}".format(betas[1]))";
    "Fxn:self).__init__(params,";
    "Fxn:__setstate__";
    "Fxn:self).__setstate__(state)";
    "Fxn:group.setdefault('amsgrad',";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError('Adam";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:grad.add(group['weight_decay'],";
    "Fxn:exp_avg.mul_(beta1).add_(1";
    "Fxn:exp_avg_sq.mul_(beta2).addcmul_(1";
    "Fxn:torch.max(max_exp_avg_sq,";
    "Fxn:max_exp_avg_sq.sqrt().add_(group['eps'])";
    "Fxn:exp_avg_sq.sqrt().add_(group['eps'])";
    "Fxn:math.sqrt(bias_correction2)";
    "Fxn:p.data.addcdiv_(-step_size,";
    "/torch/optim/adamax.py";
    "Import:torch";
    "Import:Optimizer";
    "class:Adamax(Optimizer):";
    "Fxn:__init__";
    "Fxn:betas=(0.9,";
    "Fxn:self).__init__(params,";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError('Adamax";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:grad.add(group['weight_decay'],";
    "Fxn:exp_avg.mul_(beta1).add_(1";
    "Fxn:torch.cat([";
    "Fxn:exp_inf.mul_(beta2).unsqueeze(0),";
    "Fxn:grad.abs().add_(eps).unsqueeze_(0)";
    "Fxn:torch.max(norm_buf,";
    "Fxn:out=(exp_inf,";
    "Fxn:exp_inf.new().long()))";
    "Fxn:p.data.addcdiv_(-clr,";
    "/torch/optim/asgd.py";
    "Import:math";
    "Import:torch";
    "Import:Optimizer";
    "class:ASGD(Optimizer):";
    "Fxn:__init__";
    "Fxn:self).__init__(params,";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError('ASGD";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:grad.add(group['weight_decay'],";
    "Fxn:p.data.mul_(1";
    "Fxn:p.data.add_(-state['eta'],";
    "Fxn:state['ax'].add_(p.data.sub(state['ax']).mul(state['mu']))";
    "Fxn:state['ax'].copy_(p.data)";
    "Fxn:math.pow((1";
    "/torch/optim/lbfgs.py";
    "Import:torch";
    "Import:reduce";
    "Import:Optimizer";
    "class:LBFGS(Optimizer):";
    "Fxn:__init__";
    "Fxn:self).__init__(params,";
    "Fxn:ValueError("LBFGS";
    "Fxn:"(parameter";
    "Fxn:_numel";
    "Fxn:reduce(lambda";
    "Fxn:p.numel(),";
    "Fxn:_gather_flat_grad";
    "Fxn:p.data.new(p.data.numel()).zero_()";
    "Fxn:p.grad.data.to_dense().view(-1)";
    "Fxn:p.grad.data.view(-1)";
    "Fxn:views.append(view)";
    "Fxn:torch.cat(views,";
    "Fxn:_add_grad";
    "Fxn:p.numel()";
    "Fxn:p.data.add_(step_size,";
    "Fxn:numel].view_as(p.data))";
    "Fxn:self._numel()";
    "Fxn:step";
    "Fxn:state.setdefault('func_evals',";
    "Fxn:state.setdefault('n_iter',";
    "Fxn:f(x)";
    "Fxn:closure()";
    "Fxn:self._gather_flat_grad()";
    "Fxn:flat_grad.abs().sum()";
    "Fxn:state.get('d')";
    "Fxn:state.get('t')";
    "Fxn:state.get('old_dirs')";
    "Fxn:state.get('old_stps')";
    "Fxn:state.get('H_diag')";
    "Fxn:state.get('prev_flat_grad')";
    "Fxn:state.get('prev_loss')";
    "Fxn:flat_grad.neg()";
    "Fxn:flat_grad.sub(prev_flat_grad)";
    "Fxn:d.mul(t)";
    "Fxn:y.dot(s)";
    "Fxn:old_dirs.pop(0)";
    "Fxn:old_stps.pop(0)";
    "Fxn:old_dirs.append(s)";
    "Fxn:old_stps.append(y)";
    "Fxn:y.dot(y)";
    "Fxn:old_stps[i].dot(old_dirs[i])";
    "Fxn:flat_grad.neg()";
    "Fxn:old_dirs[i].dot(q)";
    "Fxn:q.add_(-al[i],";
    "Fxn:torch.mul(q,";
    "Fxn:old_stps[i].dot(r)";
    "Fxn:r.add_(al[i]";
    "Fxn:flat_grad.clone()";
    "Fxn:prev_flat_grad.copy_(flat_grad)";
    "Fxn:flat_grad.dot(d)";
    "Fxn:RuntimeError("line";
    "Fxn:self._add_grad(t,";
    "Fxn:self._gather_flat_grad()";
    "Fxn:flat_grad.abs().sum()";
    "Fxn:d.mul(t).abs_().sum()";
    "/torch/optim/lr_scheduler.py";
    "Import:math";
    "Import:bisect_right";
    "Import:partial";
    "Import:Optimizer";
    "class:_LRScheduler(object):";
    "Fxn:__init__";
    "Fxn:TypeError('{}";
    "Fxn:Optimizer'.format(";
    "Fxn:group.setdefault('initial_lr',";
    "Fxn:KeyError("param";
    "Fxn:optimizer".format(i))";
    "Fxn:self.step(last_epoch";
    "Fxn:get_lr";
    "Fxn:step";
    "Fxn:self.get_lr()):";
    "class:LambdaLR(_LRScheduler):";
    "Fxn:__init__";
    "Fxn:ValueError("Expected";
    "Fxn:{}".format(";
    "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr";
    "Fxn:lmbda(self.last_epoch)";
    "class:StepLR(_LRScheduler):";
    "Fxn:__init__";
    "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr";
    "class:MultiStepLR(_LRScheduler):";
    "Fxn:__init__";
    "Fxn:ValueError('Milestones";
    "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr";
    "Fxn:bisect_right(self.milestones,";
    "class:ExponentialLR(_LRScheduler):";
    "Fxn:__init__";
    "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr";
    "class:CosineAnnealingLR(_LRScheduler):";
    "Fxn:__init__";
    "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr";
    "Fxn:math.cos(math.pi";
    "class:ReduceLROnPlateau(object):";
    "Fxn:__init__";
    "Fxn:ValueError('Factor";
    "Fxn:TypeError('{}";
    "Fxn:Optimizer'.format(";
    "Fxn:ValueError("expected";
    "Fxn:{}".format(";
    "Fxn:self._init_is_better(mode=mode,";
    "Fxn:self._reset()";
    "Fxn:_reset";
    "Fxn:step";
    "Fxn:self.is_better(current,";
    "Fxn:self._reduce_lr(epoch)";
    "Fxn:_reduce_lr";
    "Fxn:{:.4e}.'.format(epoch,";
    "Fxn:in_cooldown";
    "Fxn:_cmp";
    "Fxn:_init_is_better";
    "Fxn:ValueError('mode";
    "Fxn:ValueError('threshold";
    "Fxn:partial(self._cmp,";
    "/torch/optim/optimizer.py";
    "Import:defaultdict,";
    "Import:torch";
    "Import:deepcopy";
    "Import:chain";
    "Import:Variable";
    "class:Optimizer(object):";
    "Fxn:__init__";
    "Fxn:torch.is_tensor(params):";
    "Fxn:TypeError("params";
    "Fxn:torch.typename(params))";
    "Fxn:defaultdict(dict)";
    "Fxn:ValueError("optimizer";
    "Fxn:self.add_param_group(param_group)";
    "Fxn:__getstate__";
    "Fxn:__setstate__";
    "Fxn:self.__dict__.update(state)";
    "Fxn:__repr__";
    "Fxn:{0}\n'.format(i)";
    "Fxn:{1}\n'.format(key,";
    "Fxn:state_dict";
    "Fxn:pack_group";
    "Fxn:group.items()";
    "Fxn:[id(p)";
    "Fxn:[pack_group(g)";
    "Fxn:{(id(k)";
    "Fxn:self.state.items()}";
    "Fxn:load_state_dict";
    "Fxn:deepcopy(state_dict)";
    "Fxn:ValueError("loaded";
    "Fxn:ValueError("loaded";
    "Fxn:chain(*(g['params']";
    "Fxn:cast";
    "Fxn:torch.is_tensor(value):";
    "Fxn:param.is_floating_point():";
    "Fxn:value.type_as(param)";
    "Fxn:value.cuda(param.get_device())";
    "Fxn:value.cpu()";
    "Fxn:cast(param,";
    "Fxn:value.items()}";
    "Fxn:defaultdict(dict)";
    "Fxn:state_dict['state'].items():";
    "Fxn:cast(param,";
    "Fxn:update_group";
    "Fxn:update_group(g,";
    "Fxn:self.__setstate__({'state':";
    "Fxn:zero_grad";
    "Fxn:p.grad.detach_()";
    "Fxn:p.grad.zero_()";
    "Fxn:step";
    "Fxn:add_param_group";
    "Fxn:TypeError("optimizer";
    "Fxn:torch.typename(param))";
    "Fxn:ValueError("optimizing";
    "Fxn:ValueError("can't";
    "Fxn:self.defaults.items():";
    "Fxn:ValueError("parameter";
    "Fxn:param_group.setdefault(name,";
    "Fxn:param_set.update(set(group['params']))";
    "Fxn:param_set.isdisjoint(set(param_group['params'])):";
    "Fxn:ValueError("some";
    "Fxn:self.param_groups.append(param_group)";
    "/torch/optim/rmsprop.py";
    "Import:torch";
    "Import:Optimizer";
    "class:RMSprop(Optimizer):";
    "Fxn:__init__";
    "Fxn:self).__init__(params,";
    "Fxn:__setstate__";
    "Fxn:self).__setstate__(state)";
    "Fxn:group.setdefault('momentum',";
    "Fxn:group.setdefault('centered',";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError('RMSprop";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:grad.add(group['weight_decay'],";
    "Fxn:square_avg.mul_(alpha).addcmul_(1";
    "Fxn:grad_avg.mul_(alpha).add_(1";
    "Fxn:square_avg.addcmul(-1,";
    "Fxn:grad_avg).sqrt().add_(group['eps'])";
    "Fxn:square_avg.sqrt().add_(group['eps'])";
    "Fxn:buf.mul_(group['momentum']).addcdiv_(grad,";
    "Fxn:p.data.add_(-group['lr'],";
    "Fxn:p.data.addcdiv_(-group['lr'],";
    "/torch/optim/rprop.py";
    "Import:math";
    "Import:torch";
    "Import:Optimizer";
    "class:Rprop(Optimizer):";
    "Fxn:__init__";
    "Fxn:etas=(0.5,";
    "Fxn:step_sizes=(1e-6,";
    "Fxn:self).__init__(params,";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError('Rprop";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:grad.new().resize_as_(grad).fill_(group['lr'])";
    "Fxn:grad.mul(state['prev']).sign()";
    "Fxn:sign[sign.gt(0)]";
    "Fxn:sign[sign.lt(0)]";
    "Fxn:sign[sign.eq(0)]";
    "Fxn:step_size.mul_(sign).clamp_(step_size_min,";
    "Fxn:grad.clone()";
    "Fxn:grad[sign.eq(etaminus)]";
    "Fxn:p.data.addcmul_(-1,";
    "Fxn:grad.sign(),";
    "Fxn:state['prev'].copy_(grad)";
    "/torch/optim/sgd.py";
    "Import:torch";
    "Import:Optimizer,";
    "class:SGD(Optimizer):";
    "Fxn:__init__";
    "Fxn:ValueError("Nesterov";
    "Fxn:self).__init__(params,";
    "Fxn:__setstate__";
    "Fxn:self).__setstate__(state)";
    "Fxn:group.setdefault('nesterov',";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:d_p.add_(weight_decay,";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:buf.mul_(momentum).add_(d_p)";
    "Fxn:buf.mul_(momentum).add_(1";
    "Fxn:d_p.add(momentum,";
    "Fxn:p.data.add_(-group['lr'],";
    "/torch/optim/sparse_adam.py";
    "Import:math";
    "Import:torch";
    "Import:Optimizer";
    "class:SparseAdam(Optimizer):";
    "Fxn:__init__";
    "Fxn:betas=(0.9,";
    "Fxn:self).__init__(params,";
    "Fxn:step";
    "Fxn:closure()";
    "Fxn:RuntimeError('SparseAdam";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:torch.zeros_like(p.data)";
    "Fxn:grad.coalesce()";
    "Fxn:grad._indices()";
    "Fxn:grad._values()";
    "Fxn:grad.size()";
    "Fxn:make_sparse";
    "Fxn:grad_indices.dim()";
    "Fxn:values.dim()";
    "Fxn:constructor().resize_as_(grad)";
    "Fxn:constructor(grad_indices,";
    "Fxn:exp_avg._sparse_mask(grad)._values()";
    "Fxn:grad_values.sub(old_exp_avg_values).mul_(1";
    "Fxn:exp_avg.add_(make_sparse(exp_avg_update_values))";
    "Fxn:exp_avg_sq._sparse_mask(grad)._values()";
    "Fxn:grad_values.pow(2).sub_(old_exp_avg_sq_values).mul_(1";
    "Fxn:exp_avg_sq.add_(make_sparse(exp_avg_sq_update_values))";
    "Fxn:exp_avg_update_values.add_(old_exp_avg_values)";
    "Fxn:exp_avg_sq_update_values.add_(old_exp_avg_sq_values)";
    "Fxn:exp_avg_sq_update_values.sqrt_().add_(group['eps'])";
    "Fxn:math.sqrt(bias_correction2)";
    "Fxn:p.data.add_(make_sparse(-step_size";
    "Fxn:numer.div_(denom)))";
    "/torch/optim/__init__.py";
    "Import:Adadelta";
    "Import:Adagrad";
    "Import:Adam";
    "Import:SparseAdam";
    "Import:Adamax";
    "Import:ASGD";
    "Import:SGD";
    "Import:Rprop";
    "Import:RMSprop";
    "Import:Optimizer";
    "Import:LBFGS";
    "Import:lr_scheduler";
    "/torch/sparse/__init__.py";
    "/torch/testing/__init__.py";
    "Import:torch";
    "Import:random";
    "Fxn:make_non_contiguous";
    "Fxn:get_all_dtypes";
    "/torch/utils/cpp_extension.py";
    "Import:copy";
    "Import:glob";
    "Import:imp";
    "Import:import";
    "Import:import";
    "Import:setuptools";
    "Import:subprocess";
    "Import:sys";
    "Import:sysconfig";
    "Import:tempfile";
    "Import:warnings";
    "Import:torch";
    "Import:build_ext";
    "Fxn:_find_cuda_home";
    "Fxn:check_compiler_abi_compatibility";
    "class:BuildExtension(build_ext):";
    "Fxn:build_extensions";
    "Fxn:self._check_abi()";
    "Fxn:self._define_torch_extension_name(extension)";
    "Fxn:wrap_compile";
    "Fxn:copy.deepcopy(extra_postargs)";
    "Fxn:_is_cuda_file(src):";
    "Fxn:_join_cuda_home('bin',";
    "Fxn:self.compiler.set_executable('compiler_so',";
    "Fxn:cflags.append('-std=c++11')";
    "Fxn:original_compile(obj,";
    "Fxn:self.compiler.set_executable('compiler_so',";
    "Fxn:build_ext.build_extensions(self)";
    "Fxn:_check_abi";
    "Fxn:os.environ.get('CXX',";
    "Fxn:check_compiler_abi_compatibility(compiler)";
    "Fxn:_define_torch_extension_name";
    "Fxn:'-DTORCH_EXTENSION_NAME={}'.format(extension.name)";
    "Fxn:extension.extra_compile_args.values():";
    "Fxn:args.append(define)";
    "Fxn:extension.extra_compile_args.append(define)";
    "Fxn:CppExtension";
    "Fxn:setup(";
    "Fxn:CppExtension(";
    "Fxn:kwargs.get('include_dirs',";
    "Fxn:include_paths()";
    "Fxn:setuptools.Extension(name,";
    "Fxn:CUDAExtension";
    "Fxn:setup(";
    "Fxn:CUDAExtension(";
    "Fxn:kwargs.get('library_dirs',";
    "Fxn:library_dirs.append(_join_cuda_home('lib64'))";
    "Fxn:kwargs.get('libraries',";
    "Fxn:libraries.append('cudart')";
    "Fxn:kwargs.get('include_dirs',";
    "Fxn:include_paths(cuda=True)";
    "Fxn:setuptools.Extension(name,";
    "Fxn:include_paths";
    "Fxn:os.path.abspath(__file__)";
    "Fxn:os.path.dirname(os.path.dirname(here))";
    "Fxn:os.path.join(torch_path,";
    "Fxn:os.path.join(lib_include,";
    "Fxn:os.path.join(lib_include,";
    "Fxn:paths.append(_join_cuda_home('include'))";
    "Fxn:load";
    "Fxn:load(";
    "Fxn:verify_ninja_availability()";
    "Fxn:_get_build_directory(name,";
    "Fxn:extra_ldflags.append('-L{}'.format(_join_cuda_home('lib64')))";
    "Fxn:extra_ldflags.append('-lcudart')";
    "Fxn:os.path.join(build_directory,";
    "Fxn:{}...'.format(build_file_path))";
    "Fxn:_write_ninja_file(";
    "Fxn:{}...'.format(name))";
    "Fxn:_build_extension_module(name,";
    "Fxn:{}...'.format(name))";
    "Fxn:_import_module_from_library(name,";
    "Fxn:verify_ninja_availability";
    "Fxn:subprocess.check_call('ninja";
    "Fxn:--version'.split(),";
    "Fxn:RuntimeError("Ninja";
    "Fxn:_get_build_directory";
    "Fxn:os.environ.get('TORCH_EXTENSIONS_DIR')";
    "Fxn:tempfile.gettempdir()";
    "Fxn:os.path.join(tempfile.gettempdir(),";
    "Fxn:root...'.format(";
    "Fxn:os.path.join(root_extensions_directory,";
    "Fxn:os.path.exists(build_directory):";
    "Fxn:{}...'.format(build_directory))";
    "Fxn:os.makedirs(build_directory)";
    "Fxn:_build_extension_module";
    "Fxn:subprocess.check_output(";
    "Fxn:sys.exc_info()";
    "Fxn:RuntimeError("Error";
    "Fxn:{}".format(";
    "Fxn:error.output.decode()))";
    "Fxn:_import_module_from_library";
    "Fxn:imp.find_module(module_name,";
    "Fxn:imp.load_module(module_name,";
    "Fxn:_write_ninja_file";
    "Fxn:config.append('cxx";
    "Fxn:{}'.format(os.environ.get('CXX',";
    "Fxn:config.append('nvcc";
    "Fxn:{}'.format(_join_cuda_home('bin',";
    "Fxn:[os.path.abspath(file)";
    "Fxn:[os.path.abspath(file)";
    "Fxn:include_paths()";
    "Fxn:include_paths(with_cuda)";
    "Fxn:sysconfig.get_paths()['include']";
    "Fxn:includes.append(sysconfig.get_paths()['include'])";
    "Fxn:['-DTORCH_EXTENSION_NAME={}'.format(name)]";
    "Fxn:['-I{}'.format(include)";
    "Fxn:{}'.format('";
    "Fxn:'.join(cflags))]";
    "Fxn:cuda_flags.append('-std=c++11')";
    "Fxn:flags.append('cuda_flags";
    "Fxn:{}'.format('";
    "Fxn:'.join(cuda_flags)))";
    "Fxn:ldflags.append('-undefined";
    "Fxn:flags.append('ldflags";
    "Fxn:{}'.format('";
    "Fxn:'.join(ldflags)))";
    "Fxn:compile_rule.append(";
    "Fxn:compile_rule.append('";
    "Fxn:compile_rule.append('";
    "Fxn:cuda_compile_rule.append(";
    "Fxn:link_rule.append('";
    "Fxn:os.path.splitext(os.path.basename(source_file))[0]";
    "Fxn:_is_cuda_file(source_file):";
    "Fxn:'{}.cuda.o'.format(file_name)";
    "Fxn:'{}.o'.format(file_name)";
    "Fxn:object_files.append(target)";
    "Fxn:build.append('build";
    "Fxn:{}'.format(target,";
    "Fxn:'{}.so'.format(name)";
    "Fxn:{}'.format(library_target,";
    "Fxn:'.join(object_files))]";
    "Fxn:{}'.format(library_target)]";
    "Fxn:blocks.append(cuda_compile_rule)";
    "Fxn:'\n'.join(block)";
    "Fxn:build_file.write('{}\n\n'.format(lines))";
    "Fxn:_join_cuda_home";
    "Fxn:EnvironmentError('CUDA_HOME";
    "Fxn:os.path.join(CUDA_HOME,";
    "Fxn:_is_cuda_file";
    "Fxn:os.path.splitext(path)[1]";
    "Import:setup";
    "Import:BuildExtension,";
    "Import:setup";
    "Import:BuildExtension,";
    "Import:load";
    "/torch/utils/dlpack.py";
    "Import:torch";
    "Import:_from_dlpack";
    "Import:_to_dlpack";
    "/torch/utils/hooks.py";
    "Import:collections";
    "Import:weakref";
    "class:RemovableHandle(object):";
    "Fxn:__init__";
    "Fxn:weakref.ref(hooks_dict)";
    "Fxn:remove";
    "Fxn:self.hooks_dict_ref()";
    "Fxn:__getstate__";
    "Fxn:__setstate__";
    "Fxn:weakref.ref(collections.OrderedDict())";
    "Fxn:weakref.ref(state[0])";
    "Fxn:__enter__";
    "Fxn:__exit__";
    "Fxn:self.remove()";
    "/torch/utils/model_zoo.py";
    "Import:torch";
    "Import:hashlib";
    "Import:import";
    "Import:import";
    "Import:shutil";
    "Import:sys";
    "Import:tempfile";
    "Import:urlparse";
    "Import:requests.get";
    "Import:urlparse";
    "Import:urlopen";
    "Import:urlopen";
    "Import:urlparse";
    "Import:tqdm";
    "Fxn:load_url";
    "Fxn:_download_url_to_file";
    "class:tqdm(object):";
    "Fxn:__init__";
    "Fxn:update";
    "Fxn:sys.stderr.write("\r{0:.1f}%".format(100";
    "Fxn:sys.stderr.flush()";
    "Fxn:__enter__";
    "Fxn:__exit__";
    "Fxn:sys.stderr.write('\n')";
    "/torch/utils/__init__.py";
    "/torch/utils/backcompat/__init__.py";
    "Import:_set_backcompat_broadcast_warn";
    "Import:_get_backcompat_broadcast_warn";
    "Import:_set_backcompat_keepdim_warn";
    "Import:_get_backcompat_keepdim_warn";
    "class:Warning(object):";
    "Fxn:__init__";
    "Fxn:set_enabled";
    "Fxn:self.setter(value)";
    "Fxn:get_enabled";
    "Fxn:self.getter()";
    "Fxn:Warning(_set_backcompat_broadcast_warn,";
    "Fxn:Warning(_set_backcompat_keepdim_warn,";
    "/torch/utils/data/dataloader.py";
    "Import:random";
    "Import:torch";
    "Import:torch.multiprocessing";
    "Import:_set_worker_signal_handlers,";
    "Import:SequentialSampler,";
    "Import:signal";
    "Import:functools";
    "Import:collections";
    "Import:import";
    "Import:sys";
    "Import:threading";
    "Import:traceback";
    "Import:string_classes,";
    "Import:Queue";
    "Import:queue";
    "class:ExceptionWrapper(object):";
    "Fxn:__init__";
    "Fxn:"".join(traceback.format_exception(*exc_info))";
    "Fxn:_worker_loop";
    "Fxn:_set_worker_signal_handlers()";
    "Fxn:torch.set_num_threads(1)";
    "Fxn:random.seed(seed)";
    "Fxn:torch.manual_seed(seed)";
    "Fxn:init_fn(worker_id)";
    "Fxn:index_queue.get()";
    "Fxn:collate_fn([dataset[i]";
    "Fxn:data_queue.put((idx,";
    "Fxn:ExceptionWrapper(sys.exc_info())))";
    "Fxn:data_queue.put((idx,";
    "Fxn:_worker_manager_loop";
    "Fxn:torch.cuda.set_device(device_id)";
    "Fxn:in_queue.get()";
    "Fxn:done_event.is_set():";
    "Fxn:out_queue.put(r)";
    "Fxn:pin_memory_batch(batch)";
    "Fxn:out_queue.put((idx,";
    "Fxn:ExceptionWrapper(sys.exc_info())))";
    "Fxn:out_queue.put((idx,";
    "Fxn:default_collate";
    "Fxn:torch.is_tensor(batch[0]):";
    "Fxn:batch[0].storage()._new_shared(numel)";
    "Fxn:batch[0].new(storage)";
    "Fxn:torch.stack(batch,";
    "Fxn:re.search('[SaUO]',";
    "Fxn:TypeError(error_msg.format(elem.dtype))";
    "Fxn:torch.stack([torch.from_numpy(b)";
    "Fxn:elem.dtype.name.startswith('float')";
    "Fxn:numpy_type_map[elem.dtype.name](list(map(py_type,";
    "Fxn:torch.LongTensor(batch)";
    "Fxn:torch.DoubleTensor(batch)";
    "Fxn:default_collate([d[key]";
    "Fxn:[default_collate(samples)";
    "Fxn:TypeError((error_msg.format(type(batch[0]))))";
    "Fxn:pin_memory_batch";
    "Fxn:torch.is_tensor(batch):";
    "Fxn:batch.pin_memory()";
    "Fxn:pin_memory_batch(sample)";
    "Fxn:batch.items()}";
    "Fxn:[pin_memory_batch(sample)";
    "Fxn:_set_SIGCHLD_handler";
    "Fxn:signal.getsignal(signal.SIGCHLD)";
    "Fxn:handler";
    "Fxn:_error_if_any_worker_fails()";
    "Fxn:previous_handler(signum,";
    "Fxn:signal.signal(signal.SIGCHLD,";
    "class:_DataLoaderIter(object):";
    "Fxn:__init__";
    "Fxn:torch.cuda.is_available()";
    "Fxn:threading.Event()";
    "Fxn:multiprocessing.SimpleQueue()";
    "Fxn:multiprocessing.SimpleQueue()";
    "Fxn:torch.LongTensor(1).random_()[0]";
    "Fxn:multiprocessing.Process(";
    "Fxn:args=(self.dataset,";
    "Fxn:queue.Queue()";
    "Fxn:torch.cuda.current_device()";
    "Fxn:threading.Thread(";
    "Fxn:args=(self.worker_result_queue,";
    "Fxn:self.worker_manager_thread.start()";
    "Fxn:w.start()";
    "Fxn:_update_worker_pids(id(self),";
    "Fxn:_set_SIGCHLD_handler()";
    "Fxn:self._put_indices()";
    "Fxn:__len__";
    "Fxn:_get_batch";
    "Fxn:self.data_queue.get(timeout=self.timeout)";
    "Fxn:RuntimeError('DataLoader";
    "Fxn:seconds'.format(self.timeout))";
    "Fxn:self.data_queue.get()";
    "Fxn:__next__";
    "Fxn:self.collate_fn([self.dataset[i]";
    "Fxn:pin_memory_batch(batch)";
    "Fxn:self.reorder_dict.pop(self.rcvd_idx)";
    "Fxn:self._process_next_batch(batch)";
    "Fxn:self._shutdown_workers()";
    "Fxn:self._get_batch()";
    "Fxn:self._process_next_batch(batch)";
    "Fxn:__iter__";
    "Fxn:_put_indices";
    "Fxn:self.index_queue.put((self.send_idx,";
    "Fxn:_process_next_batch";
    "Fxn:self._put_indices()";
    "Fxn:batch.exc_type(batch.exc_msg)";
    "Fxn:__getstate__";
    "Fxn:NotImplementedError("_DataLoaderIter";
    "Fxn:_shutdown_workers";
    "Fxn:self.done_event.set()";
    "Fxn:self.data_queue.empty():";
    "Fxn:self.data_queue.get()";
    "Fxn:self.index_queue.put(None)";
    "Fxn:self.worker_result_queue.put(None)";
    "Fxn:_remove_worker_pids(id(self))";
    "Fxn:__del__";
    "Fxn:self._shutdown_workers()";
    "class:DataLoader(object):";
    "Fxn:__init__";
    "Fxn:ValueError('timeout";
    "Fxn:ValueError('batch_sampler";
    "Fxn:ValueError('sampler";
    "Fxn:ValueError('num_workers";
    "Fxn:ValueError('num_workers";
    "Fxn:RandomSampler(dataset)";
    "Fxn:SequentialSampler(dataset)";
    "Fxn:BatchSampler(sampler,";
    "Fxn:__iter__";
    "Fxn:_DataLoaderIter(self)";
    "Fxn:__len__";
    "/torch/utils/data/dataset.py";
    "Import:bisect";
    "Import:warnings";
    "Import:_accumulate";
    "Import:randperm";
    "class:Dataset(object):";
    "Fxn:__getitem__";
    "Fxn:__len__";
    "Fxn:__add__";
    "Fxn:ConcatDataset([self,";
    "class:TensorDataset(Dataset):";
    "Fxn:__init__";
    "Fxn:data_tensor.size(0)";
    "Fxn:target_tensor.size(0)";
    "Fxn:__getitem__";
    "Fxn:__len__";
    "Fxn:self.data_tensor.size(0)";
    "class:ConcatDataset(Dataset):";
    "Fxn:cumsum";
    "Fxn:r.append(l";
    "Fxn:__init__";
    "Fxn:self).__init__()";
    "Fxn:self.cumsum(self.datasets)";
    "Fxn:__len__";
    "Fxn:__getitem__";
    "Fxn:bisect.bisect_right(self.cumulative_sizes,";
    "Fxn:cummulative_sizes";
    "Fxn:warnings.warn("cummulative_sizes";
    "class:Subset(Dataset):";
    "Fxn:__init__";
    "Fxn:__getitem__";
    "Fxn:__len__";
    "Fxn:random_split";
    "Fxn:ValueError("Sum";
    "Fxn:randperm(sum(lengths))";
    "Fxn:[Subset(dataset,";
    "/torch/utils/data/distributed.py";
    "Import:math";
    "Import:torch";
    "Import:Sampler";
    "Import:get_world_size,";
    "class:DistributedSampler(Sampler):";
    "Fxn:__init__";
    "Fxn:get_world_size()";
    "Fxn:get_rank()";
    "Fxn:__iter__";
    "Fxn:torch.Generator()";
    "Fxn:g.manual_seed(self.epoch)";
    "Fxn:indices[:(self.total_size";
    "Fxn:__len__";
    "Fxn:set_epoch";
    "/torch/utils/data/sampler.py";
    "Import:torch";
    "class:Sampler(object):";
    "Fxn:__init__";
    "Fxn:__iter__";
    "Fxn:__len__";
    "class:SequentialSampler(Sampler):";
    "Fxn:__init__";
    "Fxn:__iter__";
    "Fxn:__len__";
    "class:RandomSampler(Sampler):";
    "Fxn:__init__";
    "Fxn:__iter__";
    "Fxn:__len__";
    "class:SubsetRandomSampler(Sampler):";
    "Fxn:__init__";
    "Fxn:__iter__";
    "Fxn:torch.randperm(len(self.indices)))";
    "Fxn:__len__";
    "class:WeightedRandomSampler(Sampler):";
    "Fxn:__init__";
    "Fxn:torch.DoubleTensor(weights)";
    "Fxn:__iter__";
    "Fxn:__len__";
    "class:BatchSampler(object):";
    "Fxn:__init__";
    "Fxn:__iter__";
    "Fxn:batch.append(int(idx))";
    "Fxn:__len__";
    "/torch/utils/data/__init__.py";
    "Import:Dataset,";
    "Import:DataLoader";
    "/torch/utils/ffi/__init__.py";
    "Import:import";
    "Import:glob";
    "Import:tempfile";
    "Import:shutil";
    "Import:wraps,";
    "Import:Template";
    "Import:torch";
    "Import:torch.cuda";
    "Import:Variable";
    "Import:_accumulate";
    "Import:cffi";
    "Fxn:_generate_typedefs";
    "Import:_wrap_function";
    "Import:lib";
    "Fxn:_import_symbols";
    "Fxn:_setup_wrapper";
    "Import:torch.cuda";
    "Fxn:_create_module_dir";
    "Fxn:_build_extension";
    "Fxn:_make_python_wrapper";
    "Fxn:create_extension";
    "Fxn:build";
    "Fxn:_wrap_function";
    "Fxn:safe_call";
    "/torch/utils/serialization/read_lua_file.py";
    "Import:sys";
    "Import:struct";
    "Import:array";
    "Import:namedtuple";
    "Import:wraps";
    "Import:torch";
    "Import:torch.legacy.nn";
    "Import:torch.cuda";
    "Import:type2backend";
    "Import:_import_dotted_name";
    "class:hashable_uniq_dict(dict):";
    "Fxn:__hash__";
    "Fxn:__getattr__";
    "Fxn:self.get(key)";
    "Fxn:__eq__";
    "class:TorchObject(object):";
    "Fxn:__init__";
    "Fxn:__getattr__";
    "Fxn:self._obj.get(k)";
    "Fxn:__getitem__";
    "Fxn:self._obj.get(k)";
    "Fxn:torch_typename";
    "Fxn:__repr__";
    "Fxn:"TorchObject(%s,";
    "Fxn:__str__";
    "Fxn:__dir__";
    "Fxn:keys.append('torch_typename')";
    "Fxn:get_python_class";
    "Fxn:typename.rpartition('.')";
    "Fxn:cls_name.startswith('Cuda'):";
    "Fxn:_import_dotted_name(module";
    "Fxn:make_tensor_reader";
    "Fxn:get_python_class(typename)";
    "Fxn:read_tensor";
    "Fxn:reader.read_int()";
    "Fxn:torch.LongStorage(reader.read_long_array(ndim))";
    "Fxn:torch.LongStorage(reader.read_long_array(ndim))";
    "Fxn:reader.read_long()";
    "Fxn:reader.read()";
    "Fxn:python_class()";
    "Fxn:python_class().set_(storage,";
    "Fxn:torch.Size(size),";
    "Fxn:make_storage_reader";
    "Fxn:get_python_class(typename)";
    "Fxn:python_class().element_size()";
    "Fxn:read_storage";
    "Fxn:reader.read_long()";
    "Fxn:python_class.from_buffer(reader.f.read(size),";
    "Fxn:register_torch_class";
    "Fxn:reader_factory(cls_name)";
    "Fxn:register_torch_class('Storage',";
    "Fxn:register_torch_class('Tensor',";
    "Fxn:tds_Vec_reader";
    "Fxn:reader.read_long()";
    "Fxn:[reader.read()";
    "Fxn:tds_Hash_reader";
    "Fxn:reader.read_long()";
    "Fxn:reader.read()";
    "Fxn:reader.read()";
    "Fxn:_load_backend";
    "Fxn:torch.is_tensor(attr):";
    "Fxn:type2backend[attr.type()]";
    "Fxn:updateOutput_patch";
    "Fxn:torch.is_tensor(input):";
    "Fxn:type2backend[input.type()]";
    "Fxn:obj.updateOutput(*args)";
    "Fxn:nn_reader";
    "Fxn:read_nn_class";
    "Fxn:cls.__new__(cls)";
    "Fxn:reader.read()";
    "Fxn:obj.__dict__.update(attributes)";
    "Fxn:_load_backend(obj)";
    "Fxn:reader_registry.update({('nn.'";
    "Fxn:nn_reader(module)";
    "Fxn:nn.__dict__.items()";
    "Fxn:name[0].upper()";
    "Fxn:custom_reader";
    "Fxn:reader_factory";
    "Fxn:nn_reader(cls)";
    "Fxn:wrapper";
    "Fxn:base(reader,";
    "Fxn:fn(reader,";
    "Fxn:BatchNorm_reader";
    "Fxn:obj.running_var.pow(-2).add(-obj.eps)";
    "Fxn:custom_reader(getattr(nn,";
    "Fxn:name))(BatchNorm_reader)";
    "Fxn:@custom_reader(nn.Transpose)";
    "Fxn:Transpose_reader";
    "Fxn:@custom_reader(nn.SpatialDivisiveNormalization)";
    "Fxn:SpatialDivisiveNormalization_reader";
    "Fxn:@custom_reader(nn.SpatialContrastiveNormalization)";
    "Fxn:SpatialContrastiveNormalization_reader";
    "Fxn:RuntimeError("loading";
    "Fxn:@custom_reader(nn.GradientReversal)";
    "Fxn:GradientReversal_reader";
    "Fxn:@custom_reader(nn.VolumetricAveragePooling)";
    "Fxn:VolumetricAveragePooling_reader";
    "Fxn:registry_addon";
    "Fxn:wrapper_factory";
    "Fxn:wrapper";
    "Fxn:build_fn(reader,";
    "Fxn:fn(obj,";
    "Fxn:attr_map";
    "Fxn:attribute_map.items():";
    "Fxn:ensure_attr";
    "Fxn:make_none_attr";
    "Fxn:decrement";
    "Fxn:decrement_positive";
    "Fxn:storage_to_size";
    "Fxn:torch.Size(value))";
    "Fxn:ensure_type";
    "Fxn:type_map.items():";
    "Fxn:converter)())";
    "Fxn:ensure_attr('Linear',";
    "Fxn:ensure_attr('CAddTable',";
    "Fxn:ensure_attr('SpatialFractionalMaxPooling',";
    "Fxn:ensure_attr('BatchNormalization',";
    "Fxn:ensure_attr('SpatialBatchNormalization',";
    "Fxn:ensure_attr('VolumetricBatchNormalization',";
    "Fxn:ensure_attr('LookupTable',";
    "Fxn:ensure_attr('MixtureTable',";
    "Fxn:ensure_attr('WeightedEuclidean',";
    "Fxn:ensure_attr('VolumetricMaxPooling',";
    "Fxn:ensure_attr('BCECriterion',";
    "Fxn:ensure_attr('SpatialClassNLLCriterion',";
    "Fxn:ensure_attr('ClassNLLCriterion',";
    "Fxn:ensure_attr('ParallelCriterion',";
    "Fxn:ensure_attr('MultiMarginCriterion',";
    "Fxn:ensure_attr('SpatialConvolution',";
    "Fxn:ensure_attr('SpatialCrossMapLRN',";
    "Fxn:ensure_attr('Dropout',";
    "Fxn:make_none_attr('SpatialConvolution',";
    "Fxn:attr_map('ReLU',";
    "Fxn:attr_map('Threshold',";
    "Fxn:attr_map('Unsqueeze',";
    "Fxn:attr_map('HardShrink',";
    "Fxn:attr_map('SoftShrink',";
    "Fxn:attr_map('GradientReversal',";
    "Fxn:attr_map('SpatialAdaptiveMaxPooling',";
    "Fxn:decrement('Index',";
    "Fxn:decrement('SelectTable',";
    "Fxn:decrement('SplitTable',";
    "Fxn:decrement_positive('JoinTable',";
    "Fxn:decrement('Parallel',";
    "Fxn:decrement('Concat',";
    "Fxn:decrement('DepthConcat',";
    "Fxn:decrement('Squeeze',";
    "Fxn:decrement('Unsqueeze',";
    "Fxn:decrement('Replicate',";
    "Fxn:decrement('MixtureTable',";
    "Fxn:decrement('Narrow',";
    "Fxn:decrement('NarrowTable',";
    "Fxn:decrement('LookupTable',";
    "Fxn:decrement('SpatialConvolutionMap',";
    "Fxn:decrement('SpatialFullConvolutionMap',";
    "Fxn:decrement('Select',";
    "Fxn:decrement('Padding',";
    "Fxn:decrement('PartialLinear',";
    "Fxn:decrement_positive('Sum',";
    "Fxn:decrement_positive('Max',";
    "Fxn:decrement_positive('Min',";
    "Fxn:decrement_positive('Mean',";
    "Fxn:storage_to_size('View',";
    "Fxn:storage_to_size('DepthConcat',";
    "Fxn:storage_to_size('MixtureTable',";
    "Fxn:ensure_type('PartialLinear',";
    "class:T7ReaderException(Exception):";
    "Fxn:__init__";
    "Fxn:_read";
    "Fxn:struct.calcsize(fmt)";
    "Fxn:struct.unpack(fmt,";
    "Fxn:self.f.read(sz))";
    "Fxn:read_boolean";
    "Fxn:self.read_int()";
    "Fxn:read_int";
    "Fxn:self._read('i')";
    "Fxn:read_long";
    "Fxn:self._read('l')";
    "Fxn:self._read('q')";
    "Fxn:self._read('i')";
    "Fxn:read_long_array";
    "Fxn:lst.append(self.read_long())";
    "Fxn:array(LONG_SIZE_ARR)";
    "Fxn:arr.fromfile(self.f,";
    "Fxn:arr.tolist()";
    "Fxn:read_float";
    "Fxn:self._read('f')";
    "Fxn:read_double";
    "Fxn:self._read('d')";
    "Fxn:read_string";
    "Fxn:self.read_int()";
    "Fxn:self.f.read(size)";
    "Fxn:read_number";
    "Fxn:self.read_double()";
    "Fxn:x.is_integer():";
    "Fxn:memoize_index";
    "Fxn:@wraps(fn)";
    "Fxn:wrapper";
    "Fxn:self.read_int()";
    "Fxn:fn(self,";
    "Fxn:read_function";
    "Fxn:self.read_int()";
    "Fxn:self.f.read(size)";
    "Fxn:self.read()";
    "Fxn:LuaFunction(size,";
    "Fxn:read_object";
    "Fxn:self.read_string()";
    "Fxn:version_str.startswith('V";
    "Fxn:self.read_string()";
    "Fxn:reader_registry[cls_name](self,";
    "Fxn:TorchObject(cls_name,";
    "Fxn:self.read())";
    "Fxn:T7ReaderException(("don't";
    "Fxn:_can_be_list";
    "Fxn:is_natural";
    "Fxn:key.is_integer())";
    "Fxn:table.keys()))";
    "Fxn:read_table";
    "Fxn:self.read_int()";
    "Fxn:hashable_uniq_dict()";
    "Fxn:self.read()";
    "Fxn:self.read()";
    "Fxn:self._can_be_list(table):";
    "Fxn:read";
    "Fxn:self.read_int()";
    "Fxn:self.read_number()";
    "Fxn:self.read_boolean()";
    "Fxn:self.read_string()";
    "Fxn:self.read_function()";
    "Fxn:self.read_object()";
    "Fxn:self.read_table()";
    "Fxn:T7ReaderException("unknown";
    "Fxn:"corrupted.".format(typeidx))";
    "Fxn:load_lua";
    "Fxn:T7Reader(f,";
    "Fxn:reader.read()";
    "/torch/utils/serialization/__init__.py";
    "Import:load_lua,";
    "/torch/utils/trainer/trainer.py";
    "Import:heapq";
    "Import:Variable";
    "class:Trainer(object):";
    "Fxn:__init__";
    "Fxn:register_plugin";
    "Fxn:plugin.register(self)";
    "Fxn:queue.append((duration,";
    "Fxn:call_plugins";
    "Fxn:queue_name)(*args)";
    "Fxn:heapq.heappushpop(queue,";
    "Fxn:run";
    "Fxn:self.plugin_queues.values():";
    "Fxn:heapq.heapify(q)";
    "Fxn:self.train()";
    "Fxn:self.call_plugins('epoch',";
    "Fxn:train";
    "Fxn:self.call_plugins('batch',";
    "Fxn:Variable(batch_input)";
    "Fxn:Variable(batch_target)";
    "Fxn:closure";
    "Fxn:self.model(input_var)";
    "Fxn:self.criterion(batch_output,";
    "Fxn:loss.backward()";
    "Fxn:self.optimizer.zero_grad()";
    "Fxn:self.optimizer.step(closure)";
    "Fxn:self.call_plugins('iteration',";
    "Fxn:self.call_plugins('update',";
    "/torch/utils/trainer/__init__.py";
    "Import:Trainer";
    "/torch/utils/trainer/plugins/accuracy.py";
    "Import:Monitor";
    "class:AccuracyMonitor(Monitor):";
    "Fxn:__init__";
    "Fxn:kwargs.setdefault('unit',";
    "Fxn:kwargs.setdefault('precision',";
    "Fxn:self).__init__(*args,";
    "Fxn:_get_value";
    "Fxn:input.size(0)";
    "Fxn:output.max(1)[1].type_as(target)";
    "Fxn:predictions.eq(target)";
    "Fxn:correct.cpu()";
    "Fxn:correct.sum()";
    "/torch/utils/trainer/plugins/logger.py";
    "Import:defaultdict";
    "Import:Plugin";
    "class:Logger(Plugin):";
    "Fxn:__init__";
    "Fxn:[(1,";
    "Fxn:self).__init__(interval)";
    "Fxn:defaultdict(lambda:";
    "Fxn:defaultdict(int))";
    "Fxn:f.split('.'),";
    "Fxn:_join_results";
    "Fxn:'.join(i[1])),";
    "Fxn:{}'.format(i[0],";
    "Fxn:'\t'.join(joined_fields)";
    "Fxn:log";
    "Fxn:register";
    "Fxn:gather_stats";
    "Fxn:_align_output";
    "Fxn:_gather_outputs";
    "Fxn:stat.get(log_fields,";
    "Fxn:stat.get('log_name',";
    "Fxn:'.'.join(field))";
    "Fxn:output.append(f.format(**stat))";
    "Fxn:'.'.join(field)";
    "Fxn:stat_parent.get('log_format',";
    "Fxn:stat_parent.get('log_unit',";
    "Fxn:output.append(fmt.format(stat))";
    "Fxn:_log_all";
    "Fxn:self._gather_outputs(field,";
    "Fxn:self._align_output(field_idx,";
    "Fxn:results.append((name,";
    "Fxn:self._join_results(results)";
    "Fxn:self.log(prefix)";
    "Fxn:self.log(output)";
    "Fxn:self.log(suffix)";
    "Fxn:iteration";
    "Fxn:self._log_all('log_iter_fields')";
    "Fxn:epoch";
    "Fxn:self._log_all('log_epoch_fields',";
    "/torch/utils/trainer/plugins/loss.py";
    "Import:Monitor";
    "class:LossMonitor(Monitor):";
    "Fxn:_get_value";
    "/torch/utils/trainer/plugins/monitor.py";
    "Import:Plugin";
    "class:Monitor(Plugin):";
    "Fxn:__init__";
    "Fxn:'.{}f'.format(precision)";
    "Fxn:self).__init__([(1,";
    "Fxn:register";
    "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:iteration";
    "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:self._get_value(*args)";
    "Fxn:stats.get('running_avg',";
    "Fxn:epoch";
    "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "/torch/utils/trainer/plugins/plugin.py";
    "class:Plugin(object):";
    "Fxn:__init__";
    "Fxn:register";
    "/torch/utils/trainer/plugins/progress.py";
    "Import:Plugin";
    "class:ProgressMonitor(Plugin):";
    "Fxn:__init__";
    "Fxn:self).__init__([(1,";
    "Fxn:register";
    "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:'({percent:.2f}%)'";
    "Fxn:iteration";
    "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:epoch";
    "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "/torch/utils/trainer/plugins/time.py";
    "Import:absolute_import";
    "Import:time";
    "Import:Monitor";
    "class:TimeMonitor(Monitor):";
    "Fxn:__init__";
    "Fxn:kwargs.setdefault('unit',";
    "Fxn:kwargs.setdefault('precision',";
    "Fxn:self).__init__(*args,";
    "Fxn:_get_value";
    "Fxn:time.time()";
    "Fxn:time.time()";
    "/torch/utils/trainer/plugins/__init__.py";
    "Import:ProgressMonitor";
    "Import:AccuracyMonitor";
    "Import:TimeMonitor";
    "Import:LossMonitor";
    "Import:Logger";
    "/torch/_thnn/utils.py";
    "Import:import";
    "Import:itertools";
    "Import:importlib";
    "Fxn:_unpickle_backend";
    "Import:torch._thnn";
    "class:THNNBackendBase(object):";
    "Fxn:__init__";
    "Fxn:__getattr__";
    "Fxn:self.methods.get(name,";
    "Fxn:register_method";
    "Fxn:library_state";
    "Fxn:__reduce__";
    "class:Function(object):";
    "Fxn:__init__";
    "Fxn:add_argument";
    "Fxn:self.arguments.append(arg)";
    "Fxn:__repr__";
    "Fxn:'('";
    "Fxn:'.join(map(lambda";
    "Fxn:a.__repr__(),";
    "class:Argument(object):";
    "Fxn:__init__";
    "Fxn:__repr__";
    "Fxn:parse_header";
    "Fxn:f.read().split('\n')";
    "Fxn:l.startswith('#'),";
    "Fxn:l.partition('//'),";
    "Fxn:l[2].strip()),";
    "Fxn:new_lines.append((split,";
    "Fxn:l.startswith('TH_API";
    "Fxn:l.lstrip('TH_API";
    "Fxn:'('";
    "Fxn:generic_functions.append(Function(fn_name))";
    "Fxn:l.split()";
    "Fxn:generic_functions[-1].add_argument(Argument(t,";
    "Fxn:load_backend";
    "Fxn:mixins=tuple()):";
    "Fxn:'THNN{}Backend'.format(t)";
    "Fxn:{})()";
    "Fxn:'{}{}'.format(t,";
    "Fxn:backend.register_method(function.name,";
    "/torch/_thnn/__init__.py";
    "Import:threading";
    "Import:torch.cuda";
    "Import:THNN_H_PATH,";
    "class:Backends(object):";
    "Fxn:__init__";
    "Fxn:__getattr__";
    "Fxn:self.backends[name].load()";
    "Fxn:__getitem__";
    "Fxn:self.backends[name].load()";
    "class:Backend(object):";
    "Fxn:__init__";
    "Fxn:mixins=tuple()):";
    "Fxn:threading.Lock()";
    "Fxn:load";
    "Fxn:load_backend(self.lib_prefix,";
    "class:THNNCudaBackendStateMixin(object):";
    "Fxn:library_state";
    "Fxn:Backends()";
    "Fxn:parse_header(THNN_H_PATH)";
    "Fxn:parse_header(THCUNN_H_PATH)";
    "Fxn:Backend(t,";
    "Fxn:type2backend.backends['THNN{}Backend'.format(t)]";
    "Fxn:type2backend.backends['torch.{}Tensor'.format(t)]";
    "Fxn:type2backend.backends[getattr(torch,";
    "Fxn:'{}Tensor'.format(t))]";
    "Fxn:Backend('Cuda'";
    "Fxn:type2backend.backends['THNNCuda{}Backend'.format(t)]";
    "Fxn:type2backend.backends['torch.cuda.{}Tensor'.format(py_name)]";
    "Fxn:type2backend.backends[getattr(torch.cuda,";
    "Fxn:'{}Tensor'.format(py_name))]";
    "tensorflow" -> "/setup.py";
    "tensorflow" -> "/.jenkins/perf_test/compare_with_baseline.py";
    "tensorflow" -> "/.jenkins/perf_test/get_stats.py";
    "tensorflow" -> "/.jenkins/perf_test/update_commit_hash.py";
    "tensorflow" -> "/aten/src/ATen/code_template.py";
    "tensorflow" -> "/aten/src/ATen/common_with_cwrap.py";
    "tensorflow" -> "/aten/src/ATen/copy_wrapper.py";
    "tensorflow" -> "/aten/src/ATen/cwrap_parser.py";
    "tensorflow" -> "/aten/src/ATen/extract_cwrap.py";
    "tensorflow" -> "/aten/src/ATen/function_wrapper.py";
    "tensorflow" -> "/aten/src/ATen/gen.py";
    "tensorflow" -> "/aten/src/ATen/native_parse.py";
    "tensorflow" -> "/aten/src/ATen/nn_parse.py";
    "tensorflow" -> "/aten/src/ATen/preprocess_declarations.py";
    "tensorflow" -> "/docs/source/conf.py";
    "tensorflow" -> "/docs/source/scripts/build_activation_images.py";
    "tensorflow" -> "/test/common.py";
    "tensorflow" -> "/test/common_nn.py";
    "tensorflow" -> "/test/run_test.py";
    "tensorflow" -> "/test/test_autograd.py";
    "tensorflow" -> "/test/test_cpp_extensions.py";
    "tensorflow" -> "/test/test_cuda.py";
    "tensorflow" -> "/test/test_dataloader.py";
    "tensorflow" -> "/test/test_distributed.py";
    "tensorflow" -> "/test/test_distributions.py";
    "tensorflow" -> "/test/test_indexing.py";
    "tensorflow" -> "/test/test_jit.py";
    "tensorflow" -> "/test/test_legacy_nn.py";
    "tensorflow" -> "/test/test_multiprocessing.py";
    "tensorflow" -> "/test/test_nccl.py";
    "tensorflow" -> "/test/test_nn.py";
    "tensorflow" -> "/test/test_optim.py";
    "tensorflow" -> "/test/test_sparse.py";
    "tensorflow" -> "/test/test_torch.py";
    "tensorflow" -> "/test/test_utils.py";
    "tensorflow" -> "/test/cpp_extensions/setup.py";
    "tensorflow" -> "/test/data/network1.py";
    "tensorflow" -> "/test/data/network2.py";
    "tensorflow" -> "/test/error_messages/storage.py";
    "tensorflow" -> "/test/optim/test.py";
    "tensorflow" -> "/tools/__init__.py";
    "tensorflow" -> "/tools/autograd/gen_autograd.py";
    "tensorflow" -> "/tools/autograd/gen_autograd_functions.py";
    "tensorflow" -> "/tools/autograd/gen_python_functions.py";
    "tensorflow" -> "/tools/autograd/gen_variable_type.py";
    "tensorflow" -> "/tools/autograd/load_derivatives.py";
    "tensorflow" -> "/tools/autograd/nested_dict.py";
    "tensorflow" -> "/tools/autograd/utils.py";
    "tensorflow" -> "/tools/autograd/__init__.py";
    "tensorflow" -> "/tools/cwrap/cwrap.py";
    "tensorflow" -> "/tools/cwrap/__init__.py";
    "tensorflow" -> "/tools/cwrap/plugins/ArgcountChecker.py";
    "tensorflow" -> "/tools/cwrap/plugins/ArgcountSortPlugin.py";
    "tensorflow" -> "/tools/cwrap/plugins/ArgumentReferences.py";
    "tensorflow" -> "/tools/cwrap/plugins/AssertNDim.py";
    "tensorflow" -> "/tools/cwrap/plugins/AutoGPU.py";
    "tensorflow" -> "/tools/cwrap/plugins/BeforeAfterCall.py";
    "tensorflow" -> "/tools/cwrap/plugins/BoolOption.py";
    "tensorflow" -> "/tools/cwrap/plugins/Broadcast.py";
    "tensorflow" -> "/tools/cwrap/plugins/ConstantArguments.py";
    "tensorflow" -> "/tools/cwrap/plugins/CuDNNPlugin.py";
    "tensorflow" -> "/tools/cwrap/plugins/GILRelease.py";
    "tensorflow" -> "/tools/cwrap/plugins/KwargsPlugin.py";
    "tensorflow" -> "/tools/cwrap/plugins/NNExtension.py";
    "tensorflow" -> "/tools/cwrap/plugins/NullableArguments.py";
    "tensorflow" -> "/tools/cwrap/plugins/OptionalArguments.py";
    "tensorflow" -> "/tools/cwrap/plugins/ProcessorSpecificPlugin.py";
    "tensorflow" -> "/tools/cwrap/plugins/ReturnArguments.py";
    "tensorflow" -> "/tools/cwrap/plugins/THPPlugin.py";
    "tensorflow" -> "/tools/cwrap/plugins/WrapDim.py";
    "tensorflow" -> "/tools/cwrap/plugins/__init__.py";
    "tensorflow" -> "/tools/jit/gen_jit_dispatch.py";
    "tensorflow" -> "/tools/jit/__init__.py";
    "tensorflow" -> "/tools/nnwrap/generate_wrappers.py";
    "tensorflow" -> "/tools/nnwrap/__init__.py";
    "tensorflow" -> "/tools/setup_helpers/cuda.py";
    "tensorflow" -> "/tools/setup_helpers/cudnn.py";
    "tensorflow" -> "/tools/setup_helpers/dist_check.py";
    "tensorflow" -> "/tools/setup_helpers/env.py";
    "tensorflow" -> "/tools/setup_helpers/generate_code.py";
    "tensorflow" -> "/tools/setup_helpers/nccl.py";
    "tensorflow" -> "/tools/setup_helpers/ninja_builder.py";
    "tensorflow" -> "/tools/setup_helpers/nnpack.py";
    "tensorflow" -> "/tools/setup_helpers/nvtoolext.py";
    "tensorflow" -> "/tools/setup_helpers/split_types.py";
    "tensorflow" -> "/tools/setup_helpers/__init__.py";
    "tensorflow" -> "/tools/shared/cwrap_common.py";
    "tensorflow" -> "/tools/shared/module_loader.py";
    "tensorflow" -> "/tools/shared/__init__.py";
    "tensorflow" -> "/torch/functional.py";
    "tensorflow" -> "/torch/random.py";
    "tensorflow" -> "/torch/serialization.py";
    "tensorflow" -> "/torch/storage.py";
    "tensorflow" -> "/torch/_six.py";
    "tensorflow" -> "/torch/_storage_docs.py";
    "tensorflow" -> "/torch/_tensor_docs.py";
    "tensorflow" -> "/torch/_tensor_str.py";
    "tensorflow" -> "/torch/_torch_docs.py";
    "tensorflow" -> "/torch/_utils.py";
    "tensorflow" -> "/torch/__init__.py";
    "tensorflow" -> "/torch/autograd/function.py";
    "tensorflow" -> "/torch/autograd/gradcheck.py";
    "tensorflow" -> "/torch/autograd/grad_mode.py";
    "tensorflow" -> "/torch/autograd/profiler.py";
    "tensorflow" -> "/torch/autograd/variable.py";
    "tensorflow" -> "/torch/autograd/__init__.py";
    "tensorflow" -> "/torch/autograd/_functions/tensor.py";
    "tensorflow" -> "/torch/autograd/_functions/utils.py";
    "tensorflow" -> "/torch/autograd/_functions/__init__.py";
    "tensorflow" -> "/torch/backends/__init__.py";
    "tensorflow" -> "/torch/backends/cudnn/rnn.py";
    "tensorflow" -> "/torch/backends/cudnn/__init__.py";
    "tensorflow" -> "/torch/contrib/_graph_vis.py";
    "tensorflow" -> "/torch/contrib/__init__.py";
    "tensorflow" -> "/torch/cuda/comm.py";
    "tensorflow" -> "/torch/cuda/error.py";
    "tensorflow" -> "/torch/cuda/nccl.py";
    "tensorflow" -> "/torch/cuda/nvtx.py";
    "tensorflow" -> "/torch/cuda/profiler.py";
    "tensorflow" -> "/torch/cuda/random.py";
    "tensorflow" -> "/torch/cuda/sparse.py";
    "tensorflow" -> "/torch/cuda/streams.py";
    "tensorflow" -> "/torch/cuda/__init__.py";
    "tensorflow" -> "/torch/distributed/launch.py";
    "tensorflow" -> "/torch/distributed/remote_types.py";
    "tensorflow" -> "/torch/distributed/__init__.py";
    "tensorflow" -> "/torch/distributions/bernoulli.py";
    "tensorflow" -> "/torch/distributions/beta.py";
    "tensorflow" -> "/torch/distributions/binomial.py";
    "tensorflow" -> "/torch/distributions/categorical.py";
    "tensorflow" -> "/torch/distributions/cauchy.py";
    "tensorflow" -> "/torch/distributions/chi2.py";
    "tensorflow" -> "/torch/distributions/constraints.py";
    "tensorflow" -> "/torch/distributions/constraint_registry.py";
    "tensorflow" -> "/torch/distributions/dirichlet.py";
    "tensorflow" -> "/torch/distributions/distribution.py";
    "tensorflow" -> "/torch/distributions/exponential.py";
    "tensorflow" -> "/torch/distributions/exp_family.py";
    "tensorflow" -> "/torch/distributions/fishersnedecor.py";
    "tensorflow" -> "/torch/distributions/gamma.py";
    "tensorflow" -> "/torch/distributions/geometric.py";
    "tensorflow" -> "/torch/distributions/gumbel.py";
    "tensorflow" -> "/torch/distributions/kl.py";
    "tensorflow" -> "/torch/distributions/laplace.py";
    "tensorflow" -> "/torch/distributions/log_normal.py";
    "tensorflow" -> "/torch/distributions/multinomial.py";
    "tensorflow" -> "/torch/distributions/normal.py";
    "tensorflow" -> "/torch/distributions/one_hot_categorical.py";
    "tensorflow" -> "/torch/distributions/pareto.py";
    "tensorflow" -> "/torch/distributions/poisson.py";
    "tensorflow" -> "/torch/distributions/relaxed_bernoulli.py";
    "tensorflow" -> "/torch/distributions/relaxed_categorical.py";
    "tensorflow" -> "/torch/distributions/studentT.py";
    "tensorflow" -> "/torch/distributions/transformed_distribution.py";
    "tensorflow" -> "/torch/distributions/transforms.py";
    "tensorflow" -> "/torch/distributions/uniform.py";
    "tensorflow" -> "/torch/distributions/utils.py";
    "tensorflow" -> "/torch/distributions/__init__.py";
    "tensorflow" -> "/torch/for_onnx/__init__.py";
    "tensorflow" -> "/torch/jit/frontend.py";
    "tensorflow" -> "/torch/jit/__init__.py";
    "tensorflow" -> "/torch/legacy/__init__.py";
    "tensorflow" -> "/torch/legacy/nn/Abs.py";
    "tensorflow" -> "/torch/legacy/nn/AbsCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/Add.py";
    "tensorflow" -> "/torch/legacy/nn/AddConstant.py";
    "tensorflow" -> "/torch/legacy/nn/BatchNormalization.py";
    "tensorflow" -> "/torch/legacy/nn/BCECriterion.py";
    "tensorflow" -> "/torch/legacy/nn/Bilinear.py";
    "tensorflow" -> "/torch/legacy/nn/CAddTable.py";
    "tensorflow" -> "/torch/legacy/nn/CDivTable.py";
    "tensorflow" -> "/torch/legacy/nn/Clamp.py";
    "tensorflow" -> "/torch/legacy/nn/ClassNLLCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/ClassSimplexCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/CMul.py";
    "tensorflow" -> "/torch/legacy/nn/CMulTable.py";
    "tensorflow" -> "/torch/legacy/nn/Concat.py";
    "tensorflow" -> "/torch/legacy/nn/ConcatTable.py";
    "tensorflow" -> "/torch/legacy/nn/Container.py";
    "tensorflow" -> "/torch/legacy/nn/Contiguous.py";
    "tensorflow" -> "/torch/legacy/nn/Copy.py";
    "tensorflow" -> "/torch/legacy/nn/Cosine.py";
    "tensorflow" -> "/torch/legacy/nn/CosineDistance.py";
    "tensorflow" -> "/torch/legacy/nn/CosineEmbeddingCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/Criterion.py";
    "tensorflow" -> "/torch/legacy/nn/CriterionTable.py";
    "tensorflow" -> "/torch/legacy/nn/CrossEntropyCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/CSubTable.py";
    "tensorflow" -> "/torch/legacy/nn/DepthConcat.py";
    "tensorflow" -> "/torch/legacy/nn/DistKLDivCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/DotProduct.py";
    "tensorflow" -> "/torch/legacy/nn/Dropout.py";
    "tensorflow" -> "/torch/legacy/nn/ELU.py";
    "tensorflow" -> "/torch/legacy/nn/Euclidean.py";
    "tensorflow" -> "/torch/legacy/nn/Exp.py";
    "tensorflow" -> "/torch/legacy/nn/FlattenTable.py";
    "tensorflow" -> "/torch/legacy/nn/GradientReversal.py";
    "tensorflow" -> "/torch/legacy/nn/HardShrink.py";
    "tensorflow" -> "/torch/legacy/nn/HardTanh.py";
    "tensorflow" -> "/torch/legacy/nn/HingeEmbeddingCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/Identity.py";
    "tensorflow" -> "/torch/legacy/nn/Index.py";
    "tensorflow" -> "/torch/legacy/nn/JoinTable.py";
    "tensorflow" -> "/torch/legacy/nn/L1Cost.py";
    "tensorflow" -> "/torch/legacy/nn/L1HingeEmbeddingCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/L1Penalty.py";
    "tensorflow" -> "/torch/legacy/nn/LeakyReLU.py";
    "tensorflow" -> "/torch/legacy/nn/Linear.py";
    "tensorflow" -> "/torch/legacy/nn/Log.py";
    "tensorflow" -> "/torch/legacy/nn/LogSigmoid.py";
    "tensorflow" -> "/torch/legacy/nn/LogSoftMax.py";
    "tensorflow" -> "/torch/legacy/nn/LookupTable.py";
    "tensorflow" -> "/torch/legacy/nn/MarginCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/MarginRankingCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/MaskedSelect.py";
    "tensorflow" -> "/torch/legacy/nn/Max.py";
    "tensorflow" -> "/torch/legacy/nn/Mean.py";
    "tensorflow" -> "/torch/legacy/nn/Min.py";
    "tensorflow" -> "/torch/legacy/nn/MixtureTable.py";
    "tensorflow" -> "/torch/legacy/nn/MM.py";
    "tensorflow" -> "/torch/legacy/nn/Module.py";
    "tensorflow" -> "/torch/legacy/nn/MSECriterion.py";
    "tensorflow" -> "/torch/legacy/nn/Mul.py";
    "tensorflow" -> "/torch/legacy/nn/MulConstant.py";
    "tensorflow" -> "/torch/legacy/nn/MultiCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/MultiLabelMarginCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/MultiLabelSoftMarginCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/MultiMarginCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/MV.py";
    "tensorflow" -> "/torch/legacy/nn/Narrow.py";
    "tensorflow" -> "/torch/legacy/nn/NarrowTable.py";
    "tensorflow" -> "/torch/legacy/nn/Normalize.py";
    "tensorflow" -> "/torch/legacy/nn/Padding.py";
    "tensorflow" -> "/torch/legacy/nn/PairwiseDistance.py";
    "tensorflow" -> "/torch/legacy/nn/Parallel.py";
    "tensorflow" -> "/torch/legacy/nn/ParallelCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/ParallelTable.py";
    "tensorflow" -> "/torch/legacy/nn/PartialLinear.py";
    "tensorflow" -> "/torch/legacy/nn/Power.py";
    "tensorflow" -> "/torch/legacy/nn/PReLU.py";
    "tensorflow" -> "/torch/legacy/nn/ReLU.py";
    "tensorflow" -> "/torch/legacy/nn/ReLU6.py";
    "tensorflow" -> "/torch/legacy/nn/Replicate.py";
    "tensorflow" -> "/torch/legacy/nn/Reshape.py";
    "tensorflow" -> "/torch/legacy/nn/RReLU.py";
    "tensorflow" -> "/torch/legacy/nn/Select.py";
    "tensorflow" -> "/torch/legacy/nn/SelectTable.py";
    "tensorflow" -> "/torch/legacy/nn/Sequential.py";
    "tensorflow" -> "/torch/legacy/nn/Sigmoid.py";
    "tensorflow" -> "/torch/legacy/nn/SmoothL1Criterion.py";
    "tensorflow" -> "/torch/legacy/nn/SoftMarginCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/SoftMax.py";
    "tensorflow" -> "/torch/legacy/nn/SoftMin.py";
    "tensorflow" -> "/torch/legacy/nn/SoftPlus.py";
    "tensorflow" -> "/torch/legacy/nn/SoftShrink.py";
    "tensorflow" -> "/torch/legacy/nn/SoftSign.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialAdaptiveMaxPooling.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialAveragePooling.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialBatchNormalization.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialClassNLLCriterion.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialContrastiveNormalization.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialConvolution.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialConvolutionLocal.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialConvolutionMap.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialCrossMapLRN.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialDilatedConvolution.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialDivisiveNormalization.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialDropout.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialFractionalMaxPooling.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialFullConvolution.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialFullConvolutionMap.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialLPPooling.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialMaxPooling.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialMaxUnpooling.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialReflectionPadding.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialReplicationPadding.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialSoftMax.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialSubSampling.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialSubtractiveNormalization.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialUpSamplingNearest.py";
    "tensorflow" -> "/torch/legacy/nn/SpatialZeroPadding.py";
    "tensorflow" -> "/torch/legacy/nn/SplitTable.py";
    "tensorflow" -> "/torch/legacy/nn/Sqrt.py";
    "tensorflow" -> "/torch/legacy/nn/Square.py";
    "tensorflow" -> "/torch/legacy/nn/Squeeze.py";
    "tensorflow" -> "/torch/legacy/nn/Sum.py";
    "tensorflow" -> "/torch/legacy/nn/Tanh.py";
    "tensorflow" -> "/torch/legacy/nn/TanhShrink.py";
    "tensorflow" -> "/torch/legacy/nn/TemporalConvolution.py";
    "tensorflow" -> "/torch/legacy/nn/TemporalMaxPooling.py";
    "tensorflow" -> "/torch/legacy/nn/TemporalSubSampling.py";
    "tensorflow" -> "/torch/legacy/nn/Threshold.py";
    "tensorflow" -> "/torch/legacy/nn/Transpose.py";
    "tensorflow" -> "/torch/legacy/nn/Unsqueeze.py";
    "tensorflow" -> "/torch/legacy/nn/utils.py";
    "tensorflow" -> "/torch/legacy/nn/View.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricAveragePooling.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricBatchNormalization.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricConvolution.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricDropout.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricFullConvolution.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricMaxPooling.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricMaxUnpooling.py";
    "tensorflow" -> "/torch/legacy/nn/VolumetricReplicationPadding.py";
    "tensorflow" -> "/torch/legacy/nn/WeightedEuclidean.py";
    "tensorflow" -> "/torch/legacy/nn/WeightedMSECriterion.py";
    "tensorflow" -> "/torch/legacy/nn/__init__.py";
    "tensorflow" -> "/torch/legacy/optim/adadelta.py";
    "tensorflow" -> "/torch/legacy/optim/adagrad.py";
    "tensorflow" -> "/torch/legacy/optim/adam.py";
    "tensorflow" -> "/torch/legacy/optim/adamax.py";
    "tensorflow" -> "/torch/legacy/optim/asgd.py";
    "tensorflow" -> "/torch/legacy/optim/cg.py";
    "tensorflow" -> "/torch/legacy/optim/lbfgs.py";
    "tensorflow" -> "/torch/legacy/optim/nag.py";
    "tensorflow" -> "/torch/legacy/optim/rmsprop.py";
    "tensorflow" -> "/torch/legacy/optim/rprop.py";
    "tensorflow" -> "/torch/legacy/optim/sgd.py";
    "tensorflow" -> "/torch/legacy/optim/__init__.py";
    "tensorflow" -> "/torch/lib/THD/benchmark/benchmark.py";
    "tensorflow" -> "/torch/multiprocessing/pool.py";
    "tensorflow" -> "/torch/multiprocessing/queue.py";
    "tensorflow" -> "/torch/multiprocessing/reductions.py";
    "tensorflow" -> "/torch/multiprocessing/__init__.py";
    "tensorflow" -> "/torch/nn/functional.py";
    "tensorflow" -> "/torch/nn/init.py";
    "tensorflow" -> "/torch/nn/parameter.py";
    "tensorflow" -> "/torch/nn/__init__.py";
    "tensorflow" -> "/torch/nn/backends/backend.py";
    "tensorflow" -> "/torch/nn/backends/thnn.py";
    "tensorflow" -> "/torch/nn/backends/__init__.py";
    "tensorflow" -> "/torch/nn/modules/activation.py";
    "tensorflow" -> "/torch/nn/modules/batchnorm.py";
    "tensorflow" -> "/torch/nn/modules/container.py";
    "tensorflow" -> "/torch/nn/modules/conv.py";
    "tensorflow" -> "/torch/nn/modules/distance.py";
    "tensorflow" -> "/torch/nn/modules/dropout.py";
    "tensorflow" -> "/torch/nn/modules/fold.py";
    "tensorflow" -> "/torch/nn/modules/instancenorm.py";
    "tensorflow" -> "/torch/nn/modules/linear.py";
    "tensorflow" -> "/torch/nn/modules/loss.py";
    "tensorflow" -> "/torch/nn/modules/module.py";
    "tensorflow" -> "/torch/nn/modules/normalization.py";
    "tensorflow" -> "/torch/nn/modules/padding.py";
    "tensorflow" -> "/torch/nn/modules/pixelshuffle.py";
    "tensorflow" -> "/torch/nn/modules/pooling.py";
    "tensorflow" -> "/torch/nn/modules/rnn.py";
    "tensorflow" -> "/torch/nn/modules/sparse.py";
    "tensorflow" -> "/torch/nn/modules/upsampling.py";
    "tensorflow" -> "/torch/nn/modules/utils.py";
    "tensorflow" -> "/torch/nn/modules/__init__.py";
    "tensorflow" -> "/torch/nn/parallel/data_parallel.py";
    "tensorflow" -> "/torch/nn/parallel/distributed.py";
    "tensorflow" -> "/torch/nn/parallel/parallel_apply.py";
    "tensorflow" -> "/torch/nn/parallel/replicate.py";
    "tensorflow" -> "/torch/nn/parallel/scatter_gather.py";
    "tensorflow" -> "/torch/nn/parallel/_functions.py";
    "tensorflow" -> "/torch/nn/parallel/__init__.py";
    "tensorflow" -> "/torch/nn/utils/clip_grad.py";
    "tensorflow" -> "/torch/nn/utils/convert_parameters.py";
    "tensorflow" -> "/torch/nn/utils/rnn.py";
    "tensorflow" -> "/torch/nn/utils/weight_norm.py";
    "tensorflow" -> "/torch/nn/utils/__init__.py";
    "tensorflow" -> "/torch/nn/_functions/dropout.py";
    "tensorflow" -> "/torch/nn/_functions/linear.py";
    "tensorflow" -> "/torch/nn/_functions/loss.py";
    "tensorflow" -> "/torch/nn/_functions/packing.py";
    "tensorflow" -> "/torch/nn/_functions/padding.py";
    "tensorflow" -> "/torch/nn/_functions/rnn.py";
    "tensorflow" -> "/torch/nn/_functions/vision.py";
    "tensorflow" -> "/torch/nn/_functions/__init__.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/auto.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/auto_double_backwards.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/auto_symbolic.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/fold.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/normalization.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/rnnFusedPointwise.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/sparse.py";
    "tensorflow" -> "/torch/nn/_functions/thnn/__init__.py";
    "tensorflow" -> "/torch/onnx/symbolic.py";
    "tensorflow" -> "/torch/onnx/utils.py";
    "tensorflow" -> "/torch/onnx/__init__.py";
    "tensorflow" -> "/torch/optim/adadelta.py";
    "tensorflow" -> "/torch/optim/adagrad.py";
    "tensorflow" -> "/torch/optim/adam.py";
    "tensorflow" -> "/torch/optim/adamax.py";
    "tensorflow" -> "/torch/optim/asgd.py";
    "tensorflow" -> "/torch/optim/lbfgs.py";
    "tensorflow" -> "/torch/optim/lr_scheduler.py";
    "tensorflow" -> "/torch/optim/optimizer.py";
    "tensorflow" -> "/torch/optim/rmsprop.py";
    "tensorflow" -> "/torch/optim/rprop.py";
    "tensorflow" -> "/torch/optim/sgd.py";
    "tensorflow" -> "/torch/optim/sparse_adam.py";
    "tensorflow" -> "/torch/optim/__init__.py";
    "tensorflow" -> "/torch/sparse/__init__.py";
    "tensorflow" -> "/torch/testing/__init__.py";
    "tensorflow" -> "/torch/utils/cpp_extension.py";
    "tensorflow" -> "/torch/utils/dlpack.py";
    "tensorflow" -> "/torch/utils/hooks.py";
    "tensorflow" -> "/torch/utils/model_zoo.py";
    "tensorflow" -> "/torch/utils/__init__.py";
    "tensorflow" -> "/torch/utils/backcompat/__init__.py";
    "tensorflow" -> "/torch/utils/data/dataloader.py";
    "tensorflow" -> "/torch/utils/data/dataset.py";
    "tensorflow" -> "/torch/utils/data/distributed.py";
    "tensorflow" -> "/torch/utils/data/sampler.py";
    "tensorflow" -> "/torch/utils/data/__init__.py";
    "tensorflow" -> "/torch/utils/ffi/__init__.py";
    "tensorflow" -> "/torch/utils/serialization/read_lua_file.py";
    "tensorflow" -> "/torch/utils/serialization/__init__.py";
    "tensorflow" -> "/torch/utils/trainer/trainer.py";
    "tensorflow" -> "/torch/utils/trainer/__init__.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/accuracy.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/logger.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/loss.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/monitor.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/plugin.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/progress.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/time.py";
    "tensorflow" -> "/torch/utils/trainer/plugins/__init__.py";
    "tensorflow" -> "/torch/_thnn/utils.py";
    "tensorflow" -> "/torch/_thnn/__init__.py";
    "/setup.py" -> "Import:setup,";
    "/setup.py" -> "Import:setuptools.command.build_ext";
    "/setup.py" -> "Import:setuptools.command.install";
    "/setup.py" -> "Import:setuptools.command.develop";
    "/setup.py" -> "Import:setuptools.command.build_py";
    "/setup.py" -> "Import:distutils.unixccompiler";
    "/setup.py" -> "Import:distutils.command.build";
    "/setup.py" -> "Import:distutils.command.clean";
    "/setup.py" -> "Import:platform";
    "/setup.py" -> "Import:subprocess";
    "/setup.py" -> "Import:shutil";
    "/setup.py" -> "Import:multiprocessing";
    "/setup.py" -> "Import:sys";
    "/setup.py" -> "Import:import";
    "/setup.py" -> "Import:json";
    "/setup.py" -> "Import:glob";
    "/setup.py" -> "Import:importlib";
    "/setup.py" -> "Import:check_env_flag";
    "/setup.py" -> "Import:WITH_CUDA,";
    "/setup.py" -> "Import:(WITH_CUDNN,";
    "/setup.py" -> "Import:WITH_NCCL,";
    "/setup.py" -> "Import:WITH_NNPACK";
    "/setup.py" -> "Import:NVTOOLEXT_HOME";
    "/setup.py" -> "Import:generate_code";
    "/setup.py" -> "Import:NinjaBuilder,";
    "/setup.py" -> "Import:WITH_DISTRIBUTED,";
    "/setup.py" -> "Import:ninja";
    "/setup.py" -> "Fxn:parallelCCompile";
    "/setup.py" -> "Import:multiprocessing.pool";
    "/setup.py" -> "Fxn:_single_compile";
    "/setup.py" -> "Fxn:patched_link";
    "/setup.py" -> "Import:distutils.sysconfig";
    "/setup.py" -> "Fxn:build_libs";
    "/setup.py" -> "Fxn:check_pydep";
    "/setup.py" -> "class:build_deps(Command):";
    "/setup.py" -> "class:build_dep(build_deps):";
    "/setup.py" -> "class:build_module(Command):";
    "/setup.py" -> "class:build_py(setuptools.command.build_py.build_py):";
    "/setup.py" -> "class:develop(setuptools.command.develop.develop):";
    "/setup.py" -> "class:build_ext(build_ext_parent):";
    "/setup.py" -> "class:build(distutils.command.build.build):";
    "/setup.py" -> "class:install(setuptools.command.install.install):";
    "/setup.py" -> "class:clean(distutils.command.clean.clean):";
    "/setup.py" -> "Import:glob";
    "/setup.py" -> "Import:numpy";
    "class:build_deps(Command):" -> "Fxn:initialize_options";
    "class:build_deps(Command):" -> "Fxn:finalize_options";
    "class:build_deps(Command):" -> "Fxn:run";
    "class:build_deps(Command):" -> "Fxn:check_file";
    "Fxn:check_file" -> "Fxn:os.path.exists(f):";
    "Fxn:check_file" -> "Fxn:{}".format(f))";
    "Fxn:check_file" -> "Fxn:sys.exit(1)";
    "Fxn:check_file" -> "Fxn:check_file(os.path.join(lib_path,";
    "Fxn:check_file" -> "Fxn:check_file(os.path.join(lib_path,";
    "Fxn:check_file" -> "Fxn:check_file(os.path.join(lib_path,";
    "Fxn:check_file" -> "Fxn:check_file(os.path.join('aten',";
    "Fxn:check_file" -> "Fxn:check_file(os.path.join('aten',";
    "Fxn:check_file" -> "Fxn:check_pydep('yaml',";
    "Fxn:check_file" -> "Fxn:check_pydep('typing',";
    "Fxn:check_file" -> "Fxn:sys.platform.startswith('linux'):";
    "Fxn:check_file" -> "Fxn:build_libs(libs)";
    "class:build_dep(build_deps):" -> "Fxn:run";
    "Fxn:run" -> "Fxn:build_libs([self.lib])";
    "Fxn:run" -> "Fxn:lib.lower()]";
    "class:build_module(Command):" -> "Fxn:initialize_options";
    "class:build_module(Command):" -> "Fxn:finalize_options";
    "class:build_module(Command):" -> "Fxn:run";
    "Fxn:run" -> "Fxn:self.run_command('build_py')";
    "Fxn:run" -> "Fxn:self.run_command('build_ext')";
    "class:build_py(setuptools.command.build_py.build_py):" -> "Fxn:run";
    "class:build_py(setuptools.command.build_py.build_py):" -> "Fxn:create_version_file";
    "Fxn:run" -> "Fxn:self.create_version_file()";
    "Fxn:run" -> "Fxn:setuptools.command.build_py.build_py.run(self)";
    "Fxn:create_version_file" -> "Fxn:os.path.join(cwd,";
    "Fxn:create_version_file" -> "Fxn:f.write("__version__";
    "Fxn:create_version_file" -> "Fxn:'{}'\n".format(version))";
    "Fxn:create_version_file" -> "Fxn:f.write("debug";
    "Fxn:create_version_file" -> "Fxn:{}\n".format(repr(DEBUG)))";
    "Fxn:create_version_file" -> "Fxn:f.write("cuda";
    "Fxn:create_version_file" -> "Fxn:{}\n".format(repr(CUDA_VERSION)))";
    "class:develop(setuptools.command.develop.develop):" -> "Fxn:run";
    "class:develop(setuptools.command.develop.develop):" -> "Fxn:create_compile_commands";
    "class:develop(setuptools.command.develop.develop):" -> "Fxn:load";
    "class:develop(setuptools.command.develop.develop):" -> "Fxn:monkey_patch_THD_link_flags";
    "Fxn:run" -> "Fxn:build_py.create_version_file()";
    "Fxn:run" -> "Fxn:setuptools.command.develop.develop.run(self)";
    "Fxn:run" -> "Fxn:self.create_compile_commands()";
    "Fxn:load" -> "Fxn:json.load(f)";
    "Fxn:load" -> "Fxn:glob.glob('build/*_compile_commands.json')";
    "Fxn:load" -> "Fxn:glob.glob('torch/lib/build/*/compile_commands.json')";
    "Fxn:load" -> "Fxn:load(f)]";
    "Fxn:load" -> "Fxn:json.dump(all_commands,";
    "Fxn:monkey_patch_THD_link_flags" -> "Fxn:f.read()";
    "Fxn:monkey_patch_THD_link_flags" -> "Fxn:thd_deps_.split(';'):";
    "Fxn:monkey_patch_THD_link_flags" -> "Fxn:thd_deps.append(l)";
    "class:build_ext(build_ext_parent):" -> "Fxn:run";
    "Fxn:run" -> "Fxn:monkey_patch_THD_link_flags()";
    "Fxn:run" -> "Fxn:generate_code(ninja_global)";
    "Fxn:run" -> "Fxn:ninja_global.run()";
    "class:install(setuptools.command.install.install):" -> "Fxn:run";
    "Fxn:run" -> "Fxn:self.run_command('build_deps')";
    "Fxn:run" -> "Fxn:self.copy_tree('torch/csrc',";
    "Fxn:run" -> "Fxn:self.copy_tree('torch/lib/pybind11/include/pybind11/',";
    "Fxn:run" -> "Fxn:self.copy_file('torch/torch.h',";
    "Fxn:run" -> "Fxn:setuptools.command.install.install.run(self)";
    "class:clean(distutils.command.clean.clean):" -> "Fxn:run";
    "class:clean(distutils.command.clean.clean):" -> "Fxn:make_relative_rpath";
    "Fxn:run" -> "Fxn:f.read()";
    "Fxn:run" -> "Fxn:ignores.split('\n')):";
    "Fxn:run" -> "Fxn:glob.glob(wildcard):";
    "Fxn:run" -> "Fxn:os.remove(filename)";
    "Fxn:run" -> "Fxn:shutil.rmtree(filename,";
    "Fxn:make_relative_rpath" -> "Fxn:find_packages(exclude=('tools',";
    "Fxn:make_relative_rpath" -> "Fxn:Extension("torch._C",";
    "Fxn:make_relative_rpath" -> "Fxn:[make_relative_rpath('lib')],";
    "Fxn:make_relative_rpath" -> "Fxn:extensions.append(C)";
    "Fxn:make_relative_rpath" -> "Fxn:Extension("torch._dl",";
    "Fxn:make_relative_rpath" -> "Fxn:extensions.append(DL)";
    "Fxn:make_relative_rpath" -> "Fxn:[make_relative_rpath('lib')]";
    "Fxn:make_relative_rpath" -> "Fxn:Extension("torch._nvrtc",";
    "Fxn:make_relative_rpath" -> "Fxn:extensions.append(THNVRTC)";
    "Fxn:make_relative_rpath" -> "Fxn:os.getenv('PYTORCH_BUILD_VERSION'):";
    "Fxn:make_relative_rpath" -> "Fxn:os.getenv('PYTORCH_BUILD_NUMBER')";
    "Fxn:make_relative_rpath" -> "Fxn:os.getenv('PYTORCH_BUILD_VERSION')";
    "Fxn:make_relative_rpath" -> "Fxn:subprocess.check_output(['git',";
    "Fxn:make_relative_rpath" -> "Fxn:cwd=cwd).decode('ascii').strip()";
    "Fxn:make_relative_rpath" -> "Fxn:cmdclass.update(build_dep_cmds)";
    "Fxn:make_relative_rpath" -> "Fxn:setup(";
    "Fxn:make_relative_rpath" -> "Fxn:description=("Tensors";
    "/.jenkins/perf_test/compare_with_baseline.py" -> "Import:sys";
    "/.jenkins/perf_test/compare_with_baseline.py" -> "Import:json";
    "/.jenkins/perf_test/compare_with_baseline.py" -> "Import:numpy";
    "/.jenkins/perf_test/compare_with_baseline.py" -> "Import:argparse";
    "/.jenkins/perf_test/get_stats.py" -> "Import:sys";
    "/.jenkins/perf_test/get_stats.py" -> "Import:json";
    "/.jenkins/perf_test/get_stats.py" -> "Import:numpy";
    "/.jenkins/perf_test/update_commit_hash.py" -> "Import:sys";
    "/.jenkins/perf_test/update_commit_hash.py" -> "Import:json";
    "/aten/src/ATen/code_template.py" -> "Import:match";
    "/aten/src/ATen/code_template.py" -> "class:CodeTemplate(object):";
    "class:CodeTemplate(object):" -> "Fxn:from_file";
    "class:CodeTemplate(object):" -> "Fxn:__init__";
    "class:CodeTemplate(object):" -> "Fxn:substitute";
    "class:CodeTemplate(object):" -> "Fxn:lookup";
    "class:CodeTemplate(object):" -> "Fxn:indent_lines";
    "class:CodeTemplate(object):" -> "Fxn:replace";
    "Fxn:from_file" -> "Fxn:CodeTemplate(f.read())";
    "Fxn:indent_lines" -> "Fxn:"".join([indent";
    "Fxn:replace" -> "Fxn:match.group(1)";
    "Fxn:replace" -> "Fxn:match.group(2)";
    "Fxn:replace" -> "Fxn:lookup(key)";
    "Fxn:replace" -> "Fxn:indent_lines(indent,";
    "Fxn:replace" -> "Fxn:'.join([str(x)";
    "Fxn:replace" -> "Fxn:self.subtitution.sub(replace,";
    "Fxn:replace" -> "Fxn:CodeTemplate("""\";
    "Fxn:replace" -> "Fxn:foo($args)";
    "Fxn:replace" -> "Fxn:commatest(int";
    "Fxn:replace" -> "Fxn:notest(int";
    "/aten/src/ATen/common_with_cwrap.py" -> "Import:deepcopy";
    "/aten/src/ATen/common_with_cwrap.py" -> "Import:product";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:parse_arguments";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:set_declaration_defaults";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:filter_unique_options";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:exclude_arg";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:exclude_arg_with_self_check";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:signature";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:enumerate_options_due_to_default";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:is_nullable_tensor_arg";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:sort_by_number_of_options";
    "/aten/src/ATen/common_with_cwrap.py" -> "Fxn:num_checked_args";
    "/aten/src/ATen/common_with_cwrap.py" -> "class:Function(object):";
    "/aten/src/ATen/common_with_cwrap.py" -> "class:Argument(object):";
    "class:Function(object):" -> "Fxn:__init__";
    "class:Function(object):" -> "Fxn:add_argument";
    "class:Function(object):" -> "Fxn:__repr__";
    "Fxn:add_argument" -> "Fxn:self.arguments.append(arg)";
    "Fxn:__repr__" -> "Fxn:'('";
    "Fxn:__repr__" -> "Fxn:'.join(map(lambda";
    "Fxn:__repr__" -> "Fxn:a.__repr__(),";
    "class:Argument(object):" -> "Fxn:__init__";
    "class:Argument(object):" -> "Fxn:__repr__";
    "class:Argument(object):" -> "Fxn:parse_header";
    "Fxn:parse_header" -> "Fxn:f.read().split('\n')";
    "Fxn:parse_header" -> "Fxn:l.startswith('#'),";
    "Fxn:parse_header" -> "Fxn:l.partition('//'),";
    "Fxn:parse_header" -> "Fxn:l[2].strip()),";
    "Fxn:parse_header" -> "Fxn:new_lines.append((split,";
    "Fxn:parse_header" -> "Fxn:l.startswith('TH_API";
    "Fxn:parse_header" -> "Fxn:l.lstrip('TH_API";
    "Fxn:parse_header" -> "Fxn:'('";
    "Fxn:parse_header" -> "Fxn:generic_functions.append(Function(fn_name))";
    "Fxn:parse_header" -> "Fxn:l.split()";
    "Fxn:parse_header" -> "Fxn:generic_functions[-1].add_argument(";
    "Fxn:parse_header" -> "Fxn:Argument(t,";
    "/aten/src/ATen/copy_wrapper.py" -> "Import:CodeTemplate";
    "/aten/src/ATen/copy_wrapper.py" -> "Import:nested_dict";
    "/aten/src/ATen/copy_wrapper.py" -> "Fxn:create_one";
    "/aten/src/ATen/copy_wrapper.py" -> "Fxn:create";
    "/aten/src/ATen/cwrap_parser.py" -> "Import:yaml";
    "/aten/src/ATen/cwrap_parser.py" -> "Fxn:parse";
    "/aten/src/ATen/extract_cwrap.py" -> "Import:OptionParser";
    "/aten/src/ATen/function_wrapper.py" -> "Import:code_template";
    "/aten/src/ATen/function_wrapper.py" -> "Import:CodeTemplate";
    "/aten/src/ATen/function_wrapper.py" -> "Import:typing";
    "/aten/src/ATen/function_wrapper.py" -> "Import:`typing`";
    "/aten/src/ATen/function_wrapper.py" -> "Import:Union,";
    "/aten/src/ATen/function_wrapper.py" -> "Import:Any,";
    "/aten/src/ATen/function_wrapper.py" -> "Import:TypedDict";
    "/aten/src/ATen/function_wrapper.py" -> "Fxn:TypedDict";
    "/aten/src/ATen/function_wrapper.py" -> "Import:sys";
    "/aten/src/ATen/function_wrapper.py" -> "class:NYIError(Exception):";
    "/aten/src/ATen/function_wrapper.py" -> "class:nested_dict(object):";
    "class:NYIError(Exception):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'checked_cast_tensor<${Tensor}>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'checked_cast_tensor<Sparse${Tensor}>(${arg_name}.tref.pImpl,"${arg_name}",${arg_pos},false)'),";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'checked_cast_tensor<${Backend}ByteTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'checked_cast_tensor<${Backend}LongTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'checked_cast_tensor<${Backend}IntTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'checked_cast_tensor<${DenseTensor}>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'checked_cast_tensor<${DenseBackend}LongTensor>(${arg_name}.pImpl,"${arg_name}",${arg_pos},";
    "Fxn:__init__" -> "Fxn:CodeTemplate('checked_cast_storage<${Storage}>(&${arg_name},"${arg_name}",${arg_pos})'),";
    "Fxn:__init__" -> "Fxn:CodeTemplate(";
    "Fxn:__init__" -> "Fxn:'check_generator<${Backend}Generator>(${arg_name},";
    "Fxn:__init__" -> "Fxn:&context->defaultGenerator(backend()))'),";
    "Fxn:__init__" -> "Fxn:CodeTemplate('THLongStorageView::makeFromSize(${arg_name})'),";
    "Fxn:__init__" -> "Fxn:CodeTemplate('THLongStorageView::makeFromStride(${arg_name},";
    "Fxn:__init__" -> "Fxn:CodeTemplate('${arg_name}.to${ScalarName}()'),";
    "Fxn:__init__" -> "Fxn:CodeTemplate('${arg_name}.to${AccScalarName}()'),";
    "Fxn:__init__" -> "Fxn:CodeTemplate('tensor_list_checked_cast<${Tensor},";
    "Fxn:__init__" -> "Fxn:'${THTensor}>(${arg_name},"${arg_name}",${arg_pos})'),";
    "Fxn:__init__" -> "Fxn:CodeTemplate('check_intlist<${size}>(${arg_name},";
    "Fxn:__init__" -> "Fxn:"{0}_.data(),";
    "Fxn:__init__" -> "Fxn:{0}_.size()",";
    "Fxn:__init__" -> "Fxn:CodeTemplate('${arg_name}_";
    "Fxn:__init__" -> "Fxn:${Tensor}(context${,arguments})',";
    "Fxn:__init__" -> "Fxn:${Backend}ByteTensor(context${,arguments})',";
    "Fxn:__init__" -> "Fxn:${Backend}LongTensor(context${,arguments})',";
    "Fxn:__init__" -> "Fxn:${Backend}IntTensor(context${,arguments})',";
    "Fxn:__init__" -> "Fxn:Sparse${Tensor}(context${,arguments})',";
    "Fxn:__init__" -> "Fxn:${DenseTensor}(context${,arguments})',";
    "Fxn:__init__" -> "Fxn:${DenseBackend}LongTensor(context${,arguments})',";
    "Fxn:__init__" -> "Fxn:'THLongStorageView::makeFromLength(static_cast<int64_t>(storage.size()))'),";
    "Fxn:__init__" -> "Fxn:'self.ndimension()-1'),";
    "class:nested_dict(object):" -> "Fxn:__init__";
    "class:nested_dict(object):" -> "Fxn:__getitem__";
    "class:nested_dict(object):" -> "Fxn:is_real_argument_to_wrapper";
    "class:nested_dict(object):" -> "Fxn:is_mutable_formal_argument";
    "class:nested_dict(object):" -> "Fxn:to_return_type";
    "class:nested_dict(object):" -> "Fxn:create_generic";
    "class:nested_dict(object):" -> "Fxn:translate_default";
    "class:nested_dict(object):" -> "Fxn:translate_formal";
    "class:nested_dict(object):" -> "Fxn:get_formals";
    "class:nested_dict(object):" -> "Fxn:insert";
    "class:nested_dict(object):" -> "Fxn:has_output_mask";
    "class:nested_dict(object):" -> "Fxn:get_return_types";
    "class:nested_dict(object):" -> "Fxn:format_return_type";
    "class:nested_dict(object):" -> "Fxn:find_dispatch_tensor";
    "class:nested_dict(object):" -> "Fxn:format_formal";
    "class:nested_dict(object):" -> "Fxn:formal_with_default";
    "class:nested_dict(object):" -> "Fxn:get_broadcast_argument";
    "class:nested_dict(object):" -> "Fxn:get_broadcast_actuals";
    "class:nested_dict(object):" -> "Fxn:emit_nn_body";
    "class:nested_dict(object):" -> "Fxn:process_option";
    "class:nested_dict(object):" -> "Fxn:native_get_formals";
    "class:nested_dict(object):" -> "Fxn:insert";
    "class:nested_dict(object):" -> "Fxn:add_type_as_dynamic_type";
    "class:nested_dict(object):" -> "Fxn:native_translate_formals";
    "class:nested_dict(object):" -> "Fxn:translate_map";
    "class:nested_dict(object):" -> "Fxn:native_get_return_types";
    "class:nested_dict(object):" -> "Fxn:process_native";
    "class:nested_dict(object):" -> "Fxn:find_dispatch_type";
    "class:nested_dict(object):" -> "Fxn:create_derived";
    "class:nested_dict(object):" -> "Fxn:replace_with_null";
    "class:nested_dict(object):" -> "Fxn:requires_checked_cast";
    "class:nested_dict(object):" -> "Fxn:nullable_argument";
    "class:nested_dict(object):" -> "Fxn:bool_option_is_string";
    "class:nested_dict(object):" -> "Fxn:get_argument";
    "class:nested_dict(object):" -> "Fxn:drop_argument";
    "class:nested_dict(object):" -> "Fxn:get_arguments";
    "class:nested_dict(object):" -> "Fxn:is_actual_return_long";
    "class:nested_dict(object):" -> "Fxn:get_zero_dim_dispatch_when_scalar";
    "class:nested_dict(object):" -> "Fxn:handle_zero_dim";
    "class:nested_dict(object):" -> "Fxn:handle_only_zero_dim";
    "class:nested_dict(object):" -> "Fxn:handle_sparse";
    "class:nested_dict(object):" -> "Fxn:allocate_arg";
    "class:nested_dict(object):" -> "Fxn:resize_arg";
    "class:nested_dict(object):" -> "Fxn:handle_call";
    "class:nested_dict(object):" -> "Fxn:emit_body";
    "class:nested_dict(object):" -> "Fxn:process_option";
    "class:nested_dict(object):" -> "Fxn:process_native";
    "Fxn:__getitem__" -> "Fxn:self.base.get(x)";
    "Fxn:__getitem__" -> "Fxn:TypedDict('Environment',";
    "Fxn:__getitem__" -> "Fxn:TypedDict('TopEnvironment',";
    "Fxn:__getitem__" -> "Fxn:TypedDict('THFormal',";
    "Fxn:__getitem__" -> "Fxn:TypedDict('AtFormal',";
    "Fxn:__getitem__" -> "Fxn:TypedDict('ReturnType',";
    "Fxn:__getitem__" -> "Fxn:TypedDict('ReturnDecl',";
    "Fxn:__getitem__" -> "Fxn:TypedDict('NNBuffer',";
    "Fxn:__getitem__" -> "Fxn:TypedDict('FunctionOption',";
    "Fxn:__getitem__" -> "Fxn:NamedTuple('OutputDeclaration',";
    "Fxn:is_real_argument_to_wrapper" -> "Fxn:argument.get('output',";
    "Fxn:is_mutable_formal_argument" -> "Fxn:argument.get('output')";
    "Fxn:to_return_type" -> "Fxn:TYPE_RETURN.get(t,";
    "Fxn:to_return_type" -> "Fxn:arg.get('allocate'):";
    "Fxn:to_return_type" -> "Fxn:is_mutable_formal_argument(arg,";
    "Fxn:to_return_type" -> "Fxn:DYNAMIC_TYPE.get(arg['type'],";
    "Fxn:translate_default" -> "Fxn:re.sub(pattern,";
    "Fxn:translate_default" -> "Fxn:default.lower()";
    "Fxn:translate_default" -> "Fxn:default.lower()";
    "Fxn:translate_formal" -> "Fxn:TYPE_FORMAL_GENERIC.get(argument['type'],";
    "Fxn:translate_formal" -> "Fxn:is_mutable_formal_argument(argument,";
    "Fxn:translate_formal" -> "Fxn:DYNAMIC_TYPE.get(argument['type'],";
    "Fxn:translate_formal" -> "Fxn:translate_default(argument,";
    "Fxn:translate_formal" -> "Fxn:argument.get('default_init',";
    "Fxn:translate_formal" -> "Fxn:translate_default(argument,";
    "Fxn:translate_formal" -> "Fxn:argument.get('output'):";
    "Fxn:translate_formal" -> "Fxn:argument.get('size'):";
    "Fxn:translate_formal" -> "Fxn:argument.get('is_nullable')";
    "Fxn:insert" -> "Fxn:seen.add(argument['name'])";
    "Fxn:insert" -> "Fxn:argument.get('kwarg_only',";
    "Fxn:insert" -> "Fxn:kwd_args.append(argument)";
    "Fxn:insert" -> "Fxn:pos_args.append(argument)";
    "Fxn:has_output_mask" -> "Fxn:argument.get('allocate',";
    "Fxn:has_output_mask" -> "Fxn:argument.get('mask',";
    "Fxn:has_output_mask" -> "Fxn:argument.get('output')";
    "Fxn:has_output_mask" -> "Fxn:argument.get('allocate',";
    "Fxn:has_output_mask" -> "Fxn:insert(argument)";
    "Fxn:has_output_mask" -> "Fxn:NYIError("Sparse";
    "Fxn:has_output_mask" -> "Fxn:insert(argument)";
    "Fxn:has_output_mask" -> "Fxn:is_real_argument_to_wrapper(argument):";
    "Fxn:has_output_mask" -> "Fxn:insert(argument)";
    "Fxn:has_output_mask" -> "Fxn:insert({";
    "Fxn:has_output_mask" -> "Fxn:'std::array<bool,{}>'.format(mask_size),";
    "Fxn:has_output_mask" -> "Fxn:'.join(['true']";
    "Fxn:has_output_mask" -> "Fxn:[translate_formal(argument,";
    "Fxn:get_return_types" -> "Fxn:[to_return_type(the_arg,";
    "Fxn:get_return_types" -> "Fxn:[to_return_type(option['arguments'][idx],";
    "Fxn:get_return_types" -> "Fxn:TYPE_RETURN.get(ret['type'],";
    "Fxn:get_return_types" -> "Fxn:DYNAMIC_TYPE.get(ret['type'],";
    "Fxn:get_return_types" -> "Fxn:Exception("format_return_type")";
    "Fxn:format_return_type" -> "Fxn:"std::tuple<{}>".format(','.join(r['type']";
    "Fxn:format_formal" -> "Fxn:{}'.format(f['type'],";
    "Fxn:formal_with_default" -> "Fxn:format_formal(f)";
    "Fxn:formal_with_default" -> "Fxn:f.get('default')";
    "Fxn:formal_with_default" -> "Fxn:'{}={}'.format(s,";
    "Fxn:get_broadcast_argument" -> "Fxn:argument.get('broadcast'):";
    "Fxn:get_broadcast_actuals" -> "Fxn:{mat1.size(0),mat2.size(1)}"";
    "Fxn:get_broadcast_actuals" -> "Fxn:broadcast_arg['broadcast'].split()[0].split(",")";
    "Fxn:get_broadcast_actuals" -> "Fxn:broadcast_arg['broadcast'].split()[1].split(':')[1].split(',')";
    "Fxn:get_broadcast_actuals" -> "Fxn:'.size('";
    "Fxn:get_broadcast_actuals" -> "Fxn:x.split('.')[1].replace('dim',";
    "Fxn:get_broadcast_actuals" -> "Fxn:','.join(broadcast_dims)";
    "Fxn:emit_nn_body" -> "Fxn:option['api_name'].replace(base_name,";
    "Fxn:emit_nn_body" -> "Fxn:{}({});'.format(fwd_name,";
    "Fxn:emit_nn_body" -> "Fxn:'.join(actuals))";
    "Fxn:emit_nn_body" -> "Fxn:option['api_name'].endswith('_out'):";
    "Fxn:emit_nn_body" -> "Fxn:body.append('Tensor";
    "Fxn:emit_nn_body" -> "Fxn:tensor();'.format(buffer['name']))";
    "Fxn:emit_nn_body" -> "Fxn:arg.get('output')]";
    "Fxn:emit_nn_body" -> "Fxn:arg.get('output')]";
    "Fxn:emit_nn_body" -> "Fxn:body.append('return";
    "Fxn:emit_nn_body" -> "Fxn:std::get<0>({}({}));'.format(fwd_name,";
    "Fxn:emit_nn_body" -> "Fxn:'.join(actuals)))";
    "Fxn:process_option" -> "Fxn:re.search(";
    "Fxn:process_option" -> "Fxn:'(^__i|[^_]_$)',";
    "Fxn:process_option" -> "Fxn:get_formals(option)";
    "Fxn:process_option" -> "Fxn:[format_formal(f)";
    "Fxn:process_option" -> "Fxn:[formal_with_default(f)";
    "Fxn:process_option" -> "Fxn:get_return_types(option)";
    "Fxn:process_option" -> "Fxn:format_return_type(option['returns'])";
    "Fxn:process_option" -> "Fxn:[format_formal(f)";
    "Fxn:process_option" -> "Fxn:[formal_with_default(f)";
    "Fxn:process_option" -> "Fxn:find_dispatch_tensor(formals)";
    "Fxn:process_option" -> "Fxn:get_broadcast_argument(option)";
    "Fxn:process_option" -> "Fxn:nested_dict(option,";
    "Fxn:process_option" -> "Fxn:option.get('cimpls')";
    "Fxn:process_option" -> "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DECLARATION_CONCRETE.substitute(env))";
    "Fxn:process_option" -> "Fxn:emit_nn_body(option)";
    "Fxn:process_option" -> "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DEFINITION_CONCRETE.substitute(";
    "Fxn:process_option" -> "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DECLARATION_ABSTRACT.substitute(env))";
    "Fxn:process_option" -> "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DEFINITION_ABSTRACT.substitute(env))";
    "Fxn:process_option" -> "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DECLARATION_BROADCAST.substitute(env))";
    "Fxn:process_option" -> "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DECLARATION_ABSTRACT.substitute(env))";
    "Fxn:process_option" -> "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DEFINITION_ABSTRACT.substitute(env))";
    "Fxn:process_option" -> "Fxn:get_broadcast_actuals(broadcast_arg,";
    "Fxn:process_option" -> "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:process_option" -> "Fxn:TYPE_METHOD_DEFINITION_BROADCAST.substitute(env))";
    "Fxn:process_option" -> "Fxn:top_env['tensor_method_declarations'].append(";
    "Fxn:process_option" -> "Fxn:TENSOR_METHOD_DECLARATION.substitute(env))";
    "Fxn:process_option" -> "Fxn:top_env['tensor_method_definitions'].append(";
    "Fxn:process_option" -> "Fxn:TENSOR_METHOD_DEFINITION.substitute(env))";
    "Fxn:process_option" -> "Fxn:method_of.append('Tensor')";
    "Fxn:process_option" -> "Fxn:'infer_type({})'.format(dispatch_tensor)";
    "Fxn:process_option" -> "Fxn:top_env['function_declarations'].append(";
    "Fxn:process_option" -> "Fxn:FUNCTION_DECLARATION.substitute(env))";
    "Fxn:process_option" -> "Fxn:top_env['function_definitions'].append(";
    "Fxn:process_option" -> "Fxn:FUNCTION_DEFINITION.substitute(env))";
    "Fxn:process_option" -> "Fxn:method_of.append('namespace')";
    "Fxn:process_option" -> "Fxn:option.get('buffers',";
    "Fxn:process_option" -> "Fxn:output_options.append(OutputDeclaration(";
    "Fxn:insert" -> "Fxn:seen.add(argument['name'])";
    "Fxn:insert" -> "Fxn:argument.get('kwarg_only',";
    "Fxn:insert" -> "Fxn:kwd_args.append(argument)";
    "Fxn:insert" -> "Fxn:pos_args.append(argument)";
    "Fxn:insert" -> "Fxn:insert(argument)";
    "Fxn:add_type_as_dynamic_type" -> "Fxn:[add_type_as_dynamic_type(argument,";
    "Fxn:translate_map" -> "Fxn:argument.get('output',";
    "Fxn:translate_map" -> "Fxn:translate_map(False).get(argument['type'],";
    "Fxn:translate_map" -> "Fxn:translate_map(True).get(argument['type'],";
    "Fxn:translate_map" -> "Fxn:[native_translate_formals(argument,";
    "Fxn:native_get_return_types" -> "Fxn:'std::vector<Tensor>'}.get(t,";
    "Fxn:native_get_return_types" -> "Fxn:option['api_name'].endswith('_out')):";
    "Fxn:native_get_return_types" -> "Fxn:return_types.append(rtype)";
    "Fxn:process_native" -> "Fxn:re.search(";
    "Fxn:process_native" -> "Fxn:'(^__i|[^_]_$)',";
    "Fxn:process_native" -> "Fxn:native_get_formals(option)";
    "Fxn:process_native" -> "Fxn:[format_formal(f)";
    "Fxn:process_native" -> "Fxn:[formal_with_default(f)";
    "Fxn:process_native" -> "Fxn:native_get_return_types(option)";
    "Fxn:process_native" -> "Fxn:format_return_type(option['returns'])";
    "Fxn:process_native" -> "Fxn:[format_formal(f)";
    "Fxn:process_native" -> "Fxn:[formal_with_default(f)";
    "Fxn:find_dispatch_type" -> "Fxn:find_dispatch_tensor(formals)";
    "Fxn:find_dispatch_type" -> "Fxn:find_dispatch_type(formals)";
    "Fxn:find_dispatch_type" -> "Fxn:[format_formal(f)";
    "Fxn:find_dispatch_type" -> "Fxn:[formal_with_default(f)";
    "Fxn:find_dispatch_type" -> "Fxn:nested_dict(option,";
    "Fxn:find_dispatch_type" -> "Fxn:get_broadcast_argument(option)";
    "Fxn:find_dispatch_type" -> "Fxn:Exception("broadcasting";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['type_method_declarations'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:TYPE_METHOD_DECLARATION_CONCRETE.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:TYPE_METHOD_DEFINITION_ABSTRACT.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:TYPE_DEFINITION_BODY_NATIVE.substitute(env)";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['type_method_definitions'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:TYPE_METHOD_DEFINITION_CONCRETE.substitute(";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['native_function_declarations'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:NATIVE_DECLARATION.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:generated_native_functions.append(value)";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['native_function_declarations'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:NATIVE_DECLARATION.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['tensor_method_declarations'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:TENSOR_METHOD_DECLARATION.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['tensor_method_definitions'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:TENSOR_METHOD_DEFINITION.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:method_of.append('Tensor')";
    "Fxn:find_dispatch_type" -> "Fxn:'infer_type({})'.format(dispatch_tensor)";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['function_declarations'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:FUNCTION_DECLARATION.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:top_env['function_definitions'].append(";
    "Fxn:find_dispatch_type" -> "Fxn:FUNCTION_DEFINITION.substitute(env))";
    "Fxn:find_dispatch_type" -> "Fxn:method_of.append('namespace')";
    "Fxn:find_dispatch_type" -> "Fxn:output_options.append(OutputDeclaration(";
    "Fxn:find_dispatch_type" -> "Fxn:process_option(option,";
    "Fxn:find_dispatch_type" -> "Fxn:process_native(option,";
    "Fxn:find_dispatch_type" -> "Fxn:output_declarations.extend(output_options)";
    "Fxn:nullable_argument" -> "Fxn:argument.get('is_nullable',";
    "Fxn:get_argument" -> "Fxn:replace_with_null(argument):";
    "Fxn:get_argument" -> "Fxn:requires_checked_cast(argument):";
    "Fxn:get_argument" -> "Fxn:CHECKED_USE.get(";
    "Fxn:get_argument" -> "Fxn:'{}_').format(argument['name'])";
    "Fxn:get_argument" -> "Fxn:HALF_CONVERSION.substitute(value=checked_use)";
    "Fxn:get_argument" -> "Fxn:nullable_argument(argument):";
    "Fxn:get_argument" -> "Fxn:CHECKED_USE_NULLABLE.substitute(";
    "Fxn:get_argument" -> "Fxn:bool_option_is_string(argument):";
    "Fxn:get_argument" -> "Fxn:'({})";
    "Fxn:get_argument" -> "Fxn:'({})";
    "Fxn:get_argument" -> "Fxn:tpl.format(argument['name'],";
    "Fxn:get_argument" -> "Fxn:bool_option_is_string(argument):";
    "Fxn:get_argument" -> "Fxn:'"{}"'.format(argument['name'])";
    "Fxn:get_argument" -> "Fxn:re.sub(pattern,";
    "Fxn:get_argument" -> "Fxn:CodeTemplate(v).substitute(backend_type_env)";
    "Fxn:get_argument" -> "Fxn:get_argument(option['arguments'][index],";
    "Fxn:get_arguments" -> "Fxn:[get_argument(argument,";
    "Fxn:get_arguments" -> "Fxn:drop_argument(argument,";
    "Fxn:get_zero_dim_dispatch_when_scalar" -> "Fxn:option.get('zero_dim_dispatch_when_scalar',";
    "Fxn:handle_zero_dim" -> "Fxn:get_zero_dim_dispatch_when_scalar(option)";
    "Fxn:handle_zero_dim" -> "Fxn:"Scalar({})".format(arg['name'])";
    "Fxn:handle_zero_dim" -> "Fxn:[ZERO_DIM_CHECK.substitute(env,";
    "Fxn:handle_only_zero_dim" -> "Fxn:option.get('zero_dim_tensor_only',";
    "Fxn:handle_only_zero_dim" -> "Fxn:get_zero_dim_dispatch_when_scalar(option)";
    "Fxn:handle_only_zero_dim" -> "Fxn:[ZERO_DIM_ONLY.substitute(env,";
    "Fxn:handle_sparse" -> "Fxn:"SparseTensor({})".format(arg['name'])";
    "Fxn:handle_sparse" -> "Fxn:[SPARSE_CHECK.substitute(env,";
    "Fxn:allocate_arg" -> "Fxn:CodeTemplate(ALLOC_WRAP[arg['type']]).substitute(env,";
    "Fxn:allocate_arg" -> "Fxn:'{}_'.format(name)";
    "Fxn:allocate_arg" -> "Fxn:arg.get('mask',";
    "Fxn:allocate_arg" -> "Fxn:nullptr'.format(output_count,";
    "Fxn:allocate_arg" -> "Fxn:.format(name,";
    "Fxn:allocate_arg" -> "Fxn:{};'.format(name,";
    "Fxn:allocate_arg" -> "Fxn:Tensor({},";
    "Fxn:allocate_arg" -> "Fxn:false);'.format(name,";
    "Fxn:resize_arg" -> "Fxn:"{}.resize_({}.sizes());".format(arg['name'],";
    "Fxn:resize_arg" -> "Fxn:arg.get('resize_scalar',";
    "Fxn:resize_arg" -> "Fxn:['{}.dim()";
    "Fxn:resize_arg" -> "Fxn:{}.size({})'.format(name,";
    "Fxn:resize_arg" -> "Fxn:['{}.size({})'.format(name,";
    "Fxn:resize_arg" -> "Fxn:"{}.resize_({{";
    "Fxn:resize_arg" -> "Fxn:}});".format(arg['name'],";
    "Fxn:resize_arg" -> "Fxn:','.join(dims))";
    "Fxn:handle_call" -> "Fxn:get_arguments(cimpl['arguments'],";
    "Fxn:handle_call" -> "Fxn:option.get('sparse',";
    "Fxn:handle_call" -> "Fxn:env['THTensor'].replace('TH',";
    "Fxn:handle_call" -> "Fxn:'THNN_{}'.format(env['THType'])";
    "Fxn:handle_call" -> "Fxn:CALL_TEMPLATE.substitute(actuals=actuals,";
    "Fxn:handle_call" -> "Fxn:cimpl.get('condition')";
    "Fxn:handle_call" -> "Fxn:{}'.format(cimpl['condition'],";
    "Fxn:emit_body" -> "Fxn:handle_sparse(env,";
    "Fxn:emit_body" -> "Fxn:handle_zero_dim(env,";
    "Fxn:emit_body" -> "Fxn:handle_only_zero_dim(env,";
    "Fxn:emit_body" -> "Fxn:option.get('scalar_check')";
    "Fxn:emit_body" -> "Fxn:is_real_argument_to_wrapper(arg):";
    "Fxn:emit_body" -> "Fxn:'{}.size()";
    "Fxn:emit_body" -> "Fxn:0'.format(arg['name'])";
    "Fxn:emit_body" -> "Fxn:seen_tensorlists.add(arg['name'])";
    "Fxn:emit_body" -> "Fxn:arg.get('wrap_dim',";
    "Fxn:emit_body" -> "Fxn:body.append("{}";
    "Fxn:emit_body" -> "Fxn:maybe_wrap_dim({},";
    "Fxn:emit_body" -> "Fxn:.format(arg['name'],";
    "Fxn:emit_body" -> "Fxn:requires_checked_cast(arg):";
    "Fxn:emit_body" -> "Fxn:seen_names.add(arg['name'])";
    "Fxn:emit_body" -> "Fxn:arg.get('allocate',";
    "Fxn:emit_body" -> "Fxn:allocate_arg(env,";
    "Fxn:emit_body" -> "Fxn:nullable_argument(arg)";
    "Fxn:emit_body" -> "Fxn:default_init.append(arg['default_init'])";
    "Fxn:emit_body" -> "Fxn:'is_noelem_tensor_size(size)'";
    "Fxn:emit_body" -> "Fxn:CHECKED_CAST[arg['type']].substitute(";
    "Fxn:emit_body" -> "Fxn:size=arg.get('size'),";
    "Fxn:emit_body" -> "Fxn:body.append("auto";
    "Fxn:emit_body" -> "Fxn:{};".format(";
    "Fxn:emit_body" -> "Fxn:drop_argument(arg,";
    "Fxn:emit_body" -> "Fxn:replace_with_null(arg):";
    "Fxn:emit_body" -> "Fxn:body.append(";
    "Fxn:emit_body" -> "Fxn:"(void)";
    "Fxn:emit_body" -> "Fxn:warning".format(arg['name']))";
    "Fxn:emit_body" -> "Fxn:initializers.append(resize_arg(arg))";
    "Fxn:emit_body" -> "Fxn:arg.get('zero',";
    "Fxn:emit_body" -> "Fxn:initializers.append("{}.zero_();".format(arg['name']))";
    "Fxn:emit_body" -> "Fxn:nullable_argument(arg)";
    "Fxn:emit_body" -> "Fxn:body.append(CONDITIONAL_INITIALIZER.substitute({";
    "Fxn:emit_body" -> "Fxn:isScalar()";
    "Fxn:emit_body" -> "Fxn:isScalar()";
    "Fxn:emit_body" -> "Fxn:arg.get('output')";
    "Fxn:emit_body" -> "Fxn:'{}->isScalar()'.format(arg['name']";
    "Fxn:emit_body" -> "Fxn:nullable_argument(arg):";
    "Fxn:emit_body" -> "Fxn:'(!{}";
    "Fxn:emit_body" -> "Fxn:{})'.format(arg['name']";
    "Fxn:emit_body" -> "Fxn:option.get('cimpls',";
    "Fxn:emit_body" -> "Fxn:[handle_call(env,";
    "Fxn:emit_body" -> "Fxn:body.append(CodeTemplate(";
    "Fxn:emit_body" -> "Fxn:option['aten_custom_call']).substitute(env))";
    "Fxn:emit_body" -> "Fxn:body.extend([call";
    "Fxn:emit_body" -> "Fxn:body.append("bool";
    "Fxn:emit_body" -> "Fxn:{};".format(scalar_check))";
    "Fxn:emit_body" -> "Fxn:scalar_check.get(arg['name']))";
    "Fxn:emit_body" -> "Fxn:"{}_->maybeScalar({});".format(arg['name'],";
    "Fxn:emit_body" -> "Fxn:nullable_argument(arg):";
    "Fxn:emit_body" -> "Fxn:{}".format(arg['name'],";
    "Fxn:emit_body" -> "Fxn:body.append(stmt)";
    "Fxn:emit_body" -> "Fxn:body.append("return";
    "Fxn:emit_body" -> "Fxn:{};".format(arg['name']))";
    "Fxn:emit_body" -> "Fxn:[to_return_type(arg,";
    "Fxn:emit_body" -> "Fxn:body.append(CodeTemplate("return";
    "Fxn:emit_body" -> "Fxn:std::tuple<${types}>(${names});").substitute(";
    "Fxn:emit_body" -> "Fxn:body.append(CodeTemplate(";
    "Fxn:emit_body" -> "Fxn:option['aten_custom_call']).substitute(env))";
    "Fxn:emit_body" -> "Fxn:ALLOC_WRAP.keys():";
    "Fxn:emit_body" -> "Fxn:"->maybeScalar({})".format(scalar_check)";
    "Fxn:emit_body" -> "Fxn:CodeTemplate(ALLOC_WRAP[ret['type']]).substitute(";
    "Fxn:emit_body" -> "Fxn:Tensor((${wrapped_tensor})${maybe_scalar},false);"";
    "Fxn:emit_body" -> "Fxn:body.append(CodeTemplate(return_tensor).substitute(";
    "Fxn:emit_body" -> "Fxn:x.sum(0)";
    "Fxn:emit_body" -> "Fxn:x.sum()";
    "Fxn:emit_body" -> "Fxn:scalarTensor(convert<${ScalarType}>(${call}));'";
    "Fxn:emit_body" -> "Fxn:body.append(CodeTemplate(return_scalar).substitute(env,";
    "Fxn:emit_body" -> "Fxn:is_actual_return_long(ret):";
    "Fxn:emit_body" -> "Fxn:"static_cast<int64_t>({})".format(call)";
    "Fxn:emit_body" -> "Fxn:body.append("return";
    "Fxn:emit_body" -> "Fxn:{};".format(call))";
    "Fxn:emit_body" -> "Fxn:Exception("NYI";
    "Fxn:process_option" -> "Fxn:nested_dict(option,";
    "Fxn:process_option" -> "Fxn:emit_body(env,";
    "Fxn:process_option" -> "Fxn:type_object_declarations.append(";
    "Fxn:process_option" -> "Fxn:TYPE_DERIVED_DECLARATION.substitute(env))";
    "Fxn:process_option" -> "Fxn:type_object_definitions.append(";
    "Fxn:process_option" -> "Fxn:TYPE_DERIVED_DEFINITION.substitute(env))";
    "Fxn:process_native" -> "Fxn:nested_dict(option,";
    "Fxn:process_native" -> "Fxn:dispatch.get(pair[0])";
    "Fxn:process_native" -> "Fxn:Exception('could";
    "Fxn:process_native" -> "Fxn:.format(pair[0],";
    "Fxn:process_native" -> "Fxn:type_object_declarations.append(";
    "Fxn:process_native" -> "Fxn:TYPE_DERIVED_DECLARATION.substitute(env))";
    "Fxn:process_native" -> "Fxn:type_object_definitions.append(";
    "Fxn:process_native" -> "Fxn:TYPE_DERIVED_DEFINITION_NATIVE.substitute(env))";
    "Fxn:process_native" -> "Fxn:option.get('skip',";
    "Fxn:process_native" -> "Fxn:option.get('cimpls')";
    "Fxn:process_native" -> "Fxn:process_option(option)";
    "Fxn:process_native" -> "Fxn:process_native(option)";
    "/aten/src/ATen/gen.py" -> "Import:argparse";
    "/aten/src/ATen/gen.py" -> "Import:import";
    "/aten/src/ATen/gen.py" -> "Import:yaml";
    "/aten/src/ATen/gen.py" -> "Import:OrderedDict";
    "/aten/src/ATen/gen.py" -> "Import:cwrap_parser";
    "/aten/src/ATen/gen.py" -> "Import:nn_parse";
    "/aten/src/ATen/gen.py" -> "Import:native_parse";
    "/aten/src/ATen/gen.py" -> "Import:preprocess_declarations";
    "/aten/src/ATen/gen.py" -> "Import:function_wrapper";
    "/aten/src/ATen/gen.py" -> "Import:copy_wrapper";
    "/aten/src/ATen/gen.py" -> "Import:CodeTemplate";
    "/aten/src/ATen/gen.py" -> "class:FileManager(object):";
    "class:FileManager(object):" -> "Fxn:__init__";
    "class:FileManager(object):" -> "Fxn:will_write";
    "class:FileManager(object):" -> "Fxn:_write_if_changed";
    "class:FileManager(object):" -> "Fxn:write_outputs";
    "class:FileManager(object):" -> "Fxn:write";
    "class:FileManager(object):" -> "Fxn:check_all_files_written";
    "class:FileManager(object):" -> "Fxn:dict_representer";
    "class:FileManager(object):" -> "Fxn:postprocess_output_declarations";
    "class:FileManager(object):" -> "Fxn:remove_key_if_none";
    "class:FileManager(object):" -> "Fxn:format_yaml";
    "class:FileManager(object):" -> "Fxn:generate_storage_type_and_tensor";
    "class:FileManager(object):" -> "Fxn:iterate_types";
    "class:FileManager(object):" -> "Fxn:declare_outputs";
    "class:FileManager(object):" -> "Fxn:filter_by_extension";
    "class:FileManager(object):" -> "Fxn:generate_outputs";
    "Fxn:will_write" -> "Fxn:'{}/{}'.format(options.output_dir,";
    "Fxn:will_write" -> "Fxn:Exception("'will_write'";
    "Fxn:will_write" -> "Fxn:self.filenames.add(filename)";
    "Fxn:_write_if_changed" -> "Fxn:f.read()";
    "Fxn:_write_if_changed" -> "Fxn:f.write(contents)";
    "Fxn:write_outputs" -> "Fxn:self._write_if_changed(";
    "Fxn:write_outputs" -> "Fxn:''.join(name";
    "Fxn:write" -> "Fxn:'{}/{}'.format(options.output_dir,";
    "Fxn:write" -> "Fxn:self._write_if_changed(filename,";
    "Fxn:write" -> "Fxn:self.undeclared_files.append(filename)";
    "Fxn:write" -> "Fxn:self.filenames.remove(filename)";
    "Fxn:check_all_files_written" -> "Fxn:Exception(";
    "Fxn:check_all_files_written" -> "Fxn:".format(self.undeclared_files)";
    "Fxn:check_all_files_written" -> "Fxn:Exception("Outputs";
    "Fxn:check_all_files_written" -> "Fxn:{}".format(self.filenames))";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:CodeTemplate.from_file(TEMPLATE_PATH";
    "Fxn:check_all_files_written" -> "Fxn:FileManager()";
    "Fxn:check_all_files_written" -> "Fxn:backends.append('CUDA')";
    "Fxn:dict_representer" -> "Fxn:dumper.represent_dict(data.items())";
    "Fxn:remove_key_if_none" -> "Fxn:dictionary.keys()";
    "Fxn:remove_key_if_none" -> "Fxn:[remove_key_if_none(decl._asdict(),";
    "Fxn:format_yaml" -> "Fxn:noalias_dumper.add_representer(OrderedDict,";
    "Fxn:format_yaml" -> "Fxn:yaml.dump(data,";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:"{}{}Storage".format(backend,";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:"{}{}{}Type".format(density_tag,";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:"{}{}{}Tensor".format(density_tag,";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:"{}{}Tensor".format(backend,";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:"Sparse{}{}Tensor".format(backend,";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:top_env['type_ids'].append(tag";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:'Cuda{}'.format(sname)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:'THCuda{}Storage'.format(sname)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:'THCuda{}Tensor'.format(sname)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:'THCS{}Tensor'.format(scalar_name)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:"TH{}Storage".format(scalar_name)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:'TH{}{}Tensor'.format(th_density_tag,";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:std::runtime_error("CPU";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:function_wrapper.create_derived(";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:file_manager.write(env['Storage']";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:STORAGE_DERIVED_CPP.substitute(env))";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:file_manager.write(env['Storage']";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:STORAGE_DERIVED_H.substitute(env))";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:TENSOR_DENSE_CPP.substitute(env)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:TENSOR_SPARSE_CPP.substitute(env)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:file_manager.write(env['Type']";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:TYPE_DERIVED_CPP.substitute(env))";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:file_manager.write(env['Type']";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:TYPE_DERIVED_H.substitute(env))";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:file_manager.write(env['Tensor']";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:TENSOR_DERIVED_CPP.substitute(env))";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:file_manager.write(env['Tensor']";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:TENSOR_DERIVED_H.substitute(env))";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:'[static_cast<int>(ScalarType::{})].reset(new";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:{}(context));')";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:.format(env['Backend'],";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:top_env['type_registrations'].append(type_register)";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:top_env['type_headers'].append(";
    "Fxn:generate_storage_type_and_tensor" -> "Fxn:"ATen/{}.h"'.format(env['Type']))";
    "Fxn:declare_outputs" -> "Fxn:file_manager.will_write(f)";
    "Fxn:declare_outputs" -> "Fxn:file_manager.will_write(fname)";
    "Fxn:declare_outputs" -> "Fxn:iterate_types():";
    "Fxn:declare_outputs" -> "Fxn:file_manager.will_write("{}{}{}.h".format(full_backend,";
    "Fxn:declare_outputs" -> "Fxn:file_manager.will_write("{}{}{}.cpp".format(full_backend,";
    "Fxn:filter_by_extension" -> "Fxn:file.endswith(extension):";
    "Fxn:filter_by_extension" -> "Fxn:filtered_files.append(file)";
    "Fxn:generate_outputs" -> "Fxn:filter_by_extension(options.files,";
    "Fxn:generate_outputs" -> "Fxn:filter_by_extension(options.files,";
    "Fxn:generate_outputs" -> "Fxn:filter_by_extension(options.files,";
    "Fxn:generate_outputs" -> "Fxn:cwrap_parser.parse(file)]";
    "Fxn:generate_outputs" -> "Fxn:nn_parse.run(nn_files)";
    "Fxn:generate_outputs" -> "Fxn:native_parse.run(native_files)";
    "Fxn:generate_outputs" -> "Fxn:preprocess_declarations.run(declarations)";
    "Fxn:generate_outputs" -> "Fxn:generators.items():";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write(fname,";
    "Fxn:generate_outputs" -> "Fxn:GENERATOR_DERIVED.substitute(env))";
    "Fxn:generate_outputs" -> "Fxn:function_wrapper.create_generic(top_env,";
    "Fxn:generate_outputs" -> "Fxn:postprocess_output_declarations(output_declarations)";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write("Declarations.yaml",";
    "Fxn:generate_outputs" -> "Fxn:format_yaml(output_declarations))";
    "Fxn:generate_outputs" -> "Fxn:iterate_types():";
    "Fxn:generate_outputs" -> "Fxn:all_types.append(generate_storage_type_and_tensor(";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write('Type.h',";
    "Fxn:generate_outputs" -> "Fxn:TYPE_H.substitute(top_env))";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write('Type.cpp',";
    "Fxn:generate_outputs" -> "Fxn:TYPE_CPP.substitute(top_env))";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write('Tensor.h',";
    "Fxn:generate_outputs" -> "Fxn:TENSOR_H.substitute(top_env))";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write('TensorMethods.h',";
    "Fxn:generate_outputs" -> "Fxn:TENSOR_METHODS_H.substitute(top_env))";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write('Functions.h',";
    "Fxn:generate_outputs" -> "Fxn:FUNCTIONS_H.substitute(top_env))";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write('Copy.cpp',";
    "Fxn:generate_outputs" -> "Fxn:copy_wrapper.create(all_types))";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write('NativeFunctions.h',";
    "Fxn:generate_outputs" -> "Fxn:NATIVE_FUNCTIONS_H.substitute(top_env))";
    "Fxn:generate_outputs" -> "Fxn:file_manager.check_all_files_written()";
    "Fxn:generate_outputs" -> "Fxn:declare_outputs()";
    "Fxn:generate_outputs" -> "Fxn:file_manager.write_outputs(options.output_dependencies)";
    "Fxn:generate_outputs" -> "Fxn:generate_outputs()";
    "/aten/src/ATen/native_parse.py" -> "Import:import";
    "/aten/src/ATen/native_parse.py" -> "Import:yaml";
    "/aten/src/ATen/native_parse.py" -> "Import:CLoader";
    "/aten/src/ATen/native_parse.py" -> "Import:Loader";
    "/aten/src/ATen/native_parse.py" -> "Fxn:parse_default";
    "/aten/src/ATen/native_parse.py" -> "Fxn:sanitize_types";
    "/aten/src/ATen/native_parse.py" -> "Fxn:parse_arguments";
    "/aten/src/ATen/native_parse.py" -> "Fxn:has_sparse_dispatches";
    "/aten/src/ATen/native_parse.py" -> "Fxn:parse_native_yaml";
    "/aten/src/ATen/native_parse.py" -> "Fxn:run";
    "/aten/src/ATen/nn_parse.py" -> "Import:copy";
    "/aten/src/ATen/nn_parse.py" -> "Import:import";
    "/aten/src/ATen/nn_parse.py" -> "Import:common_with_cwrap";
    "/aten/src/ATen/nn_parse.py" -> "Import:yaml";
    "/aten/src/ATen/nn_parse.py" -> "Import:OrderedDict,";
    "/aten/src/ATen/nn_parse.py" -> "Import:CLoader";
    "/aten/src/ATen/nn_parse.py" -> "Import:Loader";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:argument_to_declaration";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:output_arguments";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:map_to_th_type";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:is_output_arg";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:get_return";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:camel_to_snake";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:get_thnn_args";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:arg_expr";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:remove_unused_args";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:clean_name";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:unique_args";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:function_info";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:base_declaration";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:forward_declaration";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:backward_declaration";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:initialize_output_arg";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:get_condition";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:parse_nn_yaml";
    "/aten/src/ATen/nn_parse.py" -> "Fxn:run";
    "/aten/src/ATen/preprocess_declarations.py" -> "Import:copy";
    "/aten/src/ATen/preprocess_declarations.py" -> "Import:deepcopy";
    "/aten/src/ATen/preprocess_declarations.py" -> "Import:TYPE_FORMAL_GENERIC";
    "/aten/src/ATen/preprocess_declarations.py" -> "Import:common_with_cwrap";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:process_types_and_backends";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:expand";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:exclude";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:add_variants";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:handle_outputs_taken_as_arguments";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:is_nullable";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:should_generate_out_variant";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:sanitize_return";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:set_mode";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:discover_zero_dim_tensor_operations";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:exclude";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:signature";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:discover_sparse_tensor_operations";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:exclude";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:signature";
    "/aten/src/ATen/preprocess_declarations.py" -> "Fxn:run";
    "/docs/source/conf.py" -> "Import:import";
    "/docs/source/conf.py" -> "Import:sys";
    "/docs/source/conf.py" -> "Import:torch";
    "/docs/source/conf.py" -> "Import:torchvision";
    "/docs/source/conf.py" -> "Import:warnings";
    "/docs/source/conf.py" -> "Import:sphinx_rtd_theme";
    "/docs/source/conf.py" -> "Import:nodes";
    "/docs/source/conf.py" -> "Import:TypedField";
    "/docs/source/conf.py" -> "Import:addnodes";
    "/docs/source/conf.py" -> "Fxn:patched_make_field";
    "/docs/source/conf.py" -> "Fxn:handle_item";
    "/docs/source/scripts/build_activation_images.py" -> "Import:os.path";
    "/docs/source/scripts/build_activation_images.py" -> "Import:torch.nn.modules.activation";
    "/docs/source/scripts/build_activation_images.py" -> "Import:torch.autograd";
    "/docs/source/scripts/build_activation_images.py" -> "Import:matplotlib";
    "/docs/source/scripts/build_activation_images.py" -> "Import:pylab";
    "/docs/source/scripts/build_activation_images.py" -> "Fxn:plot_function";
    "/test/common.py" -> "Import:sys";
    "/test/common.py" -> "Import:import";
    "/test/common.py" -> "Import:import";
    "/test/common.py" -> "Import:argparse";
    "/test/common.py" -> "Import:unittest";
    "/test/common.py" -> "Import:warnings";
    "/test/common.py" -> "Import:random";
    "/test/common.py" -> "Import:contextlib";
    "/test/common.py" -> "Import:wraps";
    "/test/common.py" -> "Import:product";
    "/test/common.py" -> "Import:deepcopy";
    "/test/common.py" -> "Import:Number";
    "/test/common.py" -> "Import:__main__";
    "/test/common.py" -> "Import:errno";
    "/test/common.py" -> "Import:torch";
    "/test/common.py" -> "Import:torch.cuda";
    "/test/common.py" -> "Import:Variable";
    "/test/common.py" -> "Import:string_classes";
    "/test/common.py" -> "Import:torch.backends.cudnn";
    "/test/common.py" -> "Fxn:run_tests";
    "/test/common.py" -> "Import:numpy";
    "/test/common.py" -> "Import:scipy";
    "/test/common.py" -> "Fxn:skipIfNoLapack";
    "/test/common.py" -> "Fxn:wrapper";
    "/test/common.py" -> "Fxn:suppress_warnings";
    "/test/common.py" -> "Fxn:wrapper";
    "/test/common.py" -> "Fxn:get_cpu_type";
    "/test/common.py" -> "Fxn:get_gpu_type";
    "/test/common.py" -> "Fxn:to_gpu";
    "/test/common.py" -> "Fxn:set_rng_seed";
    "/test/common.py" -> "Fxn:freeze_rng_state";
    "/test/common.py" -> "Fxn:iter_indices";
    "/test/common.py" -> "Fxn:is_iterable";
    "/test/common.py" -> "class:TestCase(unittest.TestCase):";
    "/test/common.py" -> "Import:urlsplit";
    "/test/common.py" -> "Import:urllib2";
    "/test/common.py" -> "Import:urlsplit";
    "/test/common.py" -> "Import:request,";
    "class:TestCase(unittest.TestCase):" -> "Fxn:setUp";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertTensorsSlowEqual";
    "class:TestCase(unittest.TestCase):" -> "Fxn:safeToDense";
    "class:TestCase(unittest.TestCase):" -> "Fxn:safeCoalesce";
    "class:TestCase(unittest.TestCase):" -> "Fxn:unwrapVariables";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertEqual";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertTensorsEqual";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertAlmostEqual";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertNotEqual";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertObjectIn";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertExpectedRaises";
    "class:TestCase(unittest.TestCase):" -> "Fxn:assertExpected";
    "class:TestCase(unittest.TestCase):" -> "Fxn:remove_prefix";
    "class:TestCase(unittest.TestCase):" -> "Fxn:accept_output";
    "class:TestCase(unittest.TestCase):" -> "Fxn:download_file";
    "Fxn:setUp" -> "Fxn:set_rng_seed(SEED)";
    "Fxn:assertTensorsSlowEqual" -> "Fxn:self.assertEqual(x.size(),";
    "Fxn:assertTensorsSlowEqual" -> "Fxn:y.size())";
    "Fxn:assertTensorsSlowEqual" -> "Fxn:iter_indices(x):";
    "Fxn:assertTensorsSlowEqual" -> "Fxn:self.assertLessEqual(max_err,";
    "Fxn:safeToDense" -> "Fxn:self.safeCoalesce(t)";
    "Fxn:safeToDense" -> "Fxn:r.to_dense()";
    "Fxn:safeCoalesce" -> "Fxn:t.coalesce()";
    "Fxn:safeCoalesce" -> "Fxn:self.assertEqual(tc.to_dense(),";
    "Fxn:safeCoalesce" -> "Fxn:t.to_dense())";
    "Fxn:safeCoalesce" -> "Fxn:self.assertTrue(tc.is_coalesced())";
    "Fxn:safeCoalesce" -> "Fxn:t._nnz()";
    "Fxn:safeCoalesce" -> "Fxn:self.assertEqual(t._indices(),";
    "Fxn:safeCoalesce" -> "Fxn:tc._indices())";
    "Fxn:safeCoalesce" -> "Fxn:self.assertEqual(t._values(),";
    "Fxn:safeCoalesce" -> "Fxn:tc._values())";
    "Fxn:safeCoalesce" -> "Fxn:t._values()):";
    "Fxn:safeCoalesce" -> "Fxn:val.clone()";
    "Fxn:safeCoalesce" -> "Fxn:torch.is_tensor(val)";
    "Fxn:safeCoalesce" -> "Fxn:t._values().ndimension()";
    "Fxn:safeCoalesce" -> "Fxn:t._values().new(new_values)";
    "Fxn:safeCoalesce" -> "Fxn:torch.stack(new_values)";
    "Fxn:safeCoalesce" -> "Fxn:t._indices().new(new_indices).t()";
    "Fxn:safeCoalesce" -> "Fxn:t.new(new_indices,";
    "Fxn:safeCoalesce" -> "Fxn:t.size())";
    "Fxn:safeCoalesce" -> "Fxn:self.assertEqual(tc._indices(),";
    "Fxn:safeCoalesce" -> "Fxn:tg._indices())";
    "Fxn:safeCoalesce" -> "Fxn:self.assertEqual(tc._values(),";
    "Fxn:safeCoalesce" -> "Fxn:tg._values())";
    "Fxn:safeCoalesce" -> "Fxn:t.is_coalesced():";
    "Fxn:safeCoalesce" -> "Fxn:self.assertEqual(tc._indices(),";
    "Fxn:safeCoalesce" -> "Fxn:t._indices())";
    "Fxn:safeCoalesce" -> "Fxn:self.assertEqual(tc._values(),";
    "Fxn:safeCoalesce" -> "Fxn:t._values())";
    "Fxn:assertEqual" -> "Fxn:self.unwrapVariables(x,";
    "Fxn:assertEqual" -> "Fxn:self.assertEqual(x.item(),";
    "Fxn:assertEqual" -> "Fxn:self.assertEqual(x,";
    "Fxn:assertEqual" -> "Fxn:y.item(),";
    "Fxn:assertEqual" -> "Fxn:torch.is_tensor(x)";
    "Fxn:assertEqual" -> "Fxn:torch.is_tensor(y):";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(a.size(),";
    "Fxn:assertTensorsEqual" -> "Fxn:b.size(),";
    "Fxn:assertTensorsEqual" -> "Fxn:a.numel()";
    "Fxn:assertTensorsEqual" -> "Fxn:b.type_as(a)";
    "Fxn:assertTensorsEqual" -> "Fxn:b.cuda(device=a.get_device())";
    "Fxn:assertTensorsEqual" -> "Fxn:b.cpu()";
    "Fxn:assertTensorsEqual" -> "Fxn:self.assertTrue(torch.equal(nan_mask,";
    "Fxn:assertTensorsEqual" -> "Fxn:diff.is_signed()";
    "Fxn:assertTensorsEqual" -> "Fxn:diff.type():";
    "Fxn:assertTensorsEqual" -> "Fxn:diff.abs()";
    "Fxn:assertTensorsEqual" -> "Fxn:diff.max()";
    "Fxn:assertTensorsEqual" -> "Fxn:self.assertLessEqual(max_err,";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(x.is_sparse,";
    "Fxn:assertTensorsEqual" -> "Fxn:self.safeCoalesce(x)";
    "Fxn:assertTensorsEqual" -> "Fxn:self.safeCoalesce(y)";
    "Fxn:assertTensorsEqual" -> "Fxn:assertTensorsEqual(x._indices(),";
    "Fxn:assertTensorsEqual" -> "Fxn:y._indices())";
    "Fxn:assertTensorsEqual" -> "Fxn:assertTensorsEqual(x._values(),";
    "Fxn:assertTensorsEqual" -> "Fxn:y._values())";
    "Fxn:assertTensorsEqual" -> "Fxn:assertTensorsEqual(x,";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(x,";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(x,";
    "Fxn:assertTensorsEqual" -> "Fxn:is_iterable(x)";
    "Fxn:assertTensorsEqual" -> "Fxn:is_iterable(y):";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(len(x),";
    "Fxn:assertTensorsEqual" -> "Fxn:self.assertEqual(x_,";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(x,";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(x,";
    "Fxn:assertTensorsEqual" -> "Fxn:self.fail("Expected";
    "Fxn:assertTensorsEqual" -> "Fxn:y={}".format(x,";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertLessEqual(abs(x";
    "Fxn:assertTensorsEqual" -> "Fxn:self).assertEqual(x,";
    "Fxn:assertAlmostEqual" -> "Fxn:10**(-places)";
    "Fxn:assertAlmostEqual" -> "Fxn:self.assertEqual(x,";
    "Fxn:assertNotEqual" -> "Fxn:self.unwrapVariables(x,";
    "Fxn:assertNotEqual" -> "Fxn:torch.is_tensor(x)";
    "Fxn:assertNotEqual" -> "Fxn:torch.is_tensor(y):";
    "Fxn:assertNotEqual" -> "Fxn:x.size()";
    "Fxn:assertNotEqual" -> "Fxn:y.size():";
    "Fxn:assertNotEqual" -> "Fxn:self).assertNotEqual(x.size(),";
    "Fxn:assertNotEqual" -> "Fxn:y.size())";
    "Fxn:assertNotEqual" -> "Fxn:self.assertGreater(x.numel(),";
    "Fxn:assertNotEqual" -> "Fxn:y.type_as(x)";
    "Fxn:assertNotEqual" -> "Fxn:y.cuda(device=x.get_device())";
    "Fxn:assertNotEqual" -> "Fxn:y.cpu()";
    "Fxn:assertNotEqual" -> "Fxn:torch.equal(nan_mask,";
    "Fxn:assertNotEqual" -> "Fxn:diff.is_signed():";
    "Fxn:assertNotEqual" -> "Fxn:diff.abs()";
    "Fxn:assertNotEqual" -> "Fxn:diff.max()";
    "Fxn:assertNotEqual" -> "Fxn:self.assertGreaterEqual(max_err,";
    "Fxn:assertNotEqual" -> "Fxn:self).assertNotEqual(x,";
    "Fxn:assertNotEqual" -> "Fxn:is_iterable(x)";
    "Fxn:assertNotEqual" -> "Fxn:is_iterable(y):";
    "Fxn:assertNotEqual" -> "Fxn:self).assertNotEqual(x,";
    "Fxn:assertNotEqual" -> "Fxn:self.assertGreaterEqual(abs(x";
    "Fxn:assertNotEqual" -> "Fxn:self).assertNotEqual(x,";
    "Fxn:assertObjectIn" -> "Fxn:AssertionError("object";
    "Fxn:assertExpectedRaises" -> "Fxn:self.assertExpected(str(e),";
    "Fxn:assertExpectedRaises" -> "Fxn:self.fail(msg="Did";
    "Fxn:assertExpected" -> "Fxn:TypeError("assertExpected";
    "Fxn:remove_prefix" -> "Fxn:text.startswith(prefix):";
    "Fxn:remove_prefix" -> "Fxn:text[len(prefix):]";
    "Fxn:remove_prefix" -> "Fxn:remove_prefix(self.id(),";
    "Fxn:remove_prefix" -> "Fxn:os.path.realpath(sys.modules[module_id].__file__)";
    "Fxn:remove_prefix" -> "Fxn:os.path.join(os.path.dirname(test_file),";
    "Fxn:accept_output" -> "Fxn:{}:\n\n{}".format(update_type,";
    "Fxn:accept_output" -> "Fxn:f.write(s)";
    "Fxn:accept_output" -> "Fxn:f.read()";
    "Fxn:accept_output" -> "Fxn:accept_output("output")";
    "Fxn:accept_output" -> "Fxn:RuntimeError(";
    "Fxn:accept_output" -> "Fxn:--accept").format(munged_id,";
    "Fxn:accept_output" -> "Fxn:re.sub(r'CppOp\[(.+?)\]',";
    "Fxn:accept_output" -> "Fxn:re.sub(r'CppOp\[(.+?)\]',";
    "Fxn:accept_output" -> "Fxn:accept_output("updated";
    "Fxn:accept_output" -> "Fxn:self.assertMultiLineEqual(expected,";
    "Fxn:accept_output" -> "Fxn:self.assertEqual(s,";
    "Fxn:download_file" -> "Fxn:os.path.basename(urlsplit(url)[2])";
    "Fxn:download_file" -> "Fxn:os.path.join(os.path.dirname(__file__),";
    "Fxn:download_file" -> "Fxn:os.path.join(data_dir,";
    "Fxn:download_file" -> "Fxn:os.path.exists(path):";
    "Fxn:download_file" -> "Fxn:request.urlopen(url,";
    "Fxn:download_file" -> "Fxn:timeout=15).read()";
    "Fxn:download_file" -> "Fxn:f.write(data)";
    "Fxn:download_file" -> "Fxn:'{}'".format(url)";
    "Fxn:download_file" -> "Fxn:warnings.warn(msg,";
    "Fxn:download_file" -> "Fxn:unittest.SkipTest(msg)";
    "/test/common_nn.py" -> "Import:sys";
    "/test/common_nn.py" -> "Import:tempfile";
    "/test/common_nn.py" -> "Import:unittest";
    "/test/common_nn.py" -> "Import:deepcopy";
    "/test/common_nn.py" -> "Import:product";
    "/test/common_nn.py" -> "Import:torch";
    "/test/common_nn.py" -> "Import:torch.cuda";
    "/test/common_nn.py" -> "Import:Variable";
    "/test/common_nn.py" -> "Import:TestCase,";
    "/test/common_nn.py" -> "Import:get_numerical_jacobian,";
    "/test/common_nn.py" -> "Import:torch.backends.cudnn";
    "/test/common_nn.py" -> "Fxn:get_size_average";
    "/test/common_nn.py" -> "Fxn:get_weight";
    "/test/common_nn.py" -> "Fxn:kldivloss_reference";
    "/test/common_nn.py" -> "Fxn:nlllossNd_reference";
    "/test/common_nn.py" -> "Fxn:nllloss_reference";
    "/test/common_nn.py" -> "Fxn:nll_loss_helper";
    "/test/common_nn.py" -> "Fxn:smoothl1loss_reference";
    "/test/common_nn.py" -> "Fxn:_multilabelmarginloss_reference";
    "/test/common_nn.py" -> "Fxn:multilabelmarginloss_reference";
    "/test/common_nn.py" -> "Fxn:hingeembeddingloss_reference";
    "/test/common_nn.py" -> "Fxn:softmarginloss_reference";
    "/test/common_nn.py" -> "Fxn:_multimarginloss_reference";
    "/test/common_nn.py" -> "Fxn:multimarginloss_reference";
    "/test/common_nn.py" -> "Fxn:cosineembeddingloss_reference";
    "/test/common_nn.py" -> "Fxn:_cos";
    "/test/common_nn.py" -> "class:NNTestCase(TestCase):";
    "/test/common_nn.py" -> "class:TestBase(object):";
    "/test/common_nn.py" -> "class:ModuleTest(TestBase):";
    "/test/common_nn.py" -> "class:CriterionTest(TestBase):";
    "class:NNTestCase(TestCase):" -> "Fxn:_jacobian";
    "class:NNTestCase(TestCase):" -> "Fxn:_flatten_tensors";
    "class:NNTestCase(TestCase):" -> "Fxn:_zero_grad_input";
    "class:NNTestCase(TestCase):" -> "Fxn:_analytical_jacobian";
    "class:NNTestCase(TestCase):" -> "Fxn:_numerical_jacobian";
    "class:NNTestCase(TestCase):" -> "Fxn:fw";
    "class:NNTestCase(TestCase):" -> "Fxn:check_jacobian";
    "class:NNTestCase(TestCase):" -> "Fxn:check_criterion_jacobian";
    "Fxn:_jacobian" -> "Fxn:[self._jacobian(elem,";
    "Fxn:_jacobian" -> "Fxn:torch.zeros(input.nelement(),";
    "Fxn:_flatten_tensors" -> "Fxn:torch.is_tensor(x):";
    "Fxn:_flatten_tensors" -> "Fxn:x.to_dense().view(-1)";
    "Fxn:_flatten_tensors" -> "Fxn:x.view(-1)";
    "Fxn:_flatten_tensors" -> "Fxn:self._flatten_tensors(x.data)";
    "Fxn:_zero_grad_input" -> "Fxn:input.grad.data.zero_()";
    "Fxn:_zero_grad_input" -> "Fxn:input.grad.detach_()";
    "Fxn:_zero_grad_input" -> "Fxn:torch.is_tensor(input):";
    "Fxn:_zero_grad_input" -> "Fxn:self._zero_grad_input(i)";
    "Fxn:_analytical_jacobian" -> "Fxn:self._forward(module,";
    "Fxn:_analytical_jacobian" -> "Fxn:output.nelement()";
    "Fxn:_analytical_jacobian" -> "Fxn:self._jacobian(input,";
    "Fxn:_analytical_jacobian" -> "Fxn:self._get_parameters(module)[0])";
    "Fxn:_analytical_jacobian" -> "Fxn:torch.zeros(num_param,";
    "Fxn:_analytical_jacobian" -> "Fxn:self._get_parameters(module)";
    "Fxn:_analytical_jacobian" -> "Fxn:torch.zeros_like(output)";
    "Fxn:_analytical_jacobian" -> "Fxn:d_out.view(-1)";
    "Fxn:_analytical_jacobian" -> "Fxn:self._zero_grad_parameters(module)";
    "Fxn:_analytical_jacobian" -> "Fxn:self._zero_grad_input(input)";
    "Fxn:_analytical_jacobian" -> "Fxn:self._backward(module,";
    "Fxn:_analytical_jacobian" -> "Fxn:iter_tensors(d_input)):";
    "Fxn:_analytical_jacobian" -> "Fxn:d_x.contiguous().view(-1)";
    "Fxn:_analytical_jacobian" -> "Fxn:torch.cat(self._flatten_tensors(d_param),";
    "Fxn:fw" -> "Fxn:self._forward(module,";
    "Fxn:fw" -> "Fxn:contiguous(input)";
    "Fxn:fw" -> "Fxn:get_numerical_jacobian(fw,";
    "Fxn:fw" -> "Fxn:self._get_parameters(module)";
    "Fxn:fw" -> "Fxn:torch.cat([get_numerical_jacobian(fw,";
    "Fxn:check_jacobian" -> "Fxn:self._analytical_jacobian(module,";
    "Fxn:check_jacobian" -> "Fxn:self._numerical_jacobian(module,";
    "Fxn:check_jacobian" -> "Fxn:self.assertLessEqual(";
    "Fxn:check_jacobian" -> "Fxn:n).abs().max()";
    "Fxn:check_criterion_jacobian" -> "Fxn:self._forward_criterion(criterion,";
    "Fxn:check_criterion_jacobian" -> "Fxn:self._backward_criterion(criterion,";
    "Fxn:check_criterion_jacobian" -> "Fxn:deepcopy(analytical_d_x)";
    "Fxn:check_criterion_jacobian" -> "Fxn:iter_tensors(input)";
    "Fxn:check_criterion_jacobian" -> "Fxn:iter_tensors(numerical_d_x)";
    "Fxn:check_criterion_jacobian" -> "Fxn:x.view(-1)";
    "Fxn:check_criterion_jacobian" -> "Fxn:d_x.view(-1)";
    "Fxn:check_criterion_jacobian" -> "Fxn:x[i].item()";
    "Fxn:check_criterion_jacobian" -> "Fxn:self._forward_criterion(criterion,";
    "Fxn:check_criterion_jacobian" -> "Fxn:self._forward_criterion(criterion,";
    "Fxn:check_criterion_jacobian" -> "Fxn:self.assertLessEqual(";
    "Fxn:check_criterion_jacobian" -> "Fxn:n).abs().max()";
    "class:TestBase(object):" -> "Fxn:__init__";
    "class:TestBase(object):" -> "Fxn:get_name";
    "class:TestBase(object):" -> "Fxn:_unpack";
    "class:TestBase(object):" -> "Fxn:constructor_args";
    "class:TestBase(object):" -> "Fxn:_get_arg";
    "class:TestBase(object):" -> "Fxn:convert_tensors_to_vars";
    "class:TestBase(object):" -> "Fxn:tensor_to_var";
    "class:TestBase(object):" -> "Fxn:map_tensor_sizes";
    "class:TestBase(object):" -> "Fxn:_get_input";
    "class:TestBase(object):" -> "Fxn:__call__";
    "Fxn:__init__" -> "Fxn:ValueError("{}:";
    "Fxn:__init__" -> "Fxn:.format(self.get_name(),";
    "Fxn:_unpack" -> "Fxn:torch.is_tensor(value):";
    "Fxn:_unpack" -> "Fxn:is_iterable(value):";
    "Fxn:constructor_args" -> "Fxn:self._get_arg('constructor_args',";
    "Fxn:tensor_to_var" -> "Fxn:Variable(t)";
    "Fxn:tensor_to_var" -> "Fxn:torch.is_tensor(t)";
    "Fxn:tensor_to_var" -> "Fxn:tensor_to_var(args)";
    "Fxn:tensor_to_var" -> "Fxn:convert_tensors_to_vars(self._extra_kwargs[name])";
    "Fxn:tensor_to_var" -> "Fxn:convert_tensors_to_vars(self._extra_kwargs[fn_name]())";
    "Fxn:map_tensor_sizes" -> "Fxn:[map_tensor_sizes(s)";
    "Fxn:map_tensor_sizes" -> "Fxn:torch.is_tensor(sizes):";
    "Fxn:map_tensor_sizes" -> "Fxn:Variable(sizes.double())";
    "Fxn:map_tensor_sizes" -> "Fxn:torch.randn(sizes)";
    "Fxn:map_tensor_sizes" -> "Fxn:map_tensor_sizes(self._extra_kwargs[size_name])";
    "Fxn:map_tensor_sizes" -> "Fxn:self._unpack(self._arg_cache[name])";
    "Fxn:_get_input" -> "Fxn:self._get_arg('input',";
    "class:ModuleTest(TestBase):" -> "Fxn:__init__";
    "class:ModuleTest(TestBase):" -> "Fxn:__call__";
    "class:ModuleTest(TestBase):" -> "Fxn:noncontiguize";
    "class:ModuleTest(TestBase):" -> "Fxn:test_noncontig";
    "class:ModuleTest(TestBase):" -> "Fxn:test_cuda";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__init__" -> "Fxn:kwargs.get('jacobian_input',";
    "Fxn:__init__" -> "Fxn:kwargs.get('test_cuda',";
    "Fxn:__init__" -> "Fxn:kwargs.get('pickle',";
    "Fxn:__init__" -> "Fxn:kwargs.get('check_gradgrad',";
    "Fxn:__init__" -> "Fxn:kwargs.get('FIXME_no_cuda_gradgrad_comparison',";
    "Fxn:__init__" -> "Fxn:kwargs.get('precision',";
    "Fxn:__call__" -> "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:__call__" -> "Fxn:self._get_input()";
    "Fxn:__call__" -> "Fxn:test_case._forward(module,";
    "Fxn:__call__" -> "Fxn:deepcopy(input)";
    "Fxn:__call__" -> "Fxn:self.reference_fn(ref_input,";
    "Fxn:__call__" -> "Fxn:test_case._get_parameters(module)[0])";
    "Fxn:__call__" -> "Fxn:test_case.assertEqual(out,";
    "Fxn:__call__" -> "Fxn:self.test_noncontig(test_case,";
    "Fxn:__call__" -> "Fxn:TemporaryFile()";
    "Fxn:__call__" -> "Fxn:test_case._forward(module,";
    "Fxn:__call__" -> "Fxn:torch.save(module,";
    "Fxn:__call__" -> "Fxn:f.seek(0)";
    "Fxn:__call__" -> "Fxn:torch.load(f)";
    "Fxn:__call__" -> "Fxn:test_case.assertEqual(test_case._forward(module,";
    "Fxn:__call__" -> "Fxn:test_case._forward(module_copy,";
    "Fxn:__call__" -> "Fxn:self._do_test(test_case,";
    "Fxn:noncontiguize" -> "Fxn:[self.noncontiguize(o)";
    "Fxn:noncontiguize" -> "Fxn:tensor.dim()";
    "Fxn:noncontiguize" -> "Fxn:torch.stack([tensor.clone().zero_(),";
    "Fxn:noncontiguize" -> "Fxn:ndim).select(ndim,";
    "Fxn:noncontiguize" -> "Fxn:noncontig.numel()";
    "Fxn:noncontiguize" -> "Fxn:noncontig.is_contiguous()";
    "Fxn:noncontiguize" -> "Fxn:Variable(noncontig,";
    "Fxn:test_noncontig" -> "Fxn:input.dim()";
    "Fxn:test_noncontig" -> "Fxn:test_case._zero_grad_parameters(module)";
    "Fxn:test_noncontig" -> "Fxn:test_case._zero_grad_input(input)";
    "Fxn:test_noncontig" -> "Fxn:freeze_rng_state():";
    "Fxn:test_noncontig" -> "Fxn:test_case._forward(module,";
    "Fxn:test_noncontig" -> "Fxn:output.new(output.shape).normal_()";
    "Fxn:test_noncontig" -> "Fxn:output.clone()";
    "Fxn:test_noncontig" -> "Fxn:deepcopy(test_case._backward(module,";
    "Fxn:test_noncontig" -> "Fxn:deepcopy(test_case._get_parameters(module)[1])";
    "Fxn:test_noncontig" -> "Fxn:self.noncontiguize(input)";
    "Fxn:test_noncontig" -> "Fxn:self.noncontiguize(grad_output)";
    "Fxn:test_noncontig" -> "Fxn:product((True,";
    "Fxn:test_noncontig" -> "Fxn:test_case._zero_grad_parameters(module)";
    "Fxn:test_noncontig" -> "Fxn:test_case._zero_grad_input(i)";
    "Fxn:test_noncontig" -> "Fxn:freeze_rng_state():";
    "Fxn:test_noncontig" -> "Fxn:test_case._forward(module,";
    "Fxn:test_noncontig" -> "Fxn:test_case._backward(module,";
    "Fxn:test_noncontig" -> "Fxn:test_case.assertEqual(out,";
    "Fxn:test_noncontig" -> "Fxn:test_case.assertEqual(grad,";
    "Fxn:test_noncontig" -> "Fxn:test_case.assertEqual(test_case._get_parameters(module)[1],";
    "Fxn:test_cuda" -> "Fxn:unittest.SkipTest('Excluded";
    "Fxn:test_cuda" -> "Fxn:self._get_input()";
    "Fxn:test_cuda" -> "Fxn:to_gpu(cpu_input,";
    "Fxn:test_cuda" -> "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:test_cuda" -> "Fxn:self.constructor(*self.constructor_args).float().cuda()";
    "Fxn:test_cuda" -> "Fxn:test_case._get_parameters(cpu_module)";
    "Fxn:test_cuda" -> "Fxn:test_case._get_parameters(gpu_module)";
    "Fxn:test_cuda" -> "Fxn:gpu_p.copy_(cpu_p)";
    "Fxn:test_cuda" -> "Fxn:test_case._zero_grad_input(cpu_input)";
    "Fxn:test_cuda" -> "Fxn:test_case._zero_grad_input(gpu_input)";
    "Fxn:test_cuda" -> "Fxn:test_case._zero_grad_parameters(cpu_module)";
    "Fxn:test_cuda" -> "Fxn:test_case._zero_grad_parameters(gpu_module)";
    "Fxn:test_cuda" -> "Fxn:test_case._forward(cpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case._forward(gpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_output,";
    "Fxn:test_cuda" -> "Fxn:cpu_output.clone().normal_()";
    "Fxn:test_cuda" -> "Fxn:cpu_gradOutput.type('torch.cuda.FloatTensor')";
    "Fxn:test_cuda" -> "Fxn:test_case._backward(cpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case._backward(gpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_gradInput,";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_d_p,";
    "Fxn:test_cuda" -> "Fxn:cpu_module(cpu_input)";
    "Fxn:test_cuda" -> "Fxn:gpu_module(gpu_input)";
    "Fxn:test_cuda" -> "Fxn:Variable(cpu_output.data.clone().normal_(),";
    "Fxn:test_cuda" -> "Fxn:Variable(cpu_gradOutput.data.type_as(gpu_output),";
    "Fxn:test_cuda" -> "Fxn:torch.autograd.grad(";
    "Fxn:test_cuda" -> "Fxn:torch.autograd.grad(";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_d_i,";
    "Fxn:test_cuda" -> "Fxn:torch.autograd.grad(";
    "Fxn:test_cuda" -> "Fxn:cpu_output.sum()";
    "Fxn:test_cuda" -> "Fxn:x.sum(),";
    "Fxn:test_cuda" -> "Fxn:torch.autograd.grad(";
    "Fxn:test_cuda" -> "Fxn:gpu_output.sum()";
    "Fxn:test_cuda" -> "Fxn:x.sum(),";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_gradInput,";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_d_p,";
    "Fxn:test_cuda" -> "Fxn:self.test_noncontig(test_case,";
    "class:CriterionTest(TestBase):" -> "Fxn:__init__";
    "class:CriterionTest(TestBase):" -> "Fxn:_get_target";
    "class:CriterionTest(TestBase):" -> "Fxn:__call__";
    "class:CriterionTest(TestBase):" -> "Fxn:test_cuda";
    "class:CriterionTest(TestBase):" -> "Fxn:_do_extra_tests";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__init__" -> "Fxn:kwargs.get('test_cuda',";
    "Fxn:_get_target" -> "Fxn:self._get_arg('target',";
    "Fxn:__call__" -> "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:__call__" -> "Fxn:self._get_input()";
    "Fxn:__call__" -> "Fxn:module.__repr__()";
    "Fxn:__call__" -> "Fxn:self._get_target()";
    "Fxn:__call__" -> "Fxn:test_case._forward_criterion(module,";
    "Fxn:__call__" -> "Fxn:self.reference_fn(deepcopy(input),";
    "Fxn:__call__" -> "Fxn:deepcopy(target),";
    "Fxn:__call__" -> "Fxn:expected_out.item()";
    "Fxn:__call__" -> "Fxn:test_case.assertEqual(out,";
    "Fxn:__call__" -> "Fxn:test_case.check_criterion_jacobian(module,";
    "Fxn:__call__" -> "Fxn:self._do_extra_tests(test_case,";
    "Fxn:test_cuda" -> "Fxn:unittest.SkipTest('Excluded";
    "Fxn:test_cuda" -> "Fxn:self._get_input()";
    "Fxn:test_cuda" -> "Fxn:to_gpu(cpu_input,";
    "Fxn:test_cuda" -> "Fxn:self._get_target()";
    "Fxn:test_cuda" -> "Fxn:to_gpu(cpu_target,";
    "Fxn:test_cuda" -> "Fxn:self.constructor(*self.constructor_args)";
    "Fxn:test_cuda" -> "Fxn:self.constructor(*self.constructor_args).float().cuda()";
    "Fxn:test_cuda" -> "Fxn:test_case._forward_criterion(cpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case._forward_criterion(gpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_output,";
    "Fxn:test_cuda" -> "Fxn:test_case._backward_criterion(cpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case._backward_criterion(gpu_module,";
    "Fxn:test_cuda" -> "Fxn:test_case.assertEqual(cpu_gradInput,";
    "/test/run_test.py" -> "Import:print_function";
    "/test/run_test.py" -> "Import:argparse";
    "/test/run_test.py" -> "Import:import";
    "/test/run_test.py" -> "Import:shlex";
    "/test/run_test.py" -> "Import:shutil";
    "/test/run_test.py" -> "Import:subprocess";
    "/test/run_test.py" -> "Import:sys";
    "/test/run_test.py" -> "Import:tempfile";
    "/test/run_test.py" -> "Import:torch";
    "/test/run_test.py" -> "Fxn:print_to_stderr";
    "/test/run_test.py" -> "Fxn:shell";
    "/test/run_test.py" -> "Fxn:get_shell_output";
    "/test/run_test.py" -> "Fxn:run_test";
    "/test/run_test.py" -> "Fxn:test_cpp_extensions";
    "/test/run_test.py" -> "Fxn:test_distributed";
    "/test/run_test.py" -> "Fxn:parse_args";
    "/test/run_test.py" -> "Fxn:get_python_command";
    "/test/run_test.py" -> "Fxn:get_selected_tests";
    "/test/run_test.py" -> "Fxn:main";
    "/test/test_autograd.py" -> "Import:contextlib";
    "/test/test_autograd.py" -> "Import:import";
    "/test/test_autograd.py" -> "Import:sys";
    "/test/test_autograd.py" -> "Import:math";
    "/test/test_autograd.py" -> "Import:torch";
    "/test/test_autograd.py" -> "Import:unittest";
    "/test/test_autograd.py" -> "Import:warnings";
    "/test/test_autograd.py" -> "Import:deepcopy";
    "/test/test_autograd.py" -> "Import:OrderedDict";
    "/test/test_autograd.py" -> "Import:product";
    "/test/test_autograd.py" -> "Import:mul";
    "/test/test_autograd.py" -> "Import:reduce,";
    "/test/test_autograd.py" -> "Import:gradgradcheck,";
    "/test/test_autograd.py" -> "Import:once_differentiable";
    "/test/test_autograd.py" -> "Import:profile";
    "/test/test_autograd.py" -> "Import:TestCase,";
    "/test/test_autograd.py" -> "Import:Variable,";
    "/test/test_autograd.py" -> "Import:InplaceFunction";
    "/test/test_autograd.py" -> "Import:make_non_contiguous,";
    "/test/test_autograd.py" -> "Import:cPickle";
    "/test/test_autograd.py" -> "Import:pickle";
    "/test/test_autograd.py" -> "class:NoArgsClass(object):";
    "/test/test_autograd.py" -> "class:non_differentiable(object):";
    "/test/test_autograd.py" -> "class:TestAutograd(TestCase):";
    "/test/test_autograd.py" -> "class:MyFunction(Function):";
    "/test/test_autograd.py" -> "class:MyFunction(Function):";
    "/test/test_autograd.py" -> "class:MyFunction(Function):";
    "/test/test_autograd.py" -> "class:MyFunction(Function):";
    "/test/test_autograd.py" -> "class:NoneGradientFunction(Function):";
    "/test/test_autograd.py" -> "Import:import";
    "/test/test_autograd.py" -> "Import:weakref";
    "/test/test_autograd.py" -> "class:FixedGradientFunction(Function):";
    "/test/test_autograd.py" -> "class:MultiOutputFn(Function):";
    "/test/test_autograd.py" -> "class:TestFn(Function):";
    "/test/test_autograd.py" -> "class:MyOp(Function):";
    "/test/test_autograd.py" -> "class:MyFunction(Function):";
    "/test/test_autograd.py" -> "class:MyFunction(Function):";
    "/test/test_autograd.py" -> "class:MyFunction(Function):";
    "/test/test_autograd.py" -> "class:DoubleDuplicate(Function):";
    "/test/test_autograd.py" -> "class:DoubleInplace(Function):";
    "/test/test_autograd.py" -> "class:CollectOnDelete(Function):";
    "/test/test_autograd.py" -> "Import:Broadcast";
    "/test/test_autograd.py" -> "class:Identity(torch.autograd.Function):";
    "/test/test_autograd.py" -> "class:Identity(Function):";
    "/test/test_autograd.py" -> "class:Inplace(InplaceFunction):";
    "/test/test_autograd.py" -> "class:MyFn(Function):";
    "/test/test_autograd.py" -> "class:MyFn(Function):";
    "/test/test_autograd.py" -> "class:F1(Function):";
    "/test/test_autograd.py" -> "class:F2(Function):";
    "/test/test_autograd.py" -> "class:Reenter(Function):";
    "/test/test_autograd.py" -> "class:PyAdd(torch.autograd.Function):";
    "/test/test_autograd.py" -> "class:IncrementOnDelete(object):";
    "/test/test_autograd.py" -> "class:dont_convert(tuple):";
    "class:NoArgsClass(object):" -> "Fxn:__iter__";
    "class:NoArgsClass(object):" -> "Fxn:__next__";
    "class:NoArgsClass(object):" -> "Fxn:__len__";
    "Fxn:__next__" -> "Fxn:StopIteration()";
    "Fxn:__len__" -> "Fxn:NoArgsClass()";
    "class:non_differentiable(object):" -> "Fxn:__init__";
    "class:non_differentiable(object):" -> "Fxn:backward_engine";
    "class:non_differentiable(object):" -> "Fxn:graph_desc";
    "Fxn:backward_engine" -> "Fxn:engine()";
    "Fxn:graph_desc" -> "Fxn:'('";
    "Fxn:graph_desc" -> "Fxn:graph_desc(next_fn)";
    "class:TestAutograd(TestCase):" -> "Fxn:_function_test";
    "class:TestAutograd(TestCase):" -> "Fxn:test_function";
    "Fxn:_function_test" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:_function_test" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:_function_test" -> "Fxn:cls.apply(x,";
    "Fxn:_function_test" -> "Fxn:Variable(torch.ones(1),";
    "Fxn:_function_test" -> "Fxn:result.sum().backward(go,";
    "Fxn:_function_test" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:_function_test" -> "Fxn:torch.ones(5,";
    "Fxn:_function_test" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:_function_test" -> "Fxn:torch.ones(5,";
    "Fxn:_function_test" -> "Fxn:self.assertIsNotNone(x.grad.grad_fn)";
    "Fxn:_function_test" -> "Fxn:self.assertIsNotNone(y.grad.grad_fn)";
    "class:MyFunction(Function):" -> "Fxn:forward";
    "class:MyFunction(Function):" -> "Fxn:backward";
    "class:MyFunction(Function):" -> "Fxn:test_once_differentiable";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(tensor1,";
    "Fxn:backward" -> "Fxn:self.assertIsInstance(var1,";
    "Fxn:backward" -> "Fxn:self.assertIsInstance(var2,";
    "Fxn:backward" -> "Fxn:self.assertIsInstance(grad_output,";
    "Fxn:backward" -> "Fxn:self._function_test(MyFunction)";
    "Fxn:backward" -> "Fxn:graph_desc(x.grad.grad_fn)";
    "Fxn:backward" -> "Fxn:graph_desc(y.grad.grad_fn)";
    "Fxn:backward" -> "Fxn:self.assertEqual(";
    "Fxn:backward" -> "Fxn:'CloneBackward(AddBackward1(ExpandBackward(AccumulateGrad()),";
    "Fxn:backward" -> "Fxn:'MulBackward1(ExpandBackward(AccumulateGrad()),";
    "Fxn:backward" -> "Fxn:AccumulateGrad())))')";
    "Fxn:backward" -> "Fxn:self.assertEqual(";
    "Fxn:backward" -> "Fxn:'CloneBackward(AddBackward1(MulBackward0(ExpandBackward(AccumulateGrad())),";
    "Fxn:backward" -> "Fxn:'MulBackward1(ExpandBackward(AccumulateGrad()),";
    "Fxn:backward" -> "Fxn:AccumulateGrad())))')";
    "class:MyFunction(Function):" -> "Fxn:forward";
    "class:MyFunction(Function):" -> "Fxn:backward";
    "class:MyFunction(Function):" -> "Fxn:test_function_returns_input";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(tensor1,";
    "Fxn:backward" -> "Fxn:self.assertFalse(torch.is_grad_enabled())";
    "Fxn:backward" -> "Fxn:self._function_test(MyFunction)";
    "Fxn:backward" -> "Fxn:self.assertEqual(graph_desc(x.grad.grad_fn),";
    "Fxn:backward" -> "Fxn:'CloneBackward(Error(AccumulateGrad(),";
    "Fxn:backward" -> "Fxn:AccumulateGrad()))')";
    "Fxn:backward" -> "Fxn:self.assertEqual(graph_desc(y.grad.grad_fn),";
    "Fxn:backward" -> "Fxn:'CloneBackward(Error(AccumulateGrad(),";
    "Fxn:backward" -> "Fxn:AccumulateGrad()))')";
    "class:MyFunction(Function):" -> "Fxn:forward";
    "class:MyFunction(Function):" -> "Fxn:backward";
    "class:MyFunction(Function):" -> "Fxn:test_legacy_function_none_grad";
    "Fxn:backward" -> "Fxn:Variable(torch.ones(1),";
    "Fxn:backward" -> "Fxn:MyFunction.apply(v).backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(v.grad.data.tolist(),";
    "Fxn:backward" -> "Fxn:v.grad.data.zero_()";
    "Fxn:backward" -> "Fxn:MyFunction.apply(v.clone()).backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(v.grad.data.tolist(),";
    "class:MyFunction(Function):" -> "Fxn:forward";
    "class:MyFunction(Function):" -> "Fxn:backward";
    "class:MyFunction(Function):" -> "Fxn:test_accumulate_grad";
    "class:MyFunction(Function):" -> "Fxn:compute_grad";
    "class:MyFunction(Function):" -> "Fxn:test_hessian_vector";
    "class:MyFunction(Function):" -> "Fxn:test_grad";
    "class:MyFunction(Function):" -> "Fxn:test_grad_nonleaf";
    "class:MyFunction(Function):" -> "Fxn:fn";
    "class:MyFunction(Function):" -> "Fxn:test_grad_nonleaf_many_outputs";
    "class:MyFunction(Function):" -> "Fxn:hook";
    "class:MyFunction(Function):" -> "Fxn:test_sharded_grad";
    "class:MyFunction(Function):" -> "Fxn:group";
    "class:MyFunction(Function):" -> "Fxn:test_backward_badcalls";
    "class:MyFunction(Function):" -> "Fxn:test_grad_badcalls";
    "class:MyFunction(Function):" -> "Fxn:test_grad_unreachable";
    "class:MyFunction(Function):" -> "Fxn:test_hooks";
    "class:MyFunction(Function):" -> "Fxn:bw_hook";
    "class:MyFunction(Function):" -> "Fxn:bw_hook_modify";
    "class:MyFunction(Function):" -> "Fxn:test_hooks_cpp";
    "class:MyFunction(Function):" -> "Fxn:bw_hook";
    "class:MyFunction(Function):" -> "Fxn:test_hook_none";
    "Fxn:forward" -> "Fxn:torch.zeros(2,";
    "Fxn:backward" -> "Fxn:Variable(torch.ones(shape),";
    "Fxn:backward" -> "Fxn:0].expand(3,";
    "Fxn:backward" -> "Fxn:5).t().sum()";
    "Fxn:backward" -> "Fxn:MyFunction()(y).sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(v.grad.data,";
    "Fxn:backward" -> "Fxn:torch.zeros(shape))";
    "Fxn:test_accumulate_grad" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:compute_grad" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:compute_grad" -> "Fxn:y.backward(grad_output,";
    "Fxn:compute_grad" -> "Fxn:x.grad.clone()";
    "Fxn:compute_grad" -> "Fxn:y.backward(grad_output,";
    "Fxn:compute_grad" -> "Fxn:compute_grad(create_graph=False)";
    "Fxn:compute_grad" -> "Fxn:self.assertEqual(x_grad,";
    "Fxn:compute_grad" -> "Fxn:compute_grad(create_graph=True)";
    "Fxn:compute_grad" -> "Fxn:self.assertEqual(x_grad,";
    "Fxn:test_hessian_vector" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_hessian_vector" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_hessian_vector" -> "Fxn:z.backward(torch.ones(2,";
    "Fxn:test_hessian_vector" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_hessian_vector" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_hessian_vector" -> "Fxn:grad_sum.backward(torch.ones(2,";
    "Fxn:test_hessian_vector" -> "Fxn:torch.ones(2,";
    "Fxn:test_hessian_vector" -> "Fxn:torch.ones(2,";
    "Fxn:test_hessian_vector" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_hessian_vector" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_grad" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_grad" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_grad" -> "Fxn:z.backward(torch.ones(2,";
    "Fxn:test_grad" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_grad" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_grad" -> "Fxn:torch.autograd.grad(";
    "Fxn:test_grad" -> "Fxn:grad_outputs=[torch.ones(2,";
    "Fxn:test_grad" -> "Fxn:torch.ones(2,";
    "Fxn:test_grad" -> "Fxn:torch.ones(2,";
    "Fxn:test_grad" -> "Fxn:self.assertEqual(x_hv[0].data,";
    "Fxn:test_grad" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_grad" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_grad_nonleaf" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_grad_nonleaf" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_grad_nonleaf" -> "Fxn:torch.ones(2,";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(";
    "Fxn:fn" -> "Fxn:fn(x),";
    "Fxn:fn" -> "Fxn:self.assertIsNone(y.grad)";
    "Fxn:fn" -> "Fxn:self.assertIsNone(x.grad)";
    "Fxn:fn" -> "Fxn:self.assertEqual(grad_x.data,";
    "Fxn:fn" -> "Fxn:fn(x_init).data.sum()";
    "Fxn:fn" -> "Fxn:fn(x).data.sum()";
    "Fxn:fn" -> "Fxn:self.assertGreater(val_final,";
    "Fxn:fn" -> "Fxn:x.backward(grad_output)";
    "Fxn:fn" -> "Fxn:self.assertIsNotNone(y.grad)";
    "Fxn:fn" -> "Fxn:self.assertIsNotNone(x_init.grad)";
    "Fxn:test_grad_nonleaf_many_outputs" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_grad_nonleaf_many_outputs" -> "Fxn:x.chunk(2)";
    "Fxn:hook" -> "Fxn:x.register_hook(hook)";
    "Fxn:hook" -> "Fxn:torch.randn(2,";
    "Fxn:hook" -> "Fxn:torch.autograd.grad(";
    "Fxn:hook" -> "Fxn:self.assertEqual(grad_a.data,";
    "Fxn:hook" -> "Fxn:self.assertEqual(grad_b.data,";
    "Fxn:hook" -> "Fxn:self.assertFalse(hook_called[0])";
    "Fxn:hook" -> "Fxn:self.assertIsNone(x.grad)";
    "Fxn:test_sharded_grad" -> "Fxn:[Variable(torch.zeros(5,";
    "Fxn:group" -> "Fxn:group(intermediates,";
    "Fxn:group" -> "Fxn:torch.autograd.grad(loss,";
    "Fxn:group" -> "Fxn:torch.autograd.backward(intermediates,";
    "Fxn:group" -> "Fxn:self.assertEqual(l.grad.data,";
    "Fxn:test_backward_badcalls" -> "Fxn:torch.ones(1)";
    "Fxn:test_backward_badcalls" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_backward_badcalls" -> "Fxn:x.backward()";
    "Fxn:test_grad_badcalls" -> "Fxn:torch.ones(1)";
    "Fxn:test_grad_badcalls" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_grad_badcalls" -> "Fxn:torch.autograd.grad(x,";
    "Fxn:test_grad_badcalls" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_grad_badcalls" -> "Fxn:torch.autograd.grad(y,";
    "Fxn:test_grad_badcalls" -> "Fxn:Variable(torch.ones(1),";
    "Fxn:test_grad_badcalls" -> "Fxn:torch.autograd.grad(y,";
    "Fxn:test_grad_unreachable" -> "Fxn:Variable(torch.ones(1),";
    "Fxn:test_grad_unreachable" -> "Fxn:Variable(torch.ones(1),";
    "Fxn:test_grad_unreachable" -> "Fxn:torch.autograd.grad(x";
    "Fxn:test_grad_unreachable" -> "Fxn:self.assertEqual(grad_x,";
    "Fxn:test_grad_unreachable" -> "Fxn:self.assertIsNone(grad_y)";
    "Fxn:test_grad_unreachable" -> "Fxn:Variable(torch.ones(1),";
    "Fxn:test_grad_unreachable" -> "Fxn:torch.autograd.grad(x";
    "Fxn:test_grad_unreachable" -> "Fxn:self.assertEqual(grad_x,";
    "Fxn:test_grad_unreachable" -> "Fxn:self.assertIsNone(grad_z)";
    "Fxn:test_hooks" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_hooks" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertIsInstance(grad,";
    "Fxn:bw_hook" -> "Fxn:x.register_hook(lambda";
    "Fxn:bw_hook" -> "Fxn:bw_hook(0,";
    "Fxn:bw_hook" -> "Fxn:z.register_hook(lambda";
    "Fxn:bw_hook" -> "Fxn:bw_hook(1,";
    "Fxn:bw_hook" -> "Fxn:z.backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter[0],";
    "Fxn:bw_hook" -> "Fxn:z.register_hook(lambda";
    "Fxn:bw_hook" -> "Fxn:bw_hook(2,";
    "Fxn:bw_hook" -> "Fxn:z.backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter[0],";
    "Fxn:bw_hook" -> "Fxn:test2.remove()";
    "Fxn:bw_hook" -> "Fxn:z.backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter[0],";
    "Fxn:bw_hook_modify" -> "Fxn:grad.mul(2)";
    "Fxn:bw_hook_modify" -> "Fxn:test.remove()";
    "Fxn:bw_hook_modify" -> "Fxn:z.register_hook(bw_hook_modify)";
    "Fxn:bw_hook_modify" -> "Fxn:y.grad.data.zero_()";
    "Fxn:bw_hook_modify" -> "Fxn:z.backward(torch.ones(5,";
    "Fxn:bw_hook_modify" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:bw_hook_modify" -> "Fxn:y.register_hook(bw_hook_modify)";
    "Fxn:bw_hook_modify" -> "Fxn:y.grad.data.zero_()";
    "Fxn:bw_hook_modify" -> "Fxn:z.backward(torch.ones(5,";
    "Fxn:bw_hook_modify" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_hooks_cpp" -> "Fxn:torch.nn.BatchNorm1d(5,";
    "Fxn:test_hooks_cpp" -> "Fxn:bn.eval()";
    "Fxn:bw_hook" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:bn(x)";
    "Fxn:bw_hook" -> "Fxn:z.register_hook(bw_hook)";
    "Fxn:bw_hook" -> "Fxn:z.sum().backward()";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter[0],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:bw_hook" -> "Fxn:torch.ones(5,";
    "class:NoneGradientFunction(Function):" -> "Fxn:forward";
    "class:NoneGradientFunction(Function):" -> "Fxn:backward";
    "class:NoneGradientFunction(Function):" -> "Fxn:hook";
    "class:NoneGradientFunction(Function):" -> "Fxn:test_retain_grad";
    "class:NoneGradientFunction(Function):" -> "Fxn:test_retain_grad_cycle";
    "class:NoneGradientFunction(Function):" -> "Fxn:run_test";
    "class:NoneGradientFunction(Function):" -> "Fxn:inc";
    "class:NoneGradientFunction(Function):" -> "Fxn:test_backward";
    "class:NoneGradientFunction(Function):" -> "Fxn:test_sparse_backward";
    "Fxn:backward" -> "Fxn:NoneGradientFunction()";
    "Fxn:hook" -> "Fxn:self.assertIsInstance(grad_input,";
    "Fxn:hook" -> "Fxn:self.assertIsInstance(grad_output,";
    "Fxn:hook" -> "Fxn:self.assertIsNotNone(grad_input[0])";
    "Fxn:hook" -> "Fxn:self.assertIsNotNone(grad_input[1])";
    "Fxn:hook" -> "Fxn:self.assertIsNotNone(grad_output[0])";
    "Fxn:hook" -> "Fxn:self.assertIsNotNone(grad_output[1])";
    "Fxn:hook" -> "Fxn:fn.register_hook(hook)";
    "Fxn:hook" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:hook" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:hook" -> "Fxn:y)).sum().backward()";
    "Fxn:hook" -> "Fxn:self.assertTrue(was_called[0])";
    "Fxn:test_retain_grad" -> "Fxn:Variable(torch.rand(1,";
    "Fxn:test_retain_grad" -> "Fxn:h1).sum()";
    "Fxn:test_retain_grad" -> "Fxn:retain_grad()";
    "Fxn:test_retain_grad" -> "Fxn:h1.retain_grad()";
    "Fxn:test_retain_grad" -> "Fxn:h1.retain_grad()";
    "Fxn:test_retain_grad" -> "Fxn:out.backward(retain_graph=True)";
    "Fxn:test_retain_grad" -> "Fxn:self.assertEqual(h1.data";
    "Fxn:test_retain_grad" -> "Fxn:out.backward(retain_graph=True)";
    "Fxn:test_retain_grad" -> "Fxn:self.assertEqual(h1.data";
    "Fxn:test_retain_grad" -> "Fxn:input.grad.data.zero_()";
    "Fxn:test_retain_grad" -> "Fxn:input.retain_grad()";
    "Fxn:test_retain_grad" -> "Fxn:input.retain_grad()";
    "Fxn:test_retain_grad" -> "Fxn:out.backward()";
    "Fxn:test_retain_grad" -> "Fxn:self.assertEqual(input.data";
    "Fxn:test_retain_grad_cycle" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:run_test" -> "Fxn:y.retain_grad()";
    "Fxn:inc" -> "Fxn:weakref.ref(y,";
    "Fxn:inc" -> "Fxn:run_test()";
    "Fxn:inc" -> "Fxn:gc.collect()";
    "Fxn:inc" -> "Fxn:self.assertIsNone(refs[0]())";
    "Fxn:inc" -> "Fxn:self.assertEqual(counter[0],";
    "Fxn:inc" -> "Fxn:z.sum().backward()";
    "Fxn:test_backward" -> "Fxn:torch.randn(5,";
    "Fxn:test_backward" -> "Fxn:torch.randn(5,";
    "Fxn:test_backward" -> "Fxn:torch.rand(5,";
    "Fxn:test_backward" -> "Fxn:torch.randn(5,";
    "Fxn:test_backward" -> "Fxn:torch.randn(5,";
    "Fxn:test_backward" -> "Fxn:Variable(v_t,";
    "Fxn:test_backward" -> "Fxn:Variable(x_t,";
    "Fxn:test_backward" -> "Fxn:Variable(y_t,";
    "Fxn:test_backward" -> "Fxn:Variable(z_t,";
    "Fxn:test_backward" -> "Fxn:v.backward(grad_output)";
    "Fxn:test_backward" -> "Fxn:self.assertEqual(v.grad.data,";
    "Fxn:test_backward" -> "Fxn:a.backward(grad_output)";
    "Fxn:test_backward" -> "Fxn:z_t.pow(2)";
    "Fxn:test_backward" -> "Fxn:z_t.pow(2)";
    "Fxn:test_backward" -> "Fxn:y_t.pow(2)";
    "Fxn:test_backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_backward" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_backward" -> "Fxn:self.assertEqual(z.grad.data,";
    "class:FixedGradientFunction(Function):" -> "Fxn:__init__";
    "class:FixedGradientFunction(Function):" -> "Fxn:forward";
    "class:FixedGradientFunction(Function):" -> "Fxn:backward";
    "class:FixedGradientFunction(Function):" -> "Fxn:test_multi_backward";
    "class:FixedGradientFunction(Function):" -> "Fxn:test_multi_backward_no_grad";
    "class:FixedGradientFunction(Function):" -> "Fxn:call_backwards";
    "class:FixedGradientFunction(Function):" -> "Fxn:test_dependent_backward";
    "class:FixedGradientFunction(Function):" -> "Fxn:test_save_output_nr";
    "Fxn:backward" -> "Fxn:torch.Size([6,";
    "Fxn:backward" -> "Fxn:torch.LongTensor([";
    "Fxn:backward" -> "Fxn:torch.DoubleTensor([[1,";
    "Fxn:backward" -> "Fxn:Variable(torch.sparse.DoubleTensor(i1,";
    "Fxn:backward" -> "Fxn:torch.LongTensor([";
    "Fxn:backward" -> "Fxn:torch.DoubleTensor([[1,";
    "Fxn:backward" -> "Fxn:Variable(torch.sparse.DoubleTensor(i2,";
    "Fxn:backward" -> "Fxn:Variable(torch.rand(size).double())";
    "Fxn:backward" -> "Fxn:FixedGradientFunction(sparse_grad1)";
    "Fxn:backward" -> "Fxn:FixedGradientFunction(sparse_grad2)";
    "Fxn:backward" -> "Fxn:FixedGradientFunction(dense_grad)";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:dense_fn(x)";
    "Fxn:backward" -> "Fxn:sparse_fn2(x)).sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad,";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:sparse_fn1(x)";
    "Fxn:backward" -> "Fxn:sparse_fn2(x)).sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad,";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:sparse_fn2(x)).sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad,";
    "Fxn:test_multi_backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multi_backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multi_backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multi_backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multi_backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multi_backward" -> "Fxn:torch.randn(5,";
    "Fxn:test_multi_backward" -> "Fxn:torch.randn(5,";
    "Fxn:test_multi_backward" -> "Fxn:torch.autograd.backward([z,";
    "Fxn:test_multi_backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_multi_backward" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_multi_backward" -> "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:test_multi_backward" -> "Fxn:self.assertEqual(b.grad.data,";
    "Fxn:test_multi_backward" -> "Fxn:self.assertEqual(q.grad.data,";
    "Fxn:test_multi_backward_no_grad" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multi_backward_no_grad" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:call_backwards" -> "Fxn:torch.autograd.backward([z,";
    "Fxn:call_backwards" -> "Fxn:[torch.ones(5,";
    "Fxn:call_backwards" -> "Fxn:torch.ones(5,";
    "Fxn:call_backwards" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_dependent_backward" -> "Fxn:Variable(torch.randn(10),";
    "Fxn:test_dependent_backward" -> "Fxn:torch.randn(10)";
    "Fxn:test_dependent_backward" -> "Fxn:torch.randn(10)";
    "Fxn:test_dependent_backward" -> "Fxn:torch.autograd.backward([y,";
    "Fxn:test_dependent_backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_dependent_backward" -> "Fxn:xd.pow(5)";
    "Fxn:test_save_output_nr" -> "Fxn:Variable(torch.randn(10),";
    "class:MultiOutputFn(Function):" -> "Fxn:forward";
    "class:MultiOutputFn(Function):" -> "Fxn:backward";
    "Fxn:backward" -> "Fxn:torch.cat(grad)";
    "Fxn:backward" -> "Fxn:MultiOutputFn.apply(x)";
    "Fxn:backward" -> "Fxn:self.assertEqual(b.output_nr,";
    "class:TestFn(Function):" -> "Fxn:forward";
    "class:TestFn(Function):" -> "Fxn:backward";
    "class:TestFn(Function):" -> "Fxn:test_no_grad";
    "class:TestFn(Function):" -> "Fxn:test_no_grad_python_function";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(b)";
    "Fxn:backward" -> "Fxn:self.assertEqual(b.output_nr,";
    "Fxn:backward" -> "Fxn:TestFn.apply(b).sum().backward()";
    "Fxn:test_no_grad" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_no_grad" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_no_grad" -> "Fxn:torch.no_grad():";
    "Fxn:test_no_grad" -> "Fxn:self.assertFalse(w.requires_grad)";
    "Fxn:test_no_grad" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_no_grad" -> "Fxn:w.backward(torch.ones(5,";
    "Fxn:test_no_grad" -> "Fxn:self.assertIsNone(w.grad_fn)";
    "Fxn:test_no_grad_python_function" -> "Fxn:Variable(torch.ones(5,";
    "class:MyOp(Function):" -> "Fxn:forward";
    "class:MyOp(Function):" -> "Fxn:backward";
    "class:MyOp(Function):" -> "Fxn:test_indexing";
    "class:MyOp(Function):" -> "Fxn:compare";
    "class:MyOp(Function):" -> "Fxn:check_index";
    "class:MyOp(Function):" -> "Fxn:test_indexing_duplicates";
    "class:MyOp(Function):" -> "Fxn:test_volatile_deprecated";
    "class:MyOp(Function):" -> "Fxn:test_requires_grad";
    "class:MyOp(Function):" -> "Fxn:error";
    "class:MyOp(Function):" -> "Fxn:test_requires_grad_inplace";
    "class:MyOp(Function):" -> "Fxn:test_no_requires_grad_inplace";
    "class:MyOp(Function):" -> "Fxn:test_requires_grad_factory";
    "class:MyOp(Function):" -> "Fxn:test_grad_assignment";
    "class:MyOp(Function):" -> "Fxn:test_duplicate_backward_root";
    "class:MyOp(Function):" -> "Fxn:test_backward_no_grad";
    "class:MyOp(Function):" -> "Fxn:test_next_functions";
    "class:MyOp(Function):" -> "Fxn:test_inplace";
    "class:MyOp(Function):" -> "Fxn:test_mark_non_differentiable";
    "Fxn:backward" -> "Fxn:torch.no_grad():";
    "Fxn:backward" -> "Fxn:MyOp.apply(x)";
    "Fxn:backward" -> "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:test_indexing" -> "Fxn:torch.arange(1,";
    "Fxn:test_indexing" -> "Fxn:17).view(4,";
    "Fxn:test_indexing" -> "Fxn:Variable(x,";
    "Fxn:compare" -> "Fxn:torch.is_tensor(indexed_tensor):";
    "Fxn:compare" -> "Fxn:self.assertEqual(indexed_tensor,";
    "Fxn:compare" -> "Fxn:indexed_var.sum().backward()";
    "Fxn:compare" -> "Fxn:torch.Tensor(x.size()).fill_(0)";
    "Fxn:compare" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:check_index" -> "Fxn:y.grad.data.zero_()";
    "Fxn:check_index" -> "Fxn:compare(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:torch.LongTensor([0,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:torch.rand(4,";
    "Fxn:check_index" -> "Fxn:4).bernoulli().byte())";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:torch.arange(1,";
    "Fxn:check_index" -> "Fxn:49).view(4,";
    "Fxn:check_index" -> "Fxn:Variable(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:check_index(x,";
    "Fxn:check_index" -> "Fxn:torch.LongTensor([0,";
    "Fxn:check_index" -> "Fxn:Variable(z,";
    "Fxn:check_index" -> "Fxn:y.grad.data.zero_()";
    "Fxn:check_index" -> "Fxn:compare(x,";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.arange(1,";
    "Fxn:test_indexing_duplicates" -> "Fxn:17).view(4,";
    "Fxn:test_indexing_duplicates" -> "Fxn:Variable(x,";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.LongTensor([1,";
    "Fxn:test_indexing_duplicates" -> "Fxn:y[idx].sum().backward()";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.zeros(4,";
    "Fxn:test_indexing_duplicates" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.arange(1,";
    "Fxn:test_indexing_duplicates" -> "Fxn:17).view(4,";
    "Fxn:test_indexing_duplicates" -> "Fxn:Variable(x,";
    "Fxn:test_indexing_duplicates" -> "Fxn:y[idx].sum().backward()";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.zeros(4,";
    "Fxn:test_indexing_duplicates" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.arange(1,";
    "Fxn:test_indexing_duplicates" -> "Fxn:17).view(4,";
    "Fxn:test_indexing_duplicates" -> "Fxn:Variable(x,";
    "Fxn:test_indexing_duplicates" -> "Fxn:y[idx].sum().backward()";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.Tensor([[0,";
    "Fxn:test_indexing_duplicates" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.arange(1,";
    "Fxn:test_indexing_duplicates" -> "Fxn:65).view(4,";
    "Fxn:test_indexing_duplicates" -> "Fxn:Variable(x,";
    "Fxn:test_indexing_duplicates" -> "Fxn:y[idx].sum().backward()";
    "Fxn:test_indexing_duplicates" -> "Fxn:torch.Tensor(4,";
    "Fxn:test_indexing_duplicates" -> "Fxn:4).zero_()";
    "Fxn:test_indexing_duplicates" -> "Fxn:expected_grad[1].fill_(3)";
    "Fxn:test_indexing_duplicates" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_volatile_deprecated" -> "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:test_volatile_deprecated" -> "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:test_volatile_deprecated" -> "Fxn:self.assertFalse(v.volatile)";
    "Fxn:test_volatile_deprecated" -> "Fxn:self.assertIn('volatile',";
    "Fxn:test_requires_grad" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_requires_grad" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_requires_grad" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_requires_grad" -> "Fxn:self.assertFalse(a.requires_grad)";
    "Fxn:test_requires_grad" -> "Fxn:self.assertTrue(b.requires_grad)";
    "Fxn:error" -> "Fxn:OrderedDict()";
    "Fxn:error" -> "Fxn:OrderedDict()";
    "Fxn:error" -> "Fxn:OrderedDict()";
    "Fxn:error" -> "Fxn:b.backward(torch.ones(5,";
    "Fxn:test_requires_grad_inplace" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_requires_grad_inplace" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_requires_grad_inplace" -> "Fxn:self.assertTrue(a.requires_grad)";
    "Fxn:test_requires_grad_inplace" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_requires_grad_inplace" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_requires_grad_inplace" -> "Fxn:self.assertTrue(a.requires_grad)";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:a.add_(5)";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:a.sum().backward()";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:torch.ones(2,";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:b.add_(5)";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:a.sum().backward()";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:torch.ones(2,";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:a.add_(5)";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_no_requires_grad_inplace" -> "Fxn:b.add_(5)";
    "Fxn:test_requires_grad_factory" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_requires_grad_factory" -> "Fxn:fn(x,";
    "Fxn:test_requires_grad_factory" -> "Fxn:self.assertEqual(requires_grad,";
    "Fxn:test_requires_grad_factory" -> "Fxn:self.assertIs(dtype,";
    "Fxn:test_requires_grad_factory" -> "Fxn:torch.cuda.is_available()";
    "Fxn:test_requires_grad_factory" -> "Fxn:torch.cuda.device_count()";
    "Fxn:test_requires_grad_factory" -> "Fxn:fn(x,";
    "Fxn:test_requires_grad_factory" -> "Fxn:self.assertEqual(requires_grad,";
    "Fxn:test_requires_grad_factory" -> "Fxn:self.assertIs(dtype,";
    "Fxn:test_requires_grad_factory" -> "Fxn:self.assertEqual(1,";
    "Fxn:test_requires_grad_factory" -> "Fxn:output.get_device())";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_grad_assignment" -> "Fxn:5).long())";
    "Fxn:test_grad_assignment" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_grad_assignment" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_grad_assignment" -> "Fxn:5).long())";
    "Fxn:test_grad_assignment" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_grad_assignment" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_grad_assignment" -> "Fxn:unittest.SkipTest("CUDA";
    "Fxn:test_grad_assignment" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_grad_assignment" -> "Fxn:5).cuda())";
    "Fxn:test_grad_assignment" -> "Fxn:torch.cuda.device_count()";
    "Fxn:test_grad_assignment" -> "Fxn:unittest.SkipTest("At";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_grad_assignment" -> "Fxn:5).cuda(0))";
    "Fxn:test_grad_assignment" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_grad_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_grad_assignment" -> "Fxn:5).cuda(1))";
    "Fxn:test_duplicate_backward_root" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_duplicate_backward_root" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_duplicate_backward_root" -> "Fxn:x.data.clone().normal_()";
    "Fxn:test_duplicate_backward_root" -> "Fxn:torch.autograd.backward([x,";
    "Fxn:test_duplicate_backward_root" -> "Fxn:self.assertEqual(a.grad.data,";
    "Fxn:test_duplicate_backward_root" -> "Fxn:self.assertEqual(b.grad.data,";
    "Fxn:test_backward_no_grad" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_backward_no_grad" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_backward_no_grad" -> "Fxn:torch.autograd.backward([b],";
    "Fxn:test_next_functions" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_next_functions" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_next_functions" -> "Fxn:self.assertIsNotNone(a.grad_fn)";
    "Fxn:test_next_functions" -> "Fxn:self.assertEqual(len(next_functions),";
    "Fxn:test_next_functions" -> "Fxn:self.assertIsInstance(next_functions[0][0],";
    "Fxn:test_next_functions" -> "Fxn:self.assertEqual(next_functions[0][1],";
    "Fxn:test_next_functions" -> "Fxn:self.assertIsInstance(next_functions[1][0],";
    "Fxn:test_next_functions" -> "Fxn:self.assertEqual(next_functions[1][1],";
    "Fxn:test_next_functions" -> "Fxn:self.assertEqual(len(next_functions),";
    "Fxn:test_next_functions" -> "Fxn:self.assertIs(next_functions[0][0],";
    "Fxn:test_inplace" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:z.add_(2)";
    "Fxn:test_inplace" -> "Fxn:q.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_inplace" -> "Fxn:w.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:z.add_(y)";
    "Fxn:test_inplace" -> "Fxn:w.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:r.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_inplace" -> "Fxn:q.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:x.grad.data.zero_()";
    "Fxn:test_inplace" -> "Fxn:z.exp_()";
    "Fxn:test_inplace" -> "Fxn:self.assertNotEqual(z._version,";
    "Fxn:test_inplace" -> "Fxn:r.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_inplace" -> "Fxn:torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:w.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_inplace" -> "Fxn:torch.Tensor(5,";
    "Fxn:test_inplace" -> "Fxn:5).fill_((1";
    "Fxn:test_inplace" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_inplace" -> "Fxn:q.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:leaf.clone()";
    "Fxn:test_inplace" -> "Fxn:x.add_(10)";
    "Fxn:test_inplace" -> "Fxn:self.assertEqual(x.data,";
    "Fxn:test_inplace" -> "Fxn:torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:y.backward(torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:self.assertEqual(leaf.grad.data,";
    "Fxn:test_inplace" -> "Fxn:torch.ones(5,";
    "Fxn:test_inplace" -> "Fxn:x.add_(2)";
    "Fxn:test_inplace" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_inplace" -> "Fxn:z.backward(torch.ones(5,";
    "class:MyFunction(Function):" -> "Fxn:forward";
    "class:MyFunction(Function):" -> "Fxn:backward";
    "class:MyFunction(Function):" -> "Fxn:test_mark_non_differentiable_mixed";
    "Fxn:forward" -> "Fxn:ctx.mark_non_differentiable(output)";
    "Fxn:backward" -> "Fxn:0).type(torch.DoubleTensor)";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:MyFunction.apply(x)";
    "Fxn:backward" -> "Fxn:self.assertFalse(mask.requires_grad)";
    "Fxn:backward" -> "Fxn:x.masked_fill(mask,";
    "Fxn:backward" -> "Fxn:y.sum().backward()";
    "class:MyFunction(Function):" -> "Fxn:forward";
    "class:MyFunction(Function):" -> "Fxn:backward";
    "class:MyFunction(Function):" -> "Fxn:test_mark_non_differentiable_none";
    "Fxn:forward" -> "Fxn:ctx.mark_non_differentiable(a)";
    "Fxn:backward" -> "Fxn:self.assertTrue((grad_a";
    "Fxn:backward" -> "Fxn:0).all())";
    "Fxn:backward" -> "Fxn:self.assertTrue((grad_b";
    "Fxn:backward" -> "Fxn:1).all())";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:MyFunction.apply(x)";
    "Fxn:backward" -> "Fxn:self.assertFalse(a.requires_grad)";
    "Fxn:backward" -> "Fxn:self.assertTrue(b.requires_grad)";
    "Fxn:backward" -> "Fxn:b.sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:backward" -> "Fxn:torch.ones(5,";
    "class:MyFunction(Function):" -> "Fxn:forward";
    "class:MyFunction(Function):" -> "Fxn:backward";
    "class:MyFunction(Function):" -> "Fxn:test_return_duplicate";
    "Fxn:forward" -> "Fxn:input.clone()";
    "Fxn:forward" -> "Fxn:ctx.mark_non_differentiable(output)";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:MyFunction.apply(x";
    "Fxn:backward" -> "Fxn:x).sum().backward()";
    "class:DoubleDuplicate(Function):" -> "Fxn:forward";
    "class:DoubleDuplicate(Function):" -> "Fxn:backward";
    "class:DoubleDuplicate(Function):" -> "Fxn:fn";
    "class:DoubleDuplicate(Function):" -> "Fxn:test_return_duplicate_inplace";
    "Fxn:fn" -> "Fxn:DoubleDuplicate.apply(x)";
    "Fxn:fn" -> "Fxn:self.assertIs(a,";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:gradcheck(fn,";
    "Fxn:fn" -> "Fxn:gradgradcheck(fn,";
    "class:DoubleInplace(Function):" -> "Fxn:forward";
    "class:DoubleInplace(Function):" -> "Fxn:backward";
    "class:DoubleInplace(Function):" -> "Fxn:inplace_fn";
    "class:DoubleInplace(Function):" -> "Fxn:test_resize";
    "class:DoubleInplace(Function):" -> "Fxn:_test_setitem";
    "class:DoubleInplace(Function):" -> "Fxn:_test_setitem_tensor";
    "class:DoubleInplace(Function):" -> "Fxn:test_setitem";
    "class:DoubleInplace(Function):" -> "Fxn:test_setitem_mask";
    "class:DoubleInplace(Function):" -> "Fxn:test_select_sum";
    "class:DoubleInplace(Function):" -> "Fxn:func";
    "class:DoubleInplace(Function):" -> "Fxn:test_stack";
    "class:DoubleInplace(Function):" -> "Fxn:test_put";
    "class:DoubleInplace(Function):" -> "Fxn:func";
    "class:DoubleInplace(Function):" -> "Fxn:test_put_accumulate";
    "class:DoubleInplace(Function):" -> "Fxn:func";
    "class:DoubleInplace(Function):" -> "Fxn:test_fill";
    "class:DoubleInplace(Function):" -> "Fxn:func";
    "class:DoubleInplace(Function):" -> "Fxn:test_unused_output";
    "class:DoubleInplace(Function):" -> "Fxn:test_gc_in_destructor";
    "Fxn:forward" -> "Fxn:x.mul_(2)";
    "Fxn:forward" -> "Fxn:ctx.mark_dirty(x)";
    "Fxn:inplace_fn" -> "Fxn:DoubleInplace.apply(x.clone())";
    "Fxn:inplace_fn" -> "Fxn:self.assertIs(a,";
    "Fxn:inplace_fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:inplace_fn" -> "Fxn:gradcheck(inplace_fn,";
    "Fxn:inplace_fn" -> "Fxn:gradgradcheck(inplace_fn,";
    "Fxn:inplace_fn" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:inplace_fn" -> "Fxn:InplaceFunction.apply(x))";
    "Fxn:inplace_fn" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:inplace_fn" -> "Fxn:InplaceFunction.apply(x.clone()[0]))";
    "Fxn:test_resize" -> "Fxn:Variable(torch.ones(2,";
    "Fxn:test_resize" -> "Fxn:self.assertTrue(x.resize(3,";
    "Fxn:test_resize" -> "Fxn:2).size()";
    "Fxn:_test_setitem" -> "Fxn:Variable(torch.ones(*size),";
    "Fxn:_test_setitem" -> "Fxn:self.assertNotEqual(y._version,";
    "Fxn:_test_setitem" -> "Fxn:y.backward(torch.ones(*size))";
    "Fxn:_test_setitem" -> "Fxn:torch.ones(*size)";
    "Fxn:_test_setitem" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:_test_setitem_tensor" -> "Fxn:Variable(torch.ones(*size),";
    "Fxn:_test_setitem_tensor" -> "Fxn:x.new(x[index].size()).fill_(7)";
    "Fxn:_test_setitem_tensor" -> "Fxn:self.assertNotEqual(y._version,";
    "Fxn:_test_setitem_tensor" -> "Fxn:y.backward(torch.ones(*size))";
    "Fxn:_test_setitem_tensor" -> "Fxn:torch.ones(*size)";
    "Fxn:_test_setitem_tensor" -> "Fxn:novars.append(i.data)";
    "Fxn:_test_setitem_tensor" -> "Fxn:novars.append(i)";
    "Fxn:_test_setitem_tensor" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:_test_setitem_tensor" -> "Fxn:self.assertEqual(value.grad.data,";
    "Fxn:_test_setitem_tensor" -> "Fxn:torch.ones(value.data.size()))";
    "Fxn:_test_setitem_tensor" -> "Fxn:Variable(torch.randn(4),";
    "Fxn:_test_setitem_tensor" -> "Fxn:Variable(torch.zeros(2,";
    "Fxn:_test_setitem_tensor" -> "Fxn:y.backward(torch.randn(2,";
    "Fxn:_test_setitem_tensor" -> "Fxn:self.assertEqual(x.size(),";
    "Fxn:_test_setitem_tensor" -> "Fxn:x.grad.size())";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((1,),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((10,),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem" -> "Fxn:[slice(None),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem" -> "Fxn:[slice(None),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem" -> "Fxn:[slice(None),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:test_setitem" -> "Fxn:Variable(torch.LongTensor([3]),";
    "Fxn:test_setitem" -> "Fxn:requires_grad=False).sum())";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:[slice(None),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:[slice(None),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:[slice(None),";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem" -> "Fxn:[Variable(torch.LongTensor([1,";
    "Fxn:test_setitem_mask" -> "Fxn:torch.ByteTensor(5,";
    "Fxn:test_setitem_mask" -> "Fxn:5).bernoulli_()";
    "Fxn:test_setitem_mask" -> "Fxn:self._test_setitem((5,";
    "Fxn:test_setitem_mask" -> "Fxn:Variable(mask))";
    "Fxn:test_setitem_mask" -> "Fxn:self._test_setitem((5,),";
    "Fxn:test_setitem_mask" -> "Fxn:Variable(mask[0]))";
    "Fxn:test_setitem_mask" -> "Fxn:self._test_setitem((1,),";
    "Fxn:test_setitem_mask" -> "Fxn:Variable(mask[0,";
    "Fxn:test_setitem_mask" -> "Fxn:self._test_setitem_tensor((5,";
    "Fxn:test_setitem_mask" -> "Fxn:Variable(mask))";
    "Fxn:test_setitem_mask" -> "Fxn:self._test_setitem_tensor((5,),";
    "Fxn:test_setitem_mask" -> "Fxn:Variable(mask[0]))";
    "Fxn:test_select_sum" -> "Fxn:Variable(torch.randn(10),";
    "Fxn:func" -> "Fxn:x.select(0,";
    "Fxn:func" -> "Fxn:1).sum()";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_stack" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_stack" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_stack" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_stack" -> "Fxn:torch.stack([x,";
    "Fxn:test_stack" -> "Fxn:torch.randn(3,";
    "Fxn:test_stack" -> "Fxn:stacked.backward(grad)";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(z.grad.data,";
    "Fxn:test_put" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_put" -> "Fxn:Variable(torch.randn(6),";
    "Fxn:test_put" -> "Fxn:Variable(torch.LongTensor([1,";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:x.put_(idx,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_put_accumulate" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_put_accumulate" -> "Fxn:Variable(torch.randn(6),";
    "Fxn:test_put_accumulate" -> "Fxn:Variable(torch.LongTensor([1,";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:x.put_(idx,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_fill" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:x.fill_(2)";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_unused_output" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_unused_output" -> "Fxn:x.chunk(5)";
    "Fxn:test_unused_output" -> "Fxn:o.sum().backward()";
    "Fxn:test_unused_output" -> "Fxn:torch.zeros(10,";
    "Fxn:test_unused_output" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_unused_output" -> "Fxn:x.grad.data.zero_()";
    "Fxn:test_unused_output" -> "Fxn:torch.randn(2,";
    "Fxn:test_unused_output" -> "Fxn:x.chunk(5)";
    "Fxn:test_unused_output" -> "Fxn:outputs[0].backward(grad_output)";
    "Fxn:test_unused_output" -> "Fxn:torch.zeros(10,";
    "Fxn:test_unused_output" -> "Fxn:self.assertEqual(x.grad.data,";
    "class:CollectOnDelete(Function):" -> "Fxn:__del__";
    "class:CollectOnDelete(Function):" -> "Fxn:test_unused_output_gpu";
    "class:CollectOnDelete(Function):" -> "Fxn:test_backward_device";
    "Fxn:__del__" -> "Fxn:gc.collect()";
    "Fxn:__del__" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:__del__" -> "Fxn:_grad_fn=CollectOnDelete())";
    "Fxn:__del__" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_unused_output_gpu" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_unused_output_gpu" -> "Fxn:5).float().cuda(),";
    "Fxn:test_unused_output_gpu" -> "Fxn:Broadcast.apply(list(range(torch.cuda.device_count())),";
    "Fxn:test_unused_output_gpu" -> "Fxn:y.sum().backward()";
    "Fxn:test_unused_output_gpu" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_unused_output_gpu" -> "Fxn:torch.ones(5,";
    "Fxn:test_unused_output_gpu" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "class:Identity(torch.autograd.Function):" -> "Fxn:forward";
    "class:Identity(torch.autograd.Function):" -> "Fxn:backward";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_detach";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_detach_base";
    "class:Identity(torch.autograd.Function):" -> "Fxn:_test_type_conversion_backward";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_type_conversions";
    "class:Identity(torch.autograd.Function):" -> "Fxn:_test_pyscalar_conversions";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_nonzero";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_pyscalar_conversions";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_pin_memory";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_isolated_node";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_shape";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_numpy_requires_grad";
    "class:Identity(torch.autograd.Function):" -> "Fxn:test_return_leaf";
    "Fxn:forward" -> "Fxn:x.clone()";
    "Fxn:backward" -> "Fxn:torch.cuda.current_device()";
    "Fxn:backward" -> "Fxn:grad_output.clone()";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(1).cuda(1),";
    "Fxn:backward" -> "Fxn:Identity.apply(v).backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(device[0],";
    "Fxn:test_detach" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_detach" -> "Fxn:y.detach()";
    "Fxn:test_detach" -> "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:test_detach" -> "Fxn:self.assertFalse(z.requires_grad)";
    "Fxn:test_detach" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_detach" -> "Fxn:y.detach()";
    "Fxn:test_detach" -> "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:test_detach" -> "Fxn:self.assertIsNone(y.grad_fn)";
    "Fxn:test_detach" -> "Fxn:z.sum().backward()";
    "Fxn:test_detach" -> "Fxn:detach()";
    "Fxn:test_detach" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_detach" -> "Fxn:torch.ones(10,";
    "Fxn:test_detach" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_detach" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_detach" -> "Fxn:a).sum().backward(retain_graph=True)";
    "Fxn:test_detach" -> "Fxn:a.detach_()";
    "Fxn:test_detach" -> "Fxn:self.assertFalse(a.requires_grad)";
    "Fxn:test_detach" -> "Fxn:a).sum().backward()";
    "Fxn:test_detach" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_detach" -> "Fxn:torch.ones(10,";
    "Fxn:test_detach" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_detach" -> "Fxn:torch.ones(10,";
    "Fxn:test_detach" -> "Fxn:x.narrow(0,";
    "Fxn:test_detach" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_detach" -> "Fxn:view.detach_())";
    "Fxn:test_detach_base" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_detach_base" -> "Fxn:x.narrow(0,";
    "Fxn:test_detach_base" -> "Fxn:x.detach_()";
    "Fxn:test_detach_base" -> "Fxn:self.assertFalse(x.requires_grad)";
    "Fxn:test_detach_base" -> "Fxn:self.assertTrue(view.requires_grad)";
    "Fxn:test_detach_base" -> "Fxn:self.assertIsNotNone(view.grad_fn)";
    "Fxn:test_detach_base" -> "Fxn:self.assertIs(view._base,";
    "Fxn:_test_type_conversion_backward" -> "Fxn:Variable(t(torch.randn(5,";
    "Fxn:_test_type_conversion_backward" -> "Fxn:5).float()),";
    "Fxn:_test_type_conversion_backward" -> "Fxn:fvar.double().sum().backward()";
    "Fxn:_test_type_conversion_backward" -> "Fxn:self.assertEqual(fvar.grad,";
    "Fxn:_test_type_conversion_backward" -> "Fxn:torch.ones_like(fvar))";
    "Fxn:_test_type_conversion_backward" -> "Fxn:self.assertEqual(type(fvar.grad.data),";
    "Fxn:_test_type_conversion_backward" -> "Fxn:Variable(t(torch.randn(5,";
    "Fxn:_test_type_conversion_backward" -> "Fxn:5).double()),";
    "Fxn:_test_type_conversion_backward" -> "Fxn:dvar.float().sum().backward()";
    "Fxn:_test_type_conversion_backward" -> "Fxn:self.assertEqual(dvar.grad,";
    "Fxn:_test_type_conversion_backward" -> "Fxn:torch.ones_like(dvar))";
    "Fxn:_test_type_conversion_backward" -> "Fxn:self.assertEqual(type(dvar.grad.data),";
    "Fxn:test_type_conversions" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.float().data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.int().data,";
    "Fxn:test_type_conversions" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.float().cuda().data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.int().cuda().data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.int().cuda().cpu().data,";
    "Fxn:test_type_conversions" -> "Fxn:torch.cuda.device_count()";
    "Fxn:test_type_conversions" -> "Fxn:x.float().cuda(1)";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x2.data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIs(x2.get_device(),";
    "Fxn:test_type_conversions" -> "Fxn:x.float().cuda()";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x2.data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIs(x2.get_device(),";
    "Fxn:test_type_conversions" -> "Fxn:x2.cuda(1)";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x2.data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIs(x2.get_device(),";
    "Fxn:test_type_conversions" -> "Fxn:Variable(torch.randn(5).cuda(1),";
    "Fxn:test_type_conversions" -> "Fxn:y.cpu().sum().backward()";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIs(y.grad.get_device(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIs(y.long().data.get_device(),";
    "Fxn:test_type_conversions" -> "Fxn:torch.randn(5,";
    "Fxn:test_type_conversions" -> "Fxn:5).type(t)";
    "Fxn:test_type_conversions" -> "Fxn:Variable(y)";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.type(t).data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.type_as(y).data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.type(t_dtype).data,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIs(t_dtype,";
    "Fxn:test_type_conversions" -> "Fxn:x.type(t_dtype).dtype)";
    "Fxn:test_type_conversions" -> "Fxn:self.assertEqual(y.data_ptr(),";
    "Fxn:test_type_conversions" -> "Fxn:y.type(t).data_ptr())";
    "Fxn:test_type_conversions" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_type_conversions" -> "Fxn:x.cuda()";
    "Fxn:test_type_conversions" -> "Fxn:y.cuda()";
    "Fxn:test_type_conversions" -> "Fxn:y_c.type().rsplit('.',";
    "Fxn:test_type_conversions" -> "Fxn:self.assertEqual(y_c.type(),";
    "Fxn:test_type_conversions" -> "Fxn:x_c.type(y_typestr).type())";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIs(y_c.dtype,";
    "Fxn:test_type_conversions" -> "Fxn:x_c.type(y_c.dtype).dtype)";
    "Fxn:test_type_conversions" -> "Fxn:self.assertEqual(y_c.data_ptr(),";
    "Fxn:test_type_conversions" -> "Fxn:y_c.cuda().data_ptr()";
    "Fxn:test_type_conversions" -> "Fxn:y_c.data_ptr())";
    "Fxn:test_type_conversions" -> "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:test_type_conversions" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_type_conversions" -> "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:test_type_conversions" -> "Fxn:x.cuda())";
    "Fxn:test_type_conversions" -> "Fxn:torch.cuda.device_count()";
    "Fxn:test_type_conversions" -> "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:test_type_conversions" -> "Fxn:x.cuda(0))";
    "Fxn:test_type_conversions" -> "Fxn:self._test_type_conversion_backward(lambda";
    "Fxn:test_type_conversions" -> "Fxn:x.cuda(1))";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:Variable(t(torch.zeros(1,";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:1).long()))";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertEqual(integral_conv(l),";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:Variable(t(torch.randn(1,";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertEqual(float(f),";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertTrue(math.isnan(float(f)))";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertEqual(float(f),";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertEqual(float(f),";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertNotEqual(pyscalar,";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:integral_conv(float(pyscalar)))";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertEqual(float(l),";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:integral_conv(f[0]))";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertRaises(OverflowError,";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:integral_conv(f[0]))";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertRaises(OverflowError,";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:integral_conv(f[0]))";
    "Fxn:_test_pyscalar_conversions" -> "Fxn:self.assertEqual(integral_conv(f),";
    "Fxn:test_nonzero" -> "Fxn:self.assertEqual(expected,";
    "Fxn:test_nonzero" -> "Fxn:self.assertEqual(expected,";
    "Fxn:test_nonzero" -> "Fxn:test_nonzero(l,";
    "Fxn:test_nonzero" -> "Fxn:test_nonzero(l,";
    "Fxn:test_nonzero" -> "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero" -> "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero" -> "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero" -> "Fxn:test_nonzero(f,";
    "Fxn:test_nonzero" -> "Fxn:test_nonzero(f,";
    "Fxn:test_pyscalar_conversions" -> "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:test_pyscalar_conversions" -> "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:test_pyscalar_conversions" -> "Fxn:long(x))";
    "Fxn:test_pyscalar_conversions" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_pyscalar_conversions" -> "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:test_pyscalar_conversions" -> "Fxn:x.cuda(),";
    "Fxn:test_pyscalar_conversions" -> "Fxn:self._test_pyscalar_conversions(lambda";
    "Fxn:test_pyscalar_conversions" -> "Fxn:x.cuda(),";
    "Fxn:test_pyscalar_conversions" -> "Fxn:long(x))";
    "Fxn:test_pyscalar_conversions" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_pyscalar_conversions" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_pin_memory" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_pin_memory" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_pin_memory" -> "Fxn:x.pin_memory())";
    "Fxn:test_pin_memory" -> "Fxn:self.assertIsNot(x,";
    "Fxn:test_pin_memory" -> "Fxn:x.pin_memory())";
    "Fxn:test_pin_memory" -> "Fxn:self.assertTrue(x.pin_memory().requires_grad)";
    "Fxn:test_pin_memory" -> "Fxn:gradcheck(lambda";
    "Fxn:test_pin_memory" -> "Fxn:x.pin_memory(),";
    "Fxn:test_pin_memory" -> "Fxn:gradgradcheck(lambda";
    "Fxn:test_pin_memory" -> "Fxn:x.pin_memory(),";
    "Fxn:test_isolated_node" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_isolated_node" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_isolated_node" -> "Fxn:torch.max(a,";
    "Fxn:test_isolated_node" -> "Fxn:True)[1].repeat(1,";
    "Fxn:test_isolated_node" -> "Fxn:5).double()";
    "Fxn:test_isolated_node" -> "Fxn:a).sum()";
    "Fxn:test_isolated_node" -> "Fxn:o.backward()";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(2,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(x.shape[0],";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(x.shape[1],";
    "Fxn:test_numpy_requires_grad" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_numpy_requires_grad" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_numpy_requires_grad" -> "Fxn:x.numpy())";
    "class:Identity(Function):" -> "Fxn:forward";
    "class:Identity(Function):" -> "Fxn:backward";
    "class:Identity(Function):" -> "Fxn:hook";
    "class:Identity(Function):" -> "Fxn:test_return_leaf_inplace";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:Identity()(x,";
    "Fxn:hook" -> "Fxn:self.assertEqual(grad.data,";
    "Fxn:hook" -> "Fxn:torch.ones(5,";
    "Fxn:hook" -> "Fxn:q.register_hook(hook)";
    "Fxn:hook" -> "Fxn:x).sum().backward()";
    "Fxn:hook" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:hook" -> "Fxn:torch.ones(5,";
    "Fxn:hook" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:hook" -> "Fxn:torch.ones(5,";
    "Fxn:hook" -> "Fxn:self.assertTrue(hook_called[0])";
    "class:Inplace(InplaceFunction):" -> "Fxn:forward";
    "class:Inplace(InplaceFunction):" -> "Fxn:backward";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_leaf_assignment";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_no_grad_assignment";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_no_grad_modifies_version";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_backward_copy";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_functional_blas";
    "class:Inplace(InplaceFunction):" -> "Fxn:compare";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_blas_add";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_blas";
    "class:Inplace(InplaceFunction):" -> "Fxn:test_save_none_for_backward";
    "Fxn:forward" -> "Fxn:self.mark_dirty(a)";
    "Fxn:forward" -> "Fxn:a.add_(b),";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:Inplace(True)";
    "Fxn:backward" -> "Fxn:fn(x,";
    "Fxn:backward" -> "Fxn:self.assertIs(q,";
    "Fxn:backward" -> "Fxn:self.assertIs(q.grad_fn,";
    "Fxn:backward" -> "Fxn:self.assertTrue(q.requires_grad)";
    "Fxn:backward" -> "Fxn:q.sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:backward" -> "Fxn:torch.ones(5,";
    "Fxn:test_leaf_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_leaf_assignment" -> "Fxn:Variable(torch.randn(5),";
    "Fxn:test_leaf_assignment" -> "Fxn:Variable(torch.randn(5),";
    "Fxn:test_leaf_assignment" -> "Fxn:self.assertTrue(x.requires_grad)";
    "Fxn:test_leaf_assignment" -> "Fxn:self.assertIsNot(x.grad_fn,";
    "Fxn:test_leaf_assignment" -> "Fxn:x.sum().backward()";
    "Fxn:test_leaf_assignment" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_leaf_assignment" -> "Fxn:torch.ones(5))";
    "Fxn:test_leaf_assignment" -> "Fxn:self.assertEqual(z.grad.data,";
    "Fxn:test_leaf_assignment" -> "Fxn:torch.ones(5)";
    "Fxn:test_no_grad_assignment" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_no_grad_assignment" -> "Fxn:Variable(torch.randn(5))";
    "Fxn:test_no_grad_assignment" -> "Fxn:torch.no_grad():";
    "Fxn:test_no_grad_assignment" -> "Fxn:self.assertTrue(x.requires_grad)";
    "Fxn:test_no_grad_assignment" -> "Fxn:self.assertIsNone(x.grad_fn)";
    "Fxn:test_no_grad_modifies_version" -> "Fxn:Variable(torch.randn(5),";
    "Fxn:test_no_grad_modifies_version" -> "Fxn:Variable(torch.randn(5),";
    "Fxn:test_no_grad_modifies_version" -> "Fxn:y).sum()";
    "Fxn:test_no_grad_modifies_version" -> "Fxn:torch.no_grad():";
    "Fxn:test_no_grad_modifies_version" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_no_grad_modifies_version" -> "Fxn:z.backward())";
    "Fxn:test_backward_copy" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_backward_copy" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:test_backward_copy" -> "Fxn:torch.ones(5,";
    "Fxn:test_backward_copy" -> "Fxn:out.backward(grad_output)";
    "Fxn:test_backward_copy" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_backward_copy" -> "Fxn:torch.ones(5,";
    "Fxn:test_backward_copy" -> "Fxn:self.assertEqual(y.grad.data,";
    "Fxn:test_backward_copy" -> "Fxn:torch.ones(5,";
    "Fxn:compare" -> "Fxn:fn(*unpacked_args)";
    "Fxn:compare" -> "Fxn:fn(*args).data";
    "Fxn:compare" -> "Fxn:torch.is_tensor(unpacked_result):";
    "Fxn:compare" -> "Fxn:packed_result.dim()";
    "Fxn:compare" -> "Fxn:packed_result.nelement()";
    "Fxn:compare" -> "Fxn:self.assertEqual(packed_result,";
    "Fxn:test_blas_add" -> "Fxn:compare(fn,";
    "Fxn:test_blas_add" -> "Fxn:compare(fn,";
    "Fxn:test_blas_add" -> "Fxn:compare(fn,";
    "Fxn:test_blas" -> "Fxn:compare(fn,";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.mm,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_blas" -> "Fxn:test_blas_add(torch.addmm,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.bmm,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas" -> "Fxn:test_blas_add(torch.addbmm,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas" -> "Fxn:test_blas_add(torch.baddbmm,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.mv,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10)))";
    "Fxn:test_blas" -> "Fxn:test_blas_add(torch.addmv,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2)),";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10)))";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.ger,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(5)),";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(6)))";
    "Fxn:test_blas" -> "Fxn:test_blas_add(torch.addr,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(5)),";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(6)))";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(6)),";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(6)))";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(4)))";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(5)),";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10)))";
    "Fxn:test_blas" -> "Fxn:test_blas(torch.matmul,";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(10)),";
    "Fxn:test_blas" -> "Fxn:Variable(torch.randn(3,";
    "class:MyFn(Function):" -> "Fxn:forward";
    "class:MyFn(Function):" -> "Fxn:backward";
    "class:MyFn(Function):" -> "Fxn:test_too_many_grads";
    "Fxn:forward" -> "Fxn:self.save_for_backward(None,";
    "Fxn:backward" -> "Fxn:test_case.assertIsNone(n1)";
    "Fxn:backward" -> "Fxn:test_case.assertIsNone(n2)";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:MyFn()(x)";
    "Fxn:backward" -> "Fxn:y.sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "class:MyFn(Function):" -> "Fxn:forward";
    "class:MyFn(Function):" -> "Fxn:backward";
    "class:MyFn(Function):" -> "Fxn:test_pickle";
    "class:MyFn(Function):" -> "Fxn:assert_strict_equal";
    "class:MyFn(Function):" -> "Fxn:test_dep_nograd";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:backward" -> "Fxn:MyFn()(x)";
    "Fxn:backward" -> "Fxn:y.sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:backward" -> "Fxn:x.data.clone().fill_(1))";
    "Fxn:test_pickle" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_pickle" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:assert_strict_equal" -> "Fxn:self.assertEqual(var1.data,";
    "Fxn:assert_strict_equal" -> "Fxn:self.assertEqual(var1.requires_grad,";
    "Fxn:assert_strict_equal" -> "Fxn:[pickle.dumps([x,";
    "Fxn:assert_strict_equal" -> "Fxn:pickle.loads(dump)";
    "Fxn:assert_strict_equal" -> "Fxn:assert_strict_equal(xc,";
    "Fxn:assert_strict_equal" -> "Fxn:assert_strict_equal(yc,";
    "class:F1(Function):" -> "Fxn:forward";
    "class:F1(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(input.size()))";
    "Fxn:forward" -> "Fxn:self.mark_non_differentiable(out)";
    "class:F2(Function):" -> "Fxn:forward";
    "class:F2(Function):" -> "Fxn:backward";
    "class:F2(Function):" -> "Fxn:test_set_grad_enabled";
    "class:F2(Function):" -> "Fxn:test_reentrant";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(5),";
    "Fxn:backward" -> "Fxn:F1()(x)";
    "Fxn:backward" -> "Fxn:self.assertTrue(a.requires_grad)";
    "Fxn:backward" -> "Fxn:self.assertFalse(b.requires_grad)";
    "Fxn:backward" -> "Fxn:F2()(a,";
    "Fxn:backward" -> "Fxn:c.backward(torch.ones(c.size()))";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:backward" -> "Fxn:torch.ones(x.size()))";
    "Fxn:test_set_grad_enabled" -> "Fxn:torch.tensor([1],";
    "Fxn:test_set_grad_enabled" -> "Fxn:torch.set_grad_enabled(False):";
    "Fxn:test_set_grad_enabled" -> "Fxn:self.assertFalse(y.requires_grad)";
    "Fxn:test_set_grad_enabled" -> "Fxn:torch.set_grad_enabled(True):";
    "Fxn:test_set_grad_enabled" -> "Fxn:self.assertTrue(y.requires_grad)";
    "Fxn:test_set_grad_enabled" -> "Fxn:torch.set_grad_enabled(False):";
    "Fxn:test_set_grad_enabled" -> "Fxn:torch.set_grad_enabled(True)";
    "Fxn:test_set_grad_enabled" -> "Fxn:self.assertTrue(y.requires_grad)";
    "Fxn:test_reentrant" -> "Fxn:torch.randn(2,";
    "class:Reenter(Function):" -> "Fxn:forward";
    "class:Reenter(Function):" -> "Fxn:backward";
    "class:Reenter(Function):" -> "Fxn:test_cat";
    "class:Reenter(Function):" -> "Fxn:test_cat_negdim_1";
    "class:Reenter(Function):" -> "Fxn:test_cat_negdim_2";
    "class:Reenter(Function):" -> "Fxn:test_cat_empty";
    "class:Reenter(Function):" -> "Fxn:test_potrf";
    "class:Reenter(Function):" -> "Fxn:run_test";
    "class:Reenter(Function):" -> "Fxn:func";
    "class:Reenter(Function):" -> "Fxn:test_trtrs";
    "class:Reenter(Function):" -> "Fxn:_test_with_size";
    "class:Reenter(Function):" -> "Fxn:func";
    "class:Reenter(Function):" -> "Fxn:test_variable_traverse";
    "class:Reenter(Function):" -> "Fxn:get_out_and_unrefed_cycle";
    "class:Reenter(Function):" -> "Fxn:test_norm_subgradient";
    "class:Reenter(Function):" -> "Fxn:run_test";
    "class:Reenter(Function):" -> "Fxn:test_profiler";
    "class:Reenter(Function):" -> "Fxn:test_dir";
    "class:Reenter(Function):" -> "Fxn:test_as_strided";
    "class:Reenter(Function):" -> "Fxn:as_strided";
    "class:Reenter(Function):" -> "Fxn:_test_where_functional";
    "class:Reenter(Function):" -> "Fxn:where";
    "class:Reenter(Function):" -> "Fxn:test_where_functional";
    "class:Reenter(Function):" -> "Fxn:test_where_functional_cuda";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_backprop_base";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_backprop_view_of_view";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_of_view";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_gradcheck";
    "class:Reenter(Function):" -> "Fxn:func";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_makes_base_require_grad";
    "class:Reenter(Function):" -> "Fxn:func";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_backprop_view";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_modify_base";
    "class:Reenter(Function):" -> "Fxn:fn";
    "class:Reenter(Function):" -> "Fxn:test_inplace_view_python";
    "Fxn:forward" -> "Fxn:torch.enable_grad():";
    "Fxn:forward" -> "Fxn:Variable(x.data,";
    "Fxn:forward" -> "Fxn:Variable(y_data,";
    "Fxn:forward" -> "Fxn:ctx.output_var.detach()";
    "Fxn:backward" -> "Fxn:torch.enable_grad():";
    "Fxn:backward" -> "Fxn:ctx.output_var.sum().backward()";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:backward" -> "Fxn:Reenter.apply(x)";
    "Fxn:backward" -> "Fxn:out.sum().backward()";
    "Fxn:backward" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_cat" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_cat" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_cat" -> "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:test_cat" -> "Fxn:run_functional_checks(self,";
    "Fxn:test_cat" -> "Fxn:torch.cat((a,";
    "Fxn:test_cat_negdim_1" -> "Fxn:Variable(torch.randn(S,";
    "Fxn:test_cat_negdim_1" -> "Fxn:Variable(torch.randn(S,";
    "Fxn:test_cat_negdim_1" -> "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:test_cat_negdim_1" -> "Fxn:run_functional_checks(self,";
    "Fxn:test_cat_negdim_1" -> "Fxn:torch.cat((a,";
    "Fxn:test_cat_negdim_2" -> "Fxn:Variable(torch.randn(S,";
    "Fxn:test_cat_negdim_2" -> "Fxn:Variable(torch.randn(S,";
    "Fxn:test_cat_negdim_2" -> "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:test_cat_negdim_2" -> "Fxn:run_functional_checks(self,";
    "Fxn:test_cat_negdim_2" -> "Fxn:torch.cat((a,";
    "Fxn:test_cat_empty" -> "Fxn:Variable(torch.randn(S,";
    "Fxn:test_cat_empty" -> "Fxn:deepcopy(unpack_variables(f_args_variable))";
    "Fxn:test_cat_empty" -> "Fxn:run_functional_checks(self,";
    "Fxn:test_cat_empty" -> "Fxn:torch.cat((a,";
    "Fxn:test_cat_empty" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cat_empty" -> "Fxn:torch.cat((a,";
    "Fxn:test_potrf" -> "Fxn:Variable(torch.tril(torch.rand(S,";
    "Fxn:func" -> "Fxn:torch.mm(root,";
    "Fxn:func" -> "Fxn:root.t())";
    "Fxn:func" -> "Fxn:torch.potrf(x,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:func" -> "Fxn:run_test(upper=True)";
    "Fxn:func" -> "Fxn:run_test(upper=False)";
    "Fxn:_test_with_size" -> "Fxn:Variable(torch.rand(N,";
    "Fxn:_test_with_size" -> "Fxn:Variable(torch.rand(N,";
    "Fxn:_test_with_size" -> "Fxn:product((True,";
    "Fxn:func" -> "Fxn:torch.trtrs(b,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:func" -> "Fxn:_test_with_size(S,";
    "Fxn:func" -> "Fxn:_test_with_size(S,";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:Variable(torch.randn(10),";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:inp.view(10,";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:tmp.view(10)";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:my_list.append(tmp)";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:my_list.append(my_list)";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:get_out_and_unrefed_cycle()";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:gc.collect()";
    "Fxn:get_out_and_unrefed_cycle" -> "Fxn:out.backward(torch.randn(out.size()))";
    "Fxn:run_test" -> "Fxn:Variable(torch.zeros(*input_size),";
    "Fxn:run_test" -> "Fxn:input.norm(norm_deg).backward()";
    "Fxn:run_test" -> "Fxn:self.assertEqual(input.grad.data.abs().sum(),";
    "Fxn:run_test" -> "Fxn:run_test((10,),";
    "Fxn:run_test" -> "Fxn:run_test((10,";
    "Fxn:run_test" -> "Fxn:run_test((10,),";
    "Fxn:run_test" -> "Fxn:run_test((10,),";
    "Fxn:run_test" -> "Fxn:run_test((10,),";
    "Fxn:test_profiler" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_profiler" -> "Fxn:profile()";
    "Fxn:test_profiler" -> "Fxn:self.assertEqual(len(p.function_events),";
    "Fxn:test_profiler" -> "Fxn:self.assertGreater(info.cpu_interval.start,";
    "Fxn:test_profiler" -> "Fxn:self.assertEqual(info.name,";
    "Fxn:test_dir" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_dir" -> "Fxn:self.assertIn('shape',";
    "Fxn:test_dir" -> "Fxn:self.assertTrue(hasattr(x,";
    "Fxn:test_as_strided" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_as_strided" -> "Fxn:25).view(5,";
    "Fxn:as_strided" -> "Fxn:x.as_strided([3,";
    "Fxn:as_strided" -> "Fxn:gradcheck(as_strided,";
    "Fxn:as_strided" -> "Fxn:gradgradcheck(as_strided,";
    "Fxn:as_strided" -> "Fxn:[Variable(torch.randn(3,";
    "Fxn:_test_where_functional" -> "Fxn:Variable(t(torch.randn(5,";
    "Fxn:_test_where_functional" -> "Fxn:Variable(t(torch.randn(5,";
    "Fxn:_test_where_functional" -> "Fxn:Variable(t(mask_not_all_zeros((5,";
    "Fxn:where" -> "Fxn:torch.where(cond,";
    "Fxn:where" -> "Fxn:gradcheck(where,";
    "Fxn:where" -> "Fxn:gradgradcheck(where,";
    "Fxn:where" -> "Fxn:[Variable(t(torch.randn(5,";
    "Fxn:where" -> "Fxn:Variable(t(torch.randn(5,";
    "Fxn:where" -> "Fxn:Variable(t(torch.randn(5,";
    "Fxn:where" -> "Fxn:gradcheck(where,";
    "Fxn:where" -> "Fxn:gradgradcheck(where,";
    "Fxn:where" -> "Fxn:[Variable(t(torch.randn(5,";
    "Fxn:test_where_functional" -> "Fxn:self._test_where_functional(lambda";
    "Fxn:test_where_functional" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_where_functional" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_where_functional_cuda" -> "Fxn:self._test_where_functional(lambda";
    "Fxn:test_where_functional_cuda" -> "Fxn:t.cuda())";
    "Fxn:test_inplace_view_backprop_base" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_inplace_view_backprop_base" -> "Fxn:root.clone()";
    "Fxn:test_inplace_view_backprop_base" -> "Fxn:x.narrow(0,";
    "Fxn:test_inplace_view_backprop_base" -> "Fxn:v1.mul_(2)";
    "Fxn:test_inplace_view_backprop_base" -> "Fxn:x.sum().backward()";
    "Fxn:test_inplace_view_backprop_base" -> "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "Fxn:test_inplace_view_backprop_view_of_view" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_inplace_view_backprop_view_of_view" -> "Fxn:root.clone()";
    "Fxn:test_inplace_view_backprop_view_of_view" -> "Fxn:x.narrow(0,";
    "Fxn:test_inplace_view_backprop_view_of_view" -> "Fxn:x.narrow(0,";
    "Fxn:test_inplace_view_backprop_view_of_view" -> "Fxn:v1.mul_(2)";
    "Fxn:test_inplace_view_backprop_view_of_view" -> "Fxn:v2.sum().backward()";
    "Fxn:test_inplace_view_backprop_view_of_view" -> "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "Fxn:test_inplace_view_of_view" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_inplace_view_of_view" -> "Fxn:root.clone()";
    "Fxn:test_inplace_view_of_view" -> "Fxn:x.narrow(0,";
    "Fxn:test_inplace_view_of_view" -> "Fxn:v1.narrow(1,";
    "Fxn:test_inplace_view_of_view" -> "Fxn:v2.mul_(2)";
    "Fxn:test_inplace_view_of_view" -> "Fxn:x.sum().backward()";
    "Fxn:test_inplace_view_of_view" -> "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "Fxn:test_inplace_view_gradcheck" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_inplace_view_gradcheck" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:x.narrow(1,";
    "Fxn:func" -> "Fxn:2).narrow(0,";
    "Fxn:func" -> "Fxn:2).mul_(b)";
    "Fxn:func" -> "Fxn:x.narrow(1,";
    "Fxn:func" -> "Fxn:2).narrow(0,";
    "Fxn:func" -> "Fxn:2).mul_(b)";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:Variable(torch.randn(a.size()),";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_inplace_view_makes_base_require_grad" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_inplace_view_makes_base_require_grad" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:self.assertFalse(x.requires_grad)";
    "Fxn:func" -> "Fxn:x.narrow(1,";
    "Fxn:func" -> "Fxn:2).mul_(b)";
    "Fxn:func" -> "Fxn:self.assertTrue(x.requires_grad)";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:Variable(torch.randn(a.size()),";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_inplace_view_backprop_view" -> "Fxn:Variable(torch.Tensor([2,";
    "Fxn:test_inplace_view_backprop_view" -> "Fxn:Variable(torch.Tensor([3]),";
    "Fxn:test_inplace_view_backprop_view" -> "Fxn:a.narrow(0,";
    "Fxn:test_inplace_view_backprop_view" -> "Fxn:1).mul_(b)";
    "Fxn:test_inplace_view_backprop_view" -> "Fxn:res.sum().backward()";
    "Fxn:test_inplace_view_backprop_view" -> "Fxn:self.assertEqual(b.grad.data.tolist(),";
    "Fxn:test_inplace_view_backprop_view" -> "Fxn:self.assertIsNone(a.grad)";
    "Fxn:test_inplace_view_modify_base" -> "Fxn:Variable(torch.ones(1),";
    "Fxn:fn" -> "Fxn:Variable(torch.ones(5))";
    "Fxn:fn" -> "Fxn:x.select(0,";
    "Fxn:fn" -> "Fxn:self.assertFalse(v.requires_grad)";
    "Fxn:fn" -> "Fxn:self.assertIsNone(v.grad_fn)";
    "Fxn:fn" -> "Fxn:x.add_(r)";
    "Fxn:fn" -> "Fxn:self.assertTrue(v.requires_grad)";
    "Fxn:fn" -> "Fxn:gradcheck(fn,";
    "Fxn:fn" -> "Fxn:gradgradcheck(fn,";
    "Fxn:test_inplace_view_python" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_inplace_view_python" -> "Fxn:Variable(torch.randn(2,";
    "class:PyAdd(torch.autograd.Function):" -> "Fxn:forward";
    "class:PyAdd(torch.autograd.Function):" -> "Fxn:backward";
    "class:PyAdd(torch.autograd.Function):" -> "Fxn:func";
    "class:PyAdd(torch.autograd.Function):" -> "Fxn:test_inplace_view_non_contig";
    "class:PyAdd(torch.autograd.Function):" -> "Fxn:test_inplace_view_saved_output";
    "Fxn:forward" -> "Fxn:ctx.mark_dirty(x)";
    "Fxn:forward" -> "Fxn:x.add_(y)";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:PyAdd.apply(x.narrow(1,";
    "Fxn:func" -> "Fxn:2).narrow(0,";
    "Fxn:func" -> "Fxn:PyAdd.apply(x.narrow(1,";
    "Fxn:func" -> "Fxn:2).narrow(0,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:Variable(torch.randn(a.size()),";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:torch.ones(2,";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:2).select(2,";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:1).t()";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:Variable(data,";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:root.clone()";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:x.narrow(0,";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:v1.narrow(1,";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:v2.mul_(2)";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:x.sum().backward()";
    "Fxn:test_inplace_view_non_contig" -> "Fxn:self.assertEqual(root.grad.data.tolist(),";
    "class:IncrementOnDelete(object):" -> "Fxn:__del__";
    "class:IncrementOnDelete(object):" -> "Fxn:test";
    "class:IncrementOnDelete(object):" -> "Fxn:test_mul_out";
    "class:IncrementOnDelete(object):" -> "Fxn:test_mul_out_result_requires_grad";
    "class:IncrementOnDelete(object):" -> "Fxn:index_variable";
    "class:IncrementOnDelete(object):" -> "Fxn:index_perm_variable";
    "class:IncrementOnDelete(object):" -> "Fxn:gather_variable";
    "class:IncrementOnDelete(object):" -> "Fxn:mask_not_all_zeros";
    "class:IncrementOnDelete(object):" -> "Fxn:prod_zeros";
    "class:IncrementOnDelete(object):" -> "Fxn:prod_single_zero";
    "class:IncrementOnDelete(object):" -> "Fxn:random_square_matrix_of_rank";
    "class:IncrementOnDelete(object):" -> "Fxn:random_symmetric_matrix";
    "class:IncrementOnDelete(object):" -> "Fxn:random_symmetric_psd_matrix";
    "class:IncrementOnDelete(object):" -> "Fxn:random_symmetric_pd_matrix";
    "class:IncrementOnDelete(object):" -> "Fxn:make_nonzero_det";
    "class:IncrementOnDelete(object):" -> "Fxn:random_fullrank_matrix_distinct_singular_value";
    "class:IncrementOnDelete(object):" -> "Fxn:uniform_scalar";
    "class:IncrementOnDelete(object):" -> "Fxn:normal_scalar_clamp";
    "class:IncrementOnDelete(object):" -> "Fxn:bernoulli_scalar";
    "Fxn:test" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test" -> "Fxn:root.clone()";
    "Fxn:test" -> "Fxn:copy.grad_fn.register_hook(IncrementOnDelete())";
    "Fxn:test" -> "Fxn:copy.view(9)";
    "Fxn:test" -> "Fxn:torch.nn.functional.relu(view,";
    "Fxn:test" -> "Fxn:test()";
    "Fxn:test" -> "Fxn:self.assertEqual(dealloc[0],";
    "Fxn:test_mul_out" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_mul_out" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_mul_out" -> "Fxn:torch.zeros_like(a)";
    "Fxn:test_mul_out" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_mul_out" -> "Fxn:torch.mul(a,";
    "Fxn:test_mul_out" -> "Fxn:no_grad()";
    "Fxn:test_mul_out" -> "Fxn:torch.no_grad():";
    "Fxn:test_mul_out" -> "Fxn:torch.mul(a,";
    "Fxn:test_mul_out" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_mul_out_result_requires_grad" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_mul_out_result_requires_grad" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_mul_out_result_requires_grad" -> "Fxn:Variable(torch.zeros(2,";
    "Fxn:test_mul_out_result_requires_grad" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_mul_out_result_requires_grad" -> "Fxn:torch.mul(a,";
    "Fxn:index_variable" -> "Fxn:torch.rand(*shape).mul_(max_indices).floor_().long()";
    "Fxn:index_perm_variable" -> "Fxn:torch.randperm(max_indices).narrow(0,";
    "Fxn:index_perm_variable" -> "Fxn:reduce(mul,";
    "Fxn:index_perm_variable" -> "Fxn:shape)).view(shape)";
    "Fxn:gather_variable" -> "Fxn:torch.LongTensor(*shape)";
    "Fxn:gather_variable" -> "Fxn:index.select(index_dim,";
    "Fxn:gather_variable" -> "Fxn:i).copy_(";
    "Fxn:gather_variable" -> "Fxn:torch.randperm(max_indices)[:shape[batch_dim]])";
    "Fxn:gather_variable" -> "Fxn:index.select(batch_dim,";
    "Fxn:gather_variable" -> "Fxn:0).copy_(index.select(batch_dim,";
    "Fxn:mask_not_all_zeros" -> "Fxn:torch.randn(shape).gt(0)";
    "Fxn:mask_not_all_zeros" -> "Fxn:result.sum()";
    "Fxn:prod_zeros" -> "Fxn:torch.randn(dim_size,";
    "Fxn:prod_zeros" -> "Fxn:result.narrow(dim_select[0],";
    "Fxn:prod_zeros" -> "Fxn:1).narrow(dim_select[1],";
    "Fxn:prod_zeros" -> "Fxn:1).zero_()";
    "Fxn:prod_zeros" -> "Fxn:result.narrow(dim_select[0],";
    "Fxn:prod_zeros" -> "Fxn:1).narrow(dim_select[1],";
    "Fxn:prod_zeros" -> "Fxn:1).zero_()";
    "Fxn:prod_zeros" -> "Fxn:result.narrow(dim_select[0],";
    "Fxn:prod_zeros" -> "Fxn:1).narrow(dim_select[1],";
    "Fxn:prod_zeros" -> "Fxn:1).zero_()";
    "Fxn:prod_single_zero" -> "Fxn:torch.randn(dim_size,";
    "Fxn:random_square_matrix_of_rank" -> "Fxn:torch.randn(l,";
    "Fxn:random_square_matrix_of_rank" -> "Fxn:A.svd()";
    "Fxn:random_square_matrix_of_rank" -> "Fxn:u.mm(torch.diag(s)).mm(v.transpose(0,";
    "Fxn:random_symmetric_matrix" -> "Fxn:torch.randn(l,";
    "Fxn:random_symmetric_psd_matrix" -> "Fxn:torch.randn(l,";
    "Fxn:random_symmetric_psd_matrix" -> "Fxn:A.mm(A.transpose(0,";
    "Fxn:random_symmetric_pd_matrix" -> "Fxn:torch.randn(l,";
    "Fxn:random_symmetric_pd_matrix" -> "Fxn:A.mm(A.transpose(0,";
    "Fxn:random_symmetric_pd_matrix" -> "Fxn:torch.eye(l)";
    "Fxn:make_nonzero_det" -> "Fxn:A.svd()";
    "Fxn:make_nonzero_det" -> "Fxn:u.mm(torch.diag(s)).mm(v.t())";
    "Fxn:make_nonzero_det" -> "Fxn:A.det().item()";
    "Fxn:make_nonzero_det" -> "Fxn::].neg_()";
    "Fxn:random_fullrank_matrix_distinct_singular_value" -> "Fxn:torch.randn(l,";
    "Fxn:random_fullrank_matrix_distinct_singular_value" -> "Fxn:A.svd()";
    "Fxn:random_fullrank_matrix_distinct_singular_value" -> "Fxn:torch.arange(1,";
    "Fxn:random_fullrank_matrix_distinct_singular_value" -> "Fxn:1).mul_(1.0";
    "Fxn:random_fullrank_matrix_distinct_singular_value" -> "Fxn:u.mm(torch.diag(s)).mm(v.t())";
    "Fxn:uniform_scalar" -> "Fxn:torch.tensor(0).uniform_(0,";
    "Fxn:normal_scalar_clamp" -> "Fxn:torch.tensor(0).normal_().clamp(amin,";
    "Fxn:bernoulli_scalar" -> "Fxn:torch.tensor(0,";
    "Fxn:bernoulli_scalar" -> "Fxn:dtype=torch.uint8).bernoulli_()";
    "class:dont_convert(tuple):" -> "Fxn:create_input";
    "class:dont_convert(tuple):" -> "Fxn:map_arg";
    "class:dont_convert(tuple):" -> "Fxn:maybe_non_contig";
    "class:dont_convert(tuple):" -> "Fxn:unpack_variables";
    "class:dont_convert(tuple):" -> "Fxn:exclude_tensor_method";
    "class:dont_convert(tuple):" -> "Fxn:gradgradcheck_method_precision_override";
    "class:dont_convert(tuple):" -> "Fxn:run_grad_and_gradgrad_checks";
    "class:dont_convert(tuple):" -> "Fxn:run_functional_checks";
    "class:dont_convert(tuple):" -> "Fxn:do_test";
    "class:dont_convert(tuple):" -> "Fxn:check";
    "class:dont_convert(tuple):" -> "Fxn:fn";
    "class:dont_convert(tuple):" -> "Fxn:fn";
    "Fxn:maybe_non_contig" -> "Fxn:make_non_contiguous(tensor)";
    "Fxn:maybe_non_contig" -> "Fxn:torch.tensor(1).double().normal_()";
    "Fxn:maybe_non_contig" -> "Fxn:torch.is_tensor(arg[0])";
    "Fxn:maybe_non_contig" -> "Fxn:Variable(maybe_non_contig(torch.randn(*arg).double()),";
    "Fxn:maybe_non_contig" -> "Fxn:maybe_non_contig(arg.tensor)";
    "Fxn:maybe_non_contig" -> "Fxn:Variable(maybe_non_contig(arg.tensor))";
    "Fxn:maybe_non_contig" -> "Fxn:arg.double()";
    "Fxn:maybe_non_contig" -> "Fxn:maybe_non_contig(arg).detach()";
    "Fxn:maybe_non_contig" -> "Fxn:v.is_floating_point()";
    "Fxn:maybe_non_contig" -> "Fxn:map_arg(arg())";
    "Fxn:gradgradcheck_method_precision_override" -> "Fxn:test_name.split("_broadcast")[0]";
    "Fxn:gradgradcheck_method_precision_override" -> "Fxn:gradgradcheck_precision_override.get(non_broadcasted_test_name)";
    "Fxn:run_grad_and_gradgrad_checks" -> "Fxn:test_case.assertTrue(gradcheck(apply_method,";
    "Fxn:run_grad_and_gradgrad_checks" -> "Fxn:gradgradcheck_method_precision_override(test_name)";
    "Fxn:run_grad_and_gradgrad_checks" -> "Fxn:test_case.assertTrue(gradgradcheck(apply_method,";
    "Fxn:run_grad_and_gradgrad_checks" -> "Fxn:test_case.assertTrue(gradgradcheck(apply_method,";
    "Fxn:run_functional_checks" -> "Fxn:apply_fn(*f_args_variable)";
    "Fxn:run_functional_checks" -> "Fxn:run_grad_and_gradgrad_checks(test_case,";
    "Fxn:run_functional_checks" -> "Fxn:output_variable.backward(randn_like(output_variable))";
    "Fxn:run_functional_checks" -> "Fxn:test_case.assertEqual(self_variable.type(),";
    "Fxn:run_functional_checks" -> "Fxn:self_variable.grad.type())";
    "Fxn:run_functional_checks" -> "Fxn:test_case.assertEqual(self_variable.size(),";
    "Fxn:run_functional_checks" -> "Fxn:self_variable.grad.size())";
    "Fxn:run_functional_checks" -> "Fxn:product([-1,";
    "Fxn:run_functional_checks" -> "Fxn:repeat=len(dim_args_idx)):";
    "Fxn:run_functional_checks" -> "Fxn:dim_perm[dim_args_idx.index(i)]";
    "Fxn:run_functional_checks" -> "Fxn:''.join('_neg'";
    "Fxn:check" -> "Fxn:create_input((self_size,))[0]";
    "Fxn:check" -> "Fxn:create_input(args,";
    "Fxn:check" -> "Fxn:deepcopy(self_variable.data)";
    "Fxn:check" -> "Fxn:deepcopy(unpack_variables(args_variable))";
    "Fxn:check" -> "Fxn:name)(*args_variable)";
    "Fxn:check" -> "Fxn:exclude_tensor_method(name,";
    "Fxn:check" -> "Fxn:name)(*args_tensor)";
    "Fxn:check" -> "Fxn:torch.is_tensor(output_tensor)";
    "Fxn:check" -> "Fxn:torch.DoubleTensor((output_tensor,))";
    "Fxn:check" -> "Fxn:self.assertEqual(unpack_variables(output_variable),";
    "Fxn:fn" -> "Fxn:name)(*inputs[1:])";
    "Fxn:fn" -> "Fxn:run_grad_and_gradgrad_checks(self,";
    "Fxn:fn" -> "Fxn:name)(*inputs)";
    "Fxn:fn" -> "Fxn:run_functional_checks(self,";
    "Fxn:fn" -> "Fxn:create_input((self_size,),";
    "Fxn:fn" -> "Fxn:create_input(args,";
    "Fxn:fn" -> "Fxn:name)(*args_variable)";
    "Fxn:fn" -> "Fxn:output_variable.backward(randn_like(output_variable))";
    "Fxn:fn" -> "Fxn:self.assertTrue(type(self_variable.data)";
    "Fxn:fn" -> "Fxn:self.assertTrue(self_variable.size()";
    "Fxn:fn" -> "Fxn:self_variable.grad.size())";
    "Fxn:fn" -> "Fxn:name)(*args_variable)";
    "Fxn:fn" -> "Fxn:deepcopy(self_variable)";
    "Fxn:fn" -> "Fxn:deepcopy(args_variable)";
    "Fxn:fn" -> "Fxn:inplace_name)(*inplace_args_variable_copy))";
    "Fxn:fn" -> "Fxn:self.assertEqual(inplace_output_variable,";
    "Fxn:fn" -> "Fxn:inp_i.grad.data.zero_()";
    "Fxn:fn" -> "Fxn:i.grad.data.zero_()";
    "Fxn:fn" -> "Fxn:randn_like(io).double()";
    "Fxn:fn" -> "Fxn:io.backward(grad)";
    "Fxn:fn" -> "Fxn:o.backward(grad)";
    "Fxn:fn" -> "Fxn:self.assertEqual(inp_i.grad,";
    "Fxn:fn" -> "Fxn:check(name)";
    "Fxn:fn" -> "Fxn:check(inplace_name)";
    "Fxn:fn" -> "Fxn:skip(do_test)";
    "Fxn:fn" -> "Fxn:run_tests()";
    "/test/test_cpp_extensions.py" -> "Import:unittest";
    "/test/test_cpp_extensions.py" -> "Import:torch";
    "/test/test_cpp_extensions.py" -> "Import:torch.utils.cpp_extension";
    "/test/test_cpp_extensions.py" -> "Import:torch_test_cpp_extension";
    "/test/test_cpp_extensions.py" -> "Import:common";
    "/test/test_cpp_extensions.py" -> "class:TestCppExtension(common.TestCase):";
    "/test/test_cpp_extensions.py" -> "Import:torch_test_cuda_extension";
    "class:TestCppExtension(common.TestCase):" -> "Fxn:test_extension_function";
    "class:TestCppExtension(common.TestCase):" -> "Fxn:test_extension_module";
    "class:TestCppExtension(common.TestCase):" -> "Fxn:test_backward";
    "class:TestCppExtension(common.TestCase):" -> "Fxn:test_jit_compile_extension";
    "class:TestCppExtension(common.TestCase):" -> "Fxn:test_cuda_extension";
    "class:TestCppExtension(common.TestCase):" -> "Fxn:test_jit_cuda_extension";
    "Fxn:test_extension_function" -> "Fxn:torch.randn(4,";
    "Fxn:test_extension_function" -> "Fxn:torch.randn(4,";
    "Fxn:test_extension_function" -> "Fxn:cpp_extension.sigmoid_add(x,";
    "Fxn:test_extension_function" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_extension_function" -> "Fxn:x.sigmoid()";
    "Fxn:test_extension_function" -> "Fxn:y.sigmoid())";
    "Fxn:test_extension_module" -> "Fxn:cpp_extension.MatrixMultiplier(4,";
    "Fxn:test_extension_module" -> "Fxn:torch.rand(8,";
    "Fxn:test_extension_module" -> "Fxn:mm.get().mm(weights)";
    "Fxn:test_extension_module" -> "Fxn:mm.forward(weights)";
    "Fxn:test_extension_module" -> "Fxn:self.assertEqual(expected,";
    "Fxn:test_backward" -> "Fxn:cpp_extension.MatrixMultiplier(4,";
    "Fxn:test_backward" -> "Fxn:torch.rand(8,";
    "Fxn:test_backward" -> "Fxn:mm.forward(weights)";
    "Fxn:test_backward" -> "Fxn:result.sum().backward()";
    "Fxn:test_backward" -> "Fxn:mm.get()";
    "Fxn:test_backward" -> "Fxn:tensor.t().mm(torch.ones([4,";
    "Fxn:test_backward" -> "Fxn:self.assertEqual(weights.grad,";
    "Fxn:test_backward" -> "Fxn:torch.ones([4,";
    "Fxn:test_backward" -> "Fxn:4]).mm(weights.t())";
    "Fxn:test_backward" -> "Fxn:self.assertEqual(tensor.grad,";
    "Fxn:test_jit_compile_extension" -> "Fxn:torch.utils.cpp_extension.load(";
    "Fxn:test_jit_compile_extension" -> "Fxn:torch.randn(4,";
    "Fxn:test_jit_compile_extension" -> "Fxn:torch.randn(4,";
    "Fxn:test_jit_compile_extension" -> "Fxn:module.tanh_add(x,";
    "Fxn:test_jit_compile_extension" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_jit_compile_extension" -> "Fxn:x.tanh()";
    "Fxn:test_jit_compile_extension" -> "Fxn:y.tanh())";
    "Fxn:test_jit_compile_extension" -> "Fxn:module.exp_add(x,";
    "Fxn:test_jit_compile_extension" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_jit_compile_extension" -> "Fxn:x.exp()";
    "Fxn:test_jit_compile_extension" -> "Fxn:y.exp())";
    "Fxn:test_jit_compile_extension" -> "Fxn:module.Doubler(2,";
    "Fxn:test_jit_compile_extension" -> "Fxn:self.assertIsNone(doubler.get().grad)";
    "Fxn:test_jit_compile_extension" -> "Fxn:self.assertEqual(doubler.get().sum(),";
    "Fxn:test_jit_compile_extension" -> "Fxn:self.assertEqual(doubler.forward().sum(),";
    "Fxn:test_jit_compile_extension" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_extension" -> "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:test_cuda_extension" -> "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:test_cuda_extension" -> "Fxn:cuda_extension.sigmoid_add(x,";
    "Fxn:test_cuda_extension" -> "Fxn:y).cpu()";
    "Fxn:test_cuda_extension" -> "Fxn:sigmoid(0)";
    "Fxn:test_cuda_extension" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_cuda_extension" -> "Fxn:torch.ones_like(z))";
    "Fxn:test_cuda_extension" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_jit_cuda_extension" -> "Fxn:torch.utils.cpp_extension.load(";
    "Fxn:test_jit_cuda_extension" -> "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:test_jit_cuda_extension" -> "Fxn:torch.FloatTensor(100).zero_().cuda()";
    "Fxn:test_jit_cuda_extension" -> "Fxn:module.sigmoid_add(x,";
    "Fxn:test_jit_cuda_extension" -> "Fxn:y).cpu()";
    "Fxn:test_jit_cuda_extension" -> "Fxn:sigmoid(0)";
    "Fxn:test_jit_cuda_extension" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_jit_cuda_extension" -> "Fxn:torch.ones_like(z))";
    "Fxn:test_jit_cuda_extension" -> "Fxn:common.run_tests()";
    "/test/test_cuda.py" -> "Import:math";
    "/test/test_cuda.py" -> "Import:tempfile";
    "/test/test_cuda.py" -> "Import:import";
    "/test/test_cuda.py" -> "Import:unittest";
    "/test/test_cuda.py" -> "Import:repeat";
    "/test/test_cuda.py" -> "Import:torch";
    "/test/test_cuda.py" -> "Import:torch.cuda";
    "/test/test_cuda.py" -> "Import:torch.cuda.comm";
    "/test/test_cuda.py" -> "Import:TestTorch";
    "/test/test_cuda.py" -> "Import:TestCase,";
    "/test/test_cuda.py" -> "Fxn:is_floating";
    "/test/test_cuda.py" -> "Fxn:is_half";
    "/test/test_cuda.py" -> "Fxn:number";
    "/test/test_cuda.py" -> "Fxn:make_tensor";
    "/test/test_cuda.py" -> "Fxn:make_sparse_tensor";
    "/test/test_cuda.py" -> "Fxn:tensor_clamp";
    "/test/test_cuda.py" -> "Fxn:tensor_mul";
    "/test/test_cuda.py" -> "Fxn:tensor_abs_";
    "/test/test_cuda.py" -> "Fxn:constant_tensor_sub";
    "/test/test_cuda.py" -> "Fxn:constant_tensor_add";
    "/test/test_cuda.py" -> "Fxn:small_2d";
    "/test/test_cuda.py" -> "Fxn:small_2d_scaled";
    "/test/test_cuda.py" -> "Fxn:small_2d_oneish";
    "/test/test_cuda.py" -> "Fxn:small_3d";
    "/test/test_cuda.py" -> "Fxn:medium_1d";
    "/test/test_cuda.py" -> "Fxn:medium_2d";
    "/test/test_cuda.py" -> "Fxn:medium_2d_expanded";
    "/test/test_cuda.py" -> "Fxn:medium_2d_scaled";
    "/test/test_cuda.py" -> "Fxn:small_3d_ones";
    "/test/test_cuda.py" -> "Fxn:small_3d_positive";
    "/test/test_cuda.py" -> "Fxn:small_3d_unique";
    "/test/test_cuda.py" -> "Fxn:small_1d_lapack";
    "/test/test_cuda.py" -> "Fxn:small_2d_lapack";
    "/test/test_cuda.py" -> "Fxn:small_2d_lapack_skinny";
    "/test/test_cuda.py" -> "Fxn:small_2d_lapack_fat";
    "/test/test_cuda.py" -> "Fxn:large_2d_lapack";
    "/test/test_cuda.py" -> "Fxn:long_type";
    "/test/test_cuda.py" -> "Fxn:new_t";
    "/test/test_cuda.py" -> "Fxn:tmp";
    "/test/test_cuda.py" -> "Fxn:get_cycles_per_ms";
    "/test/test_cuda.py" -> "Fxn:compare_cpu_gpu";
    "/test/test_cuda.py" -> "Fxn:tmp";
    "/test/test_cuda.py" -> "class:TestCuda(TestCase):";
    "/test/test_cuda.py" -> "Import:join,";
    "class:TestCuda(TestCase):" -> "Fxn:_test_memory_stats_generator";
    "class:TestCuda(TestCase):" -> "Fxn:alloc";
    "class:TestCuda(TestCase):" -> "Fxn:assert_change";
    "class:TestCuda(TestCase):" -> "Fxn:test_memory_stats";
    "class:TestCuda(TestCase):" -> "Fxn:test_memory_stats_multigpu";
    "class:TestCuda(TestCase):" -> "Fxn:advance";
    "class:TestCuda(TestCase):" -> "Fxn:test_autogpu";
    "class:TestCuda(TestCase):" -> "Fxn:test_new";
    "class:TestCuda(TestCase):" -> "Fxn:test_copy_device";
    "class:TestCuda(TestCase):" -> "Fxn:test_serialization_array_with_storage";
    "class:TestCuda(TestCase):" -> "Fxn:test_type_conversions";
    "class:TestCuda(TestCase):" -> "Fxn:test_type_conversions_same_gpu";
    "class:TestCuda(TestCase):" -> "Fxn:test_neg";
    "class:TestCuda(TestCase):" -> "Fxn:_test_broadcast";
    "class:TestCuda(TestCase):" -> "Fxn:test_broadcast_cpu";
    "class:TestCuda(TestCase):" -> "Fxn:test_broadcast_gpu";
    "class:TestCuda(TestCase):" -> "Fxn:_test_broadcast_coalesced";
    "class:TestCuda(TestCase):" -> "Fxn:test_broadcast_coalesced";
    "class:TestCuda(TestCase):" -> "Fxn:test_broadcast_coalesced_dense_only";
    "class:TestCuda(TestCase):" -> "Fxn:test_reduce_add";
    "class:TestCuda(TestCase):" -> "Fxn:_test_reduce_add_coalesced";
    "class:TestCuda(TestCase):" -> "Fxn:test_reduce_add_coalesced";
    "class:TestCuda(TestCase):" -> "Fxn:test_reduce_add_coalesced_dense_only";
    "class:TestCuda(TestCase):" -> "Fxn:_test_scatter";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_cpu";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_cpu_dim";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_cpu_neg_dim";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_cpu_sizes";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_gpu";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_gpu_dim";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_gpu_neg_dim";
    "class:TestCuda(TestCase):" -> "Fxn:test_scatter_gpu_sizes";
    "class:TestCuda(TestCase):" -> "Fxn:_test_gather";
    "class:TestCuda(TestCase):" -> "Fxn:test_gather";
    "class:TestCuda(TestCase):" -> "Fxn:test_gather_dim";
    "class:TestCuda(TestCase):" -> "Fxn:test_from_sequence";
    "class:TestCuda(TestCase):" -> "Fxn:test_torch_manual_seed_seeds_cuda_devices";
    "class:TestCuda(TestCase):" -> "Fxn:test_manual_seed";
    "class:TestCuda(TestCase):" -> "Fxn:test_cat_autogpu";
    "class:TestCuda(TestCase):" -> "Fxn:test_cat";
    "class:TestCuda(TestCase):" -> "Fxn:test_bernoulli";
    "class:TestCuda(TestCase):" -> "Fxn:test_cat_bad_input_sizes";
    "class:TestCuda(TestCase):" -> "Fxn:test_serialization";
    "class:TestCuda(TestCase):" -> "Fxn:test_serialization_array_with_empty";
    "class:TestCuda(TestCase):" -> "Fxn:test_multigpu_serialization";
    "class:TestCuda(TestCase):" -> "Fxn:test_multigpu_serialization_remap";
    "class:TestCuda(TestCase):" -> "Fxn:gpu_remap";
    "class:TestCuda(TestCase):" -> "Fxn:test_multigpu_serialization_remap_dict";
    "class:TestCuda(TestCase):" -> "Fxn:test_cuda_set_device";
    "class:TestCuda(TestCase):" -> "Fxn:test_is_tensor";
    "class:TestCuda(TestCase):" -> "Fxn:test_cuda_synchronize";
    "class:TestCuda(TestCase):" -> "Fxn:test_streams";
    "class:TestCuda(TestCase):" -> "Fxn:test_streams_multi_gpu";
    "class:TestCuda(TestCase):" -> "Fxn:test_tensor_device";
    "class:TestCuda(TestCase):" -> "Fxn:test_events";
    "class:TestCuda(TestCase):" -> "Fxn:test_record_stream";
    "class:TestCuda(TestCase):" -> "Fxn:perform_copy";
    "class:TestCuda(TestCase):" -> "Fxn:test_noncontiguous_pinned_memory";
    "class:TestCuda(TestCase):" -> "Fxn:test_caching_pinned_memory";
    "class:TestCuda(TestCase):" -> "Fxn:test_caching_pinned_memory_multi_gpu";
    "class:TestCuda(TestCase):" -> "Fxn:_select_broadcastable_dims";
    "class:TestCuda(TestCase):" -> "Fxn:test_det_logdet_slogdet";
    "class:TestCuda(TestCase):" -> "Fxn:test_view";
    "class:TestCuda(TestCase):" -> "Fxn:test_stft";
    "class:TestCuda(TestCase):" -> "Fxn:test_multinomial";
    "class:TestCuda(TestCase):" -> "Fxn:test_broadcast";
    "class:TestCuda(TestCase):" -> "Fxn:test_contiguous";
    "class:TestCuda(TestCase):" -> "Fxn:test_broadcast_fused_matmul";
    "class:TestCuda(TestCase):" -> "Fxn:test_broadcast_batched_matmul";
    "class:TestCuda(TestCase):" -> "Fxn:test_index";
    "class:TestCuda(TestCase):" -> "Fxn:test_advancedindex";
    "class:TestCuda(TestCase):" -> "Fxn:test_advancedindex_mixed_cpu_cuda";
    "class:TestCuda(TestCase):" -> "Fxn:test";
    "class:TestCuda(TestCase):" -> "Fxn:test_advancedindex_big";
    "class:TestCuda(TestCase):" -> "Fxn:test_btrifact";
    "class:TestCuda(TestCase):" -> "Fxn:test_btrisolve";
    "class:TestCuda(TestCase):" -> "Fxn:test_dim_reduction";
    "class:TestCuda(TestCase):" -> "Fxn:test_tensor_gather";
    "class:TestCuda(TestCase):" -> "Fxn:test_tensor_scatter";
    "class:TestCuda(TestCase):" -> "Fxn:test_tensor_scatterAdd";
    "class:TestCuda(TestCase):" -> "Fxn:test_tensor_scatterFill";
    "class:TestCuda(TestCase):" -> "Fxn:test_min_max_inits";
    "class:TestCuda(TestCase):" -> "Fxn:test_int_pow";
    "class:TestCuda(TestCase):" -> "Fxn:test_var";
    "class:TestCuda(TestCase):" -> "Fxn:test_var_unbiased";
    "class:TestCuda(TestCase):" -> "Fxn:test_var_large_input";
    "class:TestCuda(TestCase):" -> "Fxn:test_var_stability";
    "class:TestCuda(TestCase):" -> "Fxn:test_digamma";
    "class:TestCuda(TestCase):" -> "Fxn:test";
    "class:TestCuda(TestCase):" -> "Fxn:test_polygamma";
    "class:TestCuda(TestCase):" -> "Fxn:test";
    "class:TestCuda(TestCase):" -> "Fxn:test_symeig";
    "class:TestCuda(TestCase):" -> "Fxn:test_arange";
    "class:TestCuda(TestCase):" -> "Fxn:test_diagonal";
    "class:TestCuda(TestCase):" -> "Fxn:test_diagflat";
    "class:TestCuda(TestCase):" -> "Fxn:test_get_set_rng_state_all";
    "class:TestCuda(TestCase):" -> "Fxn:test_nvtx";
    "class:TestCuda(TestCase):" -> "Fxn:load_ignore_file";
    "class:TestCuda(TestCase):" -> "Fxn:generate_tests";
    "Fxn:_test_memory_stats_generator" -> "Fxn:torch.cuda.current_device()";
    "Fxn:_test_memory_stats_generator" -> "Fxn:torch.cuda.memory_allocated(device)";
    "Fxn:_test_memory_stats_generator" -> "Fxn:[torch.cuda.memory_allocated(device)]";
    "Fxn:_test_memory_stats_generator" -> "Fxn:[torch.cuda.max_memory_allocated(device)]";
    "Fxn:_test_memory_stats_generator" -> "Fxn:[torch.cuda.memory_cached(device)]";
    "Fxn:_test_memory_stats_generator" -> "Fxn:[torch.cuda.max_memory_cached(device)]";
    "Fxn:alloc" -> "Fxn:torch.cuda.device(device):";
    "Fxn:alloc" -> "Fxn:torch.cuda.FloatTensor(*size)";
    "Fxn:assert_change" -> "Fxn:torch.cuda.memory_allocated(device)";
    "Fxn:assert_change" -> "Fxn:torch.cuda.max_memory_allocated(device)";
    "Fxn:assert_change" -> "Fxn:self.assertGreater(new_m,";
    "Fxn:assert_change" -> "Fxn:self.assertLess(new_m,";
    "Fxn:assert_change" -> "Fxn:self.assertEqual(new_m,";
    "Fxn:assert_change" -> "Fxn:self.assertLessEqual(new_m,";
    "Fxn:assert_change" -> "Fxn:self.assertGreaterEqual(new_max_m,";
    "Fxn:assert_change" -> "Fxn:torch.cuda.memory_cached(device)";
    "Fxn:assert_change" -> "Fxn:torch.cuda.max_memory_cached(device)";
    "Fxn:assert_change" -> "Fxn:self.assertLessEqual(new_c,";
    "Fxn:assert_change" -> "Fxn:self.assertGreaterEqual(new_max_c,";
    "Fxn:assert_change" -> "Fxn:torch.cuda.empty_cache()";
    "Fxn:assert_change" -> "Fxn:torch.cuda.memory_cached(device)";
    "Fxn:assert_change" -> "Fxn:torch.cuda.max_memory_cached(device)";
    "Fxn:assert_change" -> "Fxn:self.assertLessEqual(new_c,";
    "Fxn:assert_change" -> "Fxn:self.assertLessEqual(new_c,";
    "Fxn:assert_change" -> "Fxn:self.assertEqual(new_max_c,";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:[alloc(1),";
    "Fxn:assert_change" -> "Fxn:alloc(10,";
    "Fxn:assert_change" -> "Fxn:alloc(200,";
    "Fxn:assert_change" -> "Fxn:torch.cuda.memory_allocated(device)";
    "Fxn:assert_change" -> "Fxn:assert_change(1)";
    "Fxn:assert_change" -> "Fxn:tensors2.append(alloc(i,";
    "Fxn:assert_change" -> "Fxn:assert_change(1)";
    "Fxn:assert_change" -> "Fxn:tensors2.append(alloc(i,";
    "Fxn:assert_change" -> "Fxn:assert_change(1)";
    "Fxn:assert_change" -> "Fxn:tensors2.append(alloc(0,";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:torch.randperm(len(tensors2)):";
    "Fxn:assert_change" -> "Fxn:permute.append(tensors2[i])";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:tensors2[i].numel()";
    "Fxn:assert_change" -> "Fxn:assert_change(-x)";
    "Fxn:assert_change" -> "Fxn:tensors2.append(alloc(i,";
    "Fxn:assert_change" -> "Fxn:assert_change(1)";
    "Fxn:assert_change" -> "Fxn:assert_change(-1)";
    "Fxn:assert_change" -> "Fxn:assert_change(0)";
    "Fxn:assert_change" -> "Fxn:self.assertEqual(torch.cuda.memory_allocated(device),";
    "Fxn:assert_change" -> "Fxn:assert_change(-1)";
    "Fxn:assert_change" -> "Fxn:self.assertEqual(torch.cuda.memory_allocated(device),";
    "Fxn:assert_change" -> "Fxn:assert_change(0,";
    "Fxn:test_memory_stats" -> "Fxn:torch.cuda.empty_cache()";
    "Fxn:test_memory_stats" -> "Fxn:self._test_memory_stats_generator(self):";
    "Fxn:test_memory_stats" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:advance" -> "Fxn:torch.cuda.empty_cache()";
    "Fxn:advance" -> "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:advance" -> "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:advance" -> "Fxn:advance(gen0,";
    "Fxn:advance" -> "Fxn:advance(gen1,";
    "Fxn:advance" -> "Fxn:torch.cuda.empty_cache()";
    "Fxn:advance" -> "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:advance" -> "Fxn:self._test_memory_stats_generator(self,";
    "Fxn:advance" -> "Fxn:advance(gen0,";
    "Fxn:advance" -> "Fxn:torch.LongTensor(1).random_(0,";
    "Fxn:advance" -> "Fxn:advance(gen1,";
    "Fxn:advance" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_autogpu" -> "Fxn:torch.randn(5,";
    "Fxn:test_autogpu" -> "Fxn:5).cuda()";
    "Fxn:test_autogpu" -> "Fxn:torch.randn(5,";
    "Fxn:test_autogpu" -> "Fxn:5).cuda()";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:test_autogpu" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_autogpu" -> "Fxn:torch.randn(5,";
    "Fxn:test_autogpu" -> "Fxn:5).cuda()";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:test_autogpu" -> "Fxn:x.add(y)";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(q.get_device(),";
    "Fxn:test_autogpu" -> "Fxn:torch.randn(5,";
    "Fxn:test_autogpu" -> "Fxn:5).cuda()";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(w.get_device(),";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(y.cuda().get_device(),";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(y.cuda(-1).get_device(),";
    "Fxn:test_autogpu" -> "Fxn:z.cuda()";
    "Fxn:test_autogpu" -> "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:test_autogpu" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_new" -> "Fxn:torch.randn(3,";
    "Fxn:test_new" -> "Fxn:3).cuda()";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([0,";
    "Fxn:test_new" -> "Fxn:2]).get_device(),";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([0,";
    "Fxn:test_new" -> "Fxn:device=1).get_device(),";
    "Fxn:test_new" -> "Fxn:x.new(dtype=torch.cuda.int64,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(y.dtype,";
    "Fxn:test_new" -> "Fxn:x.new(dtype=torch.int64)";
    "Fxn:test_new" -> "Fxn:self.assertIs(y.dtype,";
    "Fxn:test_new" -> "Fxn:x.new(1,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(y.dtype,";
    "Fxn:test_new" -> "Fxn:x.new(1,";
    "Fxn:test_new" -> "Fxn:self.assertIs(y.dtype,";
    "Fxn:test_new" -> "Fxn:x.new([0,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(y.dtype,";
    "Fxn:test_new" -> "Fxn:x.new([0,";
    "Fxn:test_new" -> "Fxn:self.assertIs(y.dtype,";
    "Fxn:test_new" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([0,";
    "Fxn:test_new" -> "Fxn:2]).get_device(),";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([0,";
    "Fxn:test_new" -> "Fxn:device=1).get_device(),";
    "Fxn:test_new" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_copy_device" -> "Fxn:torch.randn(5,";
    "Fxn:test_copy_device" -> "Fxn:5).cuda()";
    "Fxn:test_copy_device" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_copy_device" -> "Fxn:x.cuda()";
    "Fxn:test_copy_device" -> "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:test_copy_device" -> "Fxn:self.assertIs(y.cuda(),";
    "Fxn:test_copy_device" -> "Fxn:y.cuda(0)";
    "Fxn:test_copy_device" -> "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:test_copy_device" -> "Fxn:self.assertIs(z.cuda(0),";
    "Fxn:test_copy_device" -> "Fxn:torch.randn(5,";
    "Fxn:test_copy_device" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_copy_device" -> "Fxn:x.cuda()";
    "Fxn:test_copy_device" -> "Fxn:self.assertEqual(y.get_device(),";
    "Fxn:test_copy_device" -> "Fxn:self.assertIs(y.cuda(),";
    "Fxn:test_copy_device" -> "Fxn:y.cuda(0)";
    "Fxn:test_copy_device" -> "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:test_copy_device" -> "Fxn:self.assertIs(z.cuda(0),";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:torch.randn(5,";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:5).cuda()";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:torch.IntTensor(2,";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:5).fill_(0).cuda()";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:y.storage()]";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:torch.save(q,";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:f.seek(0)";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:torch.load(f)";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:self.assertEqual(q_copy,";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:q_copy[0].fill_(5)";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:self.assertEqual(q_copy[0],";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:self.assertTrue(isinstance(q_copy[0],";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:self.assertTrue(isinstance(q_copy[1],";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:self.assertTrue(isinstance(q_copy[2],";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:self.assertTrue(isinstance(q_copy[3],";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:q_copy[1].fill_(10)";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:self.assertTrue(q_copy[3],";
    "Fxn:test_serialization_array_with_storage" -> "Fxn:torch.cuda.IntStorage(10).fill_(10))";
    "Fxn:test_type_conversions" -> "Fxn:torch.randn(5,";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.float(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.cuda(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.cuda().float(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.cuda().float().cpu(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(x.cuda().float().cpu().int(),";
    "Fxn:test_type_conversions" -> "Fxn:x.storage()";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(y.float(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(y.cuda(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(y.cuda().float(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(y.cuda().float().cpu(),";
    "Fxn:test_type_conversions" -> "Fxn:self.assertIsInstance(y.cuda().float().cpu().int(),";
    "Fxn:test_type_conversions" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_type_conversions_same_gpu" -> "Fxn:torch.randn(5,";
    "Fxn:test_type_conversions_same_gpu" -> "Fxn:5).cuda(1)";
    "Fxn:test_type_conversions_same_gpu" -> "Fxn:self.assertEqual(x.int().get_device(),";
    "Fxn:test_neg" -> "Fxn:TestTorch._test_neg(self,";
    "Fxn:test_neg" -> "Fxn:t.cuda())";
    "Fxn:_test_broadcast" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_test_broadcast" -> "Fxn:unittest.SkipTest("only";
    "Fxn:_test_broadcast" -> "Fxn:comm.broadcast(input,";
    "Fxn:_test_broadcast" -> "Fxn:self.assertEqual(t.get_device(),";
    "Fxn:_test_broadcast" -> "Fxn:self.assertEqual(t,";
    "Fxn:test_broadcast_cpu" -> "Fxn:self._test_broadcast(torch.randn(5,";
    "Fxn:test_broadcast_gpu" -> "Fxn:self._test_broadcast(torch.randn(5,";
    "Fxn:test_broadcast_gpu" -> "Fxn:5).cuda())";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:[comm.broadcast(t,";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:self.assertEqual(bt.get_device(),";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:self.assertEqual(bt,";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:self.assertIsInstance(bt,";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:comm.broadcast_coalesced(tensors,";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:self.assertEqual(b_tensors,";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:self.assertEqual(bt.get_device(),";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:bct.get_device())";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:self.assertIsInstance(bct,";
    "Fxn:_test_broadcast_coalesced" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_broadcast_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:test_broadcast_coalesced" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_broadcast_coalesced" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_broadcast_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:test_broadcast_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:test_broadcast_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:test_broadcast_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.FloatTensor,";
    "Fxn:test_broadcast_coalesced" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_broadcast_coalesced" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_broadcast_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:test_broadcast_coalesced" -> "Fxn:torch.randn(numel";
    "Fxn:test_broadcast_coalesced" -> "Fxn:2).int().cuda(),";
    "Fxn:test_broadcast_coalesced" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_broadcast_coalesced" -> "Fxn:self._test_broadcast_coalesced(self,";
    "Fxn:test_broadcast_coalesced" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:torch.randn(numel";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:2).int().cuda(),";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:self._test_broadcast_coalesced(self,";
    "Fxn:test_broadcast_coalesced_dense_only" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_reduce_add" -> "Fxn:torch.randn(5,";
    "Fxn:test_reduce_add" -> "Fxn:torch.randn(5,";
    "Fxn:test_reduce_add" -> "Fxn:x.cuda(0)";
    "Fxn:test_reduce_add" -> "Fxn:y.cuda(1)";
    "Fxn:test_reduce_add" -> "Fxn:comm.reduce_add((x_cuda,";
    "Fxn:test_reduce_add" -> "Fxn:self.assertEqual(result.get_device(),";
    "Fxn:test_reduce_add" -> "Fxn:self.assertEqual(result.cpu(),";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:t.cuda(1),";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:self.assertEqual(r.get_device(),";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:t.get_device())";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:self.assertEqual(r,";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:self.assertEqual(r.type(),";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:t.type())";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:comm.reduce_add_coalesced(dup_tensors,";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:self.assertEqual(r_tensors,";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:self.assertEqual(rc.get_device(),";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:r.get_device())";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:self.assertEqual(rc.type(),";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:r.type())";
    "Fxn:_test_reduce_add_coalesced" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.DoubleTensor,";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.FloatTensor,";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:make_sparse_tensor(torch.cuda.sparse.LongTensor,";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:torch.randn(numel";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:2).int().cuda(),";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:self._test_reduce_add_coalesced(self,";
    "Fxn:test_reduce_add_coalesced" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:torch.randn(numel).long().cuda(),";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:torch.randn(numel";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:2).int().cuda(),";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:torch.randn(numel).cuda(),";
    "Fxn:test_reduce_add_coalesced_dense_only" -> "Fxn:self._test_reduce_add_coalesced(self,";
    "Fxn:_test_scatter" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_test_scatter" -> "Fxn:unittest.SkipTest("only";
    "Fxn:_test_scatter" -> "Fxn:comm.scatter(input,";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(len(result),";
    "Fxn:_test_scatter" -> "Fxn:[slice(None,";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(r,";
    "Fxn:_test_scatter" -> "Fxn:input[tuple(index)],";
    "Fxn:test_scatter_cpu" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_cpu_dim" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_cpu_neg_dim" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_cpu_sizes" -> "Fxn:self._test_scatter(torch.randn(6,";
    "Fxn:test_scatter_cpu_sizes" -> "Fxn:chunk_sizes=(2,";
    "Fxn:test_scatter_gpu" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_gpu" -> "Fxn:4).cuda(),";
    "Fxn:test_scatter_gpu_dim" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_gpu_dim" -> "Fxn:4).cuda(),";
    "Fxn:test_scatter_gpu_neg_dim" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_gpu_neg_dim" -> "Fxn:4).cuda(),";
    "Fxn:test_scatter_gpu_sizes" -> "Fxn:self._test_scatter(torch.randn(6,";
    "Fxn:test_scatter_gpu_sizes" -> "Fxn:4).cuda(),";
    "Fxn:test_scatter_gpu_sizes" -> "Fxn:chunk_sizes=(2,";
    "Fxn:_test_gather" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_test_gather" -> "Fxn:unittest.SkipTest("only";
    "Fxn:_test_gather" -> "Fxn:torch.randn(2,";
    "Fxn:_test_gather" -> "Fxn:5).cuda(0)";
    "Fxn:_test_gather" -> "Fxn:torch.randn(2,";
    "Fxn:_test_gather" -> "Fxn:5).cuda(1)";
    "Fxn:_test_gather" -> "Fxn:comm.gather((x,";
    "Fxn:_test_gather" -> "Fxn:y.size(dim)";
    "Fxn:_test_gather" -> "Fxn:torch.Size(expected_size)";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result.get_device(),";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result.size(),";
    "Fxn:_test_gather" -> "Fxn:[slice(None,";
    "Fxn:_test_gather" -> "Fxn:x.size(dim))";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result[tuple(index)],";
    "Fxn:_test_gather" -> "Fxn:x.size(dim)";
    "Fxn:_test_gather" -> "Fxn:y.size(dim))";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result[tuple(index)],";
    "Fxn:test_gather" -> "Fxn:self._test_gather(0)";
    "Fxn:test_gather_dim" -> "Fxn:self._test_gather(1)";
    "Fxn:test_from_sequence" -> "Fxn:[list(range(i";
    "Fxn:test_from_sequence" -> "Fxn:torch.arange(0,";
    "Fxn:test_from_sequence" -> "Fxn:20).resize_(5,";
    "Fxn:test_from_sequence" -> "Fxn:get_gpu_type(t)";
    "Fxn:test_from_sequence" -> "Fxn:self.assertEqual(cuda_type(seq),";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:freeze_rng_state():";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:torch.zeros(4,";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:4).float().cuda()";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:torch.manual_seed(2)";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:x.uniform_()";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:torch.manual_seed(2)";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:x.clone().uniform_()";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_torch_manual_seed_seeds_cuda_devices" -> "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:test_manual_seed" -> "Fxn:freeze_rng_state():";
    "Fxn:test_manual_seed" -> "Fxn:torch.zeros(4,";
    "Fxn:test_manual_seed" -> "Fxn:4).float().cuda()";
    "Fxn:test_manual_seed" -> "Fxn:torch.cuda.manual_seed(2)";
    "Fxn:test_manual_seed" -> "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:test_manual_seed" -> "Fxn:x.uniform_()";
    "Fxn:test_manual_seed" -> "Fxn:torch.cuda.manual_seed(2)";
    "Fxn:test_manual_seed" -> "Fxn:x.clone().uniform_()";
    "Fxn:test_manual_seed" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_manual_seed" -> "Fxn:self.assertEqual(torch.cuda.initial_seed(),";
    "Fxn:test_manual_seed" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_cat_autogpu" -> "Fxn:torch.randn(4,";
    "Fxn:test_cat_autogpu" -> "Fxn:4).cuda(1)";
    "Fxn:test_cat_autogpu" -> "Fxn:torch.randn(4,";
    "Fxn:test_cat_autogpu" -> "Fxn:4).cuda(1)";
    "Fxn:test_cat_autogpu" -> "Fxn:torch.cat([x,";
    "Fxn:test_cat_autogpu" -> "Fxn:self.assertEqual(z.get_device(),";
    "Fxn:test_cat_autogpu" -> "Fxn:x.get_device())";
    "Fxn:test_cat" -> "Fxn:torch.rand(13,";
    "Fxn:test_cat" -> "Fxn:SIZE).transpose(0,";
    "Fxn:test_cat" -> "Fxn:pos_dim).cuda()";
    "Fxn:test_cat" -> "Fxn:torch.rand(17,";
    "Fxn:test_cat" -> "Fxn:SIZE).transpose(0,";
    "Fxn:test_cat" -> "Fxn:pos_dim).cuda()";
    "Fxn:test_cat" -> "Fxn:torch.rand(19,";
    "Fxn:test_cat" -> "Fxn:SIZE).transpose(0,";
    "Fxn:test_cat" -> "Fxn:pos_dim).cuda()";
    "Fxn:test_cat" -> "Fxn:torch.cat((x,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:test_cat" -> "Fxn:torch.randn(20,";
    "Fxn:test_cat" -> "Fxn:SIZE).cuda()";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(torch.cat(torch.split(x,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(torch.cat(torch.chunk(x,";
    "Fxn:test_cat" -> "Fxn:torch.randn(1,";
    "Fxn:test_cat" -> "Fxn:SIZE).cuda()";
    "Fxn:test_cat" -> "Fxn:torch.cat([x,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(z.size(),";
    "Fxn:test_bernoulli" -> "Fxn:torch.tensor([0,";
    "Fxn:test_bernoulli" -> "Fxn:self.assertEqual(x.bernoulli().tolist(),";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:1).cuda()";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:1).cuda()";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:1).cuda()";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.cat([x,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:2).cuda()";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:1).cuda()";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:1).cuda()";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.cat([x,";
    "Fxn:test_serialization" -> "Fxn:torch.randn(4,";
    "Fxn:test_serialization" -> "Fxn:4).cuda()";
    "Fxn:test_serialization" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_serialization" -> "Fxn:torch.save(x,";
    "Fxn:test_serialization" -> "Fxn:f.seek(0)";
    "Fxn:test_serialization" -> "Fxn:torch.load(f)";
    "Fxn:test_serialization" -> "Fxn:self.assertEqual(x_copy,";
    "Fxn:test_serialization" -> "Fxn:self.assertIs(type(x_copy),";
    "Fxn:test_serialization" -> "Fxn:self.assertEqual(x_copy.get_device(),";
    "Fxn:test_serialization" -> "Fxn:x.get_device())";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:[torch.randn(4,";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:4).cuda(),";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:torch.cuda.FloatTensor()]";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:torch.save(x,";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:f.seek(0)";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:torch.load(f)";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:self.assertEqual(copy,";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:self.assertIs(type(copy),";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:original.get_device())";
    "Fxn:test_serialization_array_with_empty" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_multigpu_serialization" -> "Fxn:[torch.randn(4,";
    "Fxn:test_multigpu_serialization" -> "Fxn:4).cuda(0),";
    "Fxn:test_multigpu_serialization" -> "Fxn:torch.randn(4,";
    "Fxn:test_multigpu_serialization" -> "Fxn:4).cuda(1)]";
    "Fxn:test_multigpu_serialization" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_multigpu_serialization" -> "Fxn:torch.save(x,";
    "Fxn:test_multigpu_serialization" -> "Fxn:f.seek(0)";
    "Fxn:test_multigpu_serialization" -> "Fxn:torch.load(f)";
    "Fxn:test_multigpu_serialization" -> "Fxn:self.assertEqual(copy,";
    "Fxn:test_multigpu_serialization" -> "Fxn:self.assertIs(type(copy),";
    "Fxn:test_multigpu_serialization" -> "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:test_multigpu_serialization" -> "Fxn:original.get_device())";
    "Fxn:test_multigpu_serialization" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_multigpu_serialization_remap" -> "Fxn:[torch.randn(4,";
    "Fxn:test_multigpu_serialization_remap" -> "Fxn:4).cuda(0),";
    "Fxn:test_multigpu_serialization_remap" -> "Fxn:torch.randn(4,";
    "Fxn:test_multigpu_serialization_remap" -> "Fxn:4).cuda(1)]";
    "Fxn:gpu_remap" -> "Fxn:storage.cuda(0)";
    "Fxn:gpu_remap" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:gpu_remap" -> "Fxn:torch.save(x,";
    "Fxn:gpu_remap" -> "Fxn:f.seek(0)";
    "Fxn:gpu_remap" -> "Fxn:torch.load(f,";
    "Fxn:gpu_remap" -> "Fxn:self.assertEqual(copy,";
    "Fxn:gpu_remap" -> "Fxn:self.assertIs(type(copy),";
    "Fxn:gpu_remap" -> "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:gpu_remap" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:[torch.randn(4,";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:4).cuda(0),";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:torch.randn(4,";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:4).cuda(1)]";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:torch.save(x,";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:f.seek(0)";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:torch.load(f,";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:self.assertEqual(copy,";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:self.assertIs(type(copy),";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:self.assertEqual(copy.get_device(),";
    "Fxn:test_multigpu_serialization_remap_dict" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_cuda_set_device" -> "Fxn:torch.randn(5,";
    "Fxn:test_cuda_set_device" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_cuda_set_device" -> "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:test_cuda_set_device" -> "Fxn:torch.cuda.set_device(0)";
    "Fxn:test_cuda_set_device" -> "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:test_cuda_set_device" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_cuda_set_device" -> "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:test_cuda_set_device" -> "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:test_cuda_set_device" -> "Fxn:torch.cuda.set_device(1)";
    "Fxn:test_cuda_set_device" -> "Fxn:self.assertEqual(x.cuda().get_device(),";
    "Fxn:test_is_tensor" -> "Fxn:get_gpu_type(t)()";
    "Fxn:test_is_tensor" -> "Fxn:self.assertTrue(torch.is_tensor(tensor))";
    "Fxn:test_is_tensor" -> "Fxn:self.assertTrue(torch.is_tensor(torch.cuda.HalfTensor()))";
    "Fxn:test_cuda_synchronize" -> "Fxn:torch.cuda.synchronize()";
    "Fxn:test_streams" -> "Fxn:torch.cuda.current_stream()";
    "Fxn:test_streams" -> "Fxn:torch.cuda.Stream()";
    "Fxn:test_streams" -> "Fxn:self.assertEqual(torch.cuda.current_stream(),";
    "Fxn:test_streams" -> "Fxn:self.assertNotEqual(default_stream,";
    "Fxn:test_streams" -> "Fxn:self.assertEqual(default_stream.cuda_stream,";
    "Fxn:test_streams" -> "Fxn:self.assertNotEqual(user_stream.cuda_stream,";
    "Fxn:test_streams" -> "Fxn:torch.cuda.stream(user_stream):";
    "Fxn:test_streams" -> "Fxn:self.assertEqual(torch.cuda.current_stream(),";
    "Fxn:test_streams" -> "Fxn:self.assertTrue(user_stream.query())";
    "Fxn:test_streams" -> "Fxn:torch.ByteTensor(10000000).pin_memory()";
    "Fxn:test_streams" -> "Fxn:tensor1.cuda(non_blocking=True)";
    "Fxn:test_streams" -> "Fxn:self.assertFalse(default_stream.query())";
    "Fxn:test_streams" -> "Fxn:default_stream.synchronize()";
    "Fxn:test_streams" -> "Fxn:self.assertTrue(default_stream.query())";
    "Fxn:test_streams" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_streams_multi_gpu" -> "Fxn:torch.cuda.current_stream()";
    "Fxn:test_streams_multi_gpu" -> "Fxn:self.assertEqual(default_stream.device,";
    "Fxn:test_streams_multi_gpu" -> "Fxn:torch.cuda.Stream(device=1)";
    "Fxn:test_streams_multi_gpu" -> "Fxn:self.assertEqual(stream.device,";
    "Fxn:test_streams_multi_gpu" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_streams_multi_gpu" -> "Fxn:self.assertEqual(torch.cuda.current_stream().device,";
    "Fxn:test_streams_multi_gpu" -> "Fxn:self.assertNotEqual(torch.cuda.current_stream(),";
    "Fxn:test_streams_multi_gpu" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_tensor_device" -> "Fxn:self.assertEqual(torch.cuda.FloatTensor(1).get_device(),";
    "Fxn:test_tensor_device" -> "Fxn:self.assertEqual(torch.cuda.FloatTensor(1,";
    "Fxn:test_tensor_device" -> "Fxn:device=1).get_device(),";
    "Fxn:test_tensor_device" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_tensor_device" -> "Fxn:self.assertEqual(torch.cuda.FloatTensor(1).get_device(),";
    "Fxn:test_tensor_device" -> "Fxn:self.assertEqual(torch.cuda.FloatTensor(1,";
    "Fxn:test_tensor_device" -> "Fxn:device=0).get_device(),";
    "Fxn:test_tensor_device" -> "Fxn:self.assertEqual(torch.cuda.FloatTensor(1,";
    "Fxn:test_tensor_device" -> "Fxn:device=None).get_device(),";
    "Fxn:test_events" -> "Fxn:torch.cuda.current_stream()";
    "Fxn:test_events" -> "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:test_events" -> "Fxn:self.assertTrue(event.query())";
    "Fxn:test_events" -> "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:test_events" -> "Fxn:stream.record_event(start_event)";
    "Fxn:test_events" -> "Fxn:torch.cuda._sleep(int(50";
    "Fxn:test_events" -> "Fxn:get_cycles_per_ms()))";
    "Fxn:test_events" -> "Fxn:stream.record_event(event)";
    "Fxn:test_events" -> "Fxn:self.assertFalse(event.query())";
    "Fxn:test_events" -> "Fxn:event.synchronize()";
    "Fxn:test_events" -> "Fxn:self.assertTrue(event.query())";
    "Fxn:test_events" -> "Fxn:self.assertGreater(start_event.elapsed_time(event),";
    "Fxn:test_record_stream" -> "Fxn:get_cycles_per_ms()";
    "Fxn:test_record_stream" -> "Fxn:torch.FloatTensor([1,";
    "Fxn:test_record_stream" -> "Fxn:4]).pin_memory()";
    "Fxn:test_record_stream" -> "Fxn:torch.cuda.FloatTensor(t.size())";
    "Fxn:test_record_stream" -> "Fxn:torch.cuda.Stream()";
    "Fxn:perform_copy" -> "Fxn:torch.cuda.stream(stream):";
    "Fxn:perform_copy" -> "Fxn:t.cuda(non_blocking=True)";
    "Fxn:perform_copy" -> "Fxn:tmp.data_ptr()";
    "Fxn:perform_copy" -> "Fxn:torch.cuda.current_stream().wait_stream(stream)";
    "Fxn:perform_copy" -> "Fxn:tmp.record_stream(torch.cuda.current_stream())";
    "Fxn:perform_copy" -> "Fxn:torch.cuda._sleep(int(50";
    "Fxn:perform_copy" -> "Fxn:result.copy_(tmp)";
    "Fxn:perform_copy" -> "Fxn:perform_copy()";
    "Fxn:perform_copy" -> "Fxn:torch.cuda.stream(stream):";
    "Fxn:perform_copy" -> "Fxn:torch.cuda.FloatTensor(t.size())";
    "Fxn:perform_copy" -> "Fxn:tmp2.zero_()";
    "Fxn:perform_copy" -> "Fxn:self.assertNotEqual(tmp2.data_ptr(),";
    "Fxn:perform_copy" -> "Fxn:self.assertEqual(result.tolist(),";
    "Fxn:perform_copy" -> "Fxn:torch.cuda.current_stream().synchronize()";
    "Fxn:perform_copy" -> "Fxn:torch.cuda.stream(stream):";
    "Fxn:perform_copy" -> "Fxn:torch.cuda.FloatTensor(t.size())";
    "Fxn:perform_copy" -> "Fxn:self.assertEqual(tmp3.data_ptr(),";
    "Fxn:test_noncontiguous_pinned_memory" -> "Fxn:torch.arange(0,";
    "Fxn:test_noncontiguous_pinned_memory" -> "Fxn:10).view((2,";
    "Fxn:test_noncontiguous_pinned_memory" -> "Fxn:self.assertEqual(x.t(),";
    "Fxn:test_noncontiguous_pinned_memory" -> "Fxn:x.t().pin_memory())";
    "Fxn:test_caching_pinned_memory" -> "Fxn:get_cycles_per_ms()";
    "Fxn:test_caching_pinned_memory" -> "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:test_caching_pinned_memory" -> "Fxn:t.data_ptr()";
    "Fxn:test_caching_pinned_memory" -> "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:test_caching_pinned_memory" -> "Fxn:self.assertEqual(t.data_ptr(),";
    "Fxn:test_caching_pinned_memory" -> "Fxn:torch.cuda.FloatTensor([0])";
    "Fxn:test_caching_pinned_memory" -> "Fxn:torch.cuda._sleep(int(50";
    "Fxn:test_caching_pinned_memory" -> "Fxn:gpu_tensor.copy_(t,";
    "Fxn:test_caching_pinned_memory" -> "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:test_caching_pinned_memory" -> "Fxn:self.assertNotEqual(t.data_ptr(),";
    "Fxn:test_caching_pinned_memory" -> "Fxn:self.assertEqual(list(gpu_tensor),";
    "Fxn:test_caching_pinned_memory" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:get_cycles_per_ms()";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:torch.FloatTensor([1]).pin_memory()";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:t.data_ptr()";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:torch.cuda.FloatTensor([0],";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:torch.cuda.FloatTensor([0],";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:torch.cuda.device(1):";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:torch.cuda._sleep(int(50";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:gpu_tensor1.copy_(t,";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:torch.FloatTensor([2]).pin_memory()";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:self.assertNotEqual(t.data_ptr(),";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:torch.cuda.device(0):";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:gpu_tensor0.copy_(t,";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:self.assertEqual(gpu_tensor1[0],";
    "Fxn:test_caching_pinned_memory_multi_gpu" -> "Fxn:self.assertEqual(gpu_tensor0[0],";
    "Fxn:_select_broadcastable_dims" -> "Fxn:TestTorch._select_broadcastable_dims(dims_full)";
    "Fxn:_select_broadcastable_dims" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_det_logdet_slogdet" -> "Fxn:TestTorch._test_det_logdet_slogdet(self,";
    "Fxn:test_det_logdet_slogdet" -> "Fxn:t.cuda())";
    "Fxn:test_view" -> "Fxn:TestTorch._test_view(self,";
    "Fxn:test_view" -> "Fxn:t.cuda())";
    "Fxn:test_stft" -> "Fxn:TestTorch._test_stft(self,";
    "Fxn:test_stft" -> "Fxn:t.cuda())";
    "Fxn:test_multinomial" -> "Fxn:TestTorch._test_multinomial(self,";
    "Fxn:test_broadcast" -> "Fxn:TestTorch._test_broadcast(self,";
    "Fxn:test_broadcast" -> "Fxn:t.cuda())";
    "Fxn:test_contiguous" -> "Fxn:TestTorch._test_contiguous(self,";
    "Fxn:test_contiguous" -> "Fxn:t.cuda())";
    "Fxn:test_broadcast_fused_matmul" -> "Fxn:TestTorch._test_broadcast_fused_matmul(self,";
    "Fxn:test_broadcast_fused_matmul" -> "Fxn:t.cuda())";
    "Fxn:test_broadcast_batched_matmul" -> "Fxn:TestTorch._test_broadcast_batched_matmul(self,";
    "Fxn:test_broadcast_batched_matmul" -> "Fxn:t.cuda())";
    "Fxn:test_index" -> "Fxn:TestTorch._test_index(self,";
    "Fxn:test_index" -> "Fxn:t.cuda())";
    "Fxn:test_advancedindex" -> "Fxn:TestTorch._test_advancedindex(self,";
    "Fxn:test_advancedindex" -> "Fxn:t.cuda())";
    "Fxn:test" -> "Fxn:self.assertEqual(x[:,";
    "Fxn:test" -> "Fxn:0].cpu(),";
    "Fxn:test" -> "Fxn:x.cpu()[:,";
    "Fxn:test" -> "Fxn:ia.cpu(),";
    "Fxn:test" -> "Fxn:ib.cpu(),";
    "Fxn:test" -> "Fxn:self.assertEqual(x[ia],";
    "Fxn:test" -> "Fxn:x.cpu()[ia.cpu()])";
    "Fxn:test" -> "Fxn:torch.randn(3,";
    "Fxn:test" -> "Fxn:torch.cuda.LongTensor([0,";
    "Fxn:test" -> "Fxn:torch.cuda.LongTensor([0,";
    "Fxn:test" -> "Fxn:test(x,";
    "Fxn:test" -> "Fxn:x.cuda()";
    "Fxn:test" -> "Fxn:ia.cpu()";
    "Fxn:test" -> "Fxn:ib.cpu()";
    "Fxn:test" -> "Fxn:test(x,";
    "Fxn:test" -> "Fxn:x.cpu()";
    "Fxn:test" -> "Fxn:ia.cpu()";
    "Fxn:test" -> "Fxn:ib.cuda()";
    "Fxn:test" -> "Fxn:test(x,";
    "Fxn:test" -> "Fxn:x.cuda()";
    "Fxn:test" -> "Fxn:ia.cpu()";
    "Fxn:test" -> "Fxn:ib.cuda()";
    "Fxn:test" -> "Fxn:test(x,";
    "Fxn:test_advancedindex_big" -> "Fxn:TestTorch._test_advancedindex_big(self,";
    "Fxn:test_advancedindex_big" -> "Fxn:t.cuda())";
    "Fxn:test_btrifact" -> "Fxn:TestTorch._test_btrifact(self,";
    "Fxn:test_btrifact" -> "Fxn:t.cuda())";
    "Fxn:test_btrisolve" -> "Fxn:TestTorch._test_btrisolve(self,";
    "Fxn:test_btrisolve" -> "Fxn:t.cuda())";
    "Fxn:test_dim_reduction" -> "Fxn:TestTorch._test_dim_reduction(self,";
    "Fxn:test_dim_reduction" -> "Fxn:t.cuda())";
    "Fxn:test_tensor_gather" -> "Fxn:TestTorch._test_gather(self,";
    "Fxn:test_tensor_gather" -> "Fxn:t.cuda(),";
    "Fxn:test_tensor_scatter" -> "Fxn:TestTorch._test_scatter_base(self,";
    "Fxn:test_tensor_scatter" -> "Fxn:t.cuda(),";
    "Fxn:test_tensor_scatterAdd" -> "Fxn:TestTorch._test_scatter_base(self,";
    "Fxn:test_tensor_scatterAdd" -> "Fxn:t.cuda(),";
    "Fxn:test_tensor_scatterFill" -> "Fxn:TestTorch._test_scatter_base(self,";
    "Fxn:test_tensor_scatterFill" -> "Fxn:t.cuda(),";
    "Fxn:test_min_max_inits" -> "Fxn:torch.cuda.ByteTensor([0])";
    "Fxn:test_min_max_inits" -> "Fxn:torch.cuda.ByteTensor([255])";
    "Fxn:test_min_max_inits" -> "Fxn:torch.cuda.LongTensor([0])[0]";
    "Fxn:test_min_max_inits" -> "Fxn:x.max(dim=0)";
    "Fxn:test_min_max_inits" -> "Fxn:self.assertEqual(v,";
    "Fxn:test_min_max_inits" -> "Fxn:y.min(dim=0)";
    "Fxn:test_min_max_inits" -> "Fxn:self.assertEqual(v,";
    "Fxn:test_int_pow" -> "Fxn:TestTorch._test_int_pow(self,";
    "Fxn:test_int_pow" -> "Fxn:x.cuda())";
    "Fxn:test_var" -> "Fxn:torch.randn(2,";
    "Fxn:test_var" -> "Fxn:cpu_tensor.cuda()";
    "Fxn:test_var" -> "Fxn:self.assertEqual(gpu_tensor.var(),";
    "Fxn:test_var" -> "Fxn:cpu_tensor.var())";
    "Fxn:test_var" -> "Fxn:self.assertEqual(gpu_tensor.var(1),";
    "Fxn:test_var" -> "Fxn:cpu_tensor.var(1))";
    "Fxn:test_var" -> "Fxn:self.assertEqual(gpu_tensor.var(2),";
    "Fxn:test_var" -> "Fxn:cpu_tensor.var(2))";
    "Fxn:test_var" -> "Fxn:self.assertEqual(gpu_tensor.std(),";
    "Fxn:test_var" -> "Fxn:cpu_tensor.std())";
    "Fxn:test_var" -> "Fxn:self.assertEqual(gpu_tensor.std(1),";
    "Fxn:test_var" -> "Fxn:cpu_tensor.std(1))";
    "Fxn:test_var" -> "Fxn:self.assertEqual(gpu_tensor.var(2),";
    "Fxn:test_var" -> "Fxn:cpu_tensor.var(2))";
    "Fxn:test_var" -> "Fxn:torch.randn(100)";
    "Fxn:test_var" -> "Fxn:cpu_tensor.cuda()";
    "Fxn:test_var" -> "Fxn:self.assertEqual(gpu_tensor.var(),";
    "Fxn:test_var" -> "Fxn:cpu_tensor.var())";
    "Fxn:test_var_unbiased" -> "Fxn:torch.randn(100).cuda()";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:test_var_unbiased" -> "Fxn:tensor.var(0,";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:test_var_unbiased" -> "Fxn:tensor.var(unbiased=True))";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:test_var_unbiased" -> "Fxn:tensor.var(0,";
    "Fxn:test_var_unbiased" -> "Fxn:torch.FloatTensor([1.0,";
    "Fxn:test_var_unbiased" -> "Fxn:2.0]).cuda()";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=True),";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:test_var_unbiased" -> "Fxn:torch.randn(100).cuda()";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.std(0),";
    "Fxn:test_var_unbiased" -> "Fxn:tensor.std(0,";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.std(),";
    "Fxn:test_var_unbiased" -> "Fxn:tensor.std(unbiased=True))";
    "Fxn:test_var_unbiased" -> "Fxn:self.assertEqual(tensor.std(unbiased=False),";
    "Fxn:test_var_unbiased" -> "Fxn:tensor.std(0,";
    "Fxn:test_var_large_input" -> "Fxn:torch.randn(2";
    "Fxn:test_var_large_input" -> "Fxn:tensor_cpu.cuda()";
    "Fxn:test_var_large_input" -> "Fxn:self.assertEqual(tensor_cpu.var(2),";
    "Fxn:test_var_large_input" -> "Fxn:tensor_cuda.var(2).cpu())";
    "Fxn:test_var_stability" -> "Fxn:torch.FloatTensor([2281.5,";
    "Fxn:test_var_stability" -> "Fxn:2281.25]).cuda()";
    "Fxn:test_var_stability" -> "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:test_var_stability" -> "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:test_var_stability" -> "Fxn:tensor.unsqueeze(1)";
    "Fxn:test_var_stability" -> "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:test" -> "Fxn:torch.randn(10,";
    "Fxn:test" -> "Fxn:cpu_tensor.cuda()";
    "Fxn:test" -> "Fxn:torch.zeros(10,";
    "Fxn:test" -> "Fxn:cpu_tensor.double()";
    "Fxn:test" -> "Fxn:gpu_tensor.double()";
    "Fxn:test" -> "Fxn:zeros.double()";
    "Fxn:test" -> "Fxn:cpu_tensor.digamma()";
    "Fxn:test" -> "Fxn:gpu_tensor.digamma()";
    "Fxn:test" -> "Fxn:cpu_out.cuda())";
    "Fxn:test" -> "Fxn:self.assertEqual(norm_errors,";
    "Fxn:test" -> "Fxn:test(True)";
    "Fxn:test" -> "Fxn:test(False)";
    "Fxn:test" -> "Fxn:torch.randn(10,";
    "Fxn:test" -> "Fxn:cpu_tensor.cuda()";
    "Fxn:test" -> "Fxn:torch.zeros(10,";
    "Fxn:test" -> "Fxn:cpu_tensor.double()";
    "Fxn:test" -> "Fxn:gpu_tensor.double()";
    "Fxn:test" -> "Fxn:zeros.double()";
    "Fxn:test" -> "Fxn:cpu_tensor.polygamma(n)";
    "Fxn:test" -> "Fxn:gpu_tensor.polygamma(n)";
    "Fxn:test" -> "Fxn:cpu_out.cuda())";
    "Fxn:test" -> "Fxn:self.assertEqual(norm_errors,";
    "Fxn:test" -> "Fxn:test(True)";
    "Fxn:test" -> "Fxn:test(False)";
    "Fxn:test" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_symeig" -> "Fxn:torch.randn(3,";
    "Fxn:test_symeig" -> "Fxn:3).cuda()";
    "Fxn:test_symeig" -> "Fxn:torch.mm(tensor,";
    "Fxn:test_symeig" -> "Fxn:tensor.t())";
    "Fxn:test_symeig" -> "Fxn:torch.symeig(tensor,";
    "Fxn:test_symeig" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_symeig" -> "Fxn:torch.mm(torch.mm(eigvec,";
    "Fxn:test_symeig" -> "Fxn:eigval.diag()),";
    "Fxn:test_symeig" -> "Fxn:eigvec.t()))";
    "Fxn:test_symeig" -> "Fxn:torch.randn(257,";
    "Fxn:test_symeig" -> "Fxn:257).cuda()";
    "Fxn:test_symeig" -> "Fxn:torch.mm(tensor,";
    "Fxn:test_symeig" -> "Fxn:tensor.t())";
    "Fxn:test_symeig" -> "Fxn:torch.symeig(tensor,";
    "Fxn:test_symeig" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_symeig" -> "Fxn:torch.mm(torch.mm(eigvec,";
    "Fxn:test_symeig" -> "Fxn:eigval.diag()),";
    "Fxn:test_symeig" -> "Fxn:eigvec.t()))";
    "Fxn:test_arange" -> "Fxn:torch.cuda.__dict__[t]()";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:torch.__dict__[t]()";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_arange" -> "Fxn:b.cuda())";
    "Fxn:test_diagonal" -> "Fxn:TestTorch._test_diagonal(self,";
    "Fxn:test_diagflat" -> "Fxn:TestTorch._test_diagflat(self,";
    "Fxn:test_diagflat" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:torch.cuda.get_rng_state_all()";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:device=0).normal_()";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:device=1).normal_()";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:torch.cuda.set_rng_state_all(states)";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:device=0).normal_()";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:device=1).normal_()";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:self.assertEqual(before0,";
    "Fxn:test_get_set_rng_state_all" -> "Fxn:self.assertEqual(before1,";
    "Fxn:test_nvtx" -> "Fxn:torch.cuda.nvtx.range_push("foo")";
    "Fxn:test_nvtx" -> "Fxn:torch.cuda.nvtx.mark("bar")";
    "Fxn:test_nvtx" -> "Fxn:torch.cuda.nvtx.range_pop()";
    "Fxn:load_ignore_file" -> "Fxn:join(dirname(__file__),";
    "Fxn:load_ignore_file" -> "Fxn:f.read().splitlines()";
    "Fxn:load_ignore_file" -> "Fxn:l.startswith('#')}";
    "Fxn:generate_tests" -> "Fxn:custom_precision.get(name,";
    "Fxn:generate_tests" -> "Fxn:custom_half_precision.get(name,";
    "Fxn:generate_tests" -> "Fxn:'{}.{}'.format(tensor.type(),";
    "Fxn:generate_tests" -> "Fxn:compare_cpu_gpu(constr,";
    "Fxn:generate_tests" -> "Fxn:load_ignore_file()";
    "Fxn:generate_tests" -> "Fxn:generate_tests()";
    "Fxn:generate_tests" -> "Fxn:run_tests()";
    "/test/test_dataloader.py" -> "Import:math";
    "/test/test_dataloader.py" -> "Import:sys";
    "/test/test_dataloader.py" -> "Import:errno";
    "/test/test_dataloader.py" -> "Import:import";
    "/test/test_dataloader.py" -> "Import:ctypes";
    "/test/test_dataloader.py" -> "Import:signal";
    "/test/test_dataloader.py" -> "Import:torch";
    "/test/test_dataloader.py" -> "Import:time";
    "/test/test_dataloader.py" -> "Import:traceback";
    "/test/test_dataloader.py" -> "Import:unittest";
    "/test/test_dataloader.py" -> "Import:multiprocessing";
    "/test/test_dataloader.py" -> "Import:Dataset,";
    "/test/test_dataloader.py" -> "Import:random_split";
    "/test/test_dataloader.py" -> "Import:default_collate,";
    "/test/test_dataloader.py" -> "Import:TestCase,";
    "/test/test_dataloader.py" -> "Import:TEST_CUDA";
    "/test/test_dataloader.py" -> "class:TestDatasetRandomSplit(TestCase):";
    "/test/test_dataloader.py" -> "class:TestTensorDataset(TestCase):";
    "/test/test_dataloader.py" -> "class:TestConcatDataset(TestCase):";
    "/test/test_dataloader.py" -> "class:ErrorTrackingProcess(multiprocessing.Process):";
    "/test/test_dataloader.py" -> "class:ErrorDataset(Dataset):";
    "/test/test_dataloader.py" -> "class:SegfaultDataset(Dataset):";
    "/test/test_dataloader.py" -> "class:SleepDataset(Dataset):";
    "/test/test_dataloader.py" -> "class:SeedDataset(Dataset):";
    "/test/test_dataloader.py" -> "class:SynchronizedSeedDataset(Dataset):";
    "/test/test_dataloader.py" -> "class:TestDataLoader(TestCase):";
    "/test/test_dataloader.py" -> "Import:numpy";
    "/test/test_dataloader.py" -> "class:TestDataset(torch.utils.data.Dataset):";
    "/test/test_dataloader.py" -> "Import:numpy";
    "/test/test_dataloader.py" -> "class:ScalarDataset(torch.utils.data.Dataset):";
    "/test/test_dataloader.py" -> "Import:numpy";
    "/test/test_dataloader.py" -> "class:StringDataset(Dataset):";
    "/test/test_dataloader.py" -> "class:TestStringDataLoader(TestCase):";
    "/test/test_dataloader.py" -> "class:DictDataset(Dataset):";
    "/test/test_dataloader.py" -> "class:TestDictDataLoader(TestCase):";
    "class:TestDatasetRandomSplit(TestCase):" -> "Fxn:test_lengths_must_equal_datset_size";
    "class:TestDatasetRandomSplit(TestCase):" -> "Fxn:test_splits_have_correct_size";
    "class:TestDatasetRandomSplit(TestCase):" -> "Fxn:test_splits_are_mutually_exclusive";
    "Fxn:test_lengths_must_equal_datset_size" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_lengths_must_equal_datset_size" -> "Fxn:random_split([1,";
    "Fxn:test_splits_have_correct_size" -> "Fxn:random_split([1,";
    "Fxn:test_splits_have_correct_size" -> "Fxn:self.assertEqual(len(splits),";
    "Fxn:test_splits_have_correct_size" -> "Fxn:self.assertEqual(len(splits[0]),";
    "Fxn:test_splits_have_correct_size" -> "Fxn:self.assertEqual(len(splits[1]),";
    "Fxn:test_splits_are_mutually_exclusive" -> "Fxn:random_split(data,";
    "Fxn:test_splits_are_mutually_exclusive" -> "Fxn:all_values.extend(list(splits[0]))";
    "Fxn:test_splits_are_mutually_exclusive" -> "Fxn:all_values.extend(list(splits[1]))";
    "Fxn:test_splits_are_mutually_exclusive" -> "Fxn:data.sort()";
    "Fxn:test_splits_are_mutually_exclusive" -> "Fxn:all_values.sort()";
    "Fxn:test_splits_are_mutually_exclusive" -> "Fxn:self.assertListEqual(data,";
    "class:TestTensorDataset(TestCase):" -> "Fxn:test_len";
    "class:TestTensorDataset(TestCase):" -> "Fxn:test_getitem";
    "class:TestTensorDataset(TestCase):" -> "Fxn:test_getitem_1d";
    "Fxn:test_len" -> "Fxn:TensorDataset(torch.randn(15,";
    "Fxn:test_len" -> "Fxn:torch.randperm(15))";
    "Fxn:test_len" -> "Fxn:self.assertEqual(len(source),";
    "Fxn:test_getitem" -> "Fxn:torch.randn(15,";
    "Fxn:test_getitem" -> "Fxn:torch.randn(15,";
    "Fxn:test_getitem" -> "Fxn:TensorDataset(t,";
    "Fxn:test_getitem" -> "Fxn:self.assertEqual(t[i],";
    "Fxn:test_getitem" -> "Fxn:self.assertEqual(l[i],";
    "Fxn:test_getitem_1d" -> "Fxn:torch.randn(15)";
    "Fxn:test_getitem_1d" -> "Fxn:torch.randn(15)";
    "Fxn:test_getitem_1d" -> "Fxn:TensorDataset(t,";
    "Fxn:test_getitem_1d" -> "Fxn:self.assertEqual(t[i],";
    "Fxn:test_getitem_1d" -> "Fxn:self.assertEqual(l[i],";
    "class:TestConcatDataset(TestCase):" -> "Fxn:test_concat_two_singletons";
    "class:TestConcatDataset(TestCase):" -> "Fxn:test_concat_two_non_singletons";
    "class:TestConcatDataset(TestCase):" -> "Fxn:test_concat_two_non_singletons_with_empty";
    "class:TestConcatDataset(TestCase):" -> "Fxn:test_concat_raises_index_error";
    "class:TestConcatDataset(TestCase):" -> "Fxn:test_add_dataset";
    "Fxn:test_concat_two_singletons" -> "Fxn:ConcatDataset([[0],";
    "Fxn:test_concat_two_singletons" -> "Fxn:self.assertEqual(2,";
    "Fxn:test_concat_two_singletons" -> "Fxn:self.assertEqual(0,";
    "Fxn:test_concat_two_singletons" -> "Fxn:self.assertEqual(1,";
    "Fxn:test_concat_two_non_singletons" -> "Fxn:ConcatDataset([[0,";
    "Fxn:test_concat_two_non_singletons" -> "Fxn:self.assertEqual(10,";
    "Fxn:test_concat_two_non_singletons" -> "Fxn:self.assertEqual(0,";
    "Fxn:test_concat_two_non_singletons" -> "Fxn:self.assertEqual(5,";
    "Fxn:test_concat_two_non_singletons_with_empty" -> "Fxn:ConcatDataset([[0,";
    "Fxn:test_concat_two_non_singletons_with_empty" -> "Fxn:self.assertEqual(10,";
    "Fxn:test_concat_two_non_singletons_with_empty" -> "Fxn:self.assertEqual(0,";
    "Fxn:test_concat_two_non_singletons_with_empty" -> "Fxn:self.assertEqual(5,";
    "Fxn:test_concat_raises_index_error" -> "Fxn:ConcatDataset([[0,";
    "Fxn:test_concat_raises_index_error" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:test_add_dataset" -> "Fxn:TensorDataset(torch.rand(7,";
    "Fxn:test_add_dataset" -> "Fxn:torch.rand(7))";
    "Fxn:test_add_dataset" -> "Fxn:TensorDataset(torch.rand(7,";
    "Fxn:test_add_dataset" -> "Fxn:torch.rand(7))";
    "Fxn:test_add_dataset" -> "Fxn:TensorDataset(torch.rand(7,";
    "Fxn:test_add_dataset" -> "Fxn:torch.rand(7))";
    "Fxn:test_add_dataset" -> "Fxn:self.assertEqual(21,";
    "Fxn:test_add_dataset" -> "Fxn:self.assertEqual(0,";
    "Fxn:test_add_dataset" -> "Fxn:result[0][0]).abs().sum())";
    "Fxn:test_add_dataset" -> "Fxn:self.assertEqual(0,";
    "Fxn:test_add_dataset" -> "Fxn:result[7][0]).abs().sum())";
    "Fxn:test_add_dataset" -> "Fxn:self.assertEqual(0,";
    "Fxn:test_add_dataset" -> "Fxn:result[14][0]).abs().sum())";
    "class:ErrorTrackingProcess(multiprocessing.Process):" -> "Fxn:__init__";
    "class:ErrorTrackingProcess(multiprocessing.Process):" -> "Fxn:run";
    "class:ErrorTrackingProcess(multiprocessing.Process):" -> "Fxn:exception";
    "class:ErrorTrackingProcess(multiprocessing.Process):" -> "Fxn:send_signal";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__init__" -> "Fxn:multiprocessing.Pipe()";
    "Fxn:run" -> "Fxn:os.close(sys.stderr.fileno())";
    "Fxn:run" -> "Fxn:self).run()";
    "Fxn:run" -> "Fxn:self._cconn.send(None)";
    "Fxn:run" -> "Fxn:self._cconn.send(ExceptionWrapper(sys.exc_info()))";
    "Fxn:exception" -> "Fxn:self._pconn.poll():";
    "Fxn:exception" -> "Fxn:self._pconn.recv()";
    "Fxn:exception" -> "Fxn:self._exception.exc_type(self._exception.exc_msg)";
    "Fxn:send_signal" -> "Fxn:os.kill(self.pid,";
    "class:ErrorDataset(Dataset):" -> "Fxn:__init__";
    "class:ErrorDataset(Dataset):" -> "Fxn:__len__";
    "class:SegfaultDataset(Dataset):" -> "Fxn:__init__";
    "class:SegfaultDataset(Dataset):" -> "Fxn:__getitem__";
    "class:SegfaultDataset(Dataset):" -> "Fxn:__len__";
    "Fxn:__getitem__" -> "Fxn:ctypes.string_at(0)";
    "class:SleepDataset(Dataset):" -> "Fxn:__init__";
    "class:SleepDataset(Dataset):" -> "Fxn:__getitem__";
    "class:SleepDataset(Dataset):" -> "Fxn:__len__";
    "Fxn:__getitem__" -> "Fxn:time.sleep(self.sleep_sec)";
    "class:SeedDataset(Dataset):" -> "Fxn:__init__";
    "class:SeedDataset(Dataset):" -> "Fxn:__getitem__";
    "class:SeedDataset(Dataset):" -> "Fxn:__len__";
    "Fxn:__getitem__" -> "Fxn:torch.initial_seed()";
    "class:SynchronizedSeedDataset(Dataset):" -> "Fxn:__init__";
    "class:SynchronizedSeedDataset(Dataset):" -> "Fxn:__getitem__";
    "class:SynchronizedSeedDataset(Dataset):" -> "Fxn:__len__";
    "class:SynchronizedSeedDataset(Dataset):" -> "Fxn:_test_timeout";
    "class:SynchronizedSeedDataset(Dataset):" -> "Fxn:_test_segfault";
    "class:SynchronizedSeedDataset(Dataset):" -> "Fxn:init_fn";
    "Fxn:__init__" -> "Fxn:multiprocessing.Value('i',";
    "Fxn:__init__" -> "Fxn:multiprocessing.Semaphore(0)";
    "Fxn:__getitem__" -> "Fxn:self.count.get_lock():";
    "Fxn:__getitem__" -> "Fxn:self.barrier.release()";
    "Fxn:__getitem__" -> "Fxn:self.barrier.acquire()";
    "Fxn:__getitem__" -> "Fxn:self.barrier.release()";
    "Fxn:__getitem__" -> "Fxn:torch.initial_seed()";
    "Fxn:_test_timeout" -> "Fxn:SleepDataset(10,";
    "Fxn:_test_timeout" -> "Fxn:DataLoader(dataset,";
    "Fxn:_test_segfault" -> "Fxn:SegfaultDataset(10)";
    "Fxn:_test_segfault" -> "Fxn:DataLoader(dataset,";
    "Fxn:init_fn" -> "Fxn:torch.manual_seed(12345)";
    "class:TestDataLoader(TestCase):" -> "Fxn:setUp";
    "class:TestDataLoader(TestCase):" -> "Fxn:_test_sequential";
    "class:TestDataLoader(TestCase):" -> "Fxn:_test_shuffle";
    "class:TestDataLoader(TestCase):" -> "Fxn:_test_error";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_sequential";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_sequential_batch";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_growing_dataset";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_sequential_pin_memory";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_multiple_dataloaders";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_segfault";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_timeout";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_worker_seed";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_worker_init_fn";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_shuffle";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_shuffle_batch";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_sequential_workers";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_seqential_batch_workers";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_shuffle_workers";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_shuffle_batch_workers";
    "class:TestDataLoader(TestCase):" -> "Fxn:_test_batch_sampler";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_batch_sampler";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_shuffle_pin_memory";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_numpy";
    "Fxn:setUp" -> "Fxn:torch.randn(100,";
    "Fxn:setUp" -> "Fxn:torch.randperm(50).repeat(2)";
    "Fxn:setUp" -> "Fxn:TensorDataset(self.data,";
    "Fxn:_test_sequential" -> "Fxn:self.assertEqual(sample,";
    "Fxn:_test_sequential" -> "Fxn:self.assertEqual(target,";
    "Fxn:_test_sequential" -> "Fxn:self.assertEqual(i,";
    "Fxn:_test_sequential" -> "Fxn:math.floor((len(self.dataset)";
    "Fxn:_test_shuffle" -> "Fxn:data_point.eq(sample).all():";
    "Fxn:_test_shuffle" -> "Fxn:self.assertFalse(found_data[data_point_idx])";
    "Fxn:_test_shuffle" -> "Fxn:self.assertEqual(target,";
    "Fxn:_test_shuffle" -> "Fxn:self.assertEqual(sum(found_data.values()),";
    "Fxn:_test_shuffle" -> "Fxn:self.assertEqual(sum(found_labels.values()),";
    "Fxn:_test_shuffle" -> "Fxn:self.assertEqual(i,";
    "Fxn:_test_shuffle" -> "Fxn:math.floor((len(self.dataset)";
    "Fxn:_test_error" -> "Fxn:self.assertEqual(errors,";
    "Fxn:_test_error" -> "Fxn:math.ceil(float(len(loader.dataset))";
    "Fxn:test_sequential" -> "Fxn:self._test_sequential(DataLoader(self.dataset))";
    "Fxn:test_sequential_batch" -> "Fxn:self._test_sequential(DataLoader(self.dataset,";
    "Fxn:test_growing_dataset" -> "Fxn:[torch.ones(4)";
    "Fxn:test_growing_dataset" -> "Fxn:DataLoader(dataset,";
    "Fxn:test_growing_dataset" -> "Fxn:DataLoader(dataset,";
    "Fxn:test_growing_dataset" -> "Fxn:dataset.append(torch.ones(4))";
    "Fxn:test_growing_dataset" -> "Fxn:self.assertEqual(len(dataloader_seq),";
    "Fxn:test_growing_dataset" -> "Fxn:self.assertEqual(len(dataloader_shuffle),";
    "Fxn:test_growing_dataset" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_sequential_pin_memory" -> "Fxn:DataLoader(self.dataset,";
    "Fxn:test_sequential_pin_memory" -> "Fxn:self.assertTrue(input.is_pinned())";
    "Fxn:test_sequential_pin_memory" -> "Fxn:self.assertTrue(target.is_pinned())";
    "Fxn:test_sequential_pin_memory" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_multiple_dataloaders" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_multiple_dataloaders" -> "Fxn:@unittest.skip("temporarily";
    "Fxn:test_segfault" -> "Fxn:ErrorTrackingProcess(target=_test_segfault)";
    "Fxn:test_segfault" -> "Fxn:p.start()";
    "Fxn:test_segfault" -> "Fxn:p.join(JOIN_TIMEOUT)";
    "Fxn:test_segfault" -> "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_segfault" -> "Fxn:self.assertNotEqual(p.exitcode,";
    "Fxn:test_segfault" -> "Fxn:self.assertIsInstance(p.exception,";
    "Fxn:test_segfault" -> "Fxn:self.assertRegex(str(p.exception),";
    "Fxn:test_segfault" -> "Fxn:self.assertIsInstance(p.exception,";
    "Fxn:test_segfault" -> "Fxn:self.assertRegex(str(p.exception),";
    "Fxn:test_segfault" -> "Fxn:\(pid";
    "Fxn:test_segfault" -> "Fxn:p.terminate()";
    "Fxn:test_segfault" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_timeout" -> "Fxn:ErrorTrackingProcess(target=_test_timeout)";
    "Fxn:test_timeout" -> "Fxn:p.start()";
    "Fxn:test_timeout" -> "Fxn:p.join(JOIN_TIMEOUT)";
    "Fxn:test_timeout" -> "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_timeout" -> "Fxn:self.assertNotEqual(p.exitcode,";
    "Fxn:test_timeout" -> "Fxn:self.assertIsInstance(p.exception,";
    "Fxn:test_timeout" -> "Fxn:self.assertRegex(str(p.exception),";
    "Fxn:test_timeout" -> "Fxn:p.terminate()";
    "Fxn:test_timeout" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_worker_seed" -> "Fxn:SynchronizedSeedDataset(num_workers,";
    "Fxn:test_worker_seed" -> "Fxn:DataLoader(dataset,";
    "Fxn:test_worker_seed" -> "Fxn:seeds.add(batch[0])";
    "Fxn:test_worker_seed" -> "Fxn:self.assertEqual(len(seeds),";
    "Fxn:test_worker_seed" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_worker_init_fn" -> "Fxn:SeedDataset(4)";
    "Fxn:test_worker_init_fn" -> "Fxn:DataLoader(dataset,";
    "Fxn:test_worker_init_fn" -> "Fxn:self.assertEqual(12345,";
    "Fxn:test_worker_init_fn" -> "Fxn:self.assertEqual(12345,";
    "Fxn:test_shuffle" -> "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:test_shuffle_batch" -> "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:test_shuffle_batch" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_sequential_workers" -> "Fxn:self._test_sequential(DataLoader(self.dataset,";
    "Fxn:test_sequential_workers" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_seqential_batch_workers" -> "Fxn:self._test_sequential(DataLoader(self.dataset,";
    "Fxn:test_seqential_batch_workers" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_shuffle_workers" -> "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:test_shuffle_workers" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_shuffle_batch_workers" -> "Fxn:self._test_shuffle(DataLoader(self.dataset,";
    "Fxn:_test_batch_sampler" -> "Fxn:[(0,";
    "Fxn:_test_batch_sampler" -> "Fxn:batches.append(tuple(range(i,";
    "Fxn:_test_batch_sampler" -> "Fxn:batches.append(tuple(range(i";
    "Fxn:_test_batch_sampler" -> "Fxn:DataLoader(self.dataset,";
    "Fxn:_test_batch_sampler" -> "Fxn:self.assertEqual(len(dl),";
    "Fxn:_test_batch_sampler" -> "Fxn:self.assertEqual(len(input),";
    "Fxn:_test_batch_sampler" -> "Fxn:self.assertEqual(input,";
    "Fxn:_test_batch_sampler" -> "Fxn:self.assertEqual(len(input),";
    "Fxn:_test_batch_sampler" -> "Fxn:self.assertEqual(input,";
    "Fxn:_test_batch_sampler" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_batch_sampler" -> "Fxn:self._test_batch_sampler()";
    "Fxn:test_batch_sampler" -> "Fxn:self._test_batch_sampler(num_workers=4)";
    "Fxn:test_batch_sampler" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_batch_sampler" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_shuffle_pin_memory" -> "Fxn:DataLoader(self.dataset,";
    "Fxn:test_shuffle_pin_memory" -> "Fxn:self.assertTrue(input.is_pinned())";
    "Fxn:test_shuffle_pin_memory" -> "Fxn:self.assertTrue(target.is_pinned())";
    "Fxn:test_shuffle_pin_memory" -> "Fxn:@unittest.skipIf(not";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:__getitem__";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:__len__";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:test_error";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:test_error_workers";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:test_partial_workers";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:test_len";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:check_len";
    "class:TestDataset(torch.utils.data.Dataset):" -> "Fxn:test_numpy_scalars";
    "Fxn:__getitem__" -> "Fxn:np.ones((2,";
    "Fxn:__len__" -> "Fxn:DataLoader(TestDataset(),";
    "Fxn:__len__" -> "Fxn:self.assertIsInstance(batch,";
    "Fxn:__len__" -> "Fxn:self.assertEqual(batch.size(),";
    "Fxn:__len__" -> "Fxn:torch.Size([12,";
    "Fxn:test_error" -> "Fxn:self._test_error(DataLoader(ErrorDataset(100),";
    "Fxn:test_error" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_error_workers" -> "Fxn:self._test_error(DataLoader(ErrorDataset(41),";
    "Fxn:test_error_workers" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_error_workers" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_partial_workers" -> "Fxn:w.join(JOIN_TIMEOUT)";
    "Fxn:test_partial_workers" -> "Fxn:self.assertFalse(w.is_alive(),";
    "Fxn:test_partial_workers" -> "Fxn:self.assertEqual(w.exitcode,";
    "Fxn:test_partial_workers" -> "Fxn:worker_manager_thread.join(JOIN_TIMEOUT)";
    "Fxn:test_partial_workers" -> "Fxn:self.assertFalse(worker_manager_thread.is_alive())";
    "Fxn:check_len" -> "Fxn:self.assertEqual(len(dl),";
    "Fxn:check_len" -> "Fxn:self.assertEqual(n,";
    "Fxn:check_len" -> "Fxn:check_len(self.dataset,";
    "Fxn:check_len" -> "Fxn:check_len(DataLoader(self.dataset,";
    "Fxn:check_len" -> "Fxn:check_len(DataLoader(self.dataset,";
    "Fxn:check_len" -> "Fxn:@unittest.skipIf(not";
    "class:ScalarDataset(torch.utils.data.Dataset):" -> "Fxn:__init__";
    "class:ScalarDataset(torch.utils.data.Dataset):" -> "Fxn:__getitem__";
    "class:ScalarDataset(torch.utils.data.Dataset):" -> "Fxn:__len__";
    "class:ScalarDataset(torch.utils.data.Dataset):" -> "Fxn:test_default_colate_bad_numpy_types";
    "Fxn:__getitem__" -> "Fxn:self.dtype()";
    "Fxn:__len__" -> "Fxn:dtypes.items():";
    "Fxn:__len__" -> "Fxn:ScalarDataset(dt)";
    "Fxn:__len__" -> "Fxn:DataLoader(dset,";
    "Fxn:__len__" -> "Fxn:self.assertIsInstance(batch,";
    "Fxn:__len__" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:np.array(['a',";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:default_collate(arr)";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:np.array([[['a',";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:default_collate(arr))";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:np.array([object(),";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:default_collate(arr))";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:np.array([[[object(),";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_default_colate_bad_numpy_types" -> "Fxn:default_collate(arr))";
    "class:StringDataset(Dataset):" -> "Fxn:__init__";
    "class:StringDataset(Dataset):" -> "Fxn:__len__";
    "class:StringDataset(Dataset):" -> "Fxn:__getitem__";
    "class:TestStringDataLoader(TestCase):" -> "Fxn:setUp";
    "class:TestStringDataLoader(TestCase):" -> "Fxn:test_shuffle_pin_memory";
    "Fxn:setUp" -> "Fxn:StringDataset()";
    "Fxn:setUp" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:setUp" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_shuffle_pin_memory" -> "Fxn:DataLoader(self.dataset,";
    "Fxn:test_shuffle_pin_memory" -> "Fxn:self.assertIsInstance(s[0],";
    "Fxn:test_shuffle_pin_memory" -> "Fxn:self.assertTrue(n.is_pinned())";
    "class:DictDataset(Dataset):" -> "Fxn:__len__";
    "class:DictDataset(Dataset):" -> "Fxn:__getitem__";
    "Fxn:__getitem__" -> "Fxn:torch.Tensor(4,";
    "Fxn:__getitem__" -> "Fxn:2).fill_(ndx),";
    "class:TestDictDataLoader(TestCase):" -> "Fxn:setUp";
    "class:TestDictDataLoader(TestCase):" -> "Fxn:test_sequential_batch";
    "class:TestDictDataLoader(TestCase):" -> "Fxn:test_pin_memory";
    "Fxn:setUp" -> "Fxn:DictDataset()";
    "Fxn:test_sequential_batch" -> "Fxn:DataLoader(self.dataset,";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertEqual(set(sample.keys()),";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertEqual(set(sample['another_dict'].keys()),";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertEqual(t.size(),";
    "Fxn:test_sequential_batch" -> "Fxn:torch.Size([batch_size,";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertTrue((t[0]";
    "Fxn:test_sequential_batch" -> "Fxn:idx).all())";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertTrue((t[1]";
    "Fxn:test_sequential_batch" -> "Fxn:1).all())";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertEqual(n.size(),";
    "Fxn:test_sequential_batch" -> "Fxn:torch.Size([batch_size]))";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertEqual(n[0],";
    "Fxn:test_sequential_batch" -> "Fxn:self.assertEqual(n[1],";
    "Fxn:test_sequential_batch" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_pin_memory" -> "Fxn:DataLoader(self.dataset,";
    "Fxn:test_pin_memory" -> "Fxn:self.assertTrue(sample['a_tensor'].is_pinned())";
    "Fxn:test_pin_memory" -> "Fxn:self.assertTrue(sample['another_dict']['a_number'].is_pinned())";
    "Fxn:test_pin_memory" -> "Fxn:run_tests()";
    "/test/test_distributed.py" -> "Import:fcntl";
    "/test/test_distributed.py" -> "Import:multiprocessing";
    "/test/test_distributed.py" -> "Import:import";
    "/test/test_distributed.py" -> "Import:sys";
    "/test/test_distributed.py" -> "Import:copy";
    "/test/test_distributed.py" -> "Import:time";
    "/test/test_distributed.py" -> "Import:unittest";
    "/test/test_distributed.py" -> "Import:wraps,";
    "/test/test_distributed.py" -> "Import:contextmanager";
    "/test/test_distributed.py" -> "Import:torch";
    "/test/test_distributed.py" -> "Import:torch.cuda";
    "/test/test_distributed.py" -> "Import:torch.nn";
    "/test/test_distributed.py" -> "Import:torch.distributed";
    "/test/test_distributed.py" -> "Import:torch.optim";
    "/test/test_distributed.py" -> "Import:torch.nn.functional";
    "/test/test_distributed.py" -> "Import:Variable";
    "/test/test_distributed.py" -> "Import:TestCase";
    "/test/test_distributed.py" -> "Fxn:get_timeout";
    "/test/test_distributed.py" -> "Fxn:skip_if_no_cuda_distributed";
    "/test/test_distributed.py" -> "Fxn:wrapper";
    "/test/test_distributed.py" -> "Fxn:skip_if_no_multigpu";
    "/test/test_distributed.py" -> "Fxn:wrapper";
    "/test/test_distributed.py" -> "Fxn:skip_if_small_worldsize";
    "/test/test_distributed.py" -> "Fxn:wrapper";
    "/test/test_distributed.py" -> "Fxn:apply_hack_for_nccl";
    "/test/test_distributed.py" -> "Fxn:_lock";
    "/test/test_distributed.py" -> "Fxn:_build_tensor";
    "/test/test_distributed.py" -> "class:Barrier(object):";
    "/test/test_distributed.py" -> "class:_DistTestBase(object):";
    "/test/test_distributed.py" -> "class:Net(nn.Module):";
    "/test/test_distributed.py" -> "class:TestDistBackend(TestCase,";
    "/test/test_distributed.py" -> "class:TestMPI(TestCase,";
    "class:Barrier(object):" -> "Fxn:init";
    "class:Barrier(object):" -> "Fxn:sync";
    "Fxn:init" -> "Fxn:os.path.join(TEMP_DIR,";
    "Fxn:init" -> "Fxn:os.listdir(barrier_dir):";
    "Fxn:init" -> "Fxn:os.unlink(os.path.join(barrier_dir,";
    "Fxn:sync" -> "Fxn:os.path.join(TEMP_DIR,";
    "Fxn:sync" -> "Fxn:os.path.join(barrier_dir,";
    "Fxn:sync" -> "Fxn:_lock():";
    "Fxn:sync" -> "Fxn:f.write(str(cls.barrier_id))";
    "Fxn:sync" -> "Fxn:time.time()";
    "Fxn:sync" -> "Fxn:_lock():";
    "Fxn:sync" -> "Fxn:os.listdir(barrier_dir):";
    "Fxn:sync" -> "Fxn:f.read()";
    "Fxn:sync" -> "Fxn:dist.get_world_size():";
    "Fxn:sync" -> "Fxn:time.time()";
    "Fxn:sync" -> "Fxn:RuntimeError("barrier";
    "Fxn:sync" -> "Fxn:time.sleep(0.1)";
    "class:_DistTestBase(object):" -> "Fxn:_barrier";
    "class:_DistTestBase(object):" -> "Fxn:_init_group_test";
    "class:_DistTestBase(object):" -> "Fxn:_init_global_test";
    "class:_DistTestBase(object):" -> "Fxn:test_get_rank";
    "class:_DistTestBase(object):" -> "Fxn:test_send_recv";
    "class:_DistTestBase(object):" -> "Fxn:test_send_recv_any_source";
    "class:_DistTestBase(object):" -> "Fxn:test_isend";
    "class:_DistTestBase(object):" -> "Fxn:test_irecv";
    "class:_DistTestBase(object):" -> "Fxn:_test_broadcast_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_broadcast";
    "class:_DistTestBase(object):" -> "Fxn:test_broadcast_cuda";
    "class:_DistTestBase(object):" -> "Fxn:test_broadcast_group";
    "class:_DistTestBase(object):" -> "Fxn:_test_reduce_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_sum";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_sum_cuda";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_product";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_min";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_max";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_group_sum";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_group_product";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_group_min";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_group_max";
    "class:_DistTestBase(object):" -> "Fxn:_test_all_reduce_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_sum";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_sum_cuda";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_product";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_min";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_max";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_group_sum";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_group_product";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_group_min";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_group_max";
    "class:_DistTestBase(object):" -> "Fxn:_test_scatter_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_scatter";
    "class:_DistTestBase(object):" -> "Fxn:test_scatter_group";
    "class:_DistTestBase(object):" -> "Fxn:_test_gather_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_gather";
    "class:_DistTestBase(object):" -> "Fxn:test_gather_group";
    "class:_DistTestBase(object):" -> "Fxn:_test_all_gather_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_all_gather";
    "class:_DistTestBase(object):" -> "Fxn:test_all_gather_cuda";
    "class:_DistTestBase(object):" -> "Fxn:test_all_gather_group";
    "class:_DistTestBase(object):" -> "Fxn:_test_barrier_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_barrier";
    "class:_DistTestBase(object):" -> "Fxn:test_barrier_group";
    "class:_DistTestBase(object):" -> "Fxn:_init_multigpu_helper";
    "class:_DistTestBase(object):" -> "Fxn:_test_broadcast_multigpu_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_broadcast_multigpu";
    "class:_DistTestBase(object):" -> "Fxn:_test_all_reduce_multigpu_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_all_reduce_multigpu";
    "class:_DistTestBase(object):" -> "Fxn:_test_reduce_multigpu_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_reduce_multigpu";
    "class:_DistTestBase(object):" -> "Fxn:_test_all_gather_multigpu_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_all_gather_multigpu";
    "class:_DistTestBase(object):" -> "Fxn:_test_DDP_helper";
    "class:_DistTestBase(object):" -> "Fxn:test_DistributedDataParallel";
    "Fxn:_barrier" -> "Fxn:Barrier.sync(*args,";
    "Fxn:_init_group_test" -> "Fxn:dist.new_group(group)";
    "Fxn:_init_group_test" -> "Fxn:dist.get_rank()";
    "Fxn:_init_global_test" -> "Fxn:dist.get_world_size())]";
    "Fxn:_init_global_test" -> "Fxn:dist.get_rank()";
    "Fxn:test_get_rank" -> "Fxn:os.path.join(TEMP_DIR,";
    "Fxn:test_get_rank" -> "Fxn:dist.get_world_size()";
    "Fxn:test_get_rank" -> "Fxn:f.write(str(dist.get_rank()))";
    "Fxn:test_get_rank" -> "Fxn:self._barrier()";
    "Fxn:test_get_rank" -> "Fxn:os.listdir(test_dir):";
    "Fxn:test_get_rank" -> "Fxn:all_ranks.add(int(f.read()))";
    "Fxn:test_get_rank" -> "Fxn:self.assertEqual(len(all_ranks),";
    "Fxn:test_get_rank" -> "Fxn:self._barrier()";
    "Fxn:test_get_rank" -> "Fxn:dist.get_rank()";
    "Fxn:test_get_rank" -> "Fxn:os.listdir(test_dir):";
    "Fxn:test_get_rank" -> "Fxn:os.unlink(os.path.join(test_dir,";
    "Fxn:test_get_rank" -> "Fxn:self._barrier()";
    "Fxn:test_get_rank" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_get_rank" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_send_recv" -> "Fxn:dist.get_rank()";
    "Fxn:test_send_recv" -> "Fxn:_build_tensor(rank";
    "Fxn:test_send_recv" -> "Fxn:dist.get_world_size()):";
    "Fxn:test_send_recv" -> "Fxn:dist.send(tensor,";
    "Fxn:test_send_recv" -> "Fxn:dist.get_world_size()):";
    "Fxn:test_send_recv" -> "Fxn:_build_tensor(src";
    "Fxn:test_send_recv" -> "Fxn:_build_tensor(src";
    "Fxn:test_send_recv" -> "Fxn:dist.recv(tensor,";
    "Fxn:test_send_recv" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_send_recv" -> "Fxn:self._barrier()";
    "Fxn:test_send_recv" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_send_recv" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_send_recv_any_source" -> "Fxn:dist.get_rank()";
    "Fxn:test_send_recv_any_source" -> "Fxn:_build_tensor(10,";
    "Fxn:test_send_recv_any_source" -> "Fxn:dist.get_world_size()):";
    "Fxn:test_send_recv_any_source" -> "Fxn:dist.send(tensor,";
    "Fxn:test_send_recv_any_source" -> "Fxn:dist.get_world_size()):";
    "Fxn:test_send_recv_any_source" -> "Fxn:_build_tensor(10,";
    "Fxn:test_send_recv_any_source" -> "Fxn:dist.recv(tensor)";
    "Fxn:test_send_recv_any_source" -> "Fxn:self.assertTrue(tensor.eq(sender).all())";
    "Fxn:test_send_recv_any_source" -> "Fxn:recv_ranks.add(sender)";
    "Fxn:test_send_recv_any_source" -> "Fxn:self.assertEqual(len(recv_ranks),";
    "Fxn:test_send_recv_any_source" -> "Fxn:dist.get_world_size()";
    "Fxn:test_send_recv_any_source" -> "Fxn:self._barrier()";
    "Fxn:test_send_recv_any_source" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_send_recv_any_source" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_isend" -> "Fxn:dist.get_rank()";
    "Fxn:test_isend" -> "Fxn:dist.get_world_size()";
    "Fxn:test_isend" -> "Fxn:dist.isend(_build_tensor(dest,";
    "Fxn:test_isend" -> "Fxn:request.wait()";
    "Fxn:test_isend" -> "Fxn:self.assertTrue(request.is_completed())";
    "Fxn:test_isend" -> "Fxn:_build_tensor(rank,";
    "Fxn:test_isend" -> "Fxn:dist.recv(tensor,";
    "Fxn:test_isend" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_isend" -> "Fxn:_build_tensor(rank,";
    "Fxn:test_isend" -> "Fxn:self._barrier()";
    "Fxn:test_isend" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_isend" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_irecv" -> "Fxn:dist.get_rank()";
    "Fxn:test_irecv" -> "Fxn:dist.get_world_size()";
    "Fxn:test_irecv" -> "Fxn:[_build_tensor(src,";
    "Fxn:test_irecv" -> "Fxn:dist.irecv(expected_tensors[src";
    "Fxn:test_irecv" -> "Fxn:1].wait()";
    "Fxn:test_irecv" -> "Fxn:self.assertTrue(requests[src";
    "Fxn:test_irecv" -> "Fxn:1].is_completed())";
    "Fxn:test_irecv" -> "Fxn:self.assertEqual(expected_tensors[src";
    "Fxn:test_irecv" -> "Fxn:_build_tensor(src,";
    "Fxn:test_irecv" -> "Fxn:_build_tensor(rank,";
    "Fxn:test_irecv" -> "Fxn:dist.send(tensor,";
    "Fxn:test_irecv" -> "Fxn:self._barrier()";
    "Fxn:_test_broadcast_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_broadcast_helper" -> "Fxn:value).type(ttype)";
    "Fxn:_test_broadcast_helper" -> "Fxn:expected_tensor.cuda()";
    "Fxn:_test_broadcast_helper" -> "Fxn:dist.broadcast(expected_tensor,";
    "Fxn:_test_broadcast_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_broadcast_helper" -> "Fxn:-1).type(ttype)";
    "Fxn:_test_broadcast_helper" -> "Fxn:tensor.cuda()";
    "Fxn:_test_broadcast_helper" -> "Fxn:dist.broadcast(tensor,";
    "Fxn:_test_broadcast_helper" -> "Fxn:self.assertEqual(tensor.size(),";
    "Fxn:_test_broadcast_helper" -> "Fxn:expected_tensor.size())";
    "Fxn:_test_broadcast_helper" -> "Fxn:self.assertEqual(tensor.ne(expected_tensor).max(),";
    "Fxn:_test_broadcast_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_broadcast_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast" -> "Fxn:self._init_global_test()";
    "Fxn:test_broadcast" -> "Fxn:self._test_broadcast_helper(group,";
    "Fxn:test_broadcast" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast_cuda" -> "Fxn:self._init_global_test()";
    "Fxn:test_broadcast_cuda" -> "Fxn:self._test_broadcast_helper(group,";
    "Fxn:test_broadcast_cuda" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast_group" -> "Fxn:self._init_group_test()";
    "Fxn:test_broadcast_group" -> "Fxn:self._test_broadcast_helper(group,";
    "Fxn:_test_reduce_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_reduce_helper" -> "Fxn:1).fill_(master_value)";
    "Fxn:_test_reduce_helper" -> "Fxn:tensor.cuda()";
    "Fxn:_test_reduce_helper" -> "Fxn:dist.reduce(tensor,";
    "Fxn:_test_reduce_helper" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:_test_reduce_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_reduce_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_reduce_helper" -> "Fxn:1).fill_(worker_value)";
    "Fxn:_test_reduce_helper" -> "Fxn:tensor.cuda()";
    "Fxn:_test_reduce_helper" -> "Fxn:dist.reduce(tensor,";
    "Fxn:_test_reduce_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_reduce_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:_test_reduce_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_sum" -> "Fxn:self._init_global_test()";
    "Fxn:test_reduce_sum" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_sum" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_sum_cuda" -> "Fxn:self._init_global_test()";
    "Fxn:test_reduce_sum_cuda" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_sum_cuda" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_sum_cuda" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_product" -> "Fxn:self._init_global_test()";
    "Fxn:test_reduce_product" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_product" -> "Fxn:reduce((lambda";
    "Fxn:test_reduce_product" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_product" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_min" -> "Fxn:self._init_global_test()";
    "Fxn:test_reduce_min" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_min" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_min" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_max" -> "Fxn:self._init_global_test()";
    "Fxn:test_reduce_max" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_max" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_max" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_sum" -> "Fxn:self._init_group_test()";
    "Fxn:test_reduce_group_sum" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_group_sum" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_sum" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_product" -> "Fxn:self._init_group_test()";
    "Fxn:test_reduce_group_product" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_group_product" -> "Fxn:reduce((lambda";
    "Fxn:test_reduce_group_product" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_product" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_min" -> "Fxn:self._init_group_test()";
    "Fxn:test_reduce_group_min" -> "Fxn:self._test_reduce_helper(";
    "Fxn:test_reduce_group_min" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_min" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_group_max" -> "Fxn:self._init_group_test()";
    "Fxn:test_reduce_group_max" -> "Fxn:self._test_reduce_helper(";
    "Fxn:_test_all_reduce_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_all_reduce_helper" -> "Fxn:1).fill_(master_value)";
    "Fxn:_test_all_reduce_helper" -> "Fxn:tensor.cuda()";
    "Fxn:_test_all_reduce_helper" -> "Fxn:dist.all_reduce(tensor,";
    "Fxn:_test_all_reduce_helper" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:_test_all_reduce_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_all_reduce_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_all_reduce_helper" -> "Fxn:1).fill_(worker_value)";
    "Fxn:_test_all_reduce_helper" -> "Fxn:tensor.cuda()";
    "Fxn:_test_all_reduce_helper" -> "Fxn:dist.all_reduce(tensor,";
    "Fxn:_test_all_reduce_helper" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:_test_all_reduce_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_all_reduce_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_all_reduce_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_sum" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_reduce_sum" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_sum" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_sum_cuda" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_reduce_sum_cuda" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_sum_cuda" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_product" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_reduce_product" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_product" -> "Fxn:reduce((lambda";
    "Fxn:test_all_reduce_product" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_min" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_reduce_min" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_min" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_max" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_reduce_max" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_max" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_sum" -> "Fxn:self._init_group_test()";
    "Fxn:test_all_reduce_group_sum" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_group_sum" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_product" -> "Fxn:self._init_group_test()";
    "Fxn:test_all_reduce_group_product" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_group_product" -> "Fxn:reduce((lambda";
    "Fxn:test_all_reduce_group_product" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_min" -> "Fxn:self._init_group_test()";
    "Fxn:test_all_reduce_group_min" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:test_all_reduce_group_min" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_group_max" -> "Fxn:self._init_group_test()";
    "Fxn:test_all_reduce_group_max" -> "Fxn:self._test_all_reduce_helper(";
    "Fxn:_test_scatter_helper" -> "Fxn:_build_tensor(dest";
    "Fxn:_test_scatter_helper" -> "Fxn:_build_tensor(dest";
    "Fxn:_test_scatter_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_scatter_helper" -> "Fxn:dist.scatter(tensor,";
    "Fxn:_test_scatter_helper" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:_test_scatter_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_scatter_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:_test_scatter_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_scatter" -> "Fxn:self._init_global_test()";
    "Fxn:test_scatter" -> "Fxn:self._test_scatter_helper(group,";
    "Fxn:test_scatter" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_scatter" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_scatter_group" -> "Fxn:self._init_group_test()";
    "Fxn:test_scatter_group" -> "Fxn:self._test_scatter_helper(group,";
    "Fxn:_test_gather_helper" -> "Fxn:_build_tensor(dest";
    "Fxn:_test_gather_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_gather_helper" -> "Fxn:dist.gather(tensor,";
    "Fxn:_test_gather_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_gather_helper" -> "Fxn:self.assertEqual(t1,";
    "Fxn:_test_gather_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_gather_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:_test_gather_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_gather" -> "Fxn:self._init_global_test()";
    "Fxn:test_gather" -> "Fxn:self._test_gather_helper(group,";
    "Fxn:test_gather" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_gather" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_gather_group" -> "Fxn:self._init_group_test()";
    "Fxn:test_gather_group" -> "Fxn:self._test_gather_helper(group,";
    "Fxn:_test_all_gather_helper" -> "Fxn:_build_tensor(dest";
    "Fxn:_test_all_gather_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_all_gather_helper" -> "Fxn:tensor.cuda()";
    "Fxn:_test_all_gather_helper" -> "Fxn:[t.cuda()";
    "Fxn:_test_all_gather_helper" -> "Fxn:dist.all_gather(tensors,";
    "Fxn:_test_all_gather_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_all_gather_helper" -> "Fxn:self.assertEqual(t1,";
    "Fxn:_test_all_gather_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_all_gather_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_gather" -> "Fxn:self._test_all_gather_helper(group,";
    "Fxn:test_all_gather" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather_cuda" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_gather_cuda" -> "Fxn:self._test_all_gather_helper(group,";
    "Fxn:test_all_gather_cuda" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather_group" -> "Fxn:self._init_group_test()";
    "Fxn:test_all_gather_group" -> "Fxn:self._test_all_gather_helper(group,";
    "Fxn:_test_barrier_helper" -> "Fxn:torch.DoubleTensor(1).fill_(0.0)";
    "Fxn:_test_barrier_helper" -> "Fxn:expected_time.fill_(time.time()";
    "Fxn:_test_barrier_helper" -> "Fxn:dist.broadcast(expected_time,";
    "Fxn:_test_barrier_helper" -> "Fxn:time.sleep(WAIT_TIME";
    "Fxn:_test_barrier_helper" -> "Fxn:dist.barrier(group_id)";
    "Fxn:_test_barrier_helper" -> "Fxn:dist.broadcast(expected_time,";
    "Fxn:_test_barrier_helper" -> "Fxn:dist.barrier(group_id)";
    "Fxn:_test_barrier_helper" -> "Fxn:self.assertGreaterEqual(time.time(),";
    "Fxn:_test_barrier_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_barrier_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_barrier" -> "Fxn:self._init_global_test()";
    "Fxn:test_barrier" -> "Fxn:self._test_barrier_helper(group,";
    "Fxn:test_barrier" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_barrier_group" -> "Fxn:self._init_group_test()";
    "Fxn:test_barrier_group" -> "Fxn:self._test_barrier_helper(group,";
    "Fxn:_init_multigpu_helper" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_init_multigpu_helper" -> "Fxn:dist.get_world_size()";
    "Fxn:_init_multigpu_helper" -> "Fxn:apply_hack_for_nccl()";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:[_build_tensor(src";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:-1).cuda(device=i)";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:expected_tensor.cuda(";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:dist.broadcast_multigpu(tensors,";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_broadcast_multigpu_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_broadcast_multigpu" -> "Fxn:self._init_global_test()";
    "Fxn:test_broadcast_multigpu" -> "Fxn:self._init_multigpu_helper()";
    "Fxn:test_broadcast_multigpu" -> "Fxn:self._test_broadcast_multigpu_helper(group,";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:[_build_tensor(src";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:master_value).cuda(device=i)";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:[_build_tensor(src";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:worker_value).cuda(device=i)";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:dist.all_reduce_multigpu(tensors,";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_all_reduce_multigpu_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_reduce_multigpu" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_reduce_multigpu" -> "Fxn:self._init_multigpu_helper()";
    "Fxn:test_all_reduce_multigpu" -> "Fxn:self._test_all_reduce_multigpu_helper(";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:[_build_tensor(src";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:master_value).cuda(device=i)";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:dist.reduce_multigpu(tensors,";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:_build_tensor(src";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:self.assertEqual(tensors[0],";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:[_build_tensor(src";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:worker_value).cuda(device=i)";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:dist.reduce_multigpu(tensors,";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_reduce_multigpu_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_reduce_multigpu" -> "Fxn:self._init_global_test()";
    "Fxn:test_reduce_multigpu" -> "Fxn:self._init_multigpu_helper()";
    "Fxn:test_reduce_multigpu" -> "Fxn:self._test_reduce_multigpu_helper(";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:1).cuda(device=i)";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:[_build_tensor(dest";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:output_tensors.append([t.cuda(device=gpu)";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:expected_output.append([t.cuda(device=gpu)";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:dist.all_gather_multigpu(output_tensors,";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:self.assertEqual(output_tensors,";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:self._barrier()";
    "Fxn:_test_all_gather_multigpu_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_all_gather_multigpu" -> "Fxn:self._init_global_test()";
    "Fxn:test_all_gather_multigpu" -> "Fxn:self._init_multigpu_helper()";
    "Fxn:test_all_gather_multigpu" -> "Fxn:self._test_all_gather_multigpu_helper(group,";
    "Fxn:_test_DDP_helper" -> "Fxn:model.train()";
    "Fxn:_test_DDP_helper" -> "Fxn:model(input_var)";
    "Fxn:_test_DDP_helper" -> "Fxn:loss(output,";
    "Fxn:_test_DDP_helper" -> "Fxn:l.backward()";
    "Fxn:_test_DDP_helper" -> "Fxn:@unittest.skipIf(BACKEND";
    "Fxn:test_DistributedDataParallel" -> "Fxn:self._init_global_test()";
    "Fxn:test_DistributedDataParallel" -> "Fxn:self._init_multigpu_helper()";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Linear(2,";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:nn.Linear(50,";
    "Fxn:__init__" -> "Fxn:nn.ReLU()";
    "Fxn:forward" -> "Fxn:self.relu(self.fc1(x))";
    "Fxn:forward" -> "Fxn:self.relu(self.fc2(x))";
    "Fxn:forward" -> "Fxn:self.fc3(x)";
    "Fxn:forward" -> "Fxn:F.softmax(x,";
    "Fxn:forward" -> "Fxn:Net()";
    "Fxn:forward" -> "Fxn:copy.deepcopy(model)";
    "Fxn:forward" -> "Fxn:model_gpu.cuda(gpu_subset[0])";
    "Fxn:forward" -> "Fxn:copy.deepcopy(model)";
    "Fxn:forward" -> "Fxn:model_DDP.cuda(gpu_subset[0])";
    "Fxn:forward" -> "Fxn:nn.parallel.DistributedDataParallel(model_DDP,";
    "Fxn:forward" -> "Fxn:optim.SGD(model_DDP.parameters(),";
    "Fxn:forward" -> "Fxn:optimizer.zero_grad()";
    "Fxn:forward" -> "Fxn:torch.randn(batch_size,";
    "Fxn:forward" -> "Fxn:torch.randn(batch_size,";
    "Fxn:forward" -> "Fxn:nn.MSELoss()";
    "Fxn:forward" -> "Fxn:self._test_DDP_helper(model_gpu,";
    "Fxn:forward" -> "Fxn:input_cpu.cuda(gpu_subset[0]),";
    "Fxn:forward" -> "Fxn:target.cuda(gpu_subset[0]),";
    "Fxn:forward" -> "Fxn:self._test_DDP_helper(model_DDP,";
    "Fxn:forward" -> "Fxn:model_DDP.module.modules()):";
    "Fxn:forward" -> "Fxn:self.assertEqual(layer_gpu.weight.grad,";
    "Fxn:forward" -> "Fxn:optimizer.step()";
    "Fxn:forward" -> "Fxn:self._test_DDP_helper(model_DDP,";
    "Fxn:forward" -> "Fxn:target.cuda(gpu_subset[0]),";
    "Fxn:forward" -> "Fxn:self._barrier()";
    "class:TestDistBackend(TestCase," -> "Fxn:manager_join";
    "class:TestDistBackend(TestCase," -> "Fxn:wrapper";
    "class:TestDistBackend(TestCase," -> "Fxn:setUpClass";
    "class:TestDistBackend(TestCase," -> "Fxn:setUp";
    "class:TestDistBackend(TestCase," -> "Fxn:tearDown";
    "class:TestDistBackend(TestCase," -> "Fxn:_spawn_process";
    "class:TestDistBackend(TestCase," -> "Fxn:_run";
    "class:TestDistBackend(TestCase," -> "Fxn:_join_and_reduce";
    "Fxn:manager_join" -> "Fxn:@wraps(fn)";
    "Fxn:wrapper" -> "Fxn:self._join_and_reduce(fn)";
    "Fxn:wrapper" -> "Fxn:fn(self)";
    "Fxn:setUpClass" -> "Fxn:attr.startswith('test'):";
    "Fxn:setUpClass" -> "Fxn:cls.manager_join(fn))";
    "Fxn:setUp" -> "Fxn:Barrier.init()";
    "Fxn:setUp" -> "Fxn:self.processes.append(self._spawn_process(rank))";
    "Fxn:tearDown" -> "Fxn:p.terminate()";
    "Fxn:_spawn_process" -> "Fxn:multiprocessing.Process(target=self._run,";
    "Fxn:_spawn_process" -> "Fxn:args=(rank,))";
    "Fxn:_spawn_process" -> "Fxn:process.start()";
    "Fxn:_run" -> "Fxn:dist.init_process_group(init_method=INIT_METHOD,";
    "Fxn:_run" -> "Fxn:world_size=int(WORLD_SIZE))";
    "Fxn:_run" -> "Fxn:sys.exit(0)";
    "Fxn:_run" -> "Fxn:self.id()";
    "Fxn:_run" -> "Fxn:self.id().split(".")[2])()";
    "Fxn:_run" -> "Fxn:sys.exit(0)";
    "Fxn:_join_and_reduce" -> "Fxn:get_timeout(self.id())";
    "Fxn:_join_and_reduce" -> "Fxn:p.join(self.JOIN_TIMEOUT)";
    "Fxn:_join_and_reduce" -> "Fxn:self.assertEqual(p.exitcode,";
    "Fxn:_join_and_reduce" -> "Fxn:self.assertEqual(p.exitcode,";
    "Fxn:_join_and_reduce" -> "Fxn:unittest.SkipTest("cuda";
    "Fxn:_join_and_reduce" -> "Fxn:unittest.SkipTest("multigpu";
    "Fxn:_join_and_reduce" -> "Fxn:unittest.SkipTest("worldsize";
    "Fxn:_join_and_reduce" -> "Fxn:dist.init_process_group(init_method=INIT_METHOD,";
    "/test/test_distributions.py" -> "Import:math";
    "/test/test_distributions.py" -> "Import:numbers";
    "/test/test_distributions.py" -> "Import:unittest";
    "/test/test_distributions.py" -> "Import:namedtuple";
    "/test/test_distributions.py" -> "Import:product";
    "/test/test_distributions.py" -> "Import:shuffle";
    "/test/test_distributions.py" -> "Import:torch";
    "/test/test_distributions.py" -> "Import:TestCase,";
    "/test/test_distributions.py" -> "Import:Variable,";
    "/test/test_distributions.py" -> "Import:(Bernoulli,";
    "/test/test_distributions.py" -> "Import:_kl_expfamily_expfamily";
    "/test/test_distributions.py" -> "Import:biject_to,";
    "/test/test_distributions.py" -> "Import:Constraint,";
    "/test/test_distributions.py" -> "Import:_Dirichlet_backward";
    "/test/test_distributions.py" -> "Import:(AbsTransform,";
    "/test/test_distributions.py" -> "Import:_finfo,";
    "/test/test_distributions.py" -> "Import:numpy";
    "/test/test_distributions.py" -> "Import:scipy.stats";
    "/test/test_distributions.py" -> "Import:scipy.special";
    "/test/test_distributions.py" -> "Fxn:pairwise";
    "/test/test_distributions.py" -> "Fxn:is_all_nan";
    "/test/test_distributions.py" -> "Fxn:unwrap";
    "/test/test_distributions.py" -> "class:TestDistributions(TestCase):";
    "/test/test_distributions.py" -> "class:Rounded(object):";
    "/test/test_distributions.py" -> "class:ArgMax(object):";
    "/test/test_distributions.py" -> "class:ScipyCategorical(object):";
    "/test/test_distributions.py" -> "class:TestRsample(TestCase):";
    "/test/test_distributions.py" -> "class:TestDistributionShapes(TestCase):";
    "/test/test_distributions.py" -> "class:TestKL(TestCase):";
    "/test/test_distributions.py" -> "class:Binomial30(Binomial):";
    "/test/test_distributions.py" -> "class:TestConstraints(TestCase):";
    "/test/test_distributions.py" -> "class:TestNumericalStability(TestCase):";
    "/test/test_distributions.py" -> "class:TestLazyLogitsInitialization(TestCase):";
    "/test/test_distributions.py" -> "class:TestAgainstScipy(TestCase):";
    "/test/test_distributions.py" -> "class:TestTransforms(TestCase):";
    "/test/test_distributions.py" -> "class:TestConstraintRegistry(TestCase):";
    "/test/test_distributions.py" -> "class:TestValidation(TestCase):";
    "class:TestDistributions(TestCase):" -> "Fxn:_gradcheck_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:apply_fn";
    "class:TestDistributions(TestCase):" -> "Fxn:_check_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:_check_sampler_sampler";
    "class:TestDistributions(TestCase):" -> "Fxn:_check_sampler_discrete";
    "class:TestDistributions(TestCase):" -> "Fxn:_check_enumerate_support";
    "class:TestDistributions(TestCase):" -> "Fxn:test_sample_detached";
    "class:TestDistributions(TestCase):" -> "Fxn:test_rsample_requires_grad";
    "class:TestDistributions(TestCase):" -> "Fxn:test_enumerate_support_type";
    "class:TestDistributions(TestCase):" -> "Fxn:test_has_examples";
    "class:TestDistributions(TestCase):" -> "Fxn:test_bernoulli";
    "class:TestDistributions(TestCase):" -> "Fxn:ref_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:test_bernoulli_enumerate_support";
    "class:TestDistributions(TestCase):" -> "Fxn:test_bernoulli_3d";
    "class:TestDistributions(TestCase):" -> "Fxn:test_geometric";
    "class:TestDistributions(TestCase):" -> "Fxn:test_geometric_log_prob_and_entropy";
    "class:TestDistributions(TestCase):" -> "Fxn:ref_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:test_geometric_sample";
    "class:TestDistributions(TestCase):" -> "Fxn:test_binomial";
    "class:TestDistributions(TestCase):" -> "Fxn:test_binomial_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:ref_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:test_binomial_extreme_vals";
    "class:TestDistributions(TestCase):" -> "Fxn:test_multinomial_1d";
    "class:TestDistributions(TestCase):" -> "Fxn:test_multinomial_1d_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:test_multinomial_2d";
    "class:TestDistributions(TestCase):" -> "Fxn:test_categorical_1d";
    "class:TestDistributions(TestCase):" -> "Fxn:test_categorical_2d";
    "class:TestDistributions(TestCase):" -> "Fxn:ref_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:test_categorical_enumerate_support";
    "class:TestDistributions(TestCase):" -> "Fxn:test_one_hot_categorical_1d";
    "class:TestDistributions(TestCase):" -> "Fxn:test_one_hot_categorical_2d";
    "class:TestDistributions(TestCase):" -> "Fxn:test_one_hot_categorical_enumerate_support";
    "class:TestDistributions(TestCase):" -> "Fxn:test_poisson_shape";
    "class:TestDistributions(TestCase):" -> "Fxn:test_poisson_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:ref_log_prob";
    "class:TestDistributions(TestCase):" -> "Fxn:test_poisson_sample";
    "class:TestDistributions(TestCase):" -> "Fxn:test_poisson_gpu_sample";
    "class:TestDistributions(TestCase):" -> "Fxn:test_relaxed_bernoulli";
    "class:TestDistributions(TestCase):" -> "Fxn:test_rounded_relaxed_bernoulli";
    "Fxn:_gradcheck_log_prob" -> "Fxn:dist_ctor(*ctor_params)";
    "Fxn:_gradcheck_log_prob" -> "Fxn:distribution.sample()";
    "Fxn:_gradcheck_log_prob" -> "Fxn:self.assertEqual(s.size(),";
    "Fxn:apply_fn" -> "Fxn:dist_ctor(*params).log_prob(s)";
    "Fxn:apply_fn" -> "Fxn:gradcheck(apply_fn,";
    "Fxn:_check_log_prob" -> "Fxn:dist.sample()";
    "Fxn:_check_log_prob" -> "Fxn:dist.log_prob(s)";
    "Fxn:_check_log_prob" -> "Fxn:log_probs.data.view(-1))):";
    "Fxn:_check_log_prob" -> "Fxn:asset_fn(i,";
    "Fxn:_check_sampler_sampler" -> "Fxn:.sample()";
    "Fxn:_check_sampler_sampler" -> "Fxn:torch_dist.sample((num_samples,)).squeeze()";
    "Fxn:_check_sampler_sampler" -> "Fxn:torch_samples.cpu().numpy()";
    "Fxn:_check_sampler_sampler" -> "Fxn:ref_dist.rvs(num_samples).astype(np.float64)";
    "Fxn:_check_sampler_sampler" -> "Fxn:np.random.normal(size=torch_samples.shape[-1])";
    "Fxn:_check_sampler_sampler" -> "Fxn:np.linalg.norm(axis)";
    "Fxn:_check_sampler_sampler" -> "Fxn:np.dot(torch_samples,";
    "Fxn:_check_sampler_sampler" -> "Fxn:np.dot(ref_samples,";
    "Fxn:_check_sampler_sampler" -> "Fxn:[(x,";
    "Fxn:_check_sampler_sampler" -> "Fxn:[(x,";
    "Fxn:_check_sampler_sampler" -> "Fxn:shuffle(samples)";
    "Fxn:_check_sampler_sampler" -> "Fxn:samples.sort(key=lambda";
    "Fxn:_check_sampler_sampler" -> "Fxn:np.array(samples)[:,";
    "Fxn:_check_sampler_sampler" -> "Fxn:samples.reshape((num_bins,";
    "Fxn:_check_sampler_sampler" -> "Fxn:samples_per_bin)).mean(axis=1)";
    "Fxn:_check_sampler_sampler" -> "Fxn:scipy.special.erfinv(1";
    "Fxn:_check_sampler_sampler" -> "Fxn:'{}.sample()";
    "Fxn:_check_sampler_sampler" -> "Fxn:biased:\n{}'.format(message,";
    "Fxn:_check_sampler_sampler" -> "Fxn:self.assertLess(-threshold,";
    "Fxn:_check_sampler_sampler" -> "Fxn:self.assertLess(bias,";
    "Fxn:_check_sampler_sampler" -> "Fxn:@unittest.skipIf(not";
    "Fxn:_check_sampler_discrete" -> "Fxn:torch_dist.sample((num_samples,)).squeeze()";
    "Fxn:_check_sampler_discrete" -> "Fxn:torch_samples.cpu().numpy()";
    "Fxn:_check_sampler_discrete" -> "Fxn:np.unique(torch_samples,";
    "Fxn:_check_sampler_discrete" -> "Fxn:ref_dist.pmf(unique)";
    "Fxn:_check_sampler_discrete" -> "Fxn:self.assertGreater(pmf[msk].sum(),";
    "Fxn:_check_sampler_discrete" -> "Fxn:scipy.stats.chisquare(counts[msk],";
    "Fxn:_check_sampler_discrete" -> "Fxn:self.assertGreater(p,";
    "Fxn:_check_enumerate_support" -> "Fxn:torch.Tensor(param)";
    "Fxn:_check_enumerate_support" -> "Fxn:torch.Tensor(expected)";
    "Fxn:_check_enumerate_support" -> "Fxn:dist(param).enumerate_support()";
    "Fxn:_check_enumerate_support" -> "Fxn:self.assertEqual(actual,";
    "Fxn:_check_enumerate_support" -> "Fxn:variable(param)";
    "Fxn:_check_enumerate_support" -> "Fxn:variable(expected)";
    "Fxn:_check_enumerate_support" -> "Fxn:dist(param).enumerate_support()";
    "Fxn:_check_enumerate_support" -> "Fxn:self.assertEqual(actual,";
    "Fxn:test_sample_detached" -> "Fxn:param.values()";
    "Fxn:test_sample_detached" -> "Fxn:Dist(**param)";
    "Fxn:test_sample_detached" -> "Fxn:dist.sample()";
    "Fxn:test_sample_detached" -> "Fxn:self.assertFalse(sample.requires_grad,";
    "Fxn:test_sample_detached" -> "Fxn:.sample()";
    "Fxn:test_sample_detached" -> "Fxn:detached'.format(";
    "Fxn:test_rsample_requires_grad" -> "Fxn:param.values()):";
    "Fxn:test_rsample_requires_grad" -> "Fxn:Dist(**param)";
    "Fxn:test_rsample_requires_grad" -> "Fxn:dist.rsample()";
    "Fxn:test_rsample_requires_grad" -> "Fxn:self.assertTrue(sample.requires_grad,";
    "Fxn:test_rsample_requires_grad" -> "Fxn:.rsample()";
    "Fxn:test_rsample_requires_grad" -> "Fxn:grad'.format(";
    "Fxn:test_enumerate_support_type" -> "Fxn:Dist(**param)";
    "Fxn:test_enumerate_support_type" -> "Fxn:self.assertTrue(type(unwrap(dist.sample()))";
    "Fxn:test_enumerate_support_type" -> "Fxn:msg=('{}";
    "Fxn:test_enumerate_support_type" -> "Fxn:enumerate_support.').format(Dist.__name__,";
    "Fxn:test_has_examples" -> "Fxn:self.assertIn(Dist,";
    "Fxn:test_has_examples" -> "Fxn:test_distributions.py".format(Dist.__name__))";
    "Fxn:test_bernoulli" -> "Fxn:torch.tensor([0.7,";
    "Fxn:test_bernoulli" -> "Fxn:torch.tensor(0.3,";
    "Fxn:test_bernoulli" -> "Fxn:self.assertEqual(Bernoulli(p).sample((8,)).size(),";
    "Fxn:test_bernoulli" -> "Fxn:self.assertTrue(isinstance(Bernoulli(p).sample().data,";
    "Fxn:test_bernoulli" -> "Fxn:self.assertEqual(Bernoulli(r).sample((8,)).size(),";
    "Fxn:test_bernoulli" -> "Fxn:self.assertEqual(Bernoulli(r).sample().size(),";
    "Fxn:test_bernoulli" -> "Fxn:self.assertEqual(Bernoulli(r).sample((3,";
    "Fxn:test_bernoulli" -> "Fxn:2)).size(),";
    "Fxn:test_bernoulli" -> "Fxn:self.assertEqual(Bernoulli(s).sample().size(),";
    "Fxn:test_bernoulli" -> "Fxn:self._gradcheck_log_prob(Bernoulli,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:math.log(prob";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Bernoulli(p),";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Bernoulli(logits=p.log()";
    "Fxn:ref_log_prob" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:ref_log_prob" -> "Fxn:Bernoulli(r).rsample)";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(Bernoulli(p).entropy().data,";
    "Fxn:ref_log_prob" -> "Fxn:torch.Tensor([0.6108,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(Bernoulli(torch.Tensor([0.0])).entropy(),";
    "Fxn:ref_log_prob" -> "Fxn:torch.Tensor([0.0]))";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(Bernoulli(s).entropy(),";
    "Fxn:ref_log_prob" -> "Fxn:torch.tensor(0.6108),";
    "Fxn:test_bernoulli_enumerate_support" -> "Fxn:self._check_enumerate_support(Bernoulli,";
    "Fxn:test_bernoulli_3d" -> "Fxn:variable(torch.Tensor(2,";
    "Fxn:test_bernoulli_3d" -> "Fxn:5).fill_(0.5),";
    "Fxn:test_bernoulli_3d" -> "Fxn:self.assertEqual(Bernoulli(p).sample().size(),";
    "Fxn:test_bernoulli_3d" -> "Fxn:self.assertEqual(Bernoulli(p).sample(sample_shape=(2,";
    "Fxn:test_bernoulli_3d" -> "Fxn:5)).size(),";
    "Fxn:test_bernoulli_3d" -> "Fxn:self.assertEqual(Bernoulli(p).sample((2,)).size(),";
    "Fxn:test_geometric" -> "Fxn:variable([0.7,";
    "Fxn:test_geometric" -> "Fxn:variable(0.3,";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(p).sample((8,)).size(),";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(1).sample(),";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(1).log_prob(torch.tensor(1)),";
    "Fxn:test_geometric" -> "Fxn:-float('inf'),";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(1).log_prob(torch.tensor(0)),";
    "Fxn:test_geometric" -> "Fxn:self.assertTrue(isinstance(Geometric(p).sample().data,";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(r).sample((8,)).size(),";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(r).sample().size(),";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(r).sample((3,";
    "Fxn:test_geometric" -> "Fxn:2)).size(),";
    "Fxn:test_geometric" -> "Fxn:self.assertEqual(Geometric(s).sample().size(),";
    "Fxn:test_geometric" -> "Fxn:self._gradcheck_log_prob(Geometric,";
    "Fxn:test_geometric" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_geometric" -> "Fxn:Geometric(0))";
    "Fxn:test_geometric" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:test_geometric" -> "Fxn:Geometric(r).rsample)";
    "Fxn:test_geometric" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_geometric_log_prob_and_entropy" -> "Fxn:variable([0.7,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.geom(prob,";
    "Fxn:ref_log_prob" -> "Fxn:loc=-1).logpmf(val))";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Geometric(p),";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Geometric(logits=p.log()";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(Geometric(p).entropy().data,";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.geom(p.data.numpy(),";
    "Fxn:ref_log_prob" -> "Fxn:loc=-1).entropy(),";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(float(Geometric(s).entropy()),";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.geom(s,";
    "Fxn:ref_log_prob" -> "Fxn:loc=-1).entropy().item(),";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_geometric_sample" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_geometric_sample" -> "Fxn:self._check_sampler_discrete(Geometric(prob),";
    "Fxn:test_geometric_sample" -> "Fxn:scipy.stats.geom(p=prob,";
    "Fxn:test_geometric_sample" -> "Fxn:'Geometric(prob={})'.format(prob))";
    "Fxn:test_binomial" -> "Fxn:variable(torch.arange(0.05,";
    "Fxn:test_binomial" -> "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:test_binomial" -> "Fxn:Binomial(total_count,";
    "Fxn:test_binomial" -> "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:test_binomial" -> "Fxn:Binomial(total_count,";
    "Fxn:test_binomial" -> "Fxn:p.log()),";
    "Fxn:test_binomial" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:test_binomial" -> "Fxn:Binomial(10,";
    "Fxn:test_binomial" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:test_binomial" -> "Fxn:Binomial(10,";
    "Fxn:test_binomial" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_binomial_log_prob" -> "Fxn:variable(torch.arange(0.05,";
    "Fxn:ref_log_prob" -> "Fxn:probs.data.view(-1)[idx].item()";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.binom(total_count,";
    "Fxn:ref_log_prob" -> "Fxn:p).logpmf(x)";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Binomial(total_count,";
    "Fxn:ref_log_prob" -> "Fxn:probs_to_logits(probs,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Binomial(total_count,";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:Binomial(total_count,";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:self.assertEqual(bin0.sample(),";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:self.assertAlmostEqual(bin0.log_prob(torch.tensor([0]))[0],";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:self.assertEqual(float(bin0.log_prob(torch.tensor([1])).exp()),";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:Binomial(total_count,";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:self.assertEqual(bin1.sample(),";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:self.assertAlmostEqual(bin1.log_prob(torch.tensor([total_count]))[0],";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:self.assertEqual(float(bin1.log_prob(torch.tensor([total_count";
    "Fxn:test_binomial_extreme_vals" -> "Fxn:1])).exp()),";
    "Fxn:test_multinomial_1d" -> "Fxn:variable([0.1,";
    "Fxn:test_multinomial_1d" -> "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:test_multinomial_1d" -> "Fxn:p).sample().size(),";
    "Fxn:test_multinomial_1d" -> "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:test_multinomial_1d" -> "Fxn:p).sample((2,";
    "Fxn:test_multinomial_1d" -> "Fxn:2)).size(),";
    "Fxn:test_multinomial_1d" -> "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:test_multinomial_1d" -> "Fxn:p).sample((1,)).size(),";
    "Fxn:test_multinomial_1d" -> "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:test_multinomial_1d" -> "Fxn:Multinomial(total_count,";
    "Fxn:test_multinomial_1d" -> "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:test_multinomial_1d" -> "Fxn:Multinomial(total_count,";
    "Fxn:test_multinomial_1d" -> "Fxn:p.log()),";
    "Fxn:test_multinomial_1d" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:test_multinomial_1d" -> "Fxn:Multinomial(10,";
    "Fxn:test_multinomial_1d" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:variable([0.1,";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:Multinomial(total_count,";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:dist.sample()";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:dist.log_prob(x)";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:torch.Tensor(scipy.stats.multinomial.logpmf(x.numpy(),";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:p=dist.probs.detach().numpy()))";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:self.assertEqual(log_prob.data,";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:Multinomial(total_count,";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:logits=p.log())";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:dist.sample()";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:dist.log_prob(x)";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:torch.Tensor(scipy.stats.multinomial.logpmf(x.numpy(),";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:p=dist.probs.detach().numpy()))";
    "Fxn:test_multinomial_1d_log_prob" -> "Fxn:self.assertEqual(log_prob.data,";
    "Fxn:test_multinomial_2d" -> "Fxn:variable(probabilities,";
    "Fxn:test_multinomial_2d" -> "Fxn:variable(probabilities_1,";
    "Fxn:test_multinomial_2d" -> "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:test_multinomial_2d" -> "Fxn:p).sample().size(),";
    "Fxn:test_multinomial_2d" -> "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:test_multinomial_2d" -> "Fxn:p).sample(sample_shape=(3,";
    "Fxn:test_multinomial_2d" -> "Fxn:4)).size(),";
    "Fxn:test_multinomial_2d" -> "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:test_multinomial_2d" -> "Fxn:p).sample((6,)).size(),";
    "Fxn:test_multinomial_2d" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_multinomial_2d" -> "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:test_multinomial_2d" -> "Fxn:Multinomial(total_count,";
    "Fxn:test_multinomial_2d" -> "Fxn:p.grad.zero_()";
    "Fxn:test_multinomial_2d" -> "Fxn:self._gradcheck_log_prob(lambda";
    "Fxn:test_multinomial_2d" -> "Fxn:Multinomial(total_count,";
    "Fxn:test_multinomial_2d" -> "Fxn:p.log()),";
    "Fxn:test_multinomial_2d" -> "Fxn:self.assertEqual(Multinomial(total_count,";
    "Fxn:test_multinomial_2d" -> "Fxn:s).sample().data,";
    "Fxn:test_multinomial_2d" -> "Fxn:torch.Tensor([[total_count,";
    "Fxn:test_multinomial_2d" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:test_multinomial_2d" -> "Fxn:Multinomial(10,";
    "Fxn:test_categorical_1d" -> "Fxn:variable([0.1,";
    "Fxn:test_categorical_1d" -> "Fxn:self.assertTrue(is_all_nan(Categorical(p).mean))";
    "Fxn:test_categorical_1d" -> "Fxn:self.assertTrue(is_all_nan(Categorical(p).variance))";
    "Fxn:test_categorical_1d" -> "Fxn:self.assertEqual(Categorical(p).sample().size(),";
    "Fxn:test_categorical_1d" -> "Fxn:self.assertTrue(isinstance(Categorical(p).sample().data,";
    "Fxn:test_categorical_1d" -> "Fxn:self.assertEqual(Categorical(p).sample((2,";
    "Fxn:test_categorical_1d" -> "Fxn:2)).size(),";
    "Fxn:test_categorical_1d" -> "Fxn:self.assertEqual(Categorical(p).sample((1,)).size(),";
    "Fxn:test_categorical_1d" -> "Fxn:self._gradcheck_log_prob(Categorical,";
    "Fxn:test_categorical_1d" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:test_categorical_1d" -> "Fxn:Categorical(p).rsample)";
    "Fxn:test_categorical_2d" -> "Fxn:variable(probabilities,";
    "Fxn:test_categorical_2d" -> "Fxn:variable(probabilities_1,";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertEqual(Categorical(p).mean.size(),";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertEqual(Categorical(p).variance.size(),";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertTrue(is_all_nan(Categorical(p).mean))";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertTrue(is_all_nan(Categorical(p).variance))";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertEqual(Categorical(p).sample().size(),";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertEqual(Categorical(p).sample(sample_shape=(3,";
    "Fxn:test_categorical_2d" -> "Fxn:4)).size(),";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertEqual(Categorical(p).sample((6,)).size(),";
    "Fxn:test_categorical_2d" -> "Fxn:self._gradcheck_log_prob(Categorical,";
    "Fxn:test_categorical_2d" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_categorical_2d" -> "Fxn:self.assertEqual(Categorical(s).sample(sample_shape=(2,)).data,";
    "Fxn:test_categorical_2d" -> "Fxn:torch.Tensor([[0,";
    "Fxn:ref_log_prob" -> "Fxn:p.data[idx].sum()";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:math.log(sample_prob))";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Categorical(p),";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Categorical(logits=p.log()),";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(Categorical(p).entropy().data,";
    "Fxn:ref_log_prob" -> "Fxn:torch.Tensor([1.0114,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertEqual(Categorical(s).entropy().data,";
    "Fxn:ref_log_prob" -> "Fxn:torch.Tensor([0.0,";
    "Fxn:test_categorical_enumerate_support" -> "Fxn:self._check_enumerate_support(Categorical,";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:variable([0.1,";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:self.assertEqual(OneHotCategorical(p).sample().size(),";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:self.assertTrue(isinstance(OneHotCategorical(p).sample().data,";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:self.assertEqual(OneHotCategorical(p).sample((2,";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:2)).size(),";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:self.assertEqual(OneHotCategorical(p).sample((1,)).size(),";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:self._gradcheck_log_prob(OneHotCategorical,";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:self.assertRaises(NotImplementedError,";
    "Fxn:test_one_hot_categorical_1d" -> "Fxn:OneHotCategorical(p).rsample)";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:variable(probabilities,";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:variable(probabilities_1,";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:self.assertEqual(OneHotCategorical(p).sample().size(),";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:self.assertEqual(OneHotCategorical(p).sample(sample_shape=(3,";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:4)).size(),";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:self.assertEqual(OneHotCategorical(p).sample((6,)).size(),";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:self._gradcheck_log_prob(OneHotCategorical,";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:OneHotCategorical(p)";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:dist.sample()";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:self.assertEqual(dist.log_prob(x),";
    "Fxn:test_one_hot_categorical_2d" -> "Fxn:Categorical(p).log_prob(x.max(-1)[1]))";
    "Fxn:test_one_hot_categorical_enumerate_support" -> "Fxn:self._check_enumerate_support(OneHotCategorical,";
    "Fxn:test_poisson_shape" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_poisson_shape" -> "Fxn:3).abs(),";
    "Fxn:test_poisson_shape" -> "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:test_poisson_shape" -> "Fxn:self.assertEqual(Poisson(rate).sample().size(),";
    "Fxn:test_poisson_shape" -> "Fxn:self.assertEqual(Poisson(rate).sample((7,)).size(),";
    "Fxn:test_poisson_shape" -> "Fxn:self.assertEqual(Poisson(rate_1d).sample().size(),";
    "Fxn:test_poisson_shape" -> "Fxn:self.assertEqual(Poisson(rate_1d).sample((1,)).size(),";
    "Fxn:test_poisson_shape" -> "Fxn:self.assertEqual(Poisson(2.0).sample((2,)).size(),";
    "Fxn:test_poisson_shape" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_poisson_log_prob" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_poisson_log_prob" -> "Fxn:3).abs(),";
    "Fxn:test_poisson_log_prob" -> "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:ref_log_prob" -> "Fxn:rate.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.poisson.logpmf(x,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:set_rng_seed(0)";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Poisson(rate),";
    "Fxn:ref_log_prob" -> "Fxn:self._gradcheck_log_prob(Poisson,";
    "Fxn:ref_log_prob" -> "Fxn:self._gradcheck_log_prob(Poisson,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_poisson_sample" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_poisson_sample" -> "Fxn:self._check_sampler_discrete(Poisson(rate),";
    "Fxn:test_poisson_sample" -> "Fxn:scipy.stats.poisson(rate),";
    "Fxn:test_poisson_sample" -> "Fxn:'Poisson(lambda={})'.format(rate),";
    "Fxn:test_poisson_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_poisson_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_poisson_gpu_sample" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_poisson_gpu_sample" -> "Fxn:self._check_sampler_discrete(Poisson(torch.Tensor([rate]).cuda()),";
    "Fxn:test_poisson_gpu_sample" -> "Fxn:scipy.stats.poisson(rate),";
    "Fxn:test_poisson_gpu_sample" -> "Fxn:'Poisson(lambda={},";
    "Fxn:test_poisson_gpu_sample" -> "Fxn:cuda)'.format(rate),";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:torch.tensor([0.7,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:torch.tensor(0.3,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:torch.tensor(0.67,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:p).sample((8,)).size(),";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self.assertTrue(isinstance(RelaxedBernoulli(temp,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:p).sample().data,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:r).sample((8,)).size(),";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:r).sample().size(),";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:r).sample((3,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:2)).size(),";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self.assertEqual(RelaxedBernoulli(temp,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:s).sample().size(),";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self._gradcheck_log_prob(RelaxedBernoulli,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:self._gradcheck_log_prob(RelaxedBernoulli,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:RelaxedBernoulli(temp,";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:p).rsample()";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:s.backward(torch.ones_like(s))";
    "Fxn:test_relaxed_bernoulli" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_rounded_relaxed_bernoulli" -> "Fxn:set_rng_seed(0)";
    "class:Rounded(object):" -> "Fxn:__init__";
    "class:Rounded(object):" -> "Fxn:sample";
    "class:Rounded(object):" -> "Fxn:test_relaxed_one_hot_categorical_1d";
    "class:Rounded(object):" -> "Fxn:test_relaxed_one_hot_categorical_2d";
    "class:Rounded(object):" -> "Fxn:test_argmax_relaxed_categorical";
    "Fxn:sample" -> "Fxn:torch.round(self.dist.sample(*args,";
    "Fxn:sample" -> "Fxn:product([0.1,";
    "Fxn:sample" -> "Fxn:self._check_sampler_discrete(Rounded(RelaxedBernoulli(temp,";
    "Fxn:sample" -> "Fxn:scipy.stats.bernoulli(probs),";
    "Fxn:sample" -> "Fxn:'Rounded(RelaxedBernoulli(temp={},";
    "Fxn:sample" -> "Fxn:probs={}))'.format(temp,";
    "Fxn:sample" -> "Fxn:torch.tensor(0.5)";
    "Fxn:sample" -> "Fxn:RelaxedBernoulli(1e10,";
    "Fxn:sample" -> "Fxn:dist.rsample()";
    "Fxn:sample" -> "Fxn:self.assertEqual(equal_probs,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:variable([0.1,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:torch.tensor(0.67,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:self.assertEqual(RelaxedOneHotCategorical(probs=p,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:temperature=temp).sample().size(),";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:self.assertTrue(isinstance(RelaxedOneHotCategorical(probs=p,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:temperature=temp).sample().data,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:self.assertEqual(RelaxedOneHotCategorical(probs=p,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:temperature=temp).sample((2,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:2)).size(),";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:self.assertEqual(RelaxedOneHotCategorical(probs=p,";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:temperature=temp).sample_n(1).size(),";
    "Fxn:test_relaxed_one_hot_categorical_1d" -> "Fxn:self._gradcheck_log_prob(RelaxedOneHotCategorical,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:variable([3.00],";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:variable([0.2],";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:variable(probabilities,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:variable(probabilities_1,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:self.assertEqual(RelaxedOneHotCategorical(temp,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:p).sample().size(),";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:self.assertEqual(RelaxedOneHotCategorical(temp,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:p).sample(sample_shape=(3,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:4)).size(),";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:self.assertEqual(RelaxedOneHotCategorical(temp,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:p).sample_n(6).size(),";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:self._gradcheck_log_prob(RelaxedOneHotCategorical,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:self._gradcheck_log_prob(RelaxedOneHotCategorical,";
    "Fxn:test_relaxed_one_hot_categorical_2d" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_argmax_relaxed_categorical" -> "Fxn:set_rng_seed(0)";
    "class:ArgMax(object):" -> "Fxn:__init__";
    "class:ArgMax(object):" -> "Fxn:sample";
    "Fxn:sample" -> "Fxn:self.dist.sample(*args,";
    "Fxn:sample" -> "Fxn:torch.max(s,";
    "class:ScipyCategorical(object):" -> "Fxn:__init__";
    "class:ScipyCategorical(object):" -> "Fxn:pmf";
    "class:ScipyCategorical(object):" -> "Fxn:test_uniform";
    "class:ScipyCategorical(object):" -> "Fxn:test_cauchy";
    "class:ScipyCategorical(object):" -> "Fxn:test_lognormal";
    "class:ScipyCategorical(object):" -> "Fxn:test_lognormal_logprob";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_lognormal_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_normal";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_normal_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_exponential";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_exponential_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_laplace";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_laplace_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_gamma_shape";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_gamma_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_pareto";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_pareto_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_gumbel";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_gumbel_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_fishersnedecor";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_fishersnedecor_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_chi2_shape";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_chi2_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_studentT";
    "class:ScipyCategorical(object):" -> "Fxn:ref_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_studentT_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_studentT_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_dirichlet_shape";
    "class:ScipyCategorical(object):" -> "Fxn:test_dirichlet_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_dirichlet_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_beta_shape";
    "class:ScipyCategorical(object):" -> "Fxn:test_beta_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_beta_sample";
    "class:ScipyCategorical(object):" -> "Fxn:test_cdf_icdf_inverse";
    "class:ScipyCategorical(object):" -> "Fxn:test_cdf_log_prob";
    "class:ScipyCategorical(object):" -> "Fxn:test_valid_parameter_broadcasting";
    "class:ScipyCategorical(object):" -> "Fxn:test_invalid_parameter_broadcasting";
    "Fxn:pmf" -> "Fxn:np.zeros(samples.shape";
    "Fxn:pmf" -> "Fxn:new_samples[np.arange(samples.shape[0]),";
    "Fxn:pmf" -> "Fxn:self.dist.pmf(new_samples)";
    "Fxn:pmf" -> "Fxn:product([torch.Tensor([0.1,";
    "Fxn:pmf" -> "Fxn:torch.Tensor([0.2,";
    "Fxn:pmf" -> "Fxn:self._check_sampler_discrete(ArgMax(RelaxedOneHotCategorical(temp,";
    "Fxn:pmf" -> "Fxn:ScipyCategorical(scipy.stats.multinomial(1,";
    "Fxn:pmf" -> "Fxn:'Rounded(RelaxedOneHotCategorical(temp={},";
    "Fxn:pmf" -> "Fxn:probs={}))'.format(temp,";
    "Fxn:pmf" -> "Fxn:[torch.Tensor([0.1,";
    "Fxn:pmf" -> "Fxn:torch.Tensor([0.2,";
    "Fxn:pmf" -> "Fxn:torch.ones(probs.size())";
    "Fxn:pmf" -> "Fxn:probs.size()[0]";
    "Fxn:pmf" -> "Fxn:RelaxedOneHotCategorical(1e10,";
    "Fxn:pmf" -> "Fxn:dist.rsample()";
    "Fxn:pmf" -> "Fxn:self.assertEqual(equal_probs,";
    "Fxn:test_uniform" -> "Fxn:variable(torch.zeros(5,";
    "Fxn:test_uniform" -> "Fxn:variable(torch.ones(5,";
    "Fxn:test_uniform" -> "Fxn:variable(torch.zeros(1),";
    "Fxn:test_uniform" -> "Fxn:variable(torch.ones(1)";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(Uniform(low,";
    "Fxn:test_uniform" -> "Fxn:high).sample().size(),";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(Uniform(low,";
    "Fxn:test_uniform" -> "Fxn:high).sample((7,)).size(),";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(Uniform(low_1d,";
    "Fxn:test_uniform" -> "Fxn:high_1d).sample().size(),";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(Uniform(low_1d,";
    "Fxn:test_uniform" -> "Fxn:high_1d).sample((1,)).size(),";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(Uniform(0.0,";
    "Fxn:test_uniform" -> "Fxn:1.0).sample((1,)).size(),";
    "Fxn:test_uniform" -> "Fxn:Uniform(low_1d,";
    "Fxn:test_uniform" -> "Fxn:variable([4.0])";
    "Fxn:test_uniform" -> "Fxn:variable([-1.0])";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(uniform.log_prob(above_high).item(),";
    "Fxn:test_uniform" -> "Fxn:-float('inf'),";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(uniform.log_prob(below_low).item(),";
    "Fxn:test_uniform" -> "Fxn:-float('inf'),";
    "Fxn:test_uniform" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_uniform" -> "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:test_uniform" -> "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:test_uniform" -> "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:test_uniform" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_uniform" -> "Fxn:low.new(low.size()).uniform_()";
    "Fxn:test_uniform" -> "Fxn:torch.set_rng_state(state)";
    "Fxn:test_uniform" -> "Fxn:Uniform(low,";
    "Fxn:test_uniform" -> "Fxn:high).rsample()";
    "Fxn:test_uniform" -> "Fxn:u.backward(torch.ones_like(u))";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(low.grad,";
    "Fxn:test_uniform" -> "Fxn:self.assertEqual(high.grad,";
    "Fxn:test_uniform" -> "Fxn:low.grad.zero_()";
    "Fxn:test_uniform" -> "Fxn:high.grad.zero_()";
    "Fxn:test_cauchy" -> "Fxn:variable(torch.zeros(5,";
    "Fxn:test_cauchy" -> "Fxn:variable(torch.ones(5,";
    "Fxn:test_cauchy" -> "Fxn:variable(torch.zeros(1),";
    "Fxn:test_cauchy" -> "Fxn:variable(torch.ones(1),";
    "Fxn:test_cauchy" -> "Fxn:self.assertTrue(is_all_nan(Cauchy(loc_1d,";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(Cauchy(loc_1d,";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(Cauchy(loc,";
    "Fxn:test_cauchy" -> "Fxn:scale).sample().size(),";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(Cauchy(loc,";
    "Fxn:test_cauchy" -> "Fxn:scale).sample((7,)).size(),";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(Cauchy(loc_1d,";
    "Fxn:test_cauchy" -> "Fxn:scale_1d).sample().size(),";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(Cauchy(loc_1d,";
    "Fxn:test_cauchy" -> "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(Cauchy(0.0,";
    "Fxn:test_cauchy" -> "Fxn:1.0).sample((1,)).size(),";
    "Fxn:test_cauchy" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_cauchy" -> "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:test_cauchy" -> "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:test_cauchy" -> "Fxn:self._gradcheck_log_prob(Uniform,";
    "Fxn:test_cauchy" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_cauchy" -> "Fxn:loc.new(loc.size()).cauchy_()";
    "Fxn:test_cauchy" -> "Fxn:torch.set_rng_state(state)";
    "Fxn:test_cauchy" -> "Fxn:Cauchy(loc,";
    "Fxn:test_cauchy" -> "Fxn:scale).rsample()";
    "Fxn:test_cauchy" -> "Fxn:c.backward(torch.ones_like(c))";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(loc.grad,";
    "Fxn:test_cauchy" -> "Fxn:torch.ones_like(scale))";
    "Fxn:test_cauchy" -> "Fxn:self.assertEqual(scale.grad,";
    "Fxn:test_cauchy" -> "Fxn:loc.grad.zero_()";
    "Fxn:test_cauchy" -> "Fxn:scale.grad.zero_()";
    "Fxn:test_lognormal" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_lognormal" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_lognormal" -> "Fxn:5).abs(),";
    "Fxn:test_lognormal" -> "Fxn:variable(torch.randn(1),";
    "Fxn:test_lognormal" -> "Fxn:variable(torch.randn(1),";
    "Fxn:test_lognormal" -> "Fxn:variable([1.0,";
    "Fxn:test_lognormal" -> "Fxn:variable([1e-5,";
    "Fxn:test_lognormal" -> "Fxn:self.assertEqual(LogNormal(mean,";
    "Fxn:test_lognormal" -> "Fxn:std).sample().size(),";
    "Fxn:test_lognormal" -> "Fxn:self.assertEqual(LogNormal(mean,";
    "Fxn:test_lognormal" -> "Fxn:std).sample((7,)).size(),";
    "Fxn:test_lognormal" -> "Fxn:self.assertEqual(LogNormal(mean_1d,";
    "Fxn:test_lognormal" -> "Fxn:std_1d).sample((1,)).size(),";
    "Fxn:test_lognormal" -> "Fxn:self.assertEqual(LogNormal(mean_1d,";
    "Fxn:test_lognormal" -> "Fxn:std_1d).sample().size(),";
    "Fxn:test_lognormal" -> "Fxn:self.assertEqual(LogNormal(0.2,";
    "Fxn:test_lognormal" -> "Fxn:.6).sample((1,)).size(),";
    "Fxn:test_lognormal" -> "Fxn:self.assertEqual(LogNormal(-0.7,";
    "Fxn:test_lognormal" -> "Fxn:50.0).sample((1,)).size(),";
    "Fxn:test_lognormal" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_lognormal" -> "Fxn:self.assertEqual(LogNormal(mean_delta,";
    "Fxn:test_lognormal" -> "Fxn:std_delta).sample(sample_shape=(1,";
    "Fxn:test_lognormal" -> "Fxn:torch.Tensor([[[math.exp(1),";
    "Fxn:test_lognormal" -> "Fxn:[math.exp(1),";
    "Fxn:test_lognormal" -> "Fxn:self._gradcheck_log_prob(LogNormal,";
    "Fxn:test_lognormal" -> "Fxn:self._gradcheck_log_prob(LogNormal,";
    "Fxn:test_lognormal" -> "Fxn:self._gradcheck_log_prob(LogNormal,";
    "Fxn:test_lognormal" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_lognormal_logprob" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_lognormal_logprob" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_lognormal_logprob" -> "Fxn:1).abs(),";
    "Fxn:ref_log_prob" -> "Fxn:mean.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:std.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.lognorm(s=s,";
    "Fxn:ref_log_prob" -> "Fxn:scale=math.exp(m)).logpdf(x)";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(LogNormal(mean,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_lognormal_sample" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_lognormal_sample" -> "Fxn:product([-1.0,";
    "Fxn:test_lognormal_sample" -> "Fxn:self._check_sampler_sampler(LogNormal(mean,";
    "Fxn:test_lognormal_sample" -> "Fxn:scipy.stats.lognorm(scale=math.exp(mean),";
    "Fxn:test_lognormal_sample" -> "Fxn:'LogNormal(loc={},";
    "Fxn:test_lognormal_sample" -> "Fxn:scale={})'.format(mean,";
    "Fxn:test_normal" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_normal" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_normal" -> "Fxn:5).abs(),";
    "Fxn:test_normal" -> "Fxn:variable(torch.randn(1),";
    "Fxn:test_normal" -> "Fxn:variable(torch.randn(1),";
    "Fxn:test_normal" -> "Fxn:variable([1.0,";
    "Fxn:test_normal" -> "Fxn:variable([1e-5,";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(Normal(loc,";
    "Fxn:test_normal" -> "Fxn:scale).sample().size(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(Normal(loc,";
    "Fxn:test_normal" -> "Fxn:scale).sample((7,)).size(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(Normal(loc_1d,";
    "Fxn:test_normal" -> "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(Normal(loc_1d,";
    "Fxn:test_normal" -> "Fxn:scale_1d).sample().size(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(Normal(0.2,";
    "Fxn:test_normal" -> "Fxn:.6).sample((1,)).size(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(Normal(-0.7,";
    "Fxn:test_normal" -> "Fxn:50.0).sample((1,)).size(),";
    "Fxn:test_normal" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(Normal(loc_delta,";
    "Fxn:test_normal" -> "Fxn:scale_delta).sample(sample_shape=(1,";
    "Fxn:test_normal" -> "Fxn:torch.Tensor([[[1.0,";
    "Fxn:test_normal" -> "Fxn:self._gradcheck_log_prob(Normal,";
    "Fxn:test_normal" -> "Fxn:self._gradcheck_log_prob(Normal,";
    "Fxn:test_normal" -> "Fxn:self._gradcheck_log_prob(Normal,";
    "Fxn:test_normal" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_normal" -> "Fxn:torch.normal(torch.zeros_like(loc),";
    "Fxn:test_normal" -> "Fxn:torch.ones_like(scale))";
    "Fxn:test_normal" -> "Fxn:torch.set_rng_state(state)";
    "Fxn:test_normal" -> "Fxn:Normal(loc,";
    "Fxn:test_normal" -> "Fxn:scale).rsample()";
    "Fxn:test_normal" -> "Fxn:z.backward(torch.ones_like(z))";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(loc.grad,";
    "Fxn:test_normal" -> "Fxn:torch.ones_like(loc))";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(scale.grad,";
    "Fxn:test_normal" -> "Fxn:loc.grad.zero_()";
    "Fxn:test_normal" -> "Fxn:scale.grad.zero_()";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(z.size(),";
    "Fxn:ref_log_prob" -> "Fxn:loc.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scale.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:math.sqrt(2";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:math.log(expected),";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Normal(loc,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_normal_sample" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_normal_sample" -> "Fxn:product([-1.0,";
    "Fxn:test_normal_sample" -> "Fxn:self._check_sampler_sampler(Normal(loc,";
    "Fxn:test_normal_sample" -> "Fxn:scipy.stats.norm(loc=loc,";
    "Fxn:test_normal_sample" -> "Fxn:'Normal(mean={},";
    "Fxn:test_normal_sample" -> "Fxn:std={})'.format(loc,";
    "Fxn:test_exponential" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_exponential" -> "Fxn:5).abs(),";
    "Fxn:test_exponential" -> "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(Exponential(rate).sample().size(),";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(Exponential(rate).sample((7,)).size(),";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(Exponential(rate_1d).sample((1,)).size(),";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(Exponential(rate_1d).sample().size(),";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(Exponential(0.2).sample((1,)).size(),";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(Exponential(50.0).sample((1,)).size(),";
    "Fxn:test_exponential" -> "Fxn:self._gradcheck_log_prob(Exponential,";
    "Fxn:test_exponential" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_exponential" -> "Fxn:rate.new(rate.size()).exponential_()";
    "Fxn:test_exponential" -> "Fxn:torch.set_rng_state(state)";
    "Fxn:test_exponential" -> "Fxn:Exponential(rate).rsample()";
    "Fxn:test_exponential" -> "Fxn:z.backward(torch.ones_like(z))";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(rate.grad,";
    "Fxn:test_exponential" -> "Fxn:rate.grad.zero_()";
    "Fxn:test_exponential" -> "Fxn:self.assertEqual(z.size(),";
    "Fxn:ref_log_prob" -> "Fxn:rate.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:math.log(m)";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Exponential(rate),";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_exponential_sample" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_exponential_sample" -> "Fxn:self._check_sampler_sampler(Exponential(rate),";
    "Fxn:test_exponential_sample" -> "Fxn:scipy.stats.expon(scale=1.";
    "Fxn:test_exponential_sample" -> "Fxn:'Exponential(rate={})'.format(rate))";
    "Fxn:test_laplace" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_laplace" -> "Fxn:variable(torch.randn(5,";
    "Fxn:test_laplace" -> "Fxn:5).abs(),";
    "Fxn:test_laplace" -> "Fxn:variable(torch.randn(1),";
    "Fxn:test_laplace" -> "Fxn:variable(torch.randn(1),";
    "Fxn:test_laplace" -> "Fxn:torch.Tensor([1.0,";
    "Fxn:test_laplace" -> "Fxn:torch.Tensor([1e-5,";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(Laplace(loc,";
    "Fxn:test_laplace" -> "Fxn:scale).sample().size(),";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(Laplace(loc,";
    "Fxn:test_laplace" -> "Fxn:scale).sample((7,)).size(),";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(Laplace(loc_1d,";
    "Fxn:test_laplace" -> "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(Laplace(loc_1d,";
    "Fxn:test_laplace" -> "Fxn:scale_1d).sample().size(),";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(Laplace(0.2,";
    "Fxn:test_laplace" -> "Fxn:.6).sample((1,)).size(),";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(Laplace(-0.7,";
    "Fxn:test_laplace" -> "Fxn:50.0).sample((1,)).size(),";
    "Fxn:test_laplace" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(Laplace(loc_delta,";
    "Fxn:test_laplace" -> "Fxn:scale_delta).sample(sample_shape=(1,";
    "Fxn:test_laplace" -> "Fxn:torch.Tensor([[[1.0,";
    "Fxn:test_laplace" -> "Fxn:self._gradcheck_log_prob(Laplace,";
    "Fxn:test_laplace" -> "Fxn:self._gradcheck_log_prob(Laplace,";
    "Fxn:test_laplace" -> "Fxn:self._gradcheck_log_prob(Laplace,";
    "Fxn:test_laplace" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_laplace" -> "Fxn:torch.ones_like(loc).uniform_(-.5,";
    "Fxn:test_laplace" -> "Fxn:torch.set_rng_state(state)";
    "Fxn:test_laplace" -> "Fxn:Laplace(loc,";
    "Fxn:test_laplace" -> "Fxn:scale).rsample()";
    "Fxn:test_laplace" -> "Fxn:z.backward(torch.ones_like(z))";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(loc.grad,";
    "Fxn:test_laplace" -> "Fxn:torch.ones_like(loc))";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(scale.grad,";
    "Fxn:test_laplace" -> "Fxn:-eps.sign()";
    "Fxn:test_laplace" -> "Fxn:torch.log1p(-2";
    "Fxn:test_laplace" -> "Fxn:eps.abs()))";
    "Fxn:test_laplace" -> "Fxn:loc.grad.zero_()";
    "Fxn:test_laplace" -> "Fxn:scale.grad.zero_()";
    "Fxn:test_laplace" -> "Fxn:self.assertEqual(z.size(),";
    "Fxn:ref_log_prob" -> "Fxn:loc.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scale.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Laplace(loc,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_laplace_sample" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_laplace_sample" -> "Fxn:product([-1.0,";
    "Fxn:test_laplace_sample" -> "Fxn:self._check_sampler_sampler(Laplace(loc,";
    "Fxn:test_laplace_sample" -> "Fxn:scipy.stats.laplace(loc=loc,";
    "Fxn:test_laplace_sample" -> "Fxn:'Laplace(loc={},";
    "Fxn:test_laplace_sample" -> "Fxn:scale={})'.format(loc,";
    "Fxn:test_laplace_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gamma_shape" -> "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:test_gamma_shape" -> "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:test_gamma_shape" -> "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:test_gamma_shape" -> "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:test_gamma_shape" -> "Fxn:self.assertEqual(Gamma(alpha,";
    "Fxn:test_gamma_shape" -> "Fxn:beta).sample().size(),";
    "Fxn:test_gamma_shape" -> "Fxn:self.assertEqual(Gamma(alpha,";
    "Fxn:test_gamma_shape" -> "Fxn:beta).sample((5,)).size(),";
    "Fxn:test_gamma_shape" -> "Fxn:self.assertEqual(Gamma(alpha_1d,";
    "Fxn:test_gamma_shape" -> "Fxn:beta_1d).sample((1,)).size(),";
    "Fxn:test_gamma_shape" -> "Fxn:self.assertEqual(Gamma(alpha_1d,";
    "Fxn:test_gamma_shape" -> "Fxn:beta_1d).sample().size(),";
    "Fxn:test_gamma_shape" -> "Fxn:self.assertEqual(Gamma(0.5,";
    "Fxn:test_gamma_shape" -> "Fxn:0.5).sample().size(),";
    "Fxn:test_gamma_shape" -> "Fxn:self.assertEqual(Gamma(0.5,";
    "Fxn:test_gamma_shape" -> "Fxn:0.5).sample((1,)).size(),";
    "Fxn:ref_log_prob" -> "Fxn:alpha.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:beta.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.gamma.logpdf(x,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Gamma(alpha,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gamma_sample" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_gamma_sample" -> "Fxn:product([0.1,";
    "Fxn:test_gamma_sample" -> "Fxn:self._check_sampler_sampler(Gamma(alpha,";
    "Fxn:test_gamma_sample" -> "Fxn:scipy.stats.gamma(alpha,";
    "Fxn:test_gamma_sample" -> "Fxn:'Gamma(concentration={},";
    "Fxn:test_gamma_sample" -> "Fxn:rate={})'.format(alpha,";
    "Fxn:test_gamma_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_pareto" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_pareto" -> "Fxn:3).abs(),";
    "Fxn:test_pareto" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_pareto" -> "Fxn:3).abs(),";
    "Fxn:test_pareto" -> "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:test_pareto" -> "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(scale,";
    "Fxn:test_pareto" -> "Fxn:alpha).sample().size(),";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(scale,";
    "Fxn:test_pareto" -> "Fxn:alpha).sample((5,)).size(),";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:test_pareto" -> "Fxn:alpha_1d).sample((1,)).size(),";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(scale_1d,";
    "Fxn:test_pareto" -> "Fxn:alpha_1d).sample().size(),";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(1.0,";
    "Fxn:test_pareto" -> "Fxn:1.0).sample().size(),";
    "Fxn:test_pareto" -> "Fxn:self.assertEqual(Pareto(1.0,";
    "Fxn:test_pareto" -> "Fxn:1.0).sample((1,)).size(),";
    "Fxn:ref_log_prob" -> "Fxn:scale.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:alpha.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.pareto.logpdf(x,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Pareto(scale,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_pareto_sample" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_pareto_sample" -> "Fxn:product([0.1,";
    "Fxn:test_pareto_sample" -> "Fxn:self._check_sampler_sampler(Pareto(scale,";
    "Fxn:test_pareto_sample" -> "Fxn:scipy.stats.pareto(alpha,";
    "Fxn:test_pareto_sample" -> "Fxn:'Pareto(scale={},";
    "Fxn:test_pareto_sample" -> "Fxn:alpha={})'.format(scale,";
    "Fxn:test_pareto_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gumbel" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_gumbel" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_gumbel" -> "Fxn:3).abs(),";
    "Fxn:test_gumbel" -> "Fxn:variable(torch.randn(1),";
    "Fxn:test_gumbel" -> "Fxn:variable(torch.randn(1).abs(),";
    "Fxn:test_gumbel" -> "Fxn:self.assertEqual(Gumbel(loc,";
    "Fxn:test_gumbel" -> "Fxn:scale).sample().size(),";
    "Fxn:test_gumbel" -> "Fxn:self.assertEqual(Gumbel(loc,";
    "Fxn:test_gumbel" -> "Fxn:scale).sample((5,)).size(),";
    "Fxn:test_gumbel" -> "Fxn:self.assertEqual(Gumbel(loc_1d,";
    "Fxn:test_gumbel" -> "Fxn:scale_1d).sample().size(),";
    "Fxn:test_gumbel" -> "Fxn:self.assertEqual(Gumbel(loc_1d,";
    "Fxn:test_gumbel" -> "Fxn:scale_1d).sample((1,)).size(),";
    "Fxn:test_gumbel" -> "Fxn:self.assertEqual(Gumbel(1.0,";
    "Fxn:test_gumbel" -> "Fxn:1.0).sample().size(),";
    "Fxn:test_gumbel" -> "Fxn:self.assertEqual(Gumbel(1.0,";
    "Fxn:test_gumbel" -> "Fxn:1.0).sample((1,)).size(),";
    "Fxn:ref_log_prob" -> "Fxn:loc.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scale.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.gumbel_r.logpdf(x,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Gumbel(loc,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gumbel_sample" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_gumbel_sample" -> "Fxn:product([-5.0,";
    "Fxn:test_gumbel_sample" -> "Fxn:self._check_sampler_sampler(Gumbel(loc,";
    "Fxn:test_gumbel_sample" -> "Fxn:scipy.stats.gumbel_r(loc=loc,";
    "Fxn:test_gumbel_sample" -> "Fxn:'Gumbel(loc={},";
    "Fxn:test_gumbel_sample" -> "Fxn:scale={})'.format(loc,";
    "Fxn:test_gumbel_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_fishersnedecor" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_fishersnedecor" -> "Fxn:3).abs(),";
    "Fxn:test_fishersnedecor" -> "Fxn:variable(torch.randn(2,";
    "Fxn:test_fishersnedecor" -> "Fxn:3).abs(),";
    "Fxn:test_fishersnedecor" -> "Fxn:torch.randn(1).abs()";
    "Fxn:test_fishersnedecor" -> "Fxn:torch.randn(1).abs()";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertTrue(is_all_nan(FisherSnedecor(1,";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertTrue(is_all_nan(FisherSnedecor(1,";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertEqual(FisherSnedecor(df1,";
    "Fxn:test_fishersnedecor" -> "Fxn:df2).sample().size(),";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertEqual(FisherSnedecor(df1,";
    "Fxn:test_fishersnedecor" -> "Fxn:df2).sample((5,)).size(),";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertEqual(FisherSnedecor(df1_1d,";
    "Fxn:test_fishersnedecor" -> "Fxn:df2_1d).sample().size(),";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertEqual(FisherSnedecor(df1_1d,";
    "Fxn:test_fishersnedecor" -> "Fxn:df2_1d).sample((1,)).size(),";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertEqual(FisherSnedecor(1.0,";
    "Fxn:test_fishersnedecor" -> "Fxn:1.0).sample().size(),";
    "Fxn:test_fishersnedecor" -> "Fxn:self.assertEqual(FisherSnedecor(1.0,";
    "Fxn:test_fishersnedecor" -> "Fxn:1.0).sample((1,)).size(),";
    "Fxn:ref_log_prob" -> "Fxn:df1.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:df2.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.f.logpdf(x,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(FisherSnedecor(df1,";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_fishersnedecor_sample" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_fishersnedecor_sample" -> "Fxn:product([0.1,";
    "Fxn:test_fishersnedecor_sample" -> "Fxn:self._check_sampler_sampler(FisherSnedecor(df1,";
    "Fxn:test_fishersnedecor_sample" -> "Fxn:scipy.stats.f(df1,";
    "Fxn:test_fishersnedecor_sample" -> "Fxn:'FisherSnedecor(loc={},";
    "Fxn:test_fishersnedecor_sample" -> "Fxn:scale={})'.format(df1,";
    "Fxn:test_fishersnedecor_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_chi2_shape" -> "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:test_chi2_shape" -> "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:test_chi2_shape" -> "Fxn:self.assertEqual(Chi2(df).sample().size(),";
    "Fxn:test_chi2_shape" -> "Fxn:self.assertEqual(Chi2(df).sample((5,)).size(),";
    "Fxn:test_chi2_shape" -> "Fxn:self.assertEqual(Chi2(df_1d).sample((1,)).size(),";
    "Fxn:test_chi2_shape" -> "Fxn:self.assertEqual(Chi2(df_1d).sample().size(),";
    "Fxn:test_chi2_shape" -> "Fxn:self.assertEqual(Chi2(torch.tensor(0.5,";
    "Fxn:test_chi2_shape" -> "Fxn:requires_grad=True)).sample().size(),";
    "Fxn:test_chi2_shape" -> "Fxn:self.assertEqual(Chi2(0.5).sample().size(),";
    "Fxn:test_chi2_shape" -> "Fxn:self.assertEqual(Chi2(0.5).sample((1,)).size(),";
    "Fxn:ref_log_prob" -> "Fxn:df.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.chi2.logpdf(x,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(Chi2(df),";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_chi2_sample" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_chi2_sample" -> "Fxn:self._check_sampler_sampler(Chi2(df),";
    "Fxn:test_chi2_sample" -> "Fxn:scipy.stats.chi2(df),";
    "Fxn:test_chi2_sample" -> "Fxn:'Chi2(df={})'.format(df))";
    "Fxn:test_chi2_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_studentT" -> "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:test_studentT" -> "Fxn:variable(torch.exp(torch.randn(1)),";
    "Fxn:test_studentT" -> "Fxn:self.assertTrue(is_all_nan(StudentT(1).mean))";
    "Fxn:test_studentT" -> "Fxn:self.assertTrue(is_all_nan(StudentT(1).variance))";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(2).variance,";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(df).sample().size(),";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(df).sample((5,)).size(),";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(df_1d).sample((1,)).size(),";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(df_1d).sample().size(),";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(torch.tensor(0.5,";
    "Fxn:test_studentT" -> "Fxn:requires_grad=True)).sample().size(),";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(0.5).sample().size(),";
    "Fxn:test_studentT" -> "Fxn:self.assertEqual(StudentT(0.5).sample((1,)).size(),";
    "Fxn:ref_log_prob" -> "Fxn:df.data.view(-1)[idx]";
    "Fxn:ref_log_prob" -> "Fxn:scipy.stats.t.logpdf(x,";
    "Fxn:ref_log_prob" -> "Fxn:self.assertAlmostEqual(log_prob,";
    "Fxn:ref_log_prob" -> "Fxn:self._check_log_prob(StudentT(df),";
    "Fxn:ref_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_studentT_sample" -> "Fxn:set_rng_seed(11)";
    "Fxn:test_studentT_sample" -> "Fxn:product([0.1,";
    "Fxn:test_studentT_sample" -> "Fxn:self._check_sampler_sampler(StudentT(df=df,";
    "Fxn:test_studentT_sample" -> "Fxn:scipy.stats.t(df=df,";
    "Fxn:test_studentT_sample" -> "Fxn:'StudentT(df={},";
    "Fxn:test_studentT_sample" -> "Fxn:scale={})'.format(df,";
    "Fxn:test_studentT_sample" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_studentT_log_prob" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_studentT_log_prob" -> "Fxn:product([0.1,";
    "Fxn:test_studentT_log_prob" -> "Fxn:StudentT(df=df,";
    "Fxn:test_studentT_log_prob" -> "Fxn:dist.sample((num_samples,))";
    "Fxn:test_studentT_log_prob" -> "Fxn:dist.log_prob(x)";
    "Fxn:test_studentT_log_prob" -> "Fxn:scipy.stats.t.logpdf(x[i],";
    "Fxn:test_studentT_log_prob" -> "Fxn:self.assertAlmostEqual(float(actual_log_prob[i]),";
    "Fxn:test_dirichlet_shape" -> "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:test_dirichlet_shape" -> "Fxn:variable(torch.exp(torch.randn(4)),";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(Dirichlet(alpha).sample().size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(Dirichlet(alpha).sample((5,)).size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(Dirichlet(alpha_1d).sample().size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(Dirichlet(alpha_1d).sample((1,)).size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:torch.exp(torch.randn(5))";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:Dirichlet(alpha)";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:dist.sample((num_samples,))";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:dist.log_prob(x)";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:scipy.stats.dirichlet.logpdf(x[i].numpy(),";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:alpha.numpy())";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:self.assertAlmostEqual(actual_log_prob[i],";
    "Fxn:test_dirichlet_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_dirichlet_sample" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_dirichlet_sample" -> "Fxn:torch.exp(torch.randn(3))";
    "Fxn:test_dirichlet_sample" -> "Fxn:self._check_sampler_sampler(Dirichlet(alpha),";
    "Fxn:test_dirichlet_sample" -> "Fxn:scipy.stats.dirichlet(alpha.numpy()),";
    "Fxn:test_dirichlet_sample" -> "Fxn:'Dirichlet(alpha={})'.format(list(alpha)),";
    "Fxn:test_beta_shape" -> "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:test_beta_shape" -> "Fxn:variable(torch.exp(torch.randn(2,";
    "Fxn:test_beta_shape" -> "Fxn:variable(torch.exp(torch.randn(4)),";
    "Fxn:test_beta_shape" -> "Fxn:variable(torch.exp(torch.randn(4)),";
    "Fxn:test_beta_shape" -> "Fxn:self.assertEqual(Beta(con1,";
    "Fxn:test_beta_shape" -> "Fxn:con0).sample().size(),";
    "Fxn:test_beta_shape" -> "Fxn:self.assertEqual(Beta(con1,";
    "Fxn:test_beta_shape" -> "Fxn:con0).sample((5,)).size(),";
    "Fxn:test_beta_shape" -> "Fxn:self.assertEqual(Beta(con1_1d,";
    "Fxn:test_beta_shape" -> "Fxn:con0_1d).sample().size(),";
    "Fxn:test_beta_shape" -> "Fxn:self.assertEqual(Beta(con1_1d,";
    "Fxn:test_beta_shape" -> "Fxn:con0_1d).sample((1,)).size(),";
    "Fxn:test_beta_shape" -> "Fxn:self.assertEqual(Beta(0.1,";
    "Fxn:test_beta_shape" -> "Fxn:0.3).sample().size(),";
    "Fxn:test_beta_shape" -> "Fxn:self.assertEqual(Beta(0.1,";
    "Fxn:test_beta_shape" -> "Fxn:0.3).sample((5,)).size(),";
    "Fxn:test_beta_shape" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_log_prob" -> "Fxn:np.exp(np.random.normal())";
    "Fxn:test_beta_log_prob" -> "Fxn:np.exp(np.random.normal())";
    "Fxn:test_beta_log_prob" -> "Fxn:Beta(con1,";
    "Fxn:test_beta_log_prob" -> "Fxn:dist.sample()";
    "Fxn:test_beta_log_prob" -> "Fxn:dist.log_prob(x).sum()";
    "Fxn:test_beta_log_prob" -> "Fxn:scipy.stats.beta.logpdf(x,";
    "Fxn:test_beta_log_prob" -> "Fxn:self.assertAlmostEqual(float(actual_log_prob),";
    "Fxn:test_beta_log_prob" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_sample" -> "Fxn:set_rng_seed(1)";
    "Fxn:test_beta_sample" -> "Fxn:product([0.1,";
    "Fxn:test_beta_sample" -> "Fxn:self._check_sampler_sampler(Beta(con1,";
    "Fxn:test_beta_sample" -> "Fxn:scipy.stats.beta(con1,";
    "Fxn:test_beta_sample" -> "Fxn:'Beta(alpha={},";
    "Fxn:test_beta_sample" -> "Fxn:beta={})'.format(con1,";
    "Fxn:test_beta_sample" -> "Fxn:Beta(Tensor([1e-6]),";
    "Fxn:test_beta_sample" -> "Fxn:Tensor([1e-6])).sample()[0]";
    "Fxn:test_beta_sample" -> "Fxn:self.assertTrue(np.isfinite(x)";
    "Fxn:test_beta_sample" -> "Fxn:Beta.sample():";
    "Fxn:test_beta_sample" -> "Fxn:{}'.format(x))";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:Dist(**param)";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:dist.sample(sample_shape=(20,))";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:dist.cdf(samples)";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:dist.icdf(cdf)";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:torch.abs(actual";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:torch.abs(samples))";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:self.assertLess(rel_error.max(),";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:msg='\n'.join([";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:icdf(cdf(x))";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:x'.format(Dist.__name__,";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:{}'.format(samples),";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:'cdf(x)";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:{}'.format(cdf),";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:'icdf(cdf(x))";
    "Fxn:test_cdf_icdf_inverse" -> "Fxn:{}'.format(actual),";
    "Fxn:test_cdf_log_prob" -> "Fxn:Dist(**param)";
    "Fxn:test_cdf_log_prob" -> "Fxn:variable(dist.sample().data,";
    "Fxn:test_cdf_log_prob" -> "Fxn:dist.cdf(samples)";
    "Fxn:test_cdf_log_prob" -> "Fxn:dist.log_prob(samples).exp()";
    "Fxn:test_cdf_log_prob" -> "Fxn:grad(cdfs.sum(),";
    "Fxn:test_cdf_log_prob" -> "Fxn:torch.abs()";
    "Fxn:test_cdf_log_prob" -> "Fxn:self.assertEqual(cdfs_derivative,";
    "Fxn:test_cdf_log_prob" -> "Fxn:message='\n'.join([";
    "Fxn:test_cdf_log_prob" -> "Fxn:pdf(x)'.format(Dist.__name__,";
    "Fxn:test_cdf_log_prob" -> "Fxn:{}'.format(samples),";
    "Fxn:test_cdf_log_prob" -> "Fxn:{}'.format(cdfs),";
    "Fxn:test_cdf_log_prob" -> "Fxn:{}'.format(pdfs),";
    "Fxn:test_cdf_log_prob" -> "Fxn:'grad(cdf)";
    "Fxn:test_cdf_log_prob" -> "Fxn:{}'.format(cdfs_derivative),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([1,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([1])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:df2=torch.tensor([1,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:df2=torch.tensor([1])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:df2=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:df2=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:df2=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:rate=torch.tensor([1,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:rate=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:rate=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:rate=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:rate=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([1,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([1])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([1,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([1])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:alpha=torch.tensor([1,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:alpha=torch.tensor([1])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:alpha=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:alpha=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:alpha=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([1,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:loc=torch.tensor([1])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1],";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:loc=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:scale=torch.tensor([[1]])),";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:dist.sample().size()";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:self.assertEqual(dist_sample_size,";
    "Fxn:test_valid_parameter_broadcasting" -> "Fxn:{}'.format(dist_sample_size,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([[0,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([[[0,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([[0,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([[[0,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([0,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([0,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:torch.tensor([1,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_invalid_parameter_broadcasting" -> "Fxn:.rsample()";
    "class:TestRsample(TestCase):" -> "Fxn:test_gamma";
    "class:TestRsample(TestCase):" -> "Fxn:test_chi2";
    "class:TestRsample(TestCase):" -> "Fxn:test_dirichlet_on_diagonal";
    "class:TestRsample(TestCase):" -> "Fxn:test_beta_wrt_alpha";
    "class:TestRsample(TestCase):" -> "Fxn:test_beta_wrt_beta";
    "class:TestRsample(TestCase):" -> "Fxn:test_dirichlet_multivariate";
    "class:TestRsample(TestCase):" -> "Fxn:test_dirichlet_tangent_field";
    "class:TestRsample(TestCase):" -> "Fxn:compute_v";
    "Fxn:test_gamma" -> "Fxn:variable(torch.FloatTensor([alpha]";
    "Fxn:test_gamma" -> "Fxn:variable(torch.ones(num_samples).type_as(alphas))";
    "Fxn:test_gamma" -> "Fxn:Gamma(alphas,";
    "Fxn:test_gamma" -> "Fxn:betas).rsample()";
    "Fxn:test_gamma" -> "Fxn:x.sum().backward()";
    "Fxn:test_gamma" -> "Fxn:x.data.sort()";
    "Fxn:test_gamma" -> "Fxn:x.numpy()";
    "Fxn:test_gamma" -> "Fxn:alphas.grad.data[ind].numpy()";
    "Fxn:test_gamma" -> "Fxn:cdf(x,alpha).";
    "Fxn:test_gamma" -> "Fxn:cdf(x,";
    "Fxn:test_gamma" -> "Fxn:pdf(x,";
    "Fxn:test_gamma" -> "Fxn:np.abs(actual_grad";
    "Fxn:test_gamma" -> "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:test_gamma" -> "Fxn:'\n'.join([";
    "Fxn:test_gamma" -> "Fxn:Gamma({},";
    "Fxn:test_gamma" -> "Fxn:1)'.format(alpha),";
    "Fxn:test_gamma" -> "Fxn:{}'.format(x),";
    "Fxn:test_gamma" -> "Fxn:{}'.format(expected_grad),";
    "Fxn:test_gamma" -> "Fxn:{}'.format(actual_grad),";
    "Fxn:test_gamma" -> "Fxn:{}'.format(rel_error),";
    "Fxn:test_gamma" -> "Fxn:{}'.format(rel_error.max()),";
    "Fxn:test_gamma" -> "Fxn:x={}'.format(alpha,";
    "Fxn:test_gamma" -> "Fxn:x[rel_error.argmax()]),";
    "Fxn:test_gamma" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_chi2" -> "Fxn:variable(torch.FloatTensor([df]";
    "Fxn:test_chi2" -> "Fxn:Chi2(dfs).rsample()";
    "Fxn:test_chi2" -> "Fxn:x.sum().backward()";
    "Fxn:test_chi2" -> "Fxn:x.data.sort()";
    "Fxn:test_chi2" -> "Fxn:x.numpy()";
    "Fxn:test_chi2" -> "Fxn:dfs.grad.data[ind].numpy()";
    "Fxn:test_chi2" -> "Fxn:cdf(x,df).";
    "Fxn:test_chi2" -> "Fxn:cdf(x,";
    "Fxn:test_chi2" -> "Fxn:pdf(x,";
    "Fxn:test_chi2" -> "Fxn:np.abs(actual_grad";
    "Fxn:test_chi2" -> "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:test_chi2" -> "Fxn:'\n'.join([";
    "Fxn:test_chi2" -> "Fxn:Chi2({})'.format(df),";
    "Fxn:test_chi2" -> "Fxn:{}'.format(x),";
    "Fxn:test_chi2" -> "Fxn:{}'.format(expected_grad),";
    "Fxn:test_chi2" -> "Fxn:{}'.format(actual_grad),";
    "Fxn:test_chi2" -> "Fxn:{}'.format(rel_error),";
    "Fxn:test_chi2" -> "Fxn:{}'.format(rel_error.max()),";
    "Fxn:test_chi2" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:product(grid,";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:variable(torch.FloatTensor([[a0,";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:Dirichlet(alphas).rsample()[:,";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:x.sum().backward()";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:x.data.sort()";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:x.numpy()";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:alphas.grad.data[ind].numpy()[:,";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:cdf(x,alpha).";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:Beta(alpha[0],";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:np.sqrt(alpha))";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:cdf(x,";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:pdf(x,";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:np.abs(actual_grad";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:'\n'.join([";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:Dirichlet([{},";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:{}])'.format(a0,";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:{}'.format(x),";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:{}'.format(expected_grad),";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:{}'.format(actual_grad),";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:{}'.format(rel_error),";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:{}'.format(rel_error.max()),";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:x={}'.format(x[rel_error.argmax()]),";
    "Fxn:test_dirichlet_on_diagonal" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:product(grid,";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:variable(torch.FloatTensor([con1]";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:variable(torch.FloatTensor([con0]";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:num_samples).type_as(con1s))";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:Beta(con1s,";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:con0s).rsample()";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:x.sum().backward()";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:x.data.sort()";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:x.numpy()";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:con1s.grad.data[ind].numpy()";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:cdf(x,con1,con0).";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:np.sqrt(con1))";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:cdf(x,";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:pdf(x,";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:np.abs(actual_grad";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:'\n'.join([";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:Beta({},";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:{})'.format(con1,";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:{}'.format(x),";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:{}'.format(expected_grad),";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:{}'.format(actual_grad),";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:{}'.format(rel_error),";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:{}'.format(rel_error.max()),";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:{}'.format(x[rel_error.argmax()]),";
    "Fxn:test_beta_wrt_alpha" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_beta_wrt_beta" -> "Fxn:product(grid,";
    "Fxn:test_beta_wrt_beta" -> "Fxn:variable(torch.FloatTensor([con0]";
    "Fxn:test_beta_wrt_beta" -> "Fxn:variable(torch.FloatTensor([con1]";
    "Fxn:test_beta_wrt_beta" -> "Fxn:num_samples).type_as(con0s))";
    "Fxn:test_beta_wrt_beta" -> "Fxn:Beta(con1s,";
    "Fxn:test_beta_wrt_beta" -> "Fxn:con0s).rsample()";
    "Fxn:test_beta_wrt_beta" -> "Fxn:x.sum().backward()";
    "Fxn:test_beta_wrt_beta" -> "Fxn:x.data.sort()";
    "Fxn:test_beta_wrt_beta" -> "Fxn:x.numpy()";
    "Fxn:test_beta_wrt_beta" -> "Fxn:con0s.grad.data[ind].numpy()";
    "Fxn:test_beta_wrt_beta" -> "Fxn:cdf(x,con1,con0).";
    "Fxn:test_beta_wrt_beta" -> "Fxn:np.sqrt(con0))";
    "Fxn:test_beta_wrt_beta" -> "Fxn:cdf(x,";
    "Fxn:test_beta_wrt_beta" -> "Fxn:pdf(x,";
    "Fxn:test_beta_wrt_beta" -> "Fxn:np.abs(actual_grad";
    "Fxn:test_beta_wrt_beta" -> "Fxn:self.assertLess(np.max(rel_error),";
    "Fxn:test_beta_wrt_beta" -> "Fxn:'\n'.join([";
    "Fxn:test_beta_wrt_beta" -> "Fxn:Beta({},";
    "Fxn:test_beta_wrt_beta" -> "Fxn:{})'.format(con1,";
    "Fxn:test_beta_wrt_beta" -> "Fxn:{}'.format(x),";
    "Fxn:test_beta_wrt_beta" -> "Fxn:{}'.format(expected_grad),";
    "Fxn:test_beta_wrt_beta" -> "Fxn:{}'.format(actual_grad),";
    "Fxn:test_beta_wrt_beta" -> "Fxn:{}'.format(rel_error),";
    "Fxn:test_beta_wrt_beta" -> "Fxn:{}'.format(rel_error.max()),";
    "Fxn:test_beta_wrt_beta" -> "Fxn:{!r}'.format(x[rel_error.argmax()]),";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:variable(torch.FloatTensor([alpha]),";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:torch.cat([alpha,";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:alpha.new([1])])";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:Dirichlet(alpha_vec.expand(num_samples,";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:3)).rsample()";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:torch.pow(z[:,";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:2.0).mean()";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:grad(loss,";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:self.assertEqual(actual_grad,";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:'\n'.join([";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:torch.abs(expected_grad";
    "Fxn:test_dirichlet_multivariate" -> "Fxn:actual_grad).max(),";
    "Fxn:compute_v" -> "Fxn:torch.stack([";
    "Fxn:compute_v" -> "Fxn:_Dirichlet_backward(x,";
    "Fxn:compute_v" -> "Fxn:torch.eye(3,";
    "Fxn:compute_v" -> "Fxn:3)[i].expand_as(x))[:,";
    "Fxn:compute_v" -> "Fxn:product(alpha_grid,";
    "Fxn:compute_v" -> "Fxn:variable([a1,";
    "Fxn:compute_v" -> "Fxn:requires_grad=True).expand(num_samples,";
    "Fxn:compute_v" -> "Fxn:Dirichlet(alpha).rsample()";
    "Fxn:compute_v" -> "Fxn:grad([Dirichlet(alpha).log_prob(x.detach()).sum()],";
    "Fxn:compute_v" -> "Fxn:grad([Dirichlet(alpha.detach()).log_prob(x).sum()],";
    "Fxn:compute_v" -> "Fxn:torch.stack([grad([x[:,";
    "Fxn:compute_v" -> "Fxn:i].sum()],";
    "Fxn:compute_v" -> "Fxn:self.assertEqual(compute_v(x,";
    "Fxn:compute_v" -> "Fxn:compute_v()";
    "Fxn:compute_v" -> "Fxn:torch.Tensor([[2,";
    "Fxn:compute_v" -> "Fxn:dx.norm(2,";
    "Fxn:compute_v" -> "Fxn:x.min(-1,";
    "Fxn:compute_v" -> "Fxn:compute_v(x";
    "Fxn:compute_v" -> "Fxn:compute_v(x";
    "Fxn:compute_v" -> "Fxn:dx[1]).sum(-1)";
    "Fxn:compute_v" -> "Fxn:log_prob.exp().";
    "Fxn:compute_v" -> "Fxn:v).sum(-1)";
    "Fxn:compute_v" -> "Fxn:self.assertLess(torch.abs(error).max(),";
    "Fxn:compute_v" -> "Fxn:'\n'.join([";
    "Fxn:compute_v" -> "Fxn:'Dirichlet([{},";
    "Fxn:compute_v" -> "Fxn:equation:'.format(a1,";
    "Fxn:compute_v" -> "Fxn:{}'.format(error),";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:setUp";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:tearDown";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_entropy_shape";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_bernoulli_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_bernoulli_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_geometric_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_geometric_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_beta_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_beta_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_binomial_shape";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_multinomial_shape";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_categorical_shape";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_one_hot_categorical_shape";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_cauchy_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_cauchy_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_dirichlet_shape";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_gamma_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_gamma_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_chi2_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_chi2_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_studentT_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_studentT_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_pareto_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_gumbel_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_normal_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_normal_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_uniform_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_uniform_shape_tensor_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_exponential_shape_scalar_param";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_exponential_shape_tensor_param";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_laplace_shape_scalar_params";
    "class:TestDistributionShapes(TestCase):" -> "Fxn:test_laplace_shape_tensor_params";
    "Fxn:setUp" -> "Fxn:self).setUp()";
    "Fxn:setUp" -> "Fxn:variable(torch.ones(3,";
    "Fxn:setUp" -> "Fxn:variable(torch.ones(3,";
    "Fxn:setUp" -> "Fxn:Distribution.set_default_validate_args(True)";
    "Fxn:tearDown" -> "Fxn:self).tearDown()";
    "Fxn:tearDown" -> "Fxn:Distribution.set_default_validate_args(False)";
    "Fxn:test_entropy_shape" -> "Fxn:Dist(validate_args=False,";
    "Fxn:test_entropy_shape" -> "Fxn:dist.entropy().size()";
    "Fxn:test_entropy_shape" -> "Fxn:torch.Size()";
    "Fxn:test_entropy_shape" -> "Fxn:{}'.format(";
    "Fxn:test_entropy_shape" -> "Fxn:self.assertEqual(actual_shape,";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:Bernoulli(0.3)";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:self.assertEqual(bernoulli._batch_shape,";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:self.assertEqual(bernoulli._event_shape,";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:self.assertEqual(bernoulli.sample().size(),";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:self.assertEqual(bernoulli.sample((3,";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:self.assertEqual(bernoulli.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:self.assertEqual(bernoulli.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_bernoulli_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:Bernoulli(torch.tensor([[0.6,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:self.assertEqual(bernoulli._batch_shape,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:self.assertEqual(bernoulli._event_shape,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:self.assertEqual(bernoulli.sample().size(),";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:self.assertEqual(bernoulli.sample((3,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:self.assertEqual(bernoulli.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:self.assertEqual(bernoulli.log_prob(variable(torch.ones(3,";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_bernoulli_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:Geometric(0.3)";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:self.assertEqual(geometric._batch_shape,";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:self.assertEqual(geometric._event_shape,";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:self.assertEqual(geometric.sample().size(),";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:self.assertEqual(geometric.sample((3,";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:self.assertEqual(geometric.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:self.assertEqual(geometric.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_geometric_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:Geometric(torch.tensor([[0.6,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:self.assertEqual(geometric._batch_shape,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:self.assertEqual(geometric._event_shape,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:self.assertEqual(geometric.sample().size(),";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:self.assertEqual(geometric.sample((3,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:self.assertEqual(geometric.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:self.assertEqual(geometric.log_prob(variable(torch.ones(3,";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_geometric_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:Beta(0.1,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_beta_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:Beta(torch.tensor([[0.1,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:torch.tensor([[0.1,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_beta_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_binomial_shape" -> "Fxn:Binomial(10,";
    "Fxn:test_binomial_shape" -> "Fxn:torch.tensor([0.6,";
    "Fxn:test_binomial_shape" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_binomial_shape" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_binomial_shape" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_binomial_shape" -> "Fxn:torch.Size(()))";
    "Fxn:test_binomial_shape" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_binomial_shape" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_binomial_shape" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_binomial_shape" -> "Fxn:2)).size(),";
    "Fxn:test_binomial_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_binomial_shape" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_binomial_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_binomial_shape" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_multinomial_shape" -> "Fxn:Multinomial(10,";
    "Fxn:test_multinomial_shape" -> "Fxn:torch.tensor([[0.6,";
    "Fxn:test_multinomial_shape" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_multinomial_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_multinomial_shape" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_multinomial_shape" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_multinomial_shape" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_multinomial_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_multinomial_shape" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_multinomial_shape" -> "Fxn:2)).size(),";
    "Fxn:test_multinomial_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_multinomial_shape" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_multinomial_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_multinomial_shape" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_multinomial_shape" -> "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:test_multinomial_shape" -> "Fxn:2))).size(),";
    "Fxn:test_multinomial_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape" -> "Fxn:Categorical(torch.tensor([0.6,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size(()))";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size(()))";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size())";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_categorical_shape" -> "Fxn:2)).size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:test_categorical_shape" -> "Fxn:1))).size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape" -> "Fxn:Categorical(torch.tensor([[0.6,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size(()))";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_categorical_shape" -> "Fxn:2)).size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(variable(torch.ones(3,";
    "Fxn:test_categorical_shape" -> "Fxn:1))).size(),";
    "Fxn:test_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:OneHotCategorical(torch.tensor([0.6,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size(()))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:2)).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.tensor_sample_2.sum(-1,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(dist.enumerate_support()).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:variable(torch.ones(3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:OneHotCategorical(torch.tensor([[0.6,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.sample((3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:2)).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.tensor_sample_1.sum(-1,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(dist.enumerate_support()).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((2,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:variable(torch.ones(3,";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:test_one_hot_categorical_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:Cauchy(0,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:self.assertEqual(cauchy._batch_shape,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:self.assertEqual(cauchy._event_shape,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:self.assertEqual(cauchy.sample().size(),";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:self.assertEqual(cauchy.sample(torch.Size((3,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:2))).size(),";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:self.assertEqual(cauchy.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:self.assertEqual(cauchy.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_cauchy_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:Cauchy(torch.tensor([0,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:torch.tensor([1,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:self.assertEqual(cauchy._batch_shape,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:self.assertEqual(cauchy._event_shape,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:self.assertEqual(cauchy.sample().size(),";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:self.assertEqual(cauchy.sample(torch.Size((3,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:2))).size(),";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:self.assertEqual(cauchy.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:self.assertEqual(cauchy.log_prob(variable(torch.ones(2,";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_cauchy_shape_tensor_params" -> "Fxn:torch.Size((2,";
    "Fxn:test_dirichlet_shape" -> "Fxn:Dirichlet(torch.tensor([[0.6,";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(dist._batch_shape,";
    "Fxn:test_dirichlet_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(dist._event_shape,";
    "Fxn:test_dirichlet_shape" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(dist.sample().size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(dist.sample((5,";
    "Fxn:test_dirichlet_shape" -> "Fxn:4)).size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:torch.Size((5,";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.tensor_sample_1.sum(-1,";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:torch.Size((3,)))";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_dirichlet_shape" -> "Fxn:torch.ones((3,";
    "Fxn:test_dirichlet_shape" -> "Fxn:simplex_sample.sum(-1).unsqueeze(-1)";
    "Fxn:test_dirichlet_shape" -> "Fxn:self.assertEqual(dist.log_prob(simplex_sample).size(),";
    "Fxn:test_dirichlet_shape" -> "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:Gamma(1,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:self.assertEqual(gamma._batch_shape,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:self.assertEqual(gamma._event_shape,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:self.assertEqual(gamma.sample().size(),";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:self.assertEqual(gamma.sample((3,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:self.assertEqual(gamma.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:self.assertEqual(gamma.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_gamma_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:Gamma(torch.tensor([1,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:torch.tensor([1,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:self.assertEqual(gamma._batch_shape,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:self.assertEqual(gamma._event_shape,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:self.assertEqual(gamma.sample().size(),";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:self.assertEqual(gamma.sample((3,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:self.assertEqual(gamma.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:self.assertEqual(gamma.log_prob(variable(torch.ones(2,";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_gamma_shape_tensor_params" -> "Fxn:torch.Size((2,";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:Chi2(1)";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:self.assertEqual(chi2._batch_shape,";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:self.assertEqual(chi2._event_shape,";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:self.assertEqual(chi2.sample().size(),";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:self.assertEqual(chi2.sample((3,";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:self.assertEqual(chi2.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:self.assertEqual(chi2.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_chi2_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:Chi2(torch.tensor([1,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:self.assertEqual(chi2._batch_shape,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:self.assertEqual(chi2._event_shape,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:self.assertEqual(chi2.sample().size(),";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:self.assertEqual(chi2.sample((3,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:self.assertEqual(chi2.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:self.assertEqual(chi2.log_prob(variable(torch.ones(2,";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_chi2_shape_tensor_params" -> "Fxn:torch.Size((2,";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:StudentT(1)";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:self.assertEqual(st._batch_shape,";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:self.assertEqual(st._event_shape,";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:self.assertEqual(st.sample().size(),";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:self.assertEqual(st.sample((3,";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:self.assertEqual(st.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:self.assertEqual(st.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_studentT_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:StudentT(torch.tensor([1,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:self.assertEqual(st._batch_shape,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:self.assertEqual(st._event_shape,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:self.assertEqual(st.sample().size(),";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:self.assertEqual(st.sample((3,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:self.assertEqual(st.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:self.assertEqual(st.log_prob(variable(torch.ones(2,";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_studentT_shape_tensor_params" -> "Fxn:torch.Size((2,";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:Pareto(1,";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:self.assertEqual(pareto._batch_shape,";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:self.assertEqual(pareto._event_shape,";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:self.assertEqual(pareto.sample().size(),";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:self.assertEqual(pareto.sample((3,";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:self.assertEqual(pareto.log_prob(self.tensor_sample_1";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:1).size(),";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:self.assertEqual(pareto.log_prob(self.tensor_sample_2";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:1).size(),";
    "Fxn:test_pareto_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:Gumbel(1,";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:self.assertEqual(gumbel._batch_shape,";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:self.assertEqual(gumbel._event_shape,";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:self.assertEqual(gumbel.sample().size(),";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:self.assertEqual(gumbel.sample((3,";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:self.assertEqual(gumbel.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:self.assertEqual(gumbel.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_gumbel_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:Normal(0,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:self.assertEqual(normal._batch_shape,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:self.assertEqual(normal._event_shape,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:self.assertEqual(normal.sample().size(),";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:self.assertEqual(normal.sample((3,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:self.assertEqual(normal.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:self.assertEqual(normal.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_normal_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:Normal(torch.tensor([0,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:torch.tensor([1,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:self.assertEqual(normal._batch_shape,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:self.assertEqual(normal._event_shape,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:self.assertEqual(normal.sample().size(),";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:self.assertEqual(normal.sample((3,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:self.assertEqual(normal.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:self.assertEqual(normal.log_prob(variable(torch.ones(2,";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_normal_shape_tensor_params" -> "Fxn:torch.Size((2,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:Uniform(0,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:self.assertEqual(uniform._batch_shape,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:self.assertEqual(uniform._event_shape,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:self.assertEqual(uniform.sample().size(),";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:self.assertEqual(uniform.sample(torch.Size((3,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:2))).size(),";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:self.assertEqual(uniform.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:self.assertEqual(uniform.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_uniform_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:Uniform(torch.tensor([0,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:torch.tensor([1,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:self.assertEqual(uniform._batch_shape,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:self.assertEqual(uniform._event_shape,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:self.assertEqual(uniform.sample().size(),";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:self.assertEqual(uniform.sample(torch.Size((3,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:2))).size(),";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:self.assertEqual(uniform.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:self.assertEqual(uniform.log_prob(variable(torch.ones(2,";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_uniform_shape_tensor_params" -> "Fxn:torch.Size((2,";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:Exponential(1.)";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:self.assertEqual(expon._batch_shape,";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:torch.Size())";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:self.assertEqual(expon._event_shape,";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:torch.Size())";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:self.assertEqual(expon.sample().size(),";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:torch.Size())";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:self.assertEqual(expon.sample((3,";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:2)).size(),";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:torch.Size((3,";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:self.assertEqual(expon.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:torch.Size((3,";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:self.assertEqual(expon.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_exponential_shape_scalar_param" -> "Fxn:torch.Size((3,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:Exponential(torch.tensor([1,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:self.assertEqual(expon._batch_shape,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:self.assertEqual(expon._event_shape,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:torch.Size(()))";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:self.assertEqual(expon.sample().size(),";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:self.assertEqual(expon.sample((3,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:2)).size(),";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:torch.Size((3,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:self.assertEqual(expon.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:torch.Size((3,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:self.assertEqual(expon.log_prob(variable(torch.ones(2,";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:2))).size(),";
    "Fxn:test_exponential_shape_tensor_param" -> "Fxn:torch.Size((2,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:Laplace(0,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:self.assertEqual(laplace._batch_shape,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:self.assertEqual(laplace._event_shape,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:self.assertEqual(laplace.sample().size(),";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:torch.Size())";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:self.assertEqual(laplace.sample((3,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:2)).size(),";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:self.assertEqual(laplace.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:self.assertEqual(laplace.log_prob(self.tensor_sample_2).size(),";
    "Fxn:test_laplace_shape_scalar_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:Laplace(torch.tensor([0,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:torch.tensor([1,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:self.assertEqual(laplace._batch_shape,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:self.assertEqual(laplace._event_shape,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:torch.Size(()))";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:self.assertEqual(laplace.sample().size(),";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:torch.Size((2,)))";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:self.assertEqual(laplace.sample((3,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:2)).size(),";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:self.assertEqual(laplace.log_prob(self.tensor_sample_1).size(),";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:torch.Size((3,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:self.assertEqual(laplace.log_prob(variable(torch.ones(2,";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:1))).size(),";
    "Fxn:test_laplace_shape_tensor_params" -> "Fxn:torch.Size((2,";
    "class:TestKL(TestCase):" -> "Fxn:setUp";
    "class:Binomial30(Binomial):" -> "Fxn:__init__";
    "class:Binomial30(Binomial):" -> "Fxn:test_kl_monte_carlo";
    "class:Binomial30(Binomial):" -> "Fxn:test_kl_exponential_family";
    "class:Binomial30(Binomial):" -> "Fxn:test_kl_infinite";
    "class:Binomial30(Binomial):" -> "Fxn:test_kl_edgecases";
    "class:Binomial30(Binomial):" -> "Fxn:test_kl_shape";
    "class:Binomial30(Binomial):" -> "Fxn:test_entropy_monte_carlo";
    "class:Binomial30(Binomial):" -> "Fxn:test_entropy_exponential_family";
    "Fxn:__init__" -> "Fxn:self).__init__(30,";
    "Fxn:__init__" -> "Fxn:pairwise(Bernoulli,";
    "Fxn:__init__" -> "Fxn:pairwise(Binomial30,";
    "Fxn:__init__" -> "Fxn:pairwise(Beta,";
    "Fxn:__init__" -> "Fxn:pairwise(Categorical,";
    "Fxn:__init__" -> "Fxn:pairwise(Chi2,";
    "Fxn:__init__" -> "Fxn:pairwise(Dirichlet,";
    "Fxn:__init__" -> "Fxn:pairwise(Exponential,";
    "Fxn:__init__" -> "Fxn:pairwise(Gamma,";
    "Fxn:__init__" -> "Fxn:pairwise(Gumbel,";
    "Fxn:__init__" -> "Fxn:pairwise(Laplace,";
    "Fxn:__init__" -> "Fxn:pairwise(LogNormal,";
    "Fxn:__init__" -> "Fxn:pairwise(Normal,";
    "Fxn:__init__" -> "Fxn:pairwise(OneHotCategorical,";
    "Fxn:__init__" -> "Fxn:pairwise(Pareto,";
    "Fxn:__init__" -> "Fxn:pairwise(Poisson,";
    "Fxn:__init__" -> "Fxn:pairwise(Uniform,";
    "Fxn:__init__" -> "Fxn:pairwise(Uniform,";
    "Fxn:__init__" -> "Fxn:pairwise(Uniform,";
    "Fxn:__init__" -> "Fxn:pairwise(Uniform,";
    "Fxn:__init__" -> "Fxn:Bernoulli(1)),";
    "Fxn:__init__" -> "Fxn:Bernoulli(0)),";
    "Fxn:__init__" -> "Fxn:Categorical(torch.tensor([1,";
    "Fxn:__init__" -> "Fxn:Uniform(0.25,";
    "Fxn:__init__" -> "Fxn:Uniform(0,";
    "Fxn:__init__" -> "Fxn:Uniform(0.25,";
    "Fxn:__init__" -> "Fxn:Pareto(1,";
    "Fxn:__init__" -> "Fxn:Binomial(30,";
    "Fxn:__init__" -> "Fxn:Beta(2,";
    "Fxn:__init__" -> "Fxn:Pareto(2,";
    "Fxn:__init__" -> "Fxn:Uniform(-2,";
    "Fxn:__init__" -> "Fxn:Beta(2,";
    "Fxn:__init__" -> "Fxn:Pareto(2,";
    "Fxn:__init__" -> "Fxn:Uniform(-2,";
    "Fxn:__init__" -> "Fxn:Beta(3,";
    "Fxn:__init__" -> "Fxn:Pareto(3,";
    "Fxn:__init__" -> "Fxn:Uniform(-3,";
    "Fxn:__init__" -> "Fxn:Beta(3,";
    "Fxn:__init__" -> "Fxn:Chi2(3)),";
    "Fxn:__init__" -> "Fxn:Exponential(3)),";
    "Fxn:__init__" -> "Fxn:Gamma(3,";
    "Fxn:__init__" -> "Fxn:Pareto(3,";
    "Fxn:__init__" -> "Fxn:Uniform(-3,";
    "Fxn:__init__" -> "Fxn:Beta(3,";
    "Fxn:__init__" -> "Fxn:Chi2(3)),";
    "Fxn:__init__" -> "Fxn:Exponential(3)),";
    "Fxn:__init__" -> "Fxn:Gamma(3,";
    "Fxn:__init__" -> "Fxn:Pareto(3,";
    "Fxn:__init__" -> "Fxn:Uniform(-3,";
    "Fxn:__init__" -> "Fxn:Beta(3,";
    "Fxn:__init__" -> "Fxn:Chi2(3)),";
    "Fxn:__init__" -> "Fxn:Exponential(3)),";
    "Fxn:__init__" -> "Fxn:Gamma(3,";
    "Fxn:__init__" -> "Fxn:Pareto(3,";
    "Fxn:__init__" -> "Fxn:Uniform(-3,";
    "Fxn:__init__" -> "Fxn:Chi2(3)),";
    "Fxn:__init__" -> "Fxn:Exponential(3)),";
    "Fxn:__init__" -> "Fxn:Gamma(3,";
    "Fxn:__init__" -> "Fxn:Normal(-3,";
    "Fxn:__init__" -> "Fxn:Pareto(3,";
    "Fxn:__init__" -> "Fxn:Bernoulli(0.5)),";
    "Fxn:__init__" -> "Fxn:Binomial(10,";
    "Fxn:__init__" -> "Fxn:Beta(2,";
    "Fxn:__init__" -> "Fxn:Beta(3,";
    "Fxn:__init__" -> "Fxn:Beta(3,";
    "Fxn:__init__" -> "Fxn:Chi2(3)),";
    "Fxn:__init__" -> "Fxn:Exponential(3)),";
    "Fxn:__init__" -> "Fxn:Gamma(3,";
    "Fxn:__init__" -> "Fxn:Pareto(3,";
    "Fxn:test_kl_monte_carlo" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_kl_monte_carlo" -> "Fxn:KL({},";
    "Fxn:test_kl_monte_carlo" -> "Fxn:Carlo'.format(type(p).__name__,";
    "Fxn:test_kl_monte_carlo" -> "Fxn:kl_divergence(p,";
    "Fxn:test_kl_monte_carlo" -> "Fxn:p.sample(sample_shape=(self.samples_per_batch,))";
    "Fxn:test_kl_monte_carlo" -> "Fxn:q.log_prob(x)).sum(0)";
    "Fxn:test_kl_monte_carlo" -> "Fxn:x.size(0)";
    "Fxn:test_kl_monte_carlo" -> "Fxn:torch.abs(expected";
    "Fxn:test_kl_monte_carlo" -> "Fxn:error].max()";
    "Fxn:test_kl_monte_carlo" -> "Fxn:self.assertLess(error[error";
    "Fxn:test_kl_monte_carlo" -> "Fxn:error].max(),";
    "Fxn:test_kl_monte_carlo" -> "Fxn:'\n'.join([";
    "Fxn:test_kl_monte_carlo" -> "Fxn:KL({},";
    "Fxn:test_kl_monte_carlo" -> "Fxn:{}).'.format(type(p).__name__,";
    "Fxn:test_kl_monte_carlo" -> "Fxn:{}'.format(denominator,";
    "Fxn:test_kl_monte_carlo" -> "Fxn:{}'.format(actual),";
    "Fxn:test_kl_exponential_family" -> "Fxn:KL({},";
    "Fxn:test_kl_exponential_family" -> "Fxn:Divergence'.format(type(p).__name__,";
    "Fxn:test_kl_exponential_family" -> "Fxn:kl_divergence(p,";
    "Fxn:test_kl_exponential_family" -> "Fxn:_kl_expfamily_expfamily(p,";
    "Fxn:test_kl_exponential_family" -> "Fxn:self.assertEqual(actual,";
    "Fxn:test_kl_exponential_family" -> "Fxn:message='\n'.join([";
    "Fxn:test_kl_exponential_family" -> "Fxn:KL({},";
    "Fxn:test_kl_exponential_family" -> "Fxn:{}).'.format(type(p).__name__,";
    "Fxn:test_kl_exponential_family" -> "Fxn:{}'.format(expected),";
    "Fxn:test_kl_exponential_family" -> "Fxn:{}'.format(actual),";
    "Fxn:test_kl_exponential_family" -> "Fxn:{}'.format(torch.abs(actual";
    "Fxn:test_kl_exponential_family" -> "Fxn:expected).max())";
    "Fxn:test_kl_infinite" -> "Fxn:self.assertTrue((kl_divergence(p,";
    "Fxn:test_kl_infinite" -> "Fxn:KL({},";
    "Fxn:test_kl_infinite" -> "Fxn:{})'.format(type(p).__name__,";
    "Fxn:test_kl_edgecases" -> "Fxn:self.assertEqual(kl_divergence(Bernoulli(0),";
    "Fxn:test_kl_edgecases" -> "Fxn:Bernoulli(0)),";
    "Fxn:test_kl_edgecases" -> "Fxn:self.assertEqual(kl_divergence(Bernoulli(1),";
    "Fxn:test_kl_edgecases" -> "Fxn:Bernoulli(1)),";
    "Fxn:test_kl_edgecases" -> "Fxn:self.assertEqual(kl_divergence(Categorical(torch.tensor([0,";
    "Fxn:test_kl_edgecases" -> "Fxn:Categorical(torch.tensor([0,";
    "Fxn:test_kl_shape" -> "Fxn:Dist(**param)";
    "Fxn:test_kl_shape" -> "Fxn:kl_divergence(dist,";
    "Fxn:test_kl_shape" -> "Fxn:torch.Size()";
    "Fxn:test_kl_shape" -> "Fxn:self.assertEqual(kl.shape,";
    "Fxn:test_kl_shape" -> "Fxn:message='\n'.join([";
    "Fxn:test_kl_shape" -> "Fxn:{}/{}'.format(Dist.__name__,";
    "Fxn:test_kl_shape" -> "Fxn:{}'.format(expected_shape),";
    "Fxn:test_kl_shape" -> "Fxn:{}'.format(kl.shape),";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:set_rng_seed(0)";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:Dist(**param)";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:dist.entropy()";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:dist.sample(sample_shape=(50000,))";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:-dist.log_prob(x).mean(0)";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:self.assertEqual(actual,";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:message='\n'.join([";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:.entropy().'.format(Dist.__name__,";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:{}'.format(expected),";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:{}'.format(actual),";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:{}'.format(torch.abs(actual";
    "Fxn:test_entropy_monte_carlo" -> "Fxn:expected).max()),";
    "Fxn:test_entropy_exponential_family" -> "Fxn:Dist(**param)";
    "Fxn:test_entropy_exponential_family" -> "Fxn:dist.entropy()";
    "Fxn:test_entropy_exponential_family" -> "Fxn:ExponentialFamily.entropy(dist)";
    "Fxn:test_entropy_exponential_family" -> "Fxn:self.assertEqual(actual,";
    "Fxn:test_entropy_exponential_family" -> "Fxn:message='\n'.join([";
    "Fxn:test_entropy_exponential_family" -> "Fxn:.entropy().'.format(Dist.__name__,";
    "Fxn:test_entropy_exponential_family" -> "Fxn:{}'.format(expected),";
    "Fxn:test_entropy_exponential_family" -> "Fxn:{}'.format(actual),";
    "Fxn:test_entropy_exponential_family" -> "Fxn:{}'.format(torch.abs(actual";
    "Fxn:test_entropy_exponential_family" -> "Fxn:expected).max())";
    "class:TestConstraints(TestCase):" -> "Fxn:test_params_contains";
    "class:TestConstraints(TestCase):" -> "Fxn:test_support_contains";
    "Fxn:test_params_contains" -> "Fxn:Dist(**param)";
    "Fxn:test_params_contains" -> "Fxn:param.items():";
    "Fxn:test_params_contains" -> "Fxn:torch.Tensor([value])";
    "Fxn:test_params_contains" -> "Fxn:value.sum(-1,";
    "Fxn:test_params_contains" -> "Fxn:is_dependent(constraint):";
    "Fxn:test_params_contains" -> "Fxn:{}'.format(";
    "Fxn:test_params_contains" -> "Fxn:self.assertTrue(constraint.check(value).all(),";
    "Fxn:test_support_contains" -> "Fxn:self.assertIsInstance(Dist.support,";
    "Fxn:test_support_contains" -> "Fxn:Dist(**param)";
    "Fxn:test_support_contains" -> "Fxn:dist.sample()";
    "Fxn:test_support_contains" -> "Fxn:{}'.format(";
    "Fxn:test_support_contains" -> "Fxn:self.assertTrue(constraint.check(value).all(),";
    "class:TestNumericalStability(TestCase):" -> "Fxn:_test_pdf_score";
    "class:TestNumericalStability(TestCase):" -> "Fxn:test_bernoulli_gradient";
    "class:TestNumericalStability(TestCase):" -> "Fxn:test_bernoulli_with_logits_underflow";
    "class:TestNumericalStability(TestCase):" -> "Fxn:test_bernoulli_with_logits_overflow";
    "class:TestNumericalStability(TestCase):" -> "Fxn:test_categorical_log_prob";
    "class:TestNumericalStability(TestCase):" -> "Fxn:test_categorical_log_prob_with_logits";
    "class:TestNumericalStability(TestCase):" -> "Fxn:test_multinomial_log_prob";
    "class:TestNumericalStability(TestCase):" -> "Fxn:test_multinomial_log_prob_with_logits";
    "Fxn:_test_pdf_score" -> "Fxn:Variable(probs,";
    "Fxn:_test_pdf_score" -> "Fxn:dist_class(p)";
    "Fxn:_test_pdf_score" -> "Fxn:Variable(logits,";
    "Fxn:_test_pdf_score" -> "Fxn:dist_class(logits=p)";
    "Fxn:_test_pdf_score" -> "Fxn:dist.log_prob(Variable(x))";
    "Fxn:_test_pdf_score" -> "Fxn:log_pdf.sum().backward()";
    "Fxn:_test_pdf_score" -> "Fxn:self.assertEqual(log_pdf.data,";
    "Fxn:_test_pdf_score" -> "Fxn:.format(type(x),";
    "Fxn:_test_pdf_score" -> "Fxn:self.assertEqual(p.grad.data,";
    "Fxn:_test_pdf_score" -> "Fxn:.format(type(x),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:test_bernoulli_gradient" -> "Fxn:probs=tensor_type([0]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:x=tensor_type([0]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_value=tensor_type([0]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:test_bernoulli_gradient" -> "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:test_bernoulli_gradient" -> "Fxn:probs=tensor_type([0]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:x=tensor_type([1]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_value=tensor_type([_finfo(tensor_type([])).eps]).log(),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:test_bernoulli_gradient" -> "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:test_bernoulli_gradient" -> "Fxn:probs=tensor_type([1e-4]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:x=tensor_type([1]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_value=tensor_type([math.log(1e-4)]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_gradient=tensor_type([10000]))";
    "Fxn:test_bernoulli_gradient" -> "Fxn:torch.FloatTensor([0.9999]))";
    "Fxn:test_bernoulli_gradient" -> "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:test_bernoulli_gradient" -> "Fxn:probs=tensor_type([1";
    "Fxn:test_bernoulli_gradient" -> "Fxn:x=tensor_type([0]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_value=tensor_type([math.log(1e-4)]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_gradient=tensor_type([-10000]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:test_bernoulli_gradient" -> "Fxn:logits=tensor_type([math.log(9999)]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:x=tensor_type([0]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_value=tensor_type([math.log(1e-4)]),";
    "Fxn:test_bernoulli_gradient" -> "Fxn:expected_gradient=tensor_type([-1]),";
    "Fxn:test_bernoulli_with_logits_underflow" -> "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:test_bernoulli_with_logits_underflow" -> "Fxn:logits=tensor_type([lim]),";
    "Fxn:test_bernoulli_with_logits_underflow" -> "Fxn:x=tensor_type([0]),";
    "Fxn:test_bernoulli_with_logits_underflow" -> "Fxn:expected_value=tensor_type([0]),";
    "Fxn:test_bernoulli_with_logits_underflow" -> "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:test_bernoulli_with_logits_overflow" -> "Fxn:self._test_pdf_score(dist_class=Bernoulli,";
    "Fxn:test_bernoulli_with_logits_overflow" -> "Fxn:logits=tensor_type([lim]),";
    "Fxn:test_bernoulli_with_logits_overflow" -> "Fxn:x=tensor_type([1]),";
    "Fxn:test_bernoulli_with_logits_overflow" -> "Fxn:expected_value=tensor_type([0]),";
    "Fxn:test_bernoulli_with_logits_overflow" -> "Fxn:expected_gradient=tensor_type([0]))";
    "Fxn:test_categorical_log_prob" -> "Fxn:variable(tensor_type([0,";
    "Fxn:test_categorical_log_prob" -> "Fxn:OneHotCategorical(p)";
    "Fxn:test_categorical_log_prob" -> "Fxn:categorical.log_prob(variable(tensor_type([0,";
    "Fxn:test_categorical_log_prob" -> "Fxn:self.assertEqual(log_pdf.item(),";
    "Fxn:test_categorical_log_prob_with_logits" -> "Fxn:variable(tensor_type([-float('inf'),";
    "Fxn:test_categorical_log_prob_with_logits" -> "Fxn:OneHotCategorical(logits=p)";
    "Fxn:test_categorical_log_prob_with_logits" -> "Fxn:categorical.log_prob(variable(tensor_type([0,";
    "Fxn:test_categorical_log_prob_with_logits" -> "Fxn:self.assertEqual(log_pdf_prob_1.item(),";
    "Fxn:test_categorical_log_prob_with_logits" -> "Fxn:categorical.log_prob(variable(tensor_type([1,";
    "Fxn:test_categorical_log_prob_with_logits" -> "Fxn:self.assertEqual(log_pdf_prob_0.item(),";
    "Fxn:test_categorical_log_prob_with_logits" -> "Fxn:-float('inf'),";
    "Fxn:test_multinomial_log_prob" -> "Fxn:variable(tensor_type([0,";
    "Fxn:test_multinomial_log_prob" -> "Fxn:variable(tensor_type([0,";
    "Fxn:test_multinomial_log_prob" -> "Fxn:Multinomial(10,";
    "Fxn:test_multinomial_log_prob" -> "Fxn:multinomial.log_prob(s)";
    "Fxn:test_multinomial_log_prob" -> "Fxn:self.assertEqual(log_pdf.item(),";
    "Fxn:test_multinomial_log_prob_with_logits" -> "Fxn:variable(tensor_type([-float('inf'),";
    "Fxn:test_multinomial_log_prob_with_logits" -> "Fxn:Multinomial(10,";
    "Fxn:test_multinomial_log_prob_with_logits" -> "Fxn:multinomial.log_prob(variable(tensor_type([0,";
    "Fxn:test_multinomial_log_prob_with_logits" -> "Fxn:self.assertEqual(log_pdf_prob_1.item(),";
    "Fxn:test_multinomial_log_prob_with_logits" -> "Fxn:multinomial.log_prob(variable(tensor_type([10,";
    "Fxn:test_multinomial_log_prob_with_logits" -> "Fxn:self.assertEqual(log_pdf_prob_0.item(),";
    "Fxn:test_multinomial_log_prob_with_logits" -> "Fxn:-float('inf'),";
    "class:TestLazyLogitsInitialization(TestCase):" -> "Fxn:setUp";
    "class:TestLazyLogitsInitialization(TestCase):" -> "Fxn:test_lazy_logits_initialization";
    "class:TestLazyLogitsInitialization(TestCase):" -> "Fxn:test_lazy_probs_initialization";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:param.pop('probs')";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:probs_to_logits(probs)";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:Dist(**param)";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:dist.log_prob(variable(torch.ones(shape)))";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:0/{}'.format(Dist.__name__,";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:self.assertFalse('probs'";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:dist.enumerate_support()";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:self.assertFalse('probs'";
    "Fxn:test_lazy_logits_initialization" -> "Fxn:self.assertFalse('probs'";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:Dist(**param)";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:dist.sample()";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:0/{}'.format(Dist.__name__,";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:self.assertFalse('logits'";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:dist.enumerate_support()";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:self.assertFalse('logits'";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:self.assertFalse('logits'";
    "Fxn:test_lazy_probs_initialization" -> "Fxn:@unittest.skipIf(not";
    "class:TestAgainstScipy(TestCase):" -> "Fxn:setUp";
    "class:TestAgainstScipy(TestCase):" -> "Fxn:test_mean";
    "class:TestAgainstScipy(TestCase):" -> "Fxn:test_variance_stddev";
    "class:TestAgainstScipy(TestCase):" -> "Fxn:test_cdf";
    "class:TestAgainstScipy(TestCase):" -> "Fxn:test_icdf";
    "Fxn:setUp" -> "Fxn:variable(torch.Tensor(20,).normal_()).exp()";
    "Fxn:setUp" -> "Fxn:variable(torch.Tensor(20,).normal_()).exp()";
    "Fxn:setUp" -> "Fxn:variable(torch.Tensor(20,).normal_())";
    "Fxn:setUp" -> "Fxn:torch.Tensor(20,).normal_()";
    "Fxn:setUp" -> "Fxn:softmax(random_tensor)";
    "Fxn:setUp" -> "Fxn:Bernoulli(simplex_tensor),";
    "Fxn:setUp" -> "Fxn:scipy.stats.bernoulli(simplex_tensor)";
    "Fxn:setUp" -> "Fxn:Beta(positive_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.beta(positive_var,";
    "Fxn:setUp" -> "Fxn:Binomial(10,";
    "Fxn:setUp" -> "Fxn:scipy.stats.binom(10";
    "Fxn:setUp" -> "Fxn:np.ones(simplex_tensor.shape),";
    "Fxn:setUp" -> "Fxn:Cauchy(random_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.cauchy(loc=random_var,";
    "Fxn:setUp" -> "Fxn:Dirichlet(positive_var),";
    "Fxn:setUp" -> "Fxn:scipy.stats.dirichlet(positive_var)";
    "Fxn:setUp" -> "Fxn:Exponential(positive_var),";
    "Fxn:setUp" -> "Fxn:scipy.stats.expon(scale=positive_var.reciprocal())";
    "Fxn:setUp" -> "Fxn:FisherSnedecor(positive_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.f(positive_var,";
    "Fxn:setUp" -> "Fxn:Gamma(positive_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.gamma(positive_var,";
    "Fxn:setUp" -> "Fxn:scale=positive_var2.reciprocal())";
    "Fxn:setUp" -> "Fxn:Geometric(simplex_tensor),";
    "Fxn:setUp" -> "Fxn:scipy.stats.geom(simplex_tensor,";
    "Fxn:setUp" -> "Fxn:Gumbel(random_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.gumbel_r(random_var,";
    "Fxn:setUp" -> "Fxn:Laplace(random_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.laplace(random_var,";
    "Fxn:setUp" -> "Fxn:LogNormal(random_var,";
    "Fxn:setUp" -> "Fxn:positive_var.clamp(max=3)),";
    "Fxn:setUp" -> "Fxn:scipy.stats.lognorm(s=positive_var.clamp(max=3),";
    "Fxn:setUp" -> "Fxn:scale=random_var.exp())";
    "Fxn:setUp" -> "Fxn:Multinomial(10,";
    "Fxn:setUp" -> "Fxn:scipy.stats.multinomial(10,";
    "Fxn:setUp" -> "Fxn:Normal(random_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.norm(random_var,";
    "Fxn:setUp" -> "Fxn:OneHotCategorical(simplex_tensor),";
    "Fxn:setUp" -> "Fxn:scipy.stats.multinomial(1,";
    "Fxn:setUp" -> "Fxn:Pareto(positive_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.pareto(2";
    "Fxn:setUp" -> "Fxn:Poisson(positive_var),";
    "Fxn:setUp" -> "Fxn:scipy.stats.poisson(positive_var)";
    "Fxn:setUp" -> "Fxn:StudentT(2";
    "Fxn:setUp" -> "Fxn:scipy.stats.t(2";
    "Fxn:setUp" -> "Fxn:Uniform(random_var,";
    "Fxn:setUp" -> "Fxn:scipy.stats.uniform(random_var,";
    "Fxn:test_mean" -> "Fxn:self.assertEqual(pytorch_dist.mean,";
    "Fxn:test_mean" -> "Fxn:scipy_dist.mean(),";
    "Fxn:test_variance_stddev" -> "Fxn:self.assertEqual(pytorch_dist.variance,";
    "Fxn:test_variance_stddev" -> "Fxn:np.diag(scipy_dist.cov()),";
    "Fxn:test_variance_stddev" -> "Fxn:self.assertEqual(pytorch_dist.stddev,";
    "Fxn:test_variance_stddev" -> "Fxn:np.diag(scipy_dist.cov())";
    "Fxn:test_variance_stddev" -> "Fxn:self.assertEqual(pytorch_dist.variance,";
    "Fxn:test_variance_stddev" -> "Fxn:scipy_dist.var(),";
    "Fxn:test_variance_stddev" -> "Fxn:self.assertEqual(pytorch_dist.stddev,";
    "Fxn:test_variance_stddev" -> "Fxn:scipy_dist.var()";
    "Fxn:test_cdf" -> "Fxn:pytorch_dist.sample((5,))";
    "Fxn:test_cdf" -> "Fxn:pytorch_dist.cdf(samples)";
    "Fxn:test_cdf" -> "Fxn:self.assertEqual(cdf,";
    "Fxn:test_cdf" -> "Fxn:scipy_dist.cdf(samples),";
    "Fxn:test_icdf" -> "Fxn:variable(torch.rand((5,)";
    "Fxn:test_icdf" -> "Fxn:pytorch_dist.icdf(samples)";
    "Fxn:test_icdf" -> "Fxn:self.assertEqual(icdf,";
    "Fxn:test_icdf" -> "Fxn:scipy_dist.ppf(samples),";
    "class:TestTransforms(TestCase):" -> "Fxn:setUp";
    "class:TestTransforms(TestCase):" -> "Fxn:_generate_data";
    "class:TestTransforms(TestCase):" -> "Fxn:test_inv_inv";
    "class:TestTransforms(TestCase):" -> "Fxn:test_equality";
    "class:TestTransforms(TestCase):" -> "Fxn:test_forward_inverse_cache";
    "class:TestTransforms(TestCase):" -> "Fxn:test_forward_inverse_no_cache";
    "class:TestTransforms(TestCase):" -> "Fxn:test_univariate_forward_jacobian";
    "class:TestTransforms(TestCase):" -> "Fxn:test_univariate_inverse_jacobian";
    "class:TestTransforms(TestCase):" -> "Fxn:test_transform_shapes";
    "class:TestTransforms(TestCase):" -> "Fxn:test_transformed_distribution_shapes";
    "Fxn:setUp" -> "Fxn:AbsTransform(cache_size=cache_size),";
    "Fxn:setUp" -> "Fxn:ExpTransform(cache_size=cache_size),";
    "Fxn:setUp" -> "Fxn:SigmoidTransform(cache_size=cache_size),";
    "Fxn:setUp" -> "Fxn:AffineTransform(variable(torch.Tensor(5).normal_()),";
    "Fxn:setUp" -> "Fxn:variable(torch.Tensor(5).normal_()),";
    "Fxn:setUp" -> "Fxn:AffineTransform(variable(torch.Tensor(4,";
    "Fxn:setUp" -> "Fxn:5).normal_()),";
    "Fxn:setUp" -> "Fxn:variable(torch.Tensor(4,";
    "Fxn:setUp" -> "Fxn:5).normal_()),";
    "Fxn:setUp" -> "Fxn:BoltzmannTransform(cache_size=cache_size),";
    "Fxn:setUp" -> "Fxn:StickBreakingTransform(cache_size=cache_size),";
    "Fxn:setUp" -> "Fxn:LowerCholeskyTransform(cache_size=cache_size),";
    "Fxn:setUp" -> "Fxn:ComposeTransform([";
    "Fxn:setUp" -> "Fxn:AffineTransform(variable(torch.Tensor(4,";
    "Fxn:setUp" -> "Fxn:5).normal_()),";
    "Fxn:setUp" -> "Fxn:variable(torch.Tensor(4,";
    "Fxn:setUp" -> "Fxn:5).normal_()),";
    "Fxn:setUp" -> "Fxn:ComposeTransform([";
    "Fxn:setUp" -> "Fxn:AffineTransform(variable(torch.Tensor(4,";
    "Fxn:setUp" -> "Fxn:5).normal_()),";
    "Fxn:setUp" -> "Fxn:variable(torch.Tensor(4,";
    "Fxn:setUp" -> "Fxn:5).normal_()),";
    "Fxn:setUp" -> "Fxn:ExpTransform(cache_size=cache_size),";
    "Fxn:setUp" -> "Fxn:transforms.append(t.inv)";
    "Fxn:setUp" -> "Fxn:transforms.append(identity_transform)";
    "Fxn:_generate_data" -> "Fxn:torch.Tensor(4,";
    "Fxn:_generate_data" -> "Fxn:torch.Tensor(6,";
    "Fxn:_generate_data" -> "Fxn:x.normal_()";
    "Fxn:_generate_data" -> "Fxn:x.normal_()";
    "Fxn:_generate_data" -> "Fxn:x.normal_().exp()";
    "Fxn:_generate_data" -> "Fxn:x.uniform_()";
    "Fxn:_generate_data" -> "Fxn:x.normal_().exp()";
    "Fxn:_generate_data" -> "Fxn:x.sum(-1,";
    "Fxn:_generate_data" -> "Fxn:ValueError('Unsupported";
    "Fxn:_generate_data" -> "Fxn:{}'.format(domain))";
    "Fxn:test_inv_inv" -> "Fxn:self.assertTrue(t.inv.inv";
    "Fxn:test_equality" -> "Fxn:product(transforms,";
    "Fxn:test_equality" -> "Fxn:self.assertTrue(x";
    "Fxn:test_equality" -> "Fxn:self.assertFalse(x";
    "Fxn:test_equality" -> "Fxn:self.assertFalse(x";
    "Fxn:test_equality" -> "Fxn:self.assertTrue(x";
    "Fxn:test_equality" -> "Fxn:self.assertTrue(identity_transform";
    "Fxn:test_equality" -> "Fxn:self.assertFalse(identity_transform";
    "Fxn:test_forward_inverse_cache" -> "Fxn:variable(self._generate_data(transform),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:transform(x)";
    "Fxn:test_forward_inverse_cache" -> "Fxn:transform.inv(y)";
    "Fxn:test_forward_inverse_cache" -> "Fxn:transform(x2)";
    "Fxn:test_forward_inverse_cache" -> "Fxn:self.assertEqual(x2,";
    "Fxn:test_forward_inverse_cache" -> "Fxn:message='\n'.join([";
    "Fxn:test_forward_inverse_cache" -> "Fxn:t.inv(t(-))";
    "Fxn:test_forward_inverse_cache" -> "Fxn:error'.format(transform),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:{}'.format(x),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:{}'.format(y),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:t.inv(y)";
    "Fxn:test_forward_inverse_cache" -> "Fxn:{}'.format(x2),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:self.assertEqual(y2,";
    "Fxn:test_forward_inverse_cache" -> "Fxn:message='\n'.join([";
    "Fxn:test_forward_inverse_cache" -> "Fxn:error'.format(transform),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:{}'.format(x),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:{}'.format(y),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:t.inv(y)";
    "Fxn:test_forward_inverse_cache" -> "Fxn:{}'.format(x2),";
    "Fxn:test_forward_inverse_cache" -> "Fxn:{}'.format(y2),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:variable(self._generate_data(transform),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:transform(x)";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:transform.inv(y.clone())";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:transform(x2)";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:self.assertEqual(x2,";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:message='\n'.join([";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:t.inv(t(-))";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:error'.format(transform),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:{}'.format(x),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:{}'.format(y),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:t.inv(y)";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:{}'.format(x2),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:self.assertEqual(y2,";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:message='\n'.join([";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:error'.format(transform),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:{}'.format(x),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:{}'.format(y),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:t.inv(y)";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:{}'.format(x2),";
    "Fxn:test_forward_inverse_no_cache" -> "Fxn:{}'.format(y2),";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:variable(self._generate_data(transform),";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:transform(x)";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:transform.log_abs_det_jacobian(x,";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:torch.abs(grad([y.sum()],";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:[x])[0]).log()";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:self.assertEqual(actual,";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:message='\n'.join([";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:{}.log_abs_det_jacobian()";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:{}'.format(expected),";
    "Fxn:test_univariate_forward_jacobian" -> "Fxn:{}'.format(actual),";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:variable(self._generate_data(transform.inv),";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:transform.inv(y)";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:transform.log_abs_det_jacobian(x,";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:-torch.abs(grad([x.sum()],";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:[y])[0]).log()";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:self.assertEqual(actual,";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:message='\n'.join([";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:'{}.log_abs_det_jacobian()";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:.inv()'.format(transform),";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:{}'.format(expected),";
    "Fxn:test_univariate_inverse_jacobian" -> "Fxn:{}'.format(actual),";
    "Fxn:test_transform_shapes" -> "Fxn:ExpTransform()";
    "Fxn:test_transform_shapes" -> "Fxn:BoltzmannTransform()";
    "Fxn:test_transform_shapes" -> "Fxn:LowerCholeskyTransform()";
    "Fxn:test_transform_shapes" -> "Fxn:self.assertEqual(transform0.event_dim,";
    "Fxn:test_transform_shapes" -> "Fxn:self.assertEqual(transform1.event_dim,";
    "Fxn:test_transform_shapes" -> "Fxn:self.assertEqual(transform2.event_dim,";
    "Fxn:test_transform_shapes" -> "Fxn:self.assertEqual(ComposeTransform([transform0,";
    "Fxn:test_transform_shapes" -> "Fxn:self.assertEqual(ComposeTransform([transform0,";
    "Fxn:test_transform_shapes" -> "Fxn:self.assertEqual(ComposeTransform([transform1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:ExpTransform()";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:BoltzmannTransform()";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:LowerCholeskyTransform()";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:Normal(variable(torch.zeros(4,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:variable(torch.ones(4,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:Dirichlet(variable(torch.ones(4,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist0,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:TransformedDistribution(base_dist1,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:self.assertEqual(dist.batch_shape,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:self.assertEqual(dist.event_shape,";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:dist.rsample()";
    "Fxn:test_transformed_distribution_shapes" -> "Fxn:dist.log_prob(x)";
    "class:TestConstraintRegistry(TestCase):" -> "Fxn:setUp";
    "class:TestConstraintRegistry(TestCase):" -> "Fxn:test_biject_to";
    "class:TestConstraintRegistry(TestCase):" -> "Fxn:test_transform_to";
    "Fxn:setUp" -> "Fxn:constraints.greater_than(torch.tensor([-10,";
    "Fxn:setUp" -> "Fxn:constraints.less_than(torch.tensor([-10,";
    "Fxn:setUp" -> "Fxn:constraints.interval(torch.tensor([-4,";
    "Fxn:setUp" -> "Fxn:torch.tensor([-3,";
    "Fxn:test_biject_to" -> "Fxn:biject_to(constraint)";
    "Fxn:test_biject_to" -> "Fxn:self.assertTrue(t.bijective,";
    "Fxn:test_biject_to" -> "Fxn:"biject_to({})";
    "Fxn:test_biject_to" -> "Fxn:bijective".format(constraint))";
    "Fxn:test_biject_to" -> "Fxn:variable(torch.Tensor(5,";
    "Fxn:test_biject_to" -> "Fxn:5)).normal_()";
    "Fxn:test_biject_to" -> "Fxn:self.assertTrue(constraint.check(y).all(),";
    "Fxn:test_biject_to" -> "Fxn:'\n'.join([";
    "Fxn:test_biject_to" -> "Fxn:biject_to({})".format(constraint),";
    "Fxn:test_biject_to" -> "Fxn:{}".format(x),";
    "Fxn:test_biject_to" -> "Fxn:"biject_to(...)(x)";
    "Fxn:test_biject_to" -> "Fxn:{}".format(y),";
    "Fxn:test_biject_to" -> "Fxn:t.inv(y)";
    "Fxn:test_biject_to" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_biject_to" -> "Fxn:biject_to({})";
    "Fxn:test_biject_to" -> "Fxn:inverse".format(constraint))";
    "Fxn:test_transform_to" -> "Fxn:transform_to(constraint)";
    "Fxn:test_transform_to" -> "Fxn:variable(torch.Tensor(5,";
    "Fxn:test_transform_to" -> "Fxn:5)).normal_()";
    "Fxn:test_transform_to" -> "Fxn:self.assertTrue(constraint.check(y).all(),";
    "Fxn:test_transform_to" -> "Fxn:transform_to({})".format(constraint))";
    "Fxn:test_transform_to" -> "Fxn:t.inv(y)";
    "Fxn:test_transform_to" -> "Fxn:self.assertEqual(y,";
    "Fxn:test_transform_to" -> "Fxn:transform_to({})";
    "Fxn:test_transform_to" -> "Fxn:pseudoinverse".format(constraint))";
    "class:TestValidation(TestCase):" -> "Fxn:setUp";
    "class:TestValidation(TestCase):" -> "Fxn:test_valid";
    "class:TestValidation(TestCase):" -> "Fxn:test_invalid";
    "class:TestValidation(TestCase):" -> "Fxn:tearDown";
    "Fxn:setUp" -> "Fxn:self).setUp()";
    "Fxn:setUp" -> "Fxn:Distribution.set_default_validate_args(True)";
    "Fxn:test_valid" -> "Fxn:constraints.is_dependent(Dist.params):";
    "Fxn:test_valid" -> "Fxn:Dist(validate_args=True,";
    "Fxn:test_invalid" -> "Fxn:constraints.is_dependent(Dist.params):";
    "Fxn:test_invalid" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_invalid" -> "Fxn:Dist(validate_args=True,";
    "Fxn:test_invalid" -> "Fxn:AssertionError(fail_string.format(Dist.__name__,";
    "Fxn:tearDown" -> "Fxn:self).tearDown()";
    "Fxn:tearDown" -> "Fxn:Distribution.set_default_validate_args(False)";
    "Fxn:tearDown" -> "Fxn:run_tests()";
    "/test/test_indexing.py" -> "Import:TestCase,";
    "/test/test_indexing.py" -> "Import:unittest";
    "/test/test_indexing.py" -> "Import:torch";
    "/test/test_indexing.py" -> "Import:warnings";
    "/test/test_indexing.py" -> "Import:Variable";
    "/test/test_indexing.py" -> "class:TestIndexing(TestCase):";
    "/test/test_indexing.py" -> "class:NumpyTests(TestCase):";
    "class:TestIndexing(TestCase):" -> "Fxn:test_single_int";
    "class:TestIndexing(TestCase):" -> "Fxn:test_multiple_int";
    "class:TestIndexing(TestCase):" -> "Fxn:test_none";
    "class:TestIndexing(TestCase):" -> "Fxn:test_step";
    "class:TestIndexing(TestCase):" -> "Fxn:test_step_assignment";
    "class:TestIndexing(TestCase):" -> "Fxn:test_byte_mask";
    "class:TestIndexing(TestCase):" -> "Fxn:test_multiple_byte_mask";
    "class:TestIndexing(TestCase):" -> "Fxn:test_byte_mask2d";
    "class:TestIndexing(TestCase):" -> "Fxn:test_int_indices";
    "class:TestIndexing(TestCase):" -> "Fxn:test_int_indices2d";
    "class:TestIndexing(TestCase):" -> "Fxn:test_int_indices_broadcast";
    "class:TestIndexing(TestCase):" -> "Fxn:test_empty_index";
    "class:TestIndexing(TestCase):" -> "Fxn:test_index_getitem_copy_bools_slices";
    "class:TestIndexing(TestCase):" -> "Fxn:test_index_setitem_bools_slices";
    "class:TestIndexing(TestCase):" -> "Fxn:test_setitem_expansion_error";
    "class:TestIndexing(TestCase):" -> "Fxn:test_getitem_scalars";
    "class:TestIndexing(TestCase):" -> "Fxn:test_setitem_scalars";
    "class:TestIndexing(TestCase):" -> "Fxn:test_basic_advanced_combined";
    "class:TestIndexing(TestCase):" -> "Fxn:test_int_assignment";
    "class:TestIndexing(TestCase):" -> "Fxn:test_byte_tensor_assignment";
    "class:TestIndexing(TestCase):" -> "Fxn:test_variable_slicing";
    "class:TestIndexing(TestCase):" -> "Fxn:test_ellipsis_tensor";
    "class:TestIndexing(TestCase):" -> "Fxn:test_invalid_index";
    "class:TestIndexing(TestCase):" -> "Fxn:test_zero_dim_index";
    "class:TestIndexing(TestCase):" -> "Fxn:tensor";
    "class:TestIndexing(TestCase):" -> "Fxn:byteTensor";
    "class:TestIndexing(TestCase):" -> "Fxn:ones";
    "class:TestIndexing(TestCase):" -> "Fxn:zeros";
    "Fxn:test_single_int" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_single_int" -> "Fxn:self.assertEqual(v[4].shape,";
    "Fxn:test_multiple_int" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multiple_int" -> "Fxn:self.assertEqual(v[4].shape,";
    "Fxn:test_multiple_int" -> "Fxn:self.assertEqual(v[4,";
    "Fxn:test_none" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_none" -> "Fxn:self.assertEqual(v[None].shape,";
    "Fxn:test_none" -> "Fxn:self.assertEqual(v[:,";
    "Fxn:test_none" -> "Fxn:self.assertEqual(v[:,";
    "Fxn:test_none" -> "Fxn:self.assertEqual(v[...,";
    "Fxn:test_step" -> "Fxn:Variable(torch.arange(10))";
    "Fxn:test_step" -> "Fxn:self.assertEqual(v[::1],";
    "Fxn:test_step" -> "Fxn:self.assertEqual(v[::2].data.tolist(),";
    "Fxn:test_step" -> "Fxn:self.assertEqual(v[::3].data.tolist(),";
    "Fxn:test_step" -> "Fxn:self.assertEqual(v[::11].data.tolist(),";
    "Fxn:test_step" -> "Fxn:self.assertEqual(v[1:6:2].data.tolist(),";
    "Fxn:test_step_assignment" -> "Fxn:Variable(torch.zeros(4,";
    "Fxn:test_step_assignment" -> "Fxn:Variable(torch.Tensor([3,";
    "Fxn:test_step_assignment" -> "Fxn:self.assertEqual(v[0].data.tolist(),";
    "Fxn:test_step_assignment" -> "Fxn:self.assertEqual(v[1:].data.sum(),";
    "Fxn:test_byte_mask" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_byte_mask" -> "Fxn:Variable(torch.ByteTensor([1,";
    "Fxn:test_byte_mask" -> "Fxn:self.assertEqual(v[mask].shape,";
    "Fxn:test_byte_mask" -> "Fxn:self.assertEqual(v[mask],";
    "Fxn:test_byte_mask" -> "Fxn:torch.stack([v[0],";
    "Fxn:test_byte_mask" -> "Fxn:Variable(torch.Tensor([1]))";
    "Fxn:test_byte_mask" -> "Fxn:self.assertEqual(v[v";
    "Fxn:test_byte_mask" -> "Fxn:Variable(torch.Tensor()))";
    "Fxn:test_multiple_byte_mask" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_multiple_byte_mask" -> "Fxn:Variable(torch.ByteTensor([1,";
    "Fxn:test_multiple_byte_mask" -> "Fxn:Variable(torch.ByteTensor([1,";
    "Fxn:test_multiple_byte_mask" -> "Fxn:self.assertEqual(v[mask1,";
    "Fxn:test_byte_mask2d" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_byte_mask2d" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_byte_mask2d" -> "Fxn:0).data.sum()";
    "Fxn:test_byte_mask2d" -> "Fxn:self.assertEqual(r.shape,";
    "Fxn:test_int_indices" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_int_indices" -> "Fxn:self.assertEqual(v[[0,";
    "Fxn:test_int_indices" -> "Fxn:self.assertEqual(v[:,";
    "Fxn:test_int_indices" -> "Fxn:self.assertEqual(v[:,";
    "Fxn:test_int_indices2d" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_int_indices2d" -> "Fxn:12).view(4,";
    "Fxn:test_int_indices2d" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:test_int_indices2d" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:test_int_indices2d" -> "Fxn:self.assertEqual(x[rows,";
    "Fxn:test_int_indices2d" -> "Fxn:columns].data.tolist(),";
    "Fxn:test_int_indices_broadcast" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_int_indices_broadcast" -> "Fxn:12).view(4,";
    "Fxn:test_int_indices_broadcast" -> "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:test_int_indices_broadcast" -> "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:test_int_indices_broadcast" -> "Fxn:self.assertEqual(result.data.tolist(),";
    "Fxn:test_empty_index" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_empty_index" -> "Fxn:12).view(4,";
    "Fxn:test_empty_index" -> "Fxn:Variable(torch.LongTensor())";
    "Fxn:test_empty_index" -> "Fxn:self.assertEqual(x[idx].numel(),";
    "Fxn:test_empty_index" -> "Fxn:x.clone()";
    "Fxn:test_empty_index" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_empty_index" -> "Fxn:torch.zeros(4,";
    "Fxn:test_empty_index" -> "Fxn:3).byte()";
    "Fxn:test_empty_index" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:torch.tensor(1,";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:torch.tensor(0,";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:[Variable(torch.randn(2,";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:torch.tensor(3)]";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:self.assertNotEqual(a.data_ptr(),";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:a[True].data_ptr())";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:self.assertEqual(torch.tensor([]),";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:self.assertNotEqual(a.data_ptr(),";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:a[true].data_ptr())";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:self.assertEqual(torch.tensor([]),";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:self.assertEqual(a.data_ptr(),";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:a[None].data_ptr())";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:self.assertEqual(a.data_ptr(),";
    "Fxn:test_index_getitem_copy_bools_slices" -> "Fxn:a[...].data_ptr())";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:torch.tensor(1,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:torch.tensor(0,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:[Variable(torch.randn(2,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:torch.tensor(3)]";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:torch.ones_like(a)";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:neg_ones.unsqueeze(0).unsqueeze(0)";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:a.dim()";
    "Fxn:test_index_setitem_bools_slices" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_setitem_expansion_error" -> "Fxn:torch.tensor(1,";
    "Fxn:test_setitem_expansion_error" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_setitem_expansion_error" -> "Fxn:a.expand(torch.Size([5,";
    "Fxn:test_setitem_expansion_error" -> "Fxn:a.size())";
    "Fxn:test_setitem_expansion_error" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_setitem_expansion_error" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_setitem_expansion_error" -> "Fxn:torch.autograd.Variable(a_expanded)";
    "Fxn:test_getitem_scalars" -> "Fxn:torch.tensor(0,";
    "Fxn:test_getitem_scalars" -> "Fxn:torch.tensor(1,";
    "Fxn:test_getitem_scalars" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_getitem_scalars" -> "Fxn:self.assertEqual(a[0],";
    "Fxn:test_getitem_scalars" -> "Fxn:self.assertEqual(a[0][1],";
    "Fxn:test_getitem_scalars" -> "Fxn:self.assertEqual(a[0,";
    "Fxn:test_getitem_scalars" -> "Fxn:self.assertEqual(a[0,";
    "Fxn:test_getitem_scalars" -> "Fxn:torch.tensor(0).normal_()";
    "Fxn:test_getitem_scalars" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_getitem_scalars" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:test_getitem_scalars" -> "Fxn:self.assertEqual(r,";
    "Fxn:test_setitem_scalars" -> "Fxn:torch.tensor(0,";
    "Fxn:test_setitem_scalars" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_setitem_scalars" -> "Fxn:a.clone()";
    "Fxn:test_setitem_scalars" -> "Fxn:a.clone()";
    "Fxn:test_setitem_scalars" -> "Fxn:Variable(torch.randn(3))";
    "Fxn:test_setitem_scalars" -> "Fxn:self.assertEqual(a_set_with_number,";
    "Fxn:test_setitem_scalars" -> "Fxn:self.assertEqual(7.7,";
    "Fxn:test_setitem_scalars" -> "Fxn:torch.tensor(0).normal_()";
    "Fxn:test_setitem_scalars" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_setitem_scalars" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:test_setitem_scalars" -> "Fxn:self.assertEqual(9.9,";
    "Fxn:test_basic_advanced_combined" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_basic_advanced_combined" -> "Fxn:12).view(4,";
    "Fxn:test_basic_advanced_combined" -> "Fxn:self.assertEqual(x[1:2,";
    "Fxn:test_basic_advanced_combined" -> "Fxn:self.assertEqual(x[1:2,";
    "Fxn:test_basic_advanced_combined" -> "Fxn:1:3].data.tolist(),";
    "Fxn:test_basic_advanced_combined" -> "Fxn:x.clone()";
    "Fxn:test_basic_advanced_combined" -> "Fxn:2]].zero_()";
    "Fxn:test_basic_advanced_combined" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_basic_advanced_combined" -> "Fxn:x.clone()";
    "Fxn:test_basic_advanced_combined" -> "Fxn:self.assertNotEqual(x,";
    "Fxn:test_int_assignment" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_int_assignment" -> "Fxn:4).view(2,";
    "Fxn:test_int_assignment" -> "Fxn:self.assertEqual(x.data.tolist(),";
    "Fxn:test_int_assignment" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_int_assignment" -> "Fxn:4).view(2,";
    "Fxn:test_int_assignment" -> "Fxn:Variable(torch.arange(5,";
    "Fxn:test_int_assignment" -> "Fxn:self.assertEqual(x.data.tolist(),";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:16).view(4,";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:Variable(torch.ByteTensor([True,";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:Variable(torch.Tensor([3,";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:self.assertEqual(x[0],";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:self.assertEqual(x[1].data,";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:torch.arange(4,";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:self.assertEqual(x[2],";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:self.assertEqual(x[3].data,";
    "Fxn:test_byte_tensor_assignment" -> "Fxn:torch.arange(12,";
    "Fxn:test_variable_slicing" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_variable_slicing" -> "Fxn:16).view(4,";
    "Fxn:test_variable_slicing" -> "Fxn:Variable(torch.IntTensor([0,";
    "Fxn:test_variable_slicing" -> "Fxn:self.assertEqual(x[i:j],";
    "Fxn:test_ellipsis_tensor" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_ellipsis_tensor" -> "Fxn:9).view(3,";
    "Fxn:test_ellipsis_tensor" -> "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:test_ellipsis_tensor" -> "Fxn:self.assertEqual(x[...,";
    "Fxn:test_ellipsis_tensor" -> "Fxn:idx].tolist(),";
    "Fxn:test_ellipsis_tensor" -> "Fxn:self.assertEqual(x[idx,";
    "Fxn:test_ellipsis_tensor" -> "Fxn:...].tolist(),";
    "Fxn:test_invalid_index" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_invalid_index" -> "Fxn:16).view(4,";
    "Fxn:test_invalid_index" -> "Fxn:self.assertRaisesRegex(TypeError,";
    "Fxn:test_zero_dim_index" -> "Fxn:torch.tensor(10)";
    "Fxn:test_zero_dim_index" -> "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:test_zero_dim_index" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_zero_dim_index" -> "Fxn:self.assertEqual(len(w),";
    "Fxn:tensor" -> "Fxn:Variable(torch.Tensor(*args,";
    "Fxn:byteTensor" -> "Fxn:Variable(torch.ByteTensor(data))";
    "Fxn:ones" -> "Fxn:Variable(torch.ones(*args))";
    "Fxn:zeros" -> "Fxn:Variable(torch.zeros(*args))";
    "class:NumpyTests(TestCase):" -> "Fxn:test_index_no_floats";
    "class:NumpyTests(TestCase):" -> "Fxn:test_none_index";
    "class:NumpyTests(TestCase):" -> "Fxn:test_empty_tuple_index";
    "class:NumpyTests(TestCase):" -> "Fxn:test_empty_fancy_index";
    "class:NumpyTests(TestCase):" -> "Fxn:test_ellipsis_index";
    "class:NumpyTests(TestCase):" -> "Fxn:test_single_int_index";
    "class:NumpyTests(TestCase):" -> "Fxn:test_single_bool_index";
    "class:NumpyTests(TestCase):" -> "Fxn:test_boolean_shape_mismatch";
    "class:NumpyTests(TestCase):" -> "Fxn:test_boolean_indexing_onedim";
    "class:NumpyTests(TestCase):" -> "Fxn:test_boolean_assignment_value_mismatch";
    "class:NumpyTests(TestCase):" -> "Fxn:f";
    "class:NumpyTests(TestCase):" -> "Fxn:test_boolean_indexing_twodim";
    "class:NumpyTests(TestCase):" -> "Fxn:test_everything_returns_views";
    "class:NumpyTests(TestCase):" -> "Fxn:test_broaderrors_indexing";
    "class:NumpyTests(TestCase):" -> "Fxn:test_trivial_fancy_out_of_bounds";
    "class:NumpyTests(TestCase):" -> "Fxn:test_index_is_larger";
    "class:NumpyTests(TestCase):" -> "Fxn:test_broadcast_subspace";
    "Fxn:test_index_no_floats" -> "Fxn:Variable(torch.Tensor([[[5]]]))";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index_no_floats" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_none_index" -> "Fxn:tensor([1,";
    "Fxn:test_none_index" -> "Fxn:self.assertEqual(a[None].dim(),";
    "Fxn:test_none_index" -> "Fxn:a.dim()";
    "Fxn:test_empty_tuple_index" -> "Fxn:tensor([1,";
    "Fxn:test_empty_tuple_index" -> "Fxn:self.assertEqual(a[()],";
    "Fxn:test_empty_tuple_index" -> "Fxn:self.assertEqual(a[()].data_ptr(),";
    "Fxn:test_empty_tuple_index" -> "Fxn:a.data_ptr())";
    "Fxn:test_empty_fancy_index" -> "Fxn:tensor([1,";
    "Fxn:test_empty_fancy_index" -> "Fxn:self.assertEqual(a[[]],";
    "Fxn:test_empty_fancy_index" -> "Fxn:Variable(torch.Tensor()))";
    "Fxn:test_empty_fancy_index" -> "Fxn:tensor([]).long()";
    "Fxn:test_empty_fancy_index" -> "Fxn:self.assertEqual(a[[]],";
    "Fxn:test_empty_fancy_index" -> "Fxn:Variable(torch.LongTensor()))";
    "Fxn:test_empty_fancy_index" -> "Fxn:tensor([]).float()";
    "Fxn:test_empty_fancy_index" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_ellipsis_index" -> "Fxn:tensor([[1,";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertIsNot(a[...],";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertEqual(a[...],";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertEqual(a[...].data_ptr(),";
    "Fxn:test_ellipsis_index" -> "Fxn:a.data_ptr())";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertEqual(a[0,";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertEqual(a[0,";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertEqual(a[...,";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertEqual(a[0,";
    "Fxn:test_ellipsis_index" -> "Fxn:torch.tensor(2))";
    "Fxn:test_ellipsis_index" -> "Fxn:`(Ellipsis,)`";
    "Fxn:test_ellipsis_index" -> "Fxn:torch.tensor(1)";
    "Fxn:test_ellipsis_index" -> "Fxn:b[(Ellipsis,)]";
    "Fxn:test_ellipsis_index" -> "Fxn:self.assertEqual(b,";
    "Fxn:test_single_int_index" -> "Fxn:tensor([[1,";
    "Fxn:test_single_int_index" -> "Fxn:self.assertEqual(a[0].data,";
    "Fxn:test_single_int_index" -> "Fxn:self.assertEqual(a[-1].data,";
    "Fxn:test_single_int_index" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_single_int_index" -> "Fxn:self.assertRaises(Exception,";
    "Fxn:test_single_bool_index" -> "Fxn:tensor([[1,";
    "Fxn:test_single_bool_index" -> "Fxn:self.assertEqual(a[True],";
    "Fxn:test_single_bool_index" -> "Fxn:self.assertEqual(a[False],";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:ones((5,";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:byteTensor([True])";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:byteTensor([False]";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:Variable(torch.ByteTensor(4,";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:4)).zero_()";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_boolean_shape_mismatch" -> "Fxn:arr[(slice(None),";
    "Fxn:test_boolean_indexing_onedim" -> "Fxn:tensor([[0.,";
    "Fxn:test_boolean_indexing_onedim" -> "Fxn:byteTensor([True])";
    "Fxn:test_boolean_indexing_onedim" -> "Fxn:self.assertEqual(a[b],";
    "Fxn:test_boolean_indexing_onedim" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_boolean_indexing_onedim" -> "Fxn:tensor([[1.,";
    "Fxn:test_boolean_assignment_value_mismatch" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:f" -> "Fxn:tensor(v)";
    "Fxn:f" -> "Fxn:self.assertRaisesRegex(Exception,";
    "Fxn:f" -> "Fxn:self.assertRaisesRegex(Exception,";
    "Fxn:f" -> "Fxn:self.assertRaisesRegex(Exception,";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:tensor([[1,";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:byteTensor([[True,";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:self.assertEqual(a[b],";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:tensor([1,";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:self.assertEqual(a[b[1]],";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:tensor([[4,";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:self.assertEqual(a[b[0]],";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_boolean_indexing_twodim" -> "Fxn:tensor([[0,";
    "Fxn:test_everything_returns_views" -> "Fxn:tensor(5)";
    "Fxn:test_everything_returns_views" -> "Fxn:self.assertIsNot(a,";
    "Fxn:test_everything_returns_views" -> "Fxn:a[()])";
    "Fxn:test_everything_returns_views" -> "Fxn:self.assertIsNot(a,";
    "Fxn:test_everything_returns_views" -> "Fxn:self.assertIsNot(a,";
    "Fxn:test_broaderrors_indexing" -> "Fxn:zeros(5,";
    "Fxn:test_broaderrors_indexing" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_broaderrors_indexing" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_trivial_fancy_out_of_bounds" -> "Fxn:zeros(5)";
    "Fxn:test_trivial_fancy_out_of_bounds" -> "Fxn:ones(20).long()";
    "Fxn:test_trivial_fancy_out_of_bounds" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_trivial_fancy_out_of_bounds" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_trivial_fancy_out_of_bounds" -> "Fxn:ones(20).long()";
    "Fxn:test_trivial_fancy_out_of_bounds" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_trivial_fancy_out_of_bounds" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_index_is_larger" -> "Fxn:zeros((5,";
    "Fxn:test_index_is_larger" -> "Fxn:tensor([2,";
    "Fxn:test_index_is_larger" -> "Fxn:self.assertTrue((a[:3,";
    "Fxn:test_index_is_larger" -> "Fxn:tensor([2,";
    "Fxn:test_index_is_larger" -> "Fxn:4])).all())";
    "Fxn:test_broadcast_subspace" -> "Fxn:zeros((100,";
    "Fxn:test_broadcast_subspace" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_broadcast_subspace" -> "Fxn:Variable(torch.arange(99,";
    "Fxn:test_broadcast_subspace" -> "Fxn:-1).long())";
    "Fxn:test_broadcast_subspace" -> "Fxn:b.double().unsqueeze(1).expand(100,";
    "Fxn:test_broadcast_subspace" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_broadcast_subspace" -> "Fxn:run_tests()";
    "/test/test_jit.py" -> "Import:torch";
    "/test/test_jit.py" -> "Import:torch.jit";
    "/test/test_jit.py" -> "Import:torch.nn";
    "/test/test_jit.py" -> "Import:torch.nn.functional";
    "/test/test_jit.py" -> "Import:unittest";
    "/test/test_jit.py" -> "Import:contextmanager";
    "/test/test_jit.py" -> "Import:product,";
    "/test/test_jit.py" -> "Import:torch.jit.frontend";
    "/test/test_jit.py" -> "Import:Variable,";
    "/test/test_jit.py" -> "Import:traceable";
    "/test/test_jit.py" -> "Import:TestCase,";
    "/test/test_jit.py" -> "Import:import";
    "/test/test_jit.py" -> "Import:sys";
    "/test/test_jit.py" -> "Import:numpy";
    "/test/test_jit.py" -> "Import:torchvision";
    "/test/test_jit.py" -> "Fxn:capture_stdout";
    "/test/test_jit.py" -> "Import:import";
    "/test/test_jit.py" -> "Import:fcntl";
    "/test/test_jit.py" -> "Import:errno";
    "/test/test_jit.py" -> "Fxn:LSTMCell";
    "/test/test_jit.py" -> "Fxn:LSTMCellC";
    "/test/test_jit.py" -> "class:TestJit(TestCase):";
    "/test/test_jit.py" -> "class:Net(nn.Module):";
    "/test/test_jit.py" -> "class:Net(nn.Module):";
    "/test/test_jit.py" -> "class:MyFn(Function):";
    "/test/test_jit.py" -> "class:MyLSTMCell(nn.LSTMCell):";
    "/test/test_jit.py" -> "class:MyLegacyFn(Function):";
    "/test/test_jit.py" -> "class:InplaceFn(Function):";
    "/test/test_jit.py" -> "class:RegularFn(Function):";
    "/test/test_jit.py" -> "class:MyInplaceFn(Function):";
    "/test/test_jit.py" -> "class:MyBatchNorm2d(nn.BatchNorm2d):";
    "/test/test_jit.py" -> "class:MyModel(nn.Module):";
    "/test/test_jit.py" -> "class:Adder(nn.Module):";
    "/test/test_jit.py" -> "class:MyModule(torch.nn.Module):";
    "/test/test_jit.py" -> "Import:torch.nn.functional";
    "/test/test_jit.py" -> "class:Model(nn.Module):";
    "/test/test_jit.py" -> "class:M1(torch.jit.ScriptModule):";
    "/test/test_jit.py" -> "class:M2(torch.jit.ScriptModule):";
    "class:TestJit(TestCase):" -> "Fxn:assertCompiled";
    "class:TestJit(TestCase):" -> "Fxn:assertExpectedTrace";
    "class:TestJit(TestCase):" -> "Fxn:test_simple";
    "class:TestJit(TestCase):" -> "Fxn:f";
    "class:TestJit(TestCase):" -> "Fxn:test_matmul_native";
    "class:TestJit(TestCase):" -> "Fxn:test_matmul_native_run";
    "class:TestJit(TestCase):" -> "Fxn:fn";
    "class:TestJit(TestCase):" -> "Fxn:test_index";
    "class:TestJit(TestCase):" -> "Fxn:fn";
    "class:TestJit(TestCase):" -> "Fxn:test_index_constant";
    "class:TestJit(TestCase):" -> "Fxn:fn";
    "class:TestJit(TestCase):" -> "Fxn:test_scopes";
    "class:TestJit(TestCase):" -> "Fxn:f";
    "class:TestJit(TestCase):" -> "Fxn:test_scopes_intermediate_node";
    "Fxn:assertCompiled" -> "Fxn:self.assertIsInstance(compiled_fn,";
    "Fxn:assertCompiled" -> "Fxn:self.assertLess(hits,";
    "Fxn:assertCompiled" -> "Fxn:self.assertEqual(misses,";
    "Fxn:assertExpectedTrace" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:assertExpectedTrace" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:assertExpectedTrace" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:assertExpectedTrace" -> "Fxn:torch._C._jit_pass_canonicalize(trace)";
    "Fxn:assertExpectedTrace" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:assertExpectedTrace" -> "Fxn:self.assertExpected(str(trace),";
    "Fxn:test_simple" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_simple" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:f" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:f" -> "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:f" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_matmul_native" -> "Fxn:Variable(torch.Tensor([[0.4]]),";
    "Fxn:test_matmul_native" -> "Fxn:Variable(torch.Tensor([[0.7]]),";
    "Fxn:test_matmul_native" -> "Fxn:torch.jit.get_trace_graph(lambda";
    "Fxn:test_matmul_native" -> "Fxn:x.matmul(y),";
    "Fxn:test_matmul_native" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:test_matmul_native" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:test_matmul_native" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_matmul_native_run" -> "Fxn:Variable(torch.Tensor([[0.4]]),";
    "Fxn:test_matmul_native_run" -> "Fxn:Variable(torch.Tensor([[0.7]]),";
    "Fxn:test_matmul_native_run" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn" -> "Fxn:x.matmul(y)";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_index" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_index" -> "Fxn:Variable(torch.LongTensor([0]),";
    "Fxn:test_index" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_index_constant" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_index_constant" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn" -> "Fxn:fn(x)";
    "Fxn:fn" -> "Fxn:z.backward()";
    "Fxn:fn" -> "Fxn:x.grad.clone()";
    "Fxn:fn" -> "Fxn:x.grad.zero_()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(x)";
    "Fxn:fn" -> "Fxn:z2.backward()";
    "Fxn:fn" -> "Fxn:x.grad.clone()";
    "Fxn:fn" -> "Fxn:self.assertEqual(z,";
    "Fxn:fn" -> "Fxn:self.assertEqual(grad,";
    "Fxn:test_scopes" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_scopes" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:f" -> "Fxn:torch.jit.scope('Foo',";
    "Fxn:f" -> "Fxn:torch.jit.scope('Bar',";
    "Fxn:f" -> "Fxn:torch.tanh(out)";
    "Fxn:f" -> "Fxn:torch.sigmoid(out)";
    "Fxn:f" -> "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:f" -> "Fxn:self.assertExpectedTrace(trace)";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_scopes_identity_node";
    "Fxn:forward" -> "Fxn:F.log_softmax(x,";
    "Fxn:forward" -> "Fxn:Net()";
    "Fxn:forward" -> "Fxn:Variable(torch.ones(2),";
    "Fxn:forward" -> "Fxn:torch.jit.get_trace_graph(net,";
    "Fxn:forward" -> "Fxn:torch.onnx._optimize_trace(trace,";
    "Fxn:forward" -> "Fxn:self.assertExpectedTrace(trace)";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_lstm_fusion";
    "class:Net(nn.Module):" -> "Fxn:run_lstm_fusion";
    "class:Net(nn.Module):" -> "Fxn:to_type";
    "class:Net(nn.Module):" -> "Fxn:rand_v";
    "class:Net(nn.Module):" -> "Fxn:test_run_lstm_fusion_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_run_lstm_fusion_cpu";
    "class:Net(nn.Module):" -> "Fxn:test_run_lstm_fusion_concat";
    "class:Net(nn.Module):" -> "Fxn:test_concat_fusion";
    "class:Net(nn.Module):" -> "Fxn:Foo";
    "class:Net(nn.Module):" -> "Fxn:test_fusion_distribute";
    "class:Net(nn.Module):" -> "Fxn:f";
    "class:Net(nn.Module):" -> "Fxn:test_arg_configurations";
    "class:Net(nn.Module):" -> "Fxn:fn";
    "class:Net(nn.Module):" -> "Fxn:test_cse";
    "class:Net(nn.Module):" -> "Fxn:fn";
    "class:Net(nn.Module):" -> "Fxn:test_compile_run_twice";
    "class:Net(nn.Module):" -> "Fxn:doit";
    "class:Net(nn.Module):" -> "Fxn:test_compile_addc";
    "class:Net(nn.Module):" -> "Fxn:doit";
    "class:Net(nn.Module):" -> "Fxn:test_compile_fuse_last_device";
    "class:Net(nn.Module):" -> "Fxn:doit";
    "class:Net(nn.Module):" -> "Fxn:test_traced_function";
    "class:Net(nn.Module):" -> "Fxn:doit";
    "class:Net(nn.Module):" -> "Fxn:test_disabled_traced_function";
    "class:Net(nn.Module):" -> "Fxn:doit";
    "class:Net(nn.Module):" -> "Fxn:test_assign_traces";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Sequential(";
    "Fxn:__init__" -> "Fxn:nn.Conv2d(3,";
    "Fxn:__init__" -> "Fxn:nn.ReLU(inplace=True),";
    "Fxn:__init__" -> "Fxn:nn.MaxPool2d(kernel_size=3,";
    "Fxn:forward" -> "Fxn:self.features(x)";
    "Fxn:forward" -> "Fxn:Net()";
    "Fxn:forward" -> "Fxn:Variable(torch.ones(1,";
    "Fxn:forward" -> "Fxn:torch.onnx.set_training(model,";
    "Fxn:forward" -> "Fxn:torch.jit.get_trace_graph(model,";
    "Fxn:forward" -> "Fxn:torch.onnx._optimize_trace(trace,";
    "Fxn:forward" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_lstm_fusion" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_lstm_fusion" -> "Fxn:10).float().cuda())";
    "Fxn:test_lstm_fusion" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_lstm_fusion" -> "Fxn:20).float().cuda())";
    "Fxn:test_lstm_fusion" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_lstm_fusion" -> "Fxn:20).float().cuda())";
    "Fxn:test_lstm_fusion" -> "Fxn:nn.LSTMCell(10,";
    "Fxn:test_lstm_fusion" -> "Fxn:20).float().cuda()";
    "Fxn:test_lstm_fusion" -> "Fxn:torch.jit.get_trace_graph(LSTMCell,";
    "Fxn:test_lstm_fusion" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:test_lstm_fusion" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:test_lstm_fusion" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:test_lstm_fusion" -> "Fxn:torch._C._jit_pass_fuse(trace)";
    "Fxn:test_lstm_fusion" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:to_type" -> "Fxn:x.float()";
    "Fxn:to_type" -> "Fxn:x.cuda()";
    "Fxn:rand_v" -> "Fxn:Variable(to_type(torch.randn(a,";
    "Fxn:rand_v" -> "Fxn:rand_v(3,";
    "Fxn:rand_v" -> "Fxn:rand_v(3,";
    "Fxn:rand_v" -> "Fxn:rand_v(3,";
    "Fxn:rand_v" -> "Fxn:to_type(nn.LSTMCell(10,";
    "Fxn:rand_v" -> "Fxn:torch.jit.compile(nderivs=0)(LSTMCell)";
    "Fxn:rand_v" -> "Fxn:CompiledLSTMCell(input,";
    "Fxn:rand_v" -> "Fxn:*module.parameters())";
    "Fxn:rand_v" -> "Fxn:self.assertCompiled(CompiledLSTMCell):";
    "Fxn:rand_v" -> "Fxn:CompiledLSTMCell(input,";
    "Fxn:rand_v" -> "Fxn:*module.parameters())";
    "Fxn:rand_v" -> "Fxn:self.assertEqual(z,";
    "Fxn:rand_v" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:rand_v" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_run_lstm_fusion_cuda" -> "Fxn:self.run_lstm_fusion(True)";
    "Fxn:test_run_lstm_fusion_cuda" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_run_lstm_fusion_cpu" -> "Fxn:self.run_lstm_fusion(False)";
    "Fxn:test_run_lstm_fusion_cpu" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_run_lstm_fusion_cpu" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:10).float().cuda())";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:20).float().cuda())";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:20).float().cuda())";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:nn.LSTMCell(10,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:20).float().cuda()";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:torch.jit.compile(nderivs=0)(LSTMCellC)";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:CompiledLSTMCell(input,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:*module.parameters())";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:self.assertCompiled(CompiledLSTMCell):";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:CompiledLSTMCell(input,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:*module.parameters())";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_run_lstm_fusion_concat" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_concat_fusion" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_concat_fusion" -> "Fxn:20).float().cuda())";
    "Fxn:test_concat_fusion" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_concat_fusion" -> "Fxn:20).float().cuda())";
    "Fxn:Foo" -> "Fxn:torch.cat((hx";
    "Fxn:Foo" -> "Fxn:torch.jit.get_trace_graph(Foo,";
    "Fxn:Foo" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:Foo" -> "Fxn:torch._C._jit_pass_fuse(trace)";
    "Fxn:Foo" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:Foo" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:Foo" -> "Fxn:@unittest.skipIf(not";
    "Fxn:f" -> "Fxn:y).chunk(2,";
    "Fxn:f" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:f" -> "Fxn:4).float().cuda())";
    "Fxn:f" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:f" -> "Fxn:4).float().cuda())";
    "Fxn:f" -> "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:f" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:f" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:f" -> "Fxn:self.assertExpectedTrace(trace,";
    "Fxn:f" -> "Fxn:torch._C._jit_pass_fuse(trace)";
    "Fxn:f" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_arg_configurations" -> "Fxn:Variable(torch.FloatTensor(4,";
    "Fxn:test_arg_configurations" -> "Fxn:4).uniform_())";
    "Fxn:test_arg_configurations" -> "Fxn:Variable(x.data.double())";
    "Fxn:test_arg_configurations" -> "Fxn:Variable(x.data.clone(),";
    "Fxn:test_arg_configurations" -> "Fxn:Variable(torch.randn(4))";
    "Fxn:test_arg_configurations" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_arg_configurations" -> "Fxn:Variable(x.data.cuda())";
    "Fxn:test_arg_configurations" -> "Fxn:torch.cuda.device_count()";
    "Fxn:test_arg_configurations" -> "Fxn:Variable(x.data.cuda(1))";
    "Fxn:test_arg_configurations" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn" -> "Fxn:torch._C._jit_flatten(args)";
    "Fxn:fn" -> "Fxn:self.assertFalse(fn.has_trace_for(*config))";
    "Fxn:fn" -> "Fxn:fn(*config)";
    "Fxn:fn" -> "Fxn:self.assertTrue(fn.has_trace_for(*config))";
    "Fxn:fn" -> "Fxn:self.assertFalse(fn.has_trace_for(*unk_config))";
    "Fxn:fn" -> "Fxn:self.assertEqual(fn.hits,";
    "Fxn:test_cse" -> "Fxn:Variable(torch.Tensor([0.4,";
    "Fxn:test_cse" -> "Fxn:Variable(torch.Tensor([0.7,";
    "Fxn:test_cse" -> "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn" -> "Fxn:torch.tanh(w)";
    "Fxn:fn" -> "Fxn:torch.tanh(w)";
    "Fxn:fn" -> "Fxn:fn(*inputs)";
    "Fxn:fn" -> "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_cse(trace)";
    "Fxn:fn" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_compile_run_twice" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_compile_run_twice" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:test_compile_run_twice" -> "Fxn:@torch.jit.compile(nderivs=0,";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertCompiled(doit):";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:doit" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:doit" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_compile_addc" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_compile_addc" -> "Fxn:requires_grad=True).float().cuda()";
    "Fxn:test_compile_addc" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:test_compile_addc" -> "Fxn:requires_grad=True).float().cuda()";
    "Fxn:test_compile_addc" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertCompiled(doit):";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:doit" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:doit" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_compile_fuse_last_device" -> "Fxn:torch.cuda.device_count()";
    "Fxn:test_compile_fuse_last_device" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_compile_fuse_last_device" -> "Fxn:requires_grad=True).float().cuda(max_device)";
    "Fxn:test_compile_fuse_last_device" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:test_compile_fuse_last_device" -> "Fxn:requires_grad=True).float().cuda(max_device)";
    "Fxn:test_compile_fuse_last_device" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertCompiled(doit):";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_traced_function" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_traced_function" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:test_traced_function" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertCompiled(doit):";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_disabled_traced_function" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_disabled_traced_function" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:test_disabled_traced_function" -> "Fxn:@torch.jit.compile(enabled=False)";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:doit(x,";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:self.assertEqual(z,";
    "class:MyFn(Function):" -> "Fxn:forward";
    "class:MyFn(Function):" -> "Fxn:backward";
    "class:MyFn(Function):" -> "Fxn:test_legacy_traced_module";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(out)";
    "Fxn:backward" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:backward" -> "Fxn:torch.jit.get_trace_graph(MyFn.apply,";
    "Fxn:backward" -> "Fxn:out.sum().backward()";
    "Fxn:backward" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:backward" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_legacy_traced_module" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_legacy_traced_module" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_legacy_traced_module" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_legacy_traced_module" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "class:MyLSTMCell(nn.LSTMCell):" -> "Fxn:test_autograd_closure";
    "class:MyLSTMCell(nn.LSTMCell):" -> "Fxn:fn";
    "class:MyLSTMCell(nn.LSTMCell):" -> "Fxn:test_verify";
    "class:MyLSTMCell(nn.LSTMCell):" -> "Fxn:f";
    "class:MyLSTMCell(nn.LSTMCell):" -> "Fxn:test_constant";
    "class:MyLSTMCell(nn.LSTMCell):" -> "Fxn:test_c_function";
    "class:MyLSTMCell(nn.LSTMCell):" -> "Fxn:test_legacy_fail";
    "Fxn:test_autograd_closure" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_autograd_closure" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:test_autograd_closure" -> "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn" -> "Fxn:torch.sigmoid(x";
    "Fxn:fn" -> "Fxn:torch.abs(x";
    "Fxn:fn" -> "Fxn:Variable(torch.ones(1))";
    "Fxn:fn" -> "Fxn:fn(*inputs)";
    "Fxn:fn" -> "Fxn:torch._C._tracer_exit((z,";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:w).backward()";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:x.grad.data.clone()";
    "Fxn:fn" -> "Fxn:x.grad.data.zero_()";
    "Fxn:fn" -> "Fxn:torch._C._jit_createInterpreterFactory(trace)";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:function()(x,";
    "Fxn:fn" -> "Fxn:w2).backward()";
    "Fxn:fn" -> "Fxn:self.assertEqual(z,";
    "Fxn:fn" -> "Fxn:self.assertEqual(w,";
    "Fxn:fn" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_verify" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_verify" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:f" -> "Fxn:torch.sigmoid(x";
    "Fxn:f" -> "Fxn:torch.abs(x";
    "Fxn:f" -> "Fxn:Variable(torch.ones(1))";
    "Fxn:f" -> "Fxn:torch.jit.verify(f,";
    "Fxn:test_constant" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_constant" -> "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:test_constant" -> "Fxn:Variable(torch.diag(torch.Tensor([2,";
    "Fxn:test_constant" -> "Fxn:tx.matmul(y)";
    "Fxn:test_constant" -> "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:test_constant" -> "Fxn:torch._C._jit_createInterpreterFactory(trace)";
    "Fxn:test_constant" -> "Fxn:function()(x)";
    "Fxn:test_constant" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_constant" -> "Fxn:y.data.fill_(1000)";
    "Fxn:test_constant" -> "Fxn:Variable(torch.ones(2,";
    "Fxn:test_constant" -> "Fxn:function()(x2)";
    "Fxn:test_constant" -> "Fxn:self.assertEqual(z3.data,";
    "Fxn:test_constant" -> "Fxn:torch.ones(2,";
    "Fxn:test_c_function" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_c_function" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_c_function" -> "Fxn:torch._C._tracer_enter((x,)";
    "Fxn:test_c_function" -> "Fxn:torch._C._tracer_exit((y,))";
    "Fxn:test_c_function" -> "Fxn:self.assertExpectedTrace(trace)";
    "class:MyLegacyFn(Function):" -> "Fxn:forward";
    "class:MyLegacyFn(Function):" -> "Fxn:backward";
    "class:MyLegacyFn(Function):" -> "Fxn:test_inplace_transplant";
    "class:MyLegacyFn(Function):" -> "Fxn:fn";
    "class:MyLegacyFn(Function):" -> "Fxn:test_inplace_flags";
    "Fxn:backward" -> "Fxn:Variable(torch.Tensor([0]),";
    "Fxn:backward" -> "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:backward" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:backward" -> "Fxn:MyLegacyFn()(*inputs))";
    "Fxn:backward" -> "Fxn:torch._C._tracer_exit(inputs)";
    "Fxn:test_inplace_transplant" -> "Fxn:Variable(torch.Tensor([0]),";
    "Fxn:test_inplace_transplant" -> "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:fn" -> "Fxn:x.clone()";
    "Fxn:fn" -> "Fxn:y.add_(2)";
    "Fxn:fn" -> "Fxn:y.add_(3)";
    "Fxn:fn" -> "Fxn:fn(*inputs)";
    "Fxn:fn" -> "Fxn:torch._C._tracer_exit((y,))";
    "Fxn:fn" -> "Fxn:self.assertExpectedTrace(trace)";
    "class:InplaceFn(Function):" -> "Fxn:forward";
    "class:InplaceFn(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:ctx.mark_dirty(x)";
    "Fxn:forward" -> "Fxn:x.add_(1)";
    "class:RegularFn(Function):" -> "Fxn:forward";
    "class:RegularFn(Function):" -> "Fxn:backward";
    "class:RegularFn(Function):" -> "Fxn:fn";
    "class:RegularFn(Function):" -> "Fxn:test_inplace_check";
    "Fxn:forward" -> "Fxn:x.add(1)";
    "Fxn:backward" -> "Fxn:Variable(torch.Tensor([0]),";
    "Fxn:backward" -> "Fxn:torch._C._tracer_enter((x,),";
    "Fxn:fn" -> "Fxn:RegularFn.apply(x)";
    "Fxn:fn" -> "Fxn:InplaceFn.apply(y)";
    "Fxn:fn" -> "Fxn:InplaceFn.apply(y)";
    "Fxn:fn" -> "Fxn:RegularFn.apply(y)";
    "Fxn:fn" -> "Fxn:fn(*inputs)";
    "Fxn:fn" -> "Fxn:torch._C._tracer_exit((y,))";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:fn" -> "Fxn:trace.graph().nodes()]";
    "Fxn:fn" -> "Fxn:self.assertTrue(op.hasAttribute('inplace'))";
    "Fxn:fn" -> "Fxn:self.assertEqual(op.i('inplace'),";
    "class:MyInplaceFn(Function):" -> "Fxn:forward";
    "class:MyInplaceFn(Function):" -> "Fxn:backward";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_backward";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_backward_opaque";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_backward_closure";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_trace_expire";
    "class:MyInplaceFn(Function):" -> "Fxn:record_trace";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:check";
    "class:MyInplaceFn(Function):" -> "Fxn:test_multiuse_fn";
    "class:MyInplaceFn(Function):" -> "Fxn:cell";
    "class:MyInplaceFn(Function):" -> "Fxn:test_output_unflatten";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:recursive_sum";
    "class:MyInplaceFn(Function):" -> "Fxn:test_input_flatten";
    "class:MyInplaceFn(Function):" -> "Fxn:make_var";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_flags";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_no_grad_fallback";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_backward_flag_checks";
    "class:MyInplaceFn(Function):" -> "Fxn:fn";
    "class:MyInplaceFn(Function):" -> "Fxn:test_python_ir";
    "class:MyInplaceFn(Function):" -> "Fxn:doit";
    "class:MyInplaceFn(Function):" -> "Fxn:test_cpp";
    "class:MyInplaceFn(Function):" -> "Fxn:test_batchnorm";
    "class:MyInplaceFn(Function):" -> "Fxn:test_dropout";
    "class:MyInplaceFn(Function):" -> "Fxn:test_batchnorm_run_twice";
    "Fxn:forward" -> "Fxn:x.add_(1)";
    "Fxn:forward" -> "Fxn:self.mark_dirty(x)";
    "Fxn:backward" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:fn" -> "Fxn:MyInplaceFn.apply(x)";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:fn(x)";
    "Fxn:fn" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:fn" -> "Fxn:fn(x)";
    "Fxn:test_backward" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_backward" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_backward" -> "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn" -> "Fxn:fn(*inputs)";
    "Fxn:fn" -> "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(z,";
    "Fxn:fn" -> "Fxn:Variable(torch.ones(2,";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:grad.sum().backward(create_graph=True)";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:fn" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:fn" -> "Fxn:self.skipTest("output";
    "Fxn:test_backward_opaque" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_backward_opaque" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_backward_opaque" -> "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn" -> "Fxn:x.cross(y)";
    "Fxn:fn" -> "Fxn:fn(*inputs)";
    "Fxn:fn" -> "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(z,";
    "Fxn:fn" -> "Fxn:Variable(torch.ones(3,";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:fn" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:fn" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:fn" -> "Fxn:self.skipTest("output";
    "Fxn:test_backward_closure" -> "Fxn:Variable(torch.randn(1),";
    "Fxn:test_backward_closure" -> "Fxn:@torch.jit.compile(nderivs=2)";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(fn(x),";
    "Fxn:fn" -> "Fxn:self.assertFalse(fn.has_trace_for(x))";
    "Fxn:fn" -> "Fxn:grad_x.backward()";
    "Fxn:fn" -> "Fxn:self.assertTrue(fn.has_trace_for(x))";
    "Fxn:fn" -> "Fxn:x.grad.data.clone()";
    "Fxn:fn" -> "Fxn:x.grad.data.zero_()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(x)";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(output,";
    "Fxn:fn" -> "Fxn:grad_x.backward()";
    "Fxn:fn" -> "Fxn:self.assertEqual(x.grad.data,";
    "Fxn:test_trace_expire" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_trace_expire" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:record_trace" -> "Fxn:torch._C._tracer_enter((x,";
    "Fxn:fn" -> "Fxn:fn(*inputs)";
    "Fxn:fn" -> "Fxn:torch._C._tracer_exit((z,))";
    "Fxn:check" -> "Fxn:self.assertEqual(trace.is_expired,";
    "Fxn:check" -> "Fxn:self.assertEqual(trace.is_complete,";
    "Fxn:check" -> "Fxn:record_trace(0)";
    "Fxn:check" -> "Fxn:check(False,";
    "Fxn:check" -> "Fxn:check(False,";
    "Fxn:check" -> "Fxn:record_trace(1)";
    "Fxn:check" -> "Fxn:check(False,";
    "Fxn:check" -> "Fxn:check(True,";
    "Fxn:check" -> "Fxn:record_trace(1)";
    "Fxn:check" -> "Fxn:check(False,";
    "Fxn:check" -> "Fxn:z.sum().backward()";
    "Fxn:check" -> "Fxn:check(False,";
    "Fxn:check" -> "Fxn:check(False,";
    "Fxn:test_multiuse_fn" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_multiuse_fn" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:cell" -> "Fxn:cell(cell(cell(x,";
    "Fxn:cell" -> "Fxn:self.assertFalse(cell.has_trace_for(x,";
    "Fxn:cell" -> "Fxn:out.sum().backward()";
    "Fxn:cell" -> "Fxn:self.assertTrue(cell.has_trace_for(x,";
    "Fxn:cell" -> "Fxn:torch.jit.verify(cell,";
    "Fxn:test_output_unflatten" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:fn" -> "Fxn:fn(x)";
    "Fxn:fn" -> "Fxn:torch.jit.compile(fn)";
    "Fxn:recursive_sum" -> "Fxn:obj.sum()";
    "Fxn:recursive_sum" -> "Fxn:recursive_sum(fn(x)).backward()";
    "Fxn:recursive_sum" -> "Fxn:self.assertTrue(fn.has_trace_for(x))";
    "Fxn:recursive_sum" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:recursive_sum" -> "Fxn:self.assertEqual(fn(x),";
    "Fxn:make_var" -> "Fxn:Variable(torch.randn(1),";
    "Fxn:make_var" -> "Fxn:make_var()))";
    "Fxn:fn" -> "Fxn:fn(*x)";
    "Fxn:fn" -> "Fxn:torch.jit.compile(fn)";
    "Fxn:fn" -> "Fxn:fn(*x).backward()";
    "Fxn:fn" -> "Fxn:self.assertTrue(fn.has_trace_for(*x))";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:self.assertEqual(fn(*x),";
    "Fxn:test_flags" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_flags" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:fn" -> "Fxn:y).sum()";
    "Fxn:fn" -> "Fxn:product((True,";
    "Fxn:fn" -> "Fxn:self.assertFalse(fn.has_trace_for(x,";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertFalse(fn.has_trace_for(x,";
    "Fxn:fn" -> "Fxn:[(x,";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(out,";
    "Fxn:fn" -> "Fxn:grads.setdefault(name,";
    "Fxn:fn" -> "Fxn:self.assertEqual(grad_v,";
    "Fxn:fn" -> "Fxn:self.assertEqual(fn.has_trace_for(x,";
    "Fxn:test_no_grad_fallback" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_no_grad_fallback" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertFalse(fn.has_trace_for(x,";
    "Fxn:fn" -> "Fxn:torch.no_grad():";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertTrue(fn.has_trace_for(x,";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertEqual(out,";
    "Fxn:test_backward_flag_checks" -> "Fxn:Variable(torch.randn(1),";
    "Fxn:test_backward_flag_checks" -> "Fxn:@torch.jit.compile(nderivs=2)";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(fn(x),";
    "Fxn:fn" -> "Fxn:self.assertFalse(fn.has_trace_for(x))";
    "Fxn:fn" -> "Fxn:grad_x.backward()";
    "Fxn:fn" -> "Fxn:self.assertTrue(fn.has_trace_for(x))";
    "Fxn:fn" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:fn" -> "Fxn:fn(x).backward(Variable(torch.ones(1),";
    "Fxn:fn" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:fn" -> "Fxn:torch.autograd.grad(fn(x),";
    "Fxn:fn" -> "Fxn:grad_x.backward(Variable(torch.ones(1),";
    "Fxn:test_python_ir" -> "Fxn:Variable(torch.Tensor([0.4]),";
    "Fxn:test_python_ir" -> "Fxn:Variable(torch.Tensor([0.7]),";
    "Fxn:doit" -> "Fxn:torch.sigmoid(torch.tanh(x";
    "Fxn:doit" -> "Fxn:torch.jit.get_trace_graph(doit,";
    "Fxn:doit" -> "Fxn:torch._C._jit_get_graph(traced)";
    "Fxn:doit" -> "Fxn:torch._C.Graph()";
    "Fxn:doit" -> "Fxn:g.inputs():";
    "Fxn:doit" -> "Fxn:g2.addInput()";
    "Fxn:doit" -> "Fxn:g.nodes():";
    "Fxn:doit" -> "Fxn:g2.createClone(node,";
    "Fxn:doit" -> "Fxn:g2.appendNode(n_)";
    "Fxn:doit" -> "Fxn:n_.outputs()):";
    "Fxn:doit" -> "Fxn:g.outputs():";
    "Fxn:doit" -> "Fxn:g2.registerOutput(g_to_g2[node])";
    "Fxn:doit" -> "Fxn:g2.create("TensorTest").t_("a",";
    "Fxn:doit" -> "Fxn:torch.ones([2,";
    "Fxn:doit" -> "Fxn:assert(t_node.attributeNames()";
    "Fxn:doit" -> "Fxn:g2.appendNode(t_node)";
    "Fxn:doit" -> "Fxn:assert(torch.equal(torch.ones([2,";
    "Fxn:doit" -> "Fxn:t_node.t("a")))";
    "Fxn:doit" -> "Fxn:self.assertExpected(str(g2))";
    "Fxn:doit" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:doit" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cpp" -> "Fxn:self.assertExpected(torch._C._jit_run_cpp_tests())";
    "Fxn:test_batchnorm" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_batchnorm" -> "Fxn:2).fill_(1.0),";
    "Fxn:test_batchnorm" -> "Fxn:torch.jit.get_trace_graph(nn.BatchNorm2d(2),";
    "Fxn:test_batchnorm" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_dropout" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_dropout" -> "Fxn:2).fill_(1.0),";
    "Fxn:test_dropout" -> "Fxn:torch.jit.get_trace_graph(nn.Dropout(0.6),";
    "Fxn:test_dropout" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_batchnorm_run_twice" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_non_decorator_use_fails";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_conv";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_reuse_function";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:clinear";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:cast";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_unused_input";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:fn";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_repeated_input";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:fn";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_repeated_output";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:fn";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_re_enter";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:fn";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:fn2";
    "class:MyBatchNorm2d(nn.BatchNorm2d):" -> "Fxn:test_mini_wlm";
    "Fxn:test_non_decorator_use_fails" -> "Fxn:torch.jit.compile(nn.LSTM)";
    "Fxn:test_non_decorator_use_fails" -> "Fxn:self.assertRaisesRegex(TypeError,";
    "Fxn:test_non_decorator_use_fails" -> "Fxn:MyLSTM(2,";
    "Fxn:test_conv" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:test_conv" -> "Fxn:40).fill_(1.0),";
    "Fxn:test_conv" -> "Fxn:torch.jit.get_trace_graph(nn.Conv2d(16,";
    "Fxn:test_conv" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_reuse_function" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "Fxn:clinear" -> "Fxn:F.linear(*args)";
    "Fxn:cast" -> "Fxn:Variable(cast(torch.randn(1,";
    "Fxn:cast" -> "Fxn:Variable(cast(torch.randn(1,";
    "Fxn:cast" -> "Fxn:Variable(cast(torch.randn(1,";
    "Fxn:cast" -> "Fxn:clinear(input,";
    "Fxn:cast" -> "Fxn:self.assertCompiled(clinear):";
    "Fxn:cast" -> "Fxn:clinear(r1_,";
    "Fxn:cast" -> "Fxn:F.linear(F.linear(input,";
    "Fxn:cast" -> "Fxn:self.assertEqual(r1,";
    "Fxn:test_unused_input" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn" -> "Fxn:[Variable(torch.randn(2,";
    "Fxn:fn" -> "Fxn:fn(a,";
    "Fxn:fn" -> "Fxn:c).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(a,";
    "Fxn:fn" -> "Fxn:c).sum().backward()";
    "Fxn:test_repeated_input" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn" -> "Fxn:[Variable(torch.randn(2,";
    "Fxn:fn" -> "Fxn:fn(a,";
    "Fxn:fn" -> "Fxn:a).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(a,";
    "Fxn:fn" -> "Fxn:a).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(a,";
    "Fxn:fn" -> "Fxn:b).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertExpected(str(fn.graph_for(a,";
    "Fxn:test_repeated_output" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn" -> "Fxn:[Variable(torch.randn(2,";
    "Fxn:fn" -> "Fxn:b)).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:b)).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertExpected(str(fn.graph_for(a,";
    "Fxn:test_re_enter" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn2" -> "Fxn:fn(a,";
    "Fxn:fn2" -> "Fxn:[Variable(torch.randn(2,";
    "Fxn:fn2" -> "Fxn:fn(a,";
    "Fxn:fn2" -> "Fxn:b).sum().backward()";
    "Fxn:fn2" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn2" -> "Fxn:fn(a,";
    "Fxn:fn2" -> "Fxn:b).sum().backward()";
    "Fxn:fn2" -> "Fxn:fn2(a,";
    "Fxn:fn2" -> "Fxn:c).sum().backward()";
    "Fxn:fn2" -> "Fxn:self.assertCompiled(fn2):";
    "Fxn:fn2" -> "Fxn:fn2(a,";
    "Fxn:fn2" -> "Fxn:c).sum().backward()";
    "class:MyModel(nn.Module):" -> "Fxn:__init__";
    "class:MyModel(nn.Module):" -> "Fxn:forward";
    "class:MyModel(nn.Module):" -> "Fxn:test_module_cast";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Embedding(2,";
    "Fxn:forward" -> "Fxn:self.encoder(input)";
    "Fxn:forward" -> "Fxn:hidden.clone()";
    "Fxn:forward" -> "Fxn:MyModel()";
    "Fxn:forward" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:forward" -> "Fxn:Variable(torch.FloatTensor([0]))";
    "Fxn:forward" -> "Fxn:model(x,";
    "Fxn:forward" -> "Fxn:z.sum().backward()";
    "Fxn:forward" -> "Fxn:self.assertTrue(model.has_trace_for(x,";
    "Fxn:forward" -> "Fxn:self.assertCompiled(model):";
    "Fxn:forward" -> "Fxn:model(x,";
    "Fxn:forward" -> "Fxn:z.sum().backward()";
    "Fxn:test_module_cast" -> "Fxn:@torch.jit.compile(nderivs=0)";
    "class:Adder(nn.Module):" -> "Fxn:__init__";
    "class:Adder(nn.Module):" -> "Fxn:forward";
    "class:Adder(nn.Module):" -> "Fxn:check_type";
    "class:Adder(nn.Module):" -> "Fxn:test_repeated_grad";
    "class:Adder(nn.Module):" -> "Fxn:fn";
    "class:Adder(nn.Module):" -> "Fxn:test_input_pruning";
    "class:Adder(nn.Module):" -> "Fxn:fn";
    "class:Adder(nn.Module):" -> "Fxn:test_output_pruning";
    "class:Adder(nn.Module):" -> "Fxn:fn";
    "class:Adder(nn.Module):" -> "Fxn:test_alexnet";
    "class:Adder(nn.Module):" -> "Fxn:test_debug_info";
    "class:Adder(nn.Module):" -> "Fxn:fn";
    "class:Adder(nn.Module):" -> "Fxn:test_inplace_copy";
    "class:Adder(nn.Module):" -> "Fxn:f";
    "class:Adder(nn.Module):" -> "Fxn:test_index_trace";
    "class:Adder(nn.Module):" -> "Fxn:test_saved_output";
    "class:Adder(nn.Module):" -> "Fxn:fn";
    "class:Adder(nn.Module):" -> "Fxn:test_shared_param";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Parameter(torch.randn(2,";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:forward" -> "Fxn:2).float())";
    "Fxn:forward" -> "Fxn:nn.Sequential(Adder()).float()";
    "Fxn:check_type" -> "Fxn:caster(a)";
    "Fxn:check_type" -> "Fxn:self.assertCompiled(a[0]):";
    "Fxn:check_type" -> "Fxn:check_type(lambda";
    "Fxn:check_type" -> "Fxn:check_type(lambda";
    "Fxn:check_type" -> "Fxn:x.double())";
    "Fxn:check_type" -> "Fxn:torch.cuda.is_available():";
    "Fxn:check_type" -> "Fxn:check_type(lambda";
    "Fxn:check_type" -> "Fxn:x.float().cuda())";
    "Fxn:check_type" -> "Fxn:check_type(lambda";
    "Fxn:check_type" -> "Fxn:x.double().cuda())";
    "Fxn:check_type" -> "Fxn:self.assertEqual(a[0].hits,";
    "Fxn:check_type" -> "Fxn:torch.cuda.is_available()";
    "Fxn:check_type" -> "Fxn:@unittest.skip("Broken";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:out[1]).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertExpected(str(fn.graph_for(x,";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:out[1]).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertCompiled(fn):";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.assertExpected(str(fn.graph_for(x,";
    "Fxn:test_alexnet" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_alexnet" -> "Fxn:224).fill_(1.0),";
    "Fxn:test_alexnet" -> "Fxn:torch.jit.get_trace_graph(torchvision.models.AlexNet(),";
    "Fxn:test_alexnet" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_debug_info" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:out.sum().backward()";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:fn.jit_debug_info()";
    "Fxn:fn" -> "Fxn:self.assertTrue("hits:";
    "Fxn:fn" -> "Fxn:self.assertTrue("stage";
    "Fxn:test_inplace_copy" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:f" -> "Fxn:Variable(torch.zeros(x.size()))";
    "Fxn:f" -> "Fxn:out.copy_(x)";
    "Fxn:f" -> "Fxn:torch.jit.get_trace_graph(f,";
    "Fxn:f" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:f" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:f" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_index_trace" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_index_trace" -> "Fxn:torch.jit.get_trace_graph(lambda";
    "Fxn:test_index_trace" -> "Fxn:z.sum().backward()";
    "Fxn:test_index_trace" -> "Fxn:torch._C._jit_pass_lint(trace)";
    "Fxn:test_index_trace" -> "Fxn:torch._C._jit_pass_dce(trace)";
    "Fxn:test_index_trace" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:test_saved_output" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_saved_output" -> "Fxn:@torch.jit.compile(nderivs=1)";
    "Fxn:fn" -> "Fxn:x.sigmoid()";
    "Fxn:fn" -> "Fxn:fn(x).sum().backward()";
    "Fxn:fn" -> "Fxn:self.assertExpected(str(fn.graph_for(x)))";
    "class:MyModule(torch.nn.Module):" -> "Fxn:__init__";
    "class:MyModule(torch.nn.Module):" -> "Fxn:forward";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_nested_inplace";
    "class:MyModule(torch.nn.Module):" -> "Fxn:checkGraphExecutor";
    "class:MyModule(torch.nn.Module):" -> "Fxn:allSum";
    "class:MyModule(torch.nn.Module):" -> "Fxn:run_ge_tests";
    "class:MyModule(torch.nn.Module):" -> "Fxn:rand";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_ge_unoptimized";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_ge_optimized";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_ge_cuda";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_ge";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:checkScript";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_add";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_mul";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_triple";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_slice";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_gather";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_func_call";
    "class:MyModule(torch.nn.Module):" -> "Fxn:add";
    "class:MyModule(torch.nn.Module):" -> "Fxn:mul";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_cast";
    "class:MyModule(torch.nn.Module):" -> "Fxn:to_int";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_python_frontend";
    "class:MyModule(torch.nn.Module):" -> "Fxn:fn";
    "class:MyModule(torch.nn.Module):" -> "Fxn:_make_scalar_vars";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_fibb";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_if";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_if";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_if_noelse";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_if_noelse";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_while_nonexistant_value";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_while_nonexistant_cond_value";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_while_write_outer_then_read";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_while_nest_if";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_while_if";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_if_nest_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_if_while";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_ternary";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_ternary_control";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_ternary";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_python_frontend_run";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_multiple_assignment";
    "class:MyModule(torch.nn.Module):" -> "Fxn:outer_func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_trace_annotation";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_cu";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_annotation";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_error";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:bar";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_python_call";
    "class:MyModule(torch.nn.Module):" -> "Fxn:pyfunc";
    "class:MyModule(torch.nn.Module):" -> "Fxn:other_func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_call_python";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_python_call_failure";
    "class:MyModule(torch.nn.Module):" -> "Fxn:pyfunc";
    "class:MyModule(torch.nn.Module):" -> "Fxn:other_func";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_call_python";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_python_call_annotation";
    "class:MyModule(torch.nn.Module):" -> "Fxn:pyfunc";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_script_python_call_annotation_failure";
    "class:MyModule(torch.nn.Module):" -> "Fxn:pyfunc";
    "class:MyModule(torch.nn.Module):" -> "Fxn:foo";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_desugar_module";
    "class:MyModule(torch.nn.Module):" -> "Fxn:fn";
    "class:MyModule(torch.nn.Module):" -> "Fxn:test_traced_module";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Parameter(torch.randn(2,";
    "Fxn:forward" -> "Fxn:MyModule()";
    "Fxn:forward" -> "Fxn:torch.jit.get_trace_graph(m,";
    "Fxn:forward" -> "Fxn:self.assertEqual(len(list(trace.graph().inputs())),";
    "Fxn:forward" -> "Fxn:self.assertExpected(str(trace))";
    "Fxn:test_nested_inplace" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_nested_inplace" -> "Fxn:torch.jit.get_trace_graph(lambda";
    "Fxn:test_nested_inplace" -> "Fxn:F.threshold(x,";
    "Fxn:test_nested_inplace" -> "Fxn:self.assertExpectedTrace(trace)";
    "Fxn:allSum" -> "Fxn:v.sum()";
    "Fxn:allSum" -> "Fxn:[Variable(t)";
    "Fxn:allSum" -> "Fxn:[Variable(t,";
    "Fxn:allSum" -> "Fxn:torch._C.GraphExecutor(func,";
    "Fxn:allSum" -> "Fxn:[Variable(t)";
    "Fxn:allSum" -> "Fxn:func(*nograd_inputs)";
    "Fxn:allSum" -> "Fxn:ge(*nograd_inputs)";
    "Fxn:allSum" -> "Fxn:self.assertEqual(outputs,";
    "Fxn:allSum" -> "Fxn:func(*recording_inputs)";
    "Fxn:allSum" -> "Fxn:torch.autograd.grad(allSum(outputs),";
    "Fxn:allSum" -> "Fxn:ge(*recording_inputs)";
    "Fxn:allSum" -> "Fxn:torch.autograd.grad(allSum(outputs_ge),";
    "Fxn:allSum" -> "Fxn:self.assertEqual(outputs,";
    "Fxn:allSum" -> "Fxn:self.assertEqual(grads,";
    "Fxn:allSum" -> "Fxn:func(*recording_inputs)";
    "Fxn:allSum" -> "Fxn:allSum(outputs)";
    "Fxn:allSum" -> "Fxn:torch.autograd.grad(l1,";
    "Fxn:allSum" -> "Fxn:torch.autograd.grad(l2,";
    "Fxn:allSum" -> "Fxn:[Variable(t,";
    "Fxn:allSum" -> "Fxn:ge(*recording_inputs)";
    "Fxn:allSum" -> "Fxn:allSum(outputs_ge)";
    "Fxn:allSum" -> "Fxn:torch.autograd.grad(";
    "Fxn:allSum" -> "Fxn:torch.autograd.grad(l2_ge,";
    "Fxn:allSum" -> "Fxn:self.assertEqual(outputs,";
    "Fxn:allSum" -> "Fxn:self.assertEqual(grads,";
    "Fxn:allSum" -> "Fxn:self.assertEqual(grads2,";
    "Fxn:rand" -> "Fxn:torch.rand(*args).float()";
    "Fxn:rand" -> "Fxn:t.cuda()";
    "Fxn:rand" -> "Fxn:self.checkGraphExecutor(lambda";
    "Fxn:rand" -> "Fxn:[rand(1),";
    "Fxn:rand" -> "Fxn:rand(1)],";
    "Fxn:rand" -> "Fxn:[rand(2,";
    "Fxn:rand" -> "Fxn:rand(2,";
    "Fxn:rand" -> "Fxn:self.checkGraphExecutor(lambda";
    "Fxn:rand" -> "Fxn:[rand(1),";
    "Fxn:rand" -> "Fxn:rand(1)],";
    "Fxn:foo" -> "Fxn:self.checkGraphExecutor(foo,";
    "Fxn:foo" -> "Fxn:[rand(1)],";
    "Fxn:foo" -> "Fxn:self.checkGraphExecutor(";
    "Fxn:foo" -> "Fxn:[rand(1),";
    "Fxn:foo" -> "Fxn:rand(1)],";
    "Fxn:foo" -> "Fxn:self.checkGraphExecutor(foo,";
    "Fxn:foo" -> "Fxn:[rand(1)],";
    "Fxn:foo" -> "Fxn:self.checkGraphExecutor(lambda";
    "Fxn:foo" -> "Fxn:[rand(1),";
    "Fxn:foo" -> "Fxn:rand(1)],";
    "Fxn:test_ge_unoptimized" -> "Fxn:self.run_ge_tests(False,";
    "Fxn:test_ge_unoptimized" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_ge_optimized" -> "Fxn:self.run_ge_tests(True,";
    "Fxn:test_ge_optimized" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_ge_optimized" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_ge_cuda" -> "Fxn:self.run_ge_tests(True,";
    "Fxn:foo" -> "Fxn:V(torch.rand(1)),";
    "Fxn:foo" -> "Fxn:V(torch.rand(1))";
    "Fxn:foo" -> "Fxn:torch._C.GraphExecutor(foo,";
    "Fxn:foo" -> "Fxn:V(torch.rand(1),";
    "Fxn:foo" -> "Fxn:torch.rand(1),";
    "Fxn:foo" -> "Fxn:ge(a,";
    "Fxn:foo" -> "Fxn:torch.autograd.grad(r";
    "Fxn:foo" -> "Fxn:torch.autograd.grad(l2,";
    "Fxn:foo" -> "Fxn:foo(a,";
    "Fxn:foo" -> "Fxn:torch.autograd.grad(r";
    "Fxn:foo" -> "Fxn:self.assertEqual(da,";
    "Fxn:foo" -> "Fxn:self.assertEqual(db,";
    "Fxn:foo" -> "Fxn:torch.autograd.grad(l3,";
    "Fxn:foo" -> "Fxn:self.assertEqual(g2result,";
    "Fxn:checkScript" -> "Fxn:torch.jit.CompilationUnit(script,";
    "Fxn:checkScript" -> "Fxn:torch.jit.script(script)";
    "Fxn:checkScript" -> "Fxn:capture_stdout()";
    "Fxn:checkScript" -> "Fxn:ge(*inputs)";
    "Fxn:checkScript" -> "Fxn:self.assertExpected(captured[0],";
    "Fxn:checkScript" -> "Fxn:ge(*inputs)";
    "Fxn:checkScript" -> "Fxn:self.assertEqual(outputs,";
    "Fxn:func" -> "Fxn:Variable(torch.rand(1),";
    "Fxn:func" -> "Fxn:Variable(torch.rand(1),";
    "Fxn:func" -> "Fxn:self.checkScript(script,";
    "Fxn:func" -> "Fxn:Variable(torch.rand(1),";
    "Fxn:func" -> "Fxn:Variable(torch.rand(1),";
    "Fxn:func" -> "Fxn:self.checkScript(script,";
    "Fxn:func" -> "Fxn:Variable(torch.rand(1).float(),";
    "Fxn:func" -> "Fxn:self.checkScript(script,";
    "Fxn:func" -> "Fxn:Variable(torch.rand(10).float(),";
    "Fxn:func" -> "Fxn:self.checkScript(script,";
    "Fxn:func" -> "Fxn:Variable(torch.rand(10).float(),";
    "Fxn:func" -> "Fxn:self.checkScript(script,";
    "Fxn:func" -> "Fxn:add(mul(alpha,";
    "Fxn:func" -> "Fxn:mul(beta,";
    "Fxn:func" -> "Fxn:Variable(torch.rand(1).float(),";
    "Fxn:func" -> "Fxn:Variable(torch.rand(1).float(),";
    "Fxn:func" -> "Fxn:Variable(torch.rand(3).float(),";
    "Fxn:func" -> "Fxn:Variable(torch.rand(3).float(),";
    "Fxn:func" -> "Fxn:self.checkScript(script,";
    "Fxn:func" -> "Fxn:@unittest.skip("RuntimeError:";
    "Fxn:func" -> "Fxn:VariableType::ID()";
    "Fxn:to_int" -> "Fxn:Variable(torch.FloatTensor([1.1,";
    "Fxn:to_int" -> "Fxn:Variable(torch.IntTensor([1,";
    "Fxn:to_int" -> "Fxn:self.checkScript(script,";
    "Fxn:fn" -> "Fxn:z.sigmoid()";
    "Fxn:fn" -> "Fxn:torch.jit.frontend.get_jit_ast(fn)";
    "Fxn:fn" -> "Fxn:self.assertExpected(str(ast))";
    "Fxn:_make_scalar_vars" -> "Fxn:out.append(torch.from_numpy(np.array(inp,";
    "Fxn:test_while" -> "Fxn:self._make_scalar_vars([1,";
    "Fxn:test_while" -> "Fxn:self._make_scalar_vars([20],";
    "Fxn:test_while" -> "Fxn:self.checkScript(script,";
    "Fxn:test_while" -> "Fxn:self._make_scalar_vars([10],";
    "Fxn:test_while" -> "Fxn:self._make_scalar_vars([2,";
    "Fxn:test_while" -> "Fxn:self.checkScript(script,";
    "Fxn:test_if" -> "Fxn:self._make_scalar_vars([1,";
    "Fxn:test_if" -> "Fxn:self._make_scalar_vars([7],";
    "Fxn:test_if" -> "Fxn:self.checkScript(script,";
    "Fxn:test_if_noelse" -> "Fxn:self._make_scalar_vars([-1,";
    "Fxn:test_if_noelse" -> "Fxn:self._make_scalar_vars([0],";
    "Fxn:test_if_noelse" -> "Fxn:self.checkScript(script,";
    "Fxn:test_script_while_nonexistant_value" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_script_while_nonexistant_value" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_script_while_nonexistant_cond_value" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_script_while_nonexistant_cond_value" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_while" -> "Fxn:self._make_scalar_vars([42,";
    "Fxn:test_while" -> "Fxn:self._make_scalar_vars([1379],";
    "Fxn:test_while" -> "Fxn:self.checkScript(script,";
    "Fxn:test_while_if" -> "Fxn:self._make_scalar_vars([-1234,";
    "Fxn:test_while_if" -> "Fxn:self._make_scalar_vars([-5564],";
    "Fxn:test_while_if" -> "Fxn:self.checkScript(script,";
    "Fxn:test_if_while" -> "Fxn:self._make_scalar_vars([4321,";
    "Fxn:test_if_while" -> "Fxn:self._make_scalar_vars([-4321],";
    "Fxn:test_if_while" -> "Fxn:self.checkScript(script,";
    "Fxn:test_script_ternary" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_ternary_control" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_ternary" -> "Fxn:self.assertEqual(";
    "Fxn:func" -> "Fxn:y).sigmoid()";
    "Fxn:func" -> "Fxn:Variable(torch.arange(4),";
    "Fxn:func" -> "Fxn:Variable(torch.arange(4)";
    "Fxn:func" -> "Fxn:y).sigmoid().pow(2)";
    "Fxn:func" -> "Fxn:self.checkScript(func,";
    "Fxn:func" -> "Fxn:outer_func(x)";
    "Fxn:func" -> "Fxn:torch.arange(4)";
    "Fxn:func" -> "Fxn:self.assertEqual(func(x),";
    "Fxn:test_trace_annotation" -> "Fxn:@torch.jit.trace(Variable(torch.rand(1)))";
    "Fxn:foo" -> "Fxn:Variable(torch.rand(2))";
    "Fxn:foo" -> "Fxn:self.assertEqual(s";
    "Fxn:foo" -> "Fxn:foo(s))";
    "Fxn:test_script_cu" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:foo" -> "Fxn:Variable(torch.rand(1))";
    "Fxn:foo" -> "Fxn:self.assertEqual(a,";
    "Fxn:foo" -> "Fxn:cu.foo(a))";
    "Fxn:foo" -> "Fxn:Variable(torch.rand(2))";
    "Fxn:foo" -> "Fxn:self.assertEqual(s";
    "Fxn:foo" -> "Fxn:foo(s))";
    "Fxn:foo" -> "Fxn:a.t()";
    "Fxn:foo" -> "Fxn:Variable(torch.rand(10))";
    "Fxn:foo" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:foo" -> "Fxn:foo(s)";
    "Fxn:bar" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:bar" -> "Fxn:bar(Variable(torch.rand(10),";
    "Fxn:bar" -> "Fxn:Variable(torch.rand(9),";
    "Fxn:pyfunc" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_call_python" -> "Fxn:pyfunc(a)";
    "Fxn:test_call_python" -> "Fxn:other_func(b)";
    "Fxn:test_call_python" -> "Fxn:pyfunc(b)";
    "Fxn:test_call_python" -> "Fxn:pyfunc(b)";
    "Fxn:test_call_python" -> "Fxn:self._make_scalar_vars([1],";
    "Fxn:test_call_python" -> "Fxn:self._make_scalar_vars([54],";
    "Fxn:test_call_python" -> "Fxn:self.assertEqual(cu.test_call_python(*inputs),";
    "Fxn:test_script_python_call_failure" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:pyfunc" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_call_python" -> "Fxn:pyfunc(a)";
    "Fxn:test_call_python" -> "Fxn:other_func(b)";
    "Fxn:test_call_python" -> "Fxn:pyfunc2(b)";
    "Fxn:test_call_python" -> "Fxn:pyfunc(b)";
    "Fxn:test_call_python" -> "Fxn:self._make_scalar_vars([1],";
    "Fxn:test_call_python" -> "Fxn:self._make_scalar_vars([54],";
    "Fxn:test_call_python" -> "Fxn:self.assertEqual(cu.test_call_python(*inputs),";
    "Fxn:foo" -> "Fxn:self.test(a)";
    "Fxn:foo" -> "Fxn:pyfunc(a)";
    "Fxn:foo" -> "Fxn:pyfunc(a)";
    "Fxn:foo" -> "Fxn:self._make_scalar_vars([1],";
    "Fxn:foo" -> "Fxn:self._make_scalar_vars([6],";
    "Fxn:foo" -> "Fxn:self.assertEqual(foo(*inputs),";
    "Fxn:test_script_python_call_annotation_failure" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:foo" -> "Fxn:self.test(a)";
    "Fxn:foo" -> "Fxn:pyfunc2(a)";
    "Fxn:foo" -> "Fxn:pyfunc(a)";
    "Fxn:foo" -> "Fxn:self._make_scalar_vars([1],";
    "Fxn:foo" -> "Fxn:self._make_scalar_vars([6],";
    "Fxn:foo" -> "Fxn:self.assertEqual(foo(*inputs),";
    "Fxn:fn" -> "Fxn:torch.abs(x)";
    "Fxn:fn" -> "Fxn:torch.nn.functional.prelu(x,";
    "Fxn:fn" -> "Fxn:F.prelu(x,";
    "Fxn:fn" -> "Fxn:torch.arange(-3,";
    "Fxn:fn" -> "Fxn:torch.tensor([0.5])";
    "Fxn:fn" -> "Fxn:fn(x,";
    "Fxn:fn" -> "Fxn:self.checkScript(fn,";
    "Fxn:fn" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:fn" -> "Fxn:@unittest.skipIf(not";
    "Fxn:fn" -> "Fxn:.cuda()")";
    "class:Model(nn.Module):" -> "Fxn:__init__";
    "class:Model(nn.Module):" -> "Fxn:forward";
    "class:Model(nn.Module):" -> "Fxn:test_shape_prop_mismatch_output";
    "class:Model(nn.Module):" -> "Fxn:test_shape_prop_mismatch_output";
    "class:Model(nn.Module):" -> "Fxn:test_view_shape_prop";
    "class:Model(nn.Module):" -> "Fxn:test_view_shape_prop";
    "class:Model(nn.Module):" -> "Fxn:test_integral_shape_inference";
    "class:Model(nn.Module):" -> "Fxn:test_integral_shape_inference";
    "class:Model(nn.Module):" -> "Fxn:test_fuser_multiple_blocks";
    "class:Model(nn.Module):" -> "Fxn:test_fuser_multiple_blocks";
    "class:Model(nn.Module):" -> "Fxn:test_print_graph_executor";
    "class:Model(nn.Module):" -> "Fxn:test_print_graph_executor";
    "class:Model(nn.Module):" -> "Fxn:test_script_module";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[[nn.Linear(num_features,";
    "Fxn:__init__" -> "Fxn:nn.Sigmoid()]";
    "Fxn:__init__" -> "Fxn:nn.Sequential(*chain(*layers))";
    "Fxn:forward" -> "Fxn:self.submodule[i](x)";
    "Fxn:forward" -> "Fxn:Model(5,";
    "Fxn:forward" -> "Fxn:torch.randn(2,";
    "Fxn:forward" -> "Fxn:torch.jit.trace(x)(model)";
    "Fxn:forward" -> "Fxn:__repr__()";
    "Fxn:forward" -> "Fxn:model.__repr__()";
    "Fxn:forward" -> "Fxn:self.assertRaises(AttributeError):";
    "Fxn:forward" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:forward" -> "Fxn:nn.Parameter(torch.randn(linear_submodule.weight.shape))";
    "Fxn:forward" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:forward" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:forward" -> "Fxn:linear_submodule(x)";
    "Fxn:forward" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:forward" -> "Fxn:linear_submodule.cuda()";
    "Fxn:forward" -> "Fxn:traced_model.float().cuda()";
    "Fxn:forward" -> "Fxn:traced_model(x.float().cuda())";
    "Fxn:forward" -> "Fxn:traced_model.cpu()";
    "Fxn:forward" -> "Fxn:traced_model(x.float())";
    "Fxn:forward" -> "Fxn:self.assertEqual(cpu_out,";
    "Fxn:forward" -> "Fxn:traced_model.double()";
    "Fxn:forward" -> "Fxn:v.clone()";
    "Fxn:forward" -> "Fxn:traced_model.state_dict().items()}";
    "Fxn:forward" -> "Fxn:v.clone().fill_(1)";
    "Fxn:forward" -> "Fxn:state.items()}";
    "Fxn:forward" -> "Fxn:traced_model(x)";
    "Fxn:forward" -> "Fxn:traced_model.load_state_dict(new_state)";
    "Fxn:forward" -> "Fxn:traced_model(x)";
    "Fxn:forward" -> "Fxn:traced_model.load_state_dict(state)";
    "Fxn:forward" -> "Fxn:traced_model(x)";
    "Fxn:forward" -> "Fxn:self.assertEqual(out,";
    "Fxn:forward" -> "Fxn:self.assertNotEqual(out,";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:topk(a,";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:[torch.zeros(10)]";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:[torch.zeros(2),";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:torch.from_numpy(np.array([1,";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:5])).long()]";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:cu.test_shape_prop_mismatch_output(*inputs)";
    "Fxn:test_shape_prop_mismatch_output" -> "Fxn:self.assertEqual(real_outs,";
    "Fxn:test_view_shape_prop" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_view_shape_prop" -> "Fxn:view(a,";
    "Fxn:test_view_shape_prop" -> "Fxn:[torch.zeros(10,";
    "Fxn:test_view_shape_prop" -> "Fxn:torch.zeros(100)";
    "Fxn:test_view_shape_prop" -> "Fxn:cu.test_view_shape_prop(*inputs)";
    "Fxn:test_view_shape_prop" -> "Fxn:self.assertEqual(real_outs,";
    "Fxn:test_integral_shape_inference" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_integral_shape_inference" -> "Fxn:[torch.ones(10,";
    "Fxn:test_integral_shape_inference" -> "Fxn:10).type(torch.LongTensor)]";
    "Fxn:test_integral_shape_inference" -> "Fxn:torch.ones(10,";
    "Fxn:test_integral_shape_inference" -> "Fxn:self.assertEqual(cu.test_integral_shape_inference(*inputs),";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:cat(this,";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:cat(that,";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:cat(theother,";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:[torch.ones(0,";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:[torch.ones(1,";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:[torch.ones(20,";
    "Fxn:test_fuser_multiple_blocks" -> "Fxn:self.assertEqual(cu.test_fuser_multiple_blocks(*inputs),";
    "Fxn:test_print_graph_executor" -> "Fxn:torch.jit.CompilationUnit('''";
    "Fxn:test_print_graph_executor" -> "Fxn:[torch.ones(5,";
    "Fxn:test_print_graph_executor" -> "Fxn:capture_stdout()";
    "Fxn:test_print_graph_executor" -> "Fxn:cu.test_print_graph_executor(*inputs)";
    "Fxn:test_print_graph_executor" -> "Fxn:self.assertExpected(captured[0])";
    "class:M1(torch.jit.ScriptModule):" -> "Fxn:__init__";
    "class:M1(torch.jit.ScriptModule):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(False)";
    "Fxn:__init__" -> "Fxn:nn.Parameter(torch.randn(2))";
    "class:M2(torch.jit.ScriptModule):" -> "Fxn:__init__";
    "class:M2(torch.jit.ScriptModule):" -> "Fxn:hi";
    "class:M2(torch.jit.ScriptModule):" -> "Fxn:doit";
    "class:M2(torch.jit.ScriptModule):" -> "Fxn:doit2";
    "class:M2(torch.jit.ScriptModule):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(False)";
    "Fxn:__init__" -> "Fxn:M1()";
    "Fxn:__init__" -> "Fxn:nn.Parameter(torch.randn(2,";
    "Fxn:__init__" -> "Fxn:nn.Parameter(torch.randn(2))";
    "Fxn:__init__" -> "Fxn:self.define("""";
    "Fxn:hi" -> "Fxn:self.weight.mm(a)";
    "Fxn:doit" -> "Fxn:self.weight.mm(input)";
    "Fxn:doit2" -> "Fxn:self.weight.mm(input)";
    "Fxn:forward" -> "Fxn:self.doit(input)";
    "Fxn:forward" -> "Fxn:self.doit2(input)";
    "Fxn:forward" -> "Fxn:self.hi(input)";
    "Fxn:forward" -> "Fxn:self.sub(a)";
    "Fxn:forward" -> "Fxn:M2()";
    "Fxn:forward" -> "Fxn:torch.randn(3,";
    "Fxn:forward" -> "Fxn:m2.weight.mm(input)";
    "Fxn:forward" -> "Fxn:m2.weight.mm(input)";
    "Fxn:forward" -> "Fxn:m2.weight.mm(input)";
    "Fxn:forward" -> "Fxn:self.assertEqual(ref,";
    "Fxn:forward" -> "Fxn:m2.forward(input))";
    "Fxn:forward" -> "Fxn:nn.Parameter(torch.zeros_like(m2.weight))";
    "Fxn:forward" -> "Fxn:nn.Parameter(torch.zeros_like(m2.bias))";
    "Fxn:forward" -> "Fxn:nn.Parameter(torch.zeros_like(m2.sub.weight))";
    "Fxn:forward" -> "Fxn:self.assertEqual(torch.zeros(2,";
    "Fxn:forward" -> "Fxn:m2.forward(torch.randn(3,";
    "Fxn:forward" -> "Fxn:run_tests()";
    "/test/test_legacy_nn.py" -> "Import:math";
    "/test/test_legacy_nn.py" -> "Import:random";
    "/test/test_legacy_nn.py" -> "Import:unittest";
    "/test/test_legacy_nn.py" -> "Import:collections";
    "/test/test_legacy_nn.py" -> "Import:deepcopy";
    "/test/test_legacy_nn.py" -> "Import:torch";
    "/test/test_legacy_nn.py" -> "Import:torch.legacy.nn";
    "/test/test_legacy_nn.py" -> "Import:NNTestCase,";
    "/test/test_legacy_nn.py" -> "Import:get_numerical_jacobian,";
    "/test/test_legacy_nn.py" -> "Import:to_gpu,";
    "/test/test_legacy_nn.py" -> "Import:Variable";
    "/test/test_legacy_nn.py" -> "class:OldModuleTest(ModuleTest):";
    "/test/test_legacy_nn.py" -> "class:TestNN(NNTestCase):";
    "class:OldModuleTest(ModuleTest):" -> "Fxn:__init__";
    "class:OldModuleTest(ModuleTest):" -> "Fxn:_do_test";
    "class:OldModuleTest(ModuleTest):" -> "Fxn:build_spatial_unpooling_net";
    "class:OldModuleTest(ModuleTest):" -> "Fxn:build_volumetric_unpooling_net";
    "class:OldModuleTest(ModuleTest):" -> "Fxn:prepare_tests";
    "class:OldModuleTest(ModuleTest):" -> "Fxn:add_test";
    "class:OldModuleTest(ModuleTest):" -> "Fxn:require_grad";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__init__" -> "Fxn:kwargs.get('check_inplace',";
    "Fxn:_do_test" -> "Fxn:module.training()";
    "Fxn:_do_test" -> "Fxn:torch.no_grad():";
    "Fxn:_do_test" -> "Fxn:test_case.check_jacobian(module,";
    "Fxn:_do_test" -> "Fxn:module.evaluate()";
    "Fxn:_do_test" -> "Fxn:torch.no_grad():";
    "Fxn:_do_test" -> "Fxn:test_case.check_jacobian(module,";
    "Fxn:_do_test" -> "Fxn:.type()";
    "Fxn:_do_test" -> "Fxn:module.float().double().forward(input)";
    "Fxn:_do_test" -> "Fxn:.clearState()";
    "Fxn:_do_test" -> "Fxn:module.clearState()";
    "Fxn:_do_test" -> "Fxn:module.__repr__()";
    "Fxn:_do_test" -> "Fxn:deepcopy(input)";
    "Fxn:_do_test" -> "Fxn:self.constructor(*self.constructor_args,";
    "Fxn:_do_test" -> "Fxn:freeze_rng_state():";
    "Fxn:_do_test" -> "Fxn:module.forward(input)";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(input,";
    "Fxn:_do_test" -> "Fxn:freeze_rng_state():";
    "Fxn:_do_test" -> "Fxn:module_ip.forward(input2)";
    "Fxn:_do_test" -> "Fxn:torch.equal(output,";
    "Fxn:_do_test" -> "Fxn:test_case.assertNotEqual(input,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(output,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Add,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(torch.Size([5,";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Add,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.AddConstant,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3.5,),";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.BatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(10,),";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.BatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(10,";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialBatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialBatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialBatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricBatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricBatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricBatchNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CMul,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(5,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CMul,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(50,";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CMul,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:torch.randn(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Exp,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.exp()),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Log,";
    "Fxn:_do_test" -> "Fxn:torch.rand(2,";
    "Fxn:_do_test" -> "Fxn:i.log()),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Clamp,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(-2.,";
    "Fxn:_do_test" -> "Fxn:torch.randn(3,";
    "Fxn:_do_test" -> "Fxn:i.clamp(-2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Abs,";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:i.abs()),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Bilinear,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=[(4,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Bilinear,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(5,";
    "Fxn:_do_test" -> "Fxn:input_size=[(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Euclidean,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(5,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.WeightedEuclidean,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(5,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Cosine,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(5,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CAddTable,";
    "Fxn:_do_test" -> "Fxn:input_size=[(5,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CSubTable,";
    "Fxn:_do_test" -> "Fxn:input_size=[(5,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CDivTable,";
    "Fxn:_do_test" -> "Fxn:[torch.randn(1,";
    "Fxn:_do_test" -> "Fxn:torch.rand(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CMulTable,";
    "Fxn:_do_test" -> "Fxn:input_size=[(5,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Square,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:i.mul(i)),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Sqrt,";
    "Fxn:_do_test" -> "Fxn:torch.rand(10,";
    "Fxn:_do_test" -> "Fxn:i.sqrt()),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Squeeze,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.squeeze()),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Squeeze,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.squeeze(1),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Unsqueeze,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.view(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Unsqueeze,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(0,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.view(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Unsqueeze,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.view(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.View,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(-1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.view(-1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.View,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.view(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.View,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.view(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Sum,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.sum(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Sum,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.sum(1,";
    "Fxn:_do_test" -> "Fxn:keepdim=False).div(i.size(1)),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Mean,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:torch.mean(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(lambda:";
    "Fxn:_do_test" -> "Fxn:nn.Sequential().add(nn.GradientReversal()).add(nn.GradientReversal()),";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Identity,";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.DotProduct,";
    "Fxn:_do_test" -> "Fxn:input_size=[(10,";
    "Fxn:_do_test" -> "Fxn:torch.Tensor(list(";
    "Fxn:_do_test" -> "Fxn:a.dot(b)";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.CosineDistance,";
    "Fxn:_do_test" -> "Fxn:input_size=[(10,";
    "Fxn:_do_test" -> "Fxn:torch.Tensor(list(";
    "Fxn:_do_test" -> "Fxn:a.dot(b)";
    "Fxn:_do_test" -> "Fxn:b.norm(2))";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.JoinTable,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(0,),";
    "Fxn:_do_test" -> "Fxn:input_size=[(10,";
    "Fxn:_do_test" -> "Fxn:torch.cat(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.JoinTable,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,),";
    "Fxn:_do_test" -> "Fxn:input_size=[(2,";
    "Fxn:_do_test" -> "Fxn:torch.cat(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.JoinTable,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(-1,),";
    "Fxn:_do_test" -> "Fxn:input_size=[(2,";
    "Fxn:_do_test" -> "Fxn:torch.cat(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.MM,";
    "Fxn:_do_test" -> "Fxn:input_size=[(4,";
    "Fxn:_do_test" -> "Fxn:torch.bmm(*i)),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.MV,";
    "Fxn:_do_test" -> "Fxn:input_size=[(4,";
    "Fxn:_do_test" -> "Fxn:torch.bmm(i[0],";
    "Fxn:_do_test" -> "Fxn:i[1].view(i[1].size(0),";
    "Fxn:_do_test" -> "Fxn:i[1].size(1),";
    "Fxn:_do_test" -> "Fxn:1)).squeeze()),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Max,";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:torch.max(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Max,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:torch.max(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Min,";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:torch.min(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Min,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:torch.min(i,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.MixtureTable,";
    "Fxn:_do_test" -> "Fxn:input_size=[(5,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.LookupTable,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:torch.randperm(2).repeat(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Mul,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.MulConstant,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Narrow,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(0,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.narrow(0,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Narrow,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.narrow(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Transpose,";
    "Fxn:_do_test" -> "Fxn:constructor_args=((1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.transpose(1,";
    "Fxn:_do_test" -> "Fxn:2).transpose(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Transpose,";
    "Fxn:_do_test" -> "Fxn:constructor_args=((1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:i.transpose(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Replicate,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:i.view(10,";
    "Fxn:_do_test" -> "Fxn:5).expand(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Padding,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(0,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Padding,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(0,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Padding,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(0,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.PartialLinear,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(5,";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(lambda:";
    "Fxn:_do_test" -> "Fxn:nn.PartialLinear(5,";
    "Fxn:_do_test" -> "Fxn:6).setPartition(torch.Tensor((2,";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Power,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Power,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1.5,),";
    "Fxn:_do_test" -> "Fxn:torch.rand(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Reshape,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Reshape,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Select,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:i.select(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SelectTable,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:_do_test" -> "Fxn:input_size=[(1,),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialAveragePooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialAveragePooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialAveragePooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialAdaptiveMaxPooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:nn.SpatialMaxPooling(2,";
    "Fxn:_do_test" -> "Fxn:2).forward(i)),";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialAdaptiveMaxPooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolutionLocal,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolutionLocal,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolutionLocal,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialDivisiveNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialContrastiveNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialDilatedConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialDilatedConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialMaxPooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialReflectionPadding,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialReplicationPadding,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialZeroPadding,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolutionMap,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolutionMap,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialConvolutionMap,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.full(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialFullConvolutionMap,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialFullConvolutionMap,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.oneToOne(3),";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialFullConvolutionMap,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(nn.SpatialConvolutionMap.maps.full(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(3,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(lambda:";
    "Fxn:_do_test" -> "Fxn:nn.SpatialFractionalMaxPooling(2,";
    "Fxn:_do_test" -> "Fxn:0.5).fixPoolingRegions(),";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(lambda:";
    "Fxn:_do_test" -> "Fxn:nn.SpatialFractionalMaxPooling(2,";
    "Fxn:_do_test" -> "Fxn:4).fixPoolingRegions(),";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialFullConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialLPPooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialSubSampling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialSubtractiveNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialSubtractiveNormalization,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:torch.rand(3)),";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.SpatialUpSamplingNearest,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,),";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.TemporalConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.TemporalConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.TemporalSubSampling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.TemporalSubSampling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(4,";
    "Fxn:_do_test" -> "Fxn:input_size=(10,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricAveragePooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricAveragePooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricAveragePooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(3,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricFullConvolution,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:input_size=(1,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricMaxPooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricMaxPooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricMaxPooling,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.VolumetricReplicationPadding,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(1,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:CriterionTest(nn.L1Cost,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:CriterionTest(nn.L1HingeEmbeddingCriterion,";
    "Fxn:_do_test" -> "Fxn:input_size=[(2,";
    "Fxn:_do_test" -> "Fxn:CriterionTest(nn.L1HingeEmbeddingCriterion,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(2,),";
    "Fxn:_do_test" -> "Fxn:input_size=[(2,";
    "Fxn:_do_test" -> "Fxn:CriterionTest(nn.WeightedMSECriterion,";
    "Fxn:_do_test" -> "Fxn:input_size=(2,";
    "Fxn:_do_test" -> "Fxn:target_size=(2,";
    "Fxn:_do_test" -> "Fxn:CriterionTest(nn.MarginCriterion,";
    "Fxn:_do_test" -> "Fxn:input_size=(5,";
    "Fxn:_do_test" -> "Fxn:torch.randn(5,";
    "Fxn:_do_test" -> "Fxn:10).sign()),";
    "Fxn:_do_test" -> "Fxn:CriterionTest(nn.ClassSimplexCriterion,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(30,),";
    "Fxn:_do_test" -> "Fxn:torch.randn(5,";
    "Fxn:_do_test" -> "Fxn:30).mul(10).renorm(2,";
    "Fxn:_do_test" -> "Fxn:torch.rand(5).mul(30).floor().long(),";
    "Fxn:_do_test" -> "Fxn:tests.append(";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.Normalize,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(p,),";
    "Fxn:_do_test" -> "Fxn:input_size=(4,";
    "Fxn:_do_test" -> "Fxn:i.div(i.norm(p,";
    "Fxn:_do_test" -> "Fxn:True).expand_as(i)),";
    "Fxn:_do_test" -> "Fxn:desc=str(p)),";
    "Fxn:_do_test" -> "Fxn:tests.append(";
    "Fxn:_do_test" -> "Fxn:OldModuleTest(nn.PairwiseDistance,";
    "Fxn:_do_test" -> "Fxn:constructor_args=(p,),";
    "Fxn:_do_test" -> "Fxn:input_size=[(4,";
    "Fxn:_do_test" -> "Fxn:desc=str(p))";
    "Fxn:build_spatial_unpooling_net" -> "Fxn:nn.SpatialMaxPooling(2,";
    "Fxn:build_spatial_unpooling_net" -> "Fxn:nn.SpatialMaxUnpooling(pool)";
    "Fxn:build_spatial_unpooling_net" -> "Fxn:nn.Sequential().add(pool).add(unpool)";
    "Fxn:build_spatial_unpooling_net" -> "Fxn:tests.append(";
    "Fxn:build_spatial_unpooling_net" -> "Fxn:OldModuleTest(build_spatial_unpooling_net,";
    "Fxn:build_spatial_unpooling_net" -> "Fxn:input_size=(1,";
    "Fxn:build_volumetric_unpooling_net" -> "Fxn:nn.VolumetricMaxPooling(2,";
    "Fxn:build_volumetric_unpooling_net" -> "Fxn:nn.VolumetricMaxUnpooling(pool)";
    "Fxn:build_volumetric_unpooling_net" -> "Fxn:nn.Sequential().add(pool).add(unpool)";
    "Fxn:build_volumetric_unpooling_net" -> "Fxn:tests.append(";
    "Fxn:build_volumetric_unpooling_net" -> "Fxn:OldModuleTest(build_volumetric_unpooling_net,";
    "Fxn:build_volumetric_unpooling_net" -> "Fxn:input_size=(1,";
    "Fxn:add_test" -> "Fxn:test.get_name()";
    "Fxn:add_test" -> "Fxn:RuntimeError('Found";
    "Fxn:add_test" -> "Fxn:RuntimeError('Found";
    "Fxn:add_test" -> "Fxn:test(self))";
    "Fxn:add_test" -> "Fxn:test.test_cuda(self))";
    "Fxn:add_test" -> "Fxn:add_test(test)";
    "Fxn:add_test" -> "Fxn:deepcopy(test_params)";
    "Fxn:add_test" -> "Fxn:test_params.pop('module_name')";
    "Fxn:add_test" -> "Fxn:name_remap.get(name,";
    "Fxn:add_test" -> "Fxn:OldModuleTest(**test_params)";
    "Fxn:add_test" -> "Fxn:add_test(test)";
    "Fxn:add_test" -> "Fxn:deepcopy(test_params)";
    "Fxn:add_test" -> "Fxn:test_params.pop('module_name')";
    "Fxn:add_test" -> "Fxn:name_remap.get(name,";
    "Fxn:add_test" -> "Fxn:name.replace('Loss',";
    "Fxn:add_test" -> "Fxn:test_params.keys()";
    "Fxn:add_test" -> "Fxn:test_params.pop('legacy_constructor_args',";
    "Fxn:add_test" -> "Fxn:CriterionTest(**test_params)";
    "Fxn:add_test" -> "Fxn:add_test(test)";
    "Fxn:require_grad" -> "Fxn:input.detach()";
    "class:TestNN(NNTestCase):" -> "Fxn:_numerical_jacobian";
    "class:TestNN(NNTestCase):" -> "Fxn:fw";
    "class:TestNN(NNTestCase):" -> "Fxn:_forward";
    "class:TestNN(NNTestCase):" -> "Fxn:_backward";
    "class:TestNN(NNTestCase):" -> "Fxn:_forward_criterion";
    "class:TestNN(NNTestCase):" -> "Fxn:_backward_criterion";
    "class:TestNN(NNTestCase):" -> "Fxn:_zero_grad_parameters";
    "class:TestNN(NNTestCase):" -> "Fxn:_get_parameters";
    "class:TestNN(NNTestCase):" -> "Fxn:test_Dropout";
    "class:TestNN(NNTestCase):" -> "Fxn:test_SpatialDropout";
    "class:TestNN(NNTestCase):" -> "Fxn:test_VolumetricDropout";
    "class:TestNN(NNTestCase):" -> "Fxn:test_ReLU_reference";
    "class:TestNN(NNTestCase):" -> "Fxn:test_ReLU6_reference";
    "class:TestNN(NNTestCase):" -> "Fxn:test_Copy";
    "class:TestNN(NNTestCase):" -> "Fxn:test_FlattenTable";
    "class:TestNN(NNTestCase):" -> "Fxn:test_Concat";
    "class:TestNN(NNTestCase):" -> "Fxn:test_Parallel";
    "class:TestNN(NNTestCase):" -> "Fxn:test_ParallelTable";
    "class:TestNN(NNTestCase):" -> "Fxn:test_ConcatTable";
    "class:TestNN(NNTestCase):" -> "Fxn:test_DepthConcat";
    "class:TestNN(NNTestCase):" -> "Fxn:test_Contiguous";
    "class:TestNN(NNTestCase):" -> "Fxn:test_Index";
    "class:TestNN(NNTestCase):" -> "Fxn:test_L1Penalty";
    "class:TestNN(NNTestCase):" -> "Fxn:test_MaskedSelect";
    "class:TestNN(NNTestCase):" -> "Fxn:test_MultiCriterion";
    "class:TestNN(NNTestCase):" -> "Fxn:test_ParallelCriterion";
    "class:TestNN(NNTestCase):" -> "Fxn:test_NarrowTable";
    "class:TestNN(NNTestCase):" -> "Fxn:test_accUpdateGradParameters";
    "class:TestNN(NNTestCase):" -> "Fxn:_build_net";
    "class:TestNN(NNTestCase):" -> "Fxn:test_parameters";
    "class:TestNN(NNTestCase):" -> "Fxn:test_flattenParameters";
    "class:TestNN(NNTestCase):" -> "Fxn:test_findModules";
    "class:TestNN(NNTestCase):" -> "Fxn:test_apply";
    "class:TestNN(NNTestCase):" -> "Fxn:callback";
    "class:TestNN(NNTestCase):" -> "Fxn:test_listModules";
    "class:TestNN(NNTestCase):" -> "Fxn:callback";
    "class:TestNN(NNTestCase):" -> "Fxn:test_replace";
    "class:TestNN(NNTestCase):" -> "Fxn:callback";
    "Fxn:fw" -> "Fxn:self._forward(module,";
    "Fxn:fw" -> "Fxn:contiguous(input)";
    "Fxn:fw" -> "Fxn:require_grad(input)";
    "Fxn:fw" -> "Fxn:get_numerical_jacobian(fw,";
    "Fxn:fw" -> "Fxn:self._get_parameters(module)";
    "Fxn:fw" -> "Fxn:p.detach()";
    "Fxn:fw" -> "Fxn:jacobians.append(get_numerical_jacobian(fw,";
    "Fxn:fw" -> "Fxn:torch.cat(jacobians,";
    "Fxn:_forward" -> "Fxn:freeze_rng_state():";
    "Fxn:_forward" -> "Fxn:torch.no_grad():";
    "Fxn:_forward" -> "Fxn:module.forward(input)";
    "Fxn:_backward" -> "Fxn:module.backward(input,";
    "Fxn:_forward_criterion" -> "Fxn:torch.no_grad():";
    "Fxn:_forward_criterion" -> "Fxn:criterion.forward(input,";
    "Fxn:_backward_criterion" -> "Fxn:torch.no_grad():";
    "Fxn:_backward_criterion" -> "Fxn:criterion.backward(input,";
    "Fxn:_zero_grad_parameters" -> "Fxn:module.zeroGradParameters()";
    "Fxn:_get_parameters" -> "Fxn:module.parameters()";
    "Fxn:test_Dropout" -> "Fxn:torch.Tensor(1000).fill_(1";
    "Fxn:test_Dropout" -> "Fxn:nn.Dropout(p)";
    "Fxn:test_Dropout" -> "Fxn:module.forward(input)";
    "Fxn:test_Dropout" -> "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:test_Dropout" -> "Fxn:module.backward(input,";
    "Fxn:test_Dropout" -> "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:test_Dropout" -> "Fxn:nn.Dropout(p,";
    "Fxn:test_Dropout" -> "Fxn:module.forward(input.clone())";
    "Fxn:test_Dropout" -> "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:test_Dropout" -> "Fxn:module.backward(input.clone(),";
    "Fxn:test_Dropout" -> "Fxn:input.clone())";
    "Fxn:test_Dropout" -> "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:test_Dropout" -> "Fxn:module.__repr__()";
    "Fxn:test_SpatialDropout" -> "Fxn:random.randint(1,";
    "Fxn:test_SpatialDropout" -> "Fxn:random.randint(1,";
    "Fxn:test_SpatialDropout" -> "Fxn:random.randint(1,";
    "Fxn:test_SpatialDropout" -> "Fxn:torch.Tensor(b,";
    "Fxn:test_SpatialDropout" -> "Fxn:h).fill_(1)";
    "Fxn:test_SpatialDropout" -> "Fxn:nn.SpatialDropout(p)";
    "Fxn:test_SpatialDropout" -> "Fxn:module.training()";
    "Fxn:test_SpatialDropout" -> "Fxn:module.forward(input)";
    "Fxn:test_SpatialDropout" -> "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:test_SpatialDropout" -> "Fxn:module.backward(input,";
    "Fxn:test_SpatialDropout" -> "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:test_SpatialDropout" -> "Fxn:module.__repr__()";
    "Fxn:test_VolumetricDropout" -> "Fxn:random.randint(1,";
    "Fxn:test_VolumetricDropout" -> "Fxn:random.randint(1,";
    "Fxn:test_VolumetricDropout" -> "Fxn:random.randint(1,";
    "Fxn:test_VolumetricDropout" -> "Fxn:random.randint(1,";
    "Fxn:test_VolumetricDropout" -> "Fxn:torch.Tensor(bsz,";
    "Fxn:test_VolumetricDropout" -> "Fxn:h).fill_(1)";
    "Fxn:test_VolumetricDropout" -> "Fxn:nn.VolumetricDropout(p)";
    "Fxn:test_VolumetricDropout" -> "Fxn:module.training()";
    "Fxn:test_VolumetricDropout" -> "Fxn:module.forward(input)";
    "Fxn:test_VolumetricDropout" -> "Fxn:self.assertLess(abs(output.mean()";
    "Fxn:test_VolumetricDropout" -> "Fxn:module.backward(input,";
    "Fxn:test_VolumetricDropout" -> "Fxn:self.assertLess(abs(gradInput.mean()";
    "Fxn:test_VolumetricDropout" -> "Fxn:module.__repr__()";
    "Fxn:test_ReLU_reference" -> "Fxn:torch.randn(10,";
    "Fxn:test_ReLU_reference" -> "Fxn:nn.ReLU()";
    "Fxn:test_ReLU_reference" -> "Fxn:module.forward(input)";
    "Fxn:test_ReLU_reference" -> "Fxn:self.assertTrue(output[input.ge(0)].eq(input[input.gt(0)]).all())";
    "Fxn:test_ReLU_reference" -> "Fxn:self.assertTrue(output[input.lt(0)].eq(0).all())";
    "Fxn:test_ReLU6_reference" -> "Fxn:torch.randn(10,";
    "Fxn:test_ReLU6_reference" -> "Fxn:20).mul(10)";
    "Fxn:test_ReLU6_reference" -> "Fxn:nn.ReLU6()";
    "Fxn:test_ReLU6_reference" -> "Fxn:module.forward(input)";
    "Fxn:test_ReLU6_reference" -> "Fxn:self.assertTrue(output[input.ge(6)].eq(6).all())";
    "Fxn:test_ReLU6_reference" -> "Fxn:self.assertTrue(output[input.lt(0)].eq(0).all())";
    "Fxn:test_Copy" -> "Fxn:torch.randn(3,";
    "Fxn:test_Copy" -> "Fxn:4).double()";
    "Fxn:test_Copy" -> "Fxn:nn.Copy(torch.DoubleTensor,";
    "Fxn:test_Copy" -> "Fxn:c.forward(input)";
    "Fxn:test_Copy" -> "Fxn:self.assertIsInstance(output,";
    "Fxn:test_Copy" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_Copy" -> "Fxn:input.float(),";
    "Fxn:test_Copy" -> "Fxn:c.backward(input,";
    "Fxn:test_Copy" -> "Fxn:output.fill_(1))";
    "Fxn:test_Copy" -> "Fxn:self.assertIsInstance(gradInput,";
    "Fxn:test_Copy" -> "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_Copy" -> "Fxn:output.double(),";
    "Fxn:test_Copy" -> "Fxn:c.double()";
    "Fxn:test_Copy" -> "Fxn:self.assertIsInstance(output,";
    "Fxn:test_Copy" -> "Fxn:c.__repr__()";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(1),";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(2),";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(3)";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(4)";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(1),";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(2),";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(3),";
    "Fxn:test_FlattenTable" -> "Fxn:torch.rand(4)";
    "Fxn:test_FlattenTable" -> "Fxn:nn.FlattenTable()";
    "Fxn:test_FlattenTable" -> "Fxn:m.forward(input)";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(len(output),";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(output[0],";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(output[1],";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(output[2],";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(output[3],";
    "Fxn:test_FlattenTable" -> "Fxn:m.backward(input,";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(gradOutput[0],";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(gradOutput[1],";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(gradOutput[2],";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(gradOutput[3],";
    "Fxn:test_FlattenTable" -> "Fxn:m.__repr__()";
    "Fxn:test_FlattenTable" -> "Fxn:m.forward(input)";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(old_input_map,";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertEqual(old_output,";
    "Fxn:test_FlattenTable" -> "Fxn:input[1].append(torch.rand(5))";
    "Fxn:test_FlattenTable" -> "Fxn:m.forward(input)";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertNotEqual(old_input_map,";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertNotEqual(old_output,";
    "Fxn:test_FlattenTable" -> "Fxn:input.pop()";
    "Fxn:test_FlattenTable" -> "Fxn:m.forward(input)";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertNotEqual(old_input_map,";
    "Fxn:test_FlattenTable" -> "Fxn:self.assertNotEqual(old_output,";
    "Fxn:test_Concat" -> "Fxn:torch.randn(4,";
    "Fxn:test_Concat" -> "Fxn:random.randint(2,";
    "Fxn:test_Concat" -> "Fxn:[nn.Linear(2,";
    "Fxn:test_Concat" -> "Fxn:nn.Concat(0)";
    "Fxn:test_Concat" -> "Fxn:m.add(l)";
    "Fxn:test_Concat" -> "Fxn:l.zeroGradParameters()";
    "Fxn:test_Concat" -> "Fxn:l.weight.fill_(1)";
    "Fxn:test_Concat" -> "Fxn:l.bias.fill_(0)";
    "Fxn:test_Concat" -> "Fxn:m.__repr__()";
    "Fxn:test_Concat" -> "Fxn:m.forward(input)";
    "Fxn:test_Concat" -> "Fxn:input.sum(1,";
    "Fxn:test_Concat" -> "Fxn:True).expand(4,";
    "Fxn:test_Concat" -> "Fxn:5).repeat(num_modules,";
    "Fxn:test_Concat" -> "Fxn:self.assertEqual(output2,";
    "Fxn:test_Concat" -> "Fxn:m.backward(input,";
    "Fxn:test_Concat" -> "Fxn:torch.ones(output2.size()))";
    "Fxn:test_Concat" -> "Fxn:torch.ones(4,";
    "Fxn:test_Concat" -> "Fxn:2).fill_(num_modules";
    "Fxn:test_Concat" -> "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_Concat" -> "Fxn:input.sum(0,";
    "Fxn:test_Concat" -> "Fxn:keepdim=True).expand(5,";
    "Fxn:test_Concat" -> "Fxn:self.assertEqual(gradWeight,";
    "Fxn:test_Parallel" -> "Fxn:torch.randn(3,";
    "Fxn:test_Parallel" -> "Fxn:nn.Parallel(0,";
    "Fxn:test_Parallel" -> "Fxn:m.add(nn.View(4,";
    "Fxn:test_Parallel" -> "Fxn:m.add(nn.View(4,";
    "Fxn:test_Parallel" -> "Fxn:m.add(nn.View(4,";
    "Fxn:test_Parallel" -> "Fxn:m.__repr__()";
    "Fxn:test_Parallel" -> "Fxn:m.forward(input)";
    "Fxn:test_Parallel" -> "Fxn:input.transpose(0,";
    "Fxn:test_Parallel" -> "Fxn:2).transpose(0,";
    "Fxn:test_Parallel" -> "Fxn:self.assertEqual(output2,";
    "Fxn:test_Parallel" -> "Fxn:m.backward(input,";
    "Fxn:test_Parallel" -> "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_ParallelTable" -> "Fxn:torch.randn(3,";
    "Fxn:test_ParallelTable" -> "Fxn:nn.ParallelTable()";
    "Fxn:test_ParallelTable" -> "Fxn:p.add(nn.View(4,";
    "Fxn:test_ParallelTable" -> "Fxn:p.add(nn.View(4,";
    "Fxn:test_ParallelTable" -> "Fxn:p.add(nn.View(4,";
    "Fxn:test_ParallelTable" -> "Fxn:nn.Sequential()";
    "Fxn:test_ParallelTable" -> "Fxn:m.add(nn.SplitTable(0))";
    "Fxn:test_ParallelTable" -> "Fxn:m.add(p)";
    "Fxn:test_ParallelTable" -> "Fxn:m.add(nn.JoinTable(2))";
    "Fxn:test_ParallelTable" -> "Fxn:p.__repr__()";
    "Fxn:test_ParallelTable" -> "Fxn:m.forward(input)";
    "Fxn:test_ParallelTable" -> "Fxn:input.transpose(0,";
    "Fxn:test_ParallelTable" -> "Fxn:2).transpose(0,";
    "Fxn:test_ParallelTable" -> "Fxn:self.assertEqual(output2,";
    "Fxn:test_ParallelTable" -> "Fxn:m.backward(input,";
    "Fxn:test_ParallelTable" -> "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_ConcatTable" -> "Fxn:torch.randn(3,";
    "Fxn:test_ConcatTable" -> "Fxn:4).float(),";
    "Fxn:test_ConcatTable" -> "Fxn:torch.randn(3,";
    "Fxn:test_ConcatTable" -> "Fxn:4).float(),";
    "Fxn:test_ConcatTable" -> "Fxn:[torch.randn(3,";
    "Fxn:test_ConcatTable" -> "Fxn:4).float()]";
    "Fxn:test_ConcatTable" -> "Fxn:torch.randn(3,";
    "Fxn:test_ConcatTable" -> "Fxn:4).float(),";
    "Fxn:test_ConcatTable" -> "Fxn:torch.randn(3,";
    "Fxn:test_ConcatTable" -> "Fxn:4).float(),";
    "Fxn:test_ConcatTable" -> "Fxn:torch.randn(3,";
    "Fxn:test_ConcatTable" -> "Fxn:4).float()";
    "Fxn:test_ConcatTable" -> "Fxn:nn.ConcatTable()";
    "Fxn:test_ConcatTable" -> "Fxn:module.add(nn.Identity())";
    "Fxn:test_ConcatTable" -> "Fxn:module.add(nn.Identity())";
    "Fxn:test_ConcatTable" -> "Fxn:module.add(nn.Identity())";
    "Fxn:test_ConcatTable" -> "Fxn:module.float()";
    "Fxn:test_ConcatTable" -> "Fxn:module.__repr__()";
    "Fxn:test_ConcatTable" -> "Fxn:module.forward(input)";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(output2,";
    "Fxn:test_ConcatTable" -> "Fxn:module.backward(input,";
    "Fxn:test_ConcatTable" -> "Fxn:[_gradOutput[0].sum(0,";
    "Fxn:test_ConcatTable" -> "Fxn:_gradOutput[1].sum(";
    "Fxn:test_ConcatTable" -> "Fxn:[_gradOutput[2].sum(0,";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertTrue(isinstance(gradInput,";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertFalse(isinstance(gradInput[0],";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertFalse(isinstance(gradInput[1],";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertTrue(isinstance(gradInput[2],";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(len(gradInput),";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(len(gradInput[2]),";
    "Fxn:test_ConcatTable" -> "Fxn:iter_tensors(gradInput2)):";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(t1,";
    "Fxn:test_ConcatTable" -> "Fxn:nn.ConcatTable()";
    "Fxn:test_ConcatTable" -> "Fxn:test.add(nn.Identity())";
    "Fxn:test_ConcatTable" -> "Fxn:test.add(nn.Identity())";
    "Fxn:test_ConcatTable" -> "Fxn:[torch.randn(5),";
    "Fxn:test_ConcatTable" -> "Fxn:torch.randn(5)]";
    "Fxn:test_ConcatTable" -> "Fxn:[torch.randn(5)]";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(o1,";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(go1,";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(o2,";
    "Fxn:test_ConcatTable" -> "Fxn:self.assertEqual(go2,";
    "Fxn:test_DepthConcat" -> "Fxn:torch.randn(2,";
    "Fxn:test_DepthConcat" -> "Fxn:torch.randn(2,";
    "Fxn:test_DepthConcat" -> "Fxn:nn.DepthConcat(1)";
    "Fxn:test_DepthConcat" -> "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:test_DepthConcat" -> "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:test_DepthConcat" -> "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:test_DepthConcat" -> "Fxn:concat.add(nn.SpatialConvolution(3,";
    "Fxn:test_DepthConcat" -> "Fxn:concat.zeroGradParameters()";
    "Fxn:test_DepthConcat" -> "Fxn:concat.forward(input)";
    "Fxn:test_DepthConcat" -> "Fxn:concat.backward(input,";
    "Fxn:test_DepthConcat" -> "Fxn:torch.Tensor(2,";
    "Fxn:test_DepthConcat" -> "Fxn:12).zero_()";
    "Fxn:test_DepthConcat" -> "Fxn:input.clone().zero_()";
    "Fxn:test_DepthConcat" -> "Fxn:concat.get(i)";
    "Fxn:test_DepthConcat" -> "Fxn:conv.gradWeight.clone()";
    "Fxn:test_DepthConcat" -> "Fxn:conv.zeroGradParameters()";
    "Fxn:test_DepthConcat" -> "Fxn:output[narrows[i]].copy_(conv.forward(input))";
    "Fxn:test_DepthConcat" -> "Fxn:gradInput.add_(conv.backward(input,";
    "Fxn:test_DepthConcat" -> "Fxn:self.assertEqual(gradWeight,";
    "Fxn:test_DepthConcat" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_DepthConcat" -> "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_DepthConcat" -> "Fxn:concat.__repr__()";
    "Fxn:test_Contiguous" -> "Fxn:torch.randn(10,";
    "Fxn:test_Contiguous" -> "Fxn:nn.Contiguous()";
    "Fxn:test_Contiguous" -> "Fxn:noncontig.is_contiguous()";
    "Fxn:test_Contiguous" -> "Fxn:module.forward(noncontig)";
    "Fxn:test_Contiguous" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_Contiguous" -> "Fxn:self.assertTrue(output.is_contiguous())";
    "Fxn:test_Contiguous" -> "Fxn:module.__repr__()";
    "Fxn:test_Index" -> "Fxn:nn.Index(0)";
    "Fxn:test_Index" -> "Fxn:[torch.Tensor((10,";
    "Fxn:test_Index" -> "Fxn:torch.LongTensor((0,";
    "Fxn:test_Index" -> "Fxn:net.forward(input)";
    "Fxn:test_Index" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_Index" -> "Fxn:torch.Tensor((10,";
    "Fxn:test_Index" -> "Fxn:torch.Tensor((1,";
    "Fxn:test_Index" -> "Fxn:net.backward(input,";
    "Fxn:test_Index" -> "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:test_Index" -> "Fxn:torch.Tensor((1,";
    "Fxn:test_Index" -> "Fxn:[torch.Tensor(((10,";
    "Fxn:test_Index" -> "Fxn:torch.LongTensor((0,";
    "Fxn:test_Index" -> "Fxn:net.forward(input)";
    "Fxn:test_Index" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_Index" -> "Fxn:torch.Tensor(((10,";
    "Fxn:test_Index" -> "Fxn:torch.Tensor(((1,";
    "Fxn:test_Index" -> "Fxn:net.backward(input,";
    "Fxn:test_Index" -> "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:test_Index" -> "Fxn:torch.Tensor(((2,";
    "Fxn:test_Index" -> "Fxn:net.__repr__()";
    "Fxn:test_L1Penalty" -> "Fxn:nn.L1Penalty(weight,";
    "Fxn:test_L1Penalty" -> "Fxn:torch.rand(2,";
    "Fxn:test_L1Penalty" -> "Fxn:10).add_(-0.5)";
    "Fxn:test_L1Penalty" -> "Fxn:m.forward(input)";
    "Fxn:test_L1Penalty" -> "Fxn:m.backward(input,";
    "Fxn:test_L1Penalty" -> "Fxn:torch.ones(input.size()))";
    "Fxn:test_L1Penalty" -> "Fxn:self.assertEqual(input.abs().sum()";
    "Fxn:test_L1Penalty" -> "Fxn:input.lt(0).type_as(grad).mul_(-1)).mul_(weight)";
    "Fxn:test_L1Penalty" -> "Fxn:self.assertEqual(true_grad,";
    "Fxn:test_L1Penalty" -> "Fxn:m.__repr__()";
    "Fxn:test_MaskedSelect" -> "Fxn:torch.randn(4,";
    "Fxn:test_MaskedSelect" -> "Fxn:torch.ByteTensor(4,";
    "Fxn:test_MaskedSelect" -> "Fxn:5).bernoulli_()";
    "Fxn:test_MaskedSelect" -> "Fxn:nn.MaskedSelect()";
    "Fxn:test_MaskedSelect" -> "Fxn:module.forward([input,";
    "Fxn:test_MaskedSelect" -> "Fxn:self.assertEqual(input.masked_select(mask),";
    "Fxn:test_MaskedSelect" -> "Fxn:torch.Tensor((20,";
    "Fxn:test_MaskedSelect" -> "Fxn:torch.Tensor(((10,";
    "Fxn:test_MaskedSelect" -> "Fxn:torch.Tensor(((20,";
    "Fxn:test_MaskedSelect" -> "Fxn:torch.ByteTensor(((1,";
    "Fxn:test_MaskedSelect" -> "Fxn:nn.MaskedSelect()";
    "Fxn:test_MaskedSelect" -> "Fxn:module.forward([input,";
    "Fxn:test_MaskedSelect" -> "Fxn:module.backward([input,";
    "Fxn:test_MaskedSelect" -> "Fxn:self.assertEqual(inTarget,";
    "Fxn:test_MaskedSelect" -> "Fxn:module.__repr__()";
    "Fxn:test_MultiCriterion" -> "Fxn:torch.rand(2,";
    "Fxn:test_MultiCriterion" -> "Fxn:torch.LongTensor((1,";
    "Fxn:test_MultiCriterion" -> "Fxn:nn.ClassNLLCriterion()";
    "Fxn:test_MultiCriterion" -> "Fxn:nn.CrossEntropyCriterion()";
    "Fxn:test_MultiCriterion" -> "Fxn:nn.MultiCriterion().add(nll,";
    "Fxn:test_MultiCriterion" -> "Fxn:0.5).add(nll2)";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.forward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:nll.forward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:nll2.forward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.backward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:nll.backward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:target).clone().div(2).add(nll2.backward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(gradInput,";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.float()";
    "Fxn:test_MultiCriterion" -> "Fxn:gradInput.clone()";
    "Fxn:test_MultiCriterion" -> "Fxn:input.float()";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.forward(input3,";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.backward(input3,";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(gradInput.float(),";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.__repr__()";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.double()";
    "Fxn:test_MultiCriterion" -> "Fxn:[torch.randn(2,";
    "Fxn:test_MultiCriterion" -> "Fxn:[torch.randn(2,";
    "Fxn:test_MultiCriterion" -> "Fxn:torch.randn(2,";
    "Fxn:test_MultiCriterion" -> "Fxn:[torch.IntTensor((1,";
    "Fxn:test_MultiCriterion" -> "Fxn:[torch.IntTensor((5,";
    "Fxn:test_MultiCriterion" -> "Fxn:torch.IntTensor((4,";
    "Fxn:test_MultiCriterion" -> "Fxn:nn.ParallelCriterion().add(nll).add(nn.ParallelCriterion().add(nll.clone()).add(nll.clone()))";
    "Fxn:test_MultiCriterion" -> "Fxn:nn.ParallelCriterion().add(nll2).add(nn.ParallelCriterion().add(nll2.clone()).add(nll2.clone()))";
    "Fxn:test_MultiCriterion" -> "Fxn:nn.MultiCriterion().add(pnllc,";
    "Fxn:test_MultiCriterion" -> "Fxn:0.5).add(pnllc2)";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.forward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:pnllc.forward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:pnllc2.forward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_MultiCriterion" -> "Fxn:mc.backward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:pnllc.clone().backward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:pnllc2.backward(input,";
    "Fxn:test_MultiCriterion" -> "Fxn:gradInput2[0].div(2).add(gradInput2b[0])";
    "Fxn:test_MultiCriterion" -> "Fxn:gradInput2[1][0].div(2).add(gradInput2b[1][0])";
    "Fxn:test_MultiCriterion" -> "Fxn:gradInput2[1][1].div(2).add(gradInput2b[1][1])";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(gradInput[1],";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(gradInput[1][9],";
    "Fxn:test_MultiCriterion" -> "Fxn:self.assertEqual(gradInput[1][1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:[torch.rand(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:torch.randn(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:[torch.LongTensor((1,";
    "Fxn:test_ParallelCriterion" -> "Fxn:torch.randn(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.ClassNLLCriterion()";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.MSECriterion()";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.ParallelCriterion().add(nll,";
    "Fxn:test_ParallelCriterion" -> "Fxn:0.5).add(mse)";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.forward(input,";
    "Fxn:test_ParallelCriterion" -> "Fxn:nll.forward(input[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:mse.forward(input[1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_ParallelCriterion" -> "Fxn:[nll.backward(input[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:target[0]).clone().div(2),";
    "Fxn:test_ParallelCriterion" -> "Fxn:mse.backward(input[1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.backward(input,";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.float()";
    "Fxn:test_ParallelCriterion" -> "Fxn:gradInput[0].clone(),";
    "Fxn:test_ParallelCriterion" -> "Fxn:gradInput[1].clone()";
    "Fxn:test_ParallelCriterion" -> "Fxn:[input[0].float(),";
    "Fxn:test_ParallelCriterion" -> "Fxn:input[1].float()]";
    "Fxn:test_ParallelCriterion" -> "Fxn:target[1].float()]";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.forward(input3,";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.backward(input3,";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[0].float(),";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[1].float(),";
    "Fxn:test_ParallelCriterion" -> "Fxn:[torch.rand(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:torch.randn(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:torch.randn(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.MSECriterion()";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.ParallelCriterion(True).add(mse,";
    "Fxn:test_ParallelCriterion" -> "Fxn:0.5).add(nn.MSECriterion())";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.forward(input,";
    "Fxn:test_ParallelCriterion" -> "Fxn:mse.forward(input[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:mse.forward(input[1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.backward(input,";
    "Fxn:test_ParallelCriterion" -> "Fxn:[mse.backward(input[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:target).clone().div(2),";
    "Fxn:test_ParallelCriterion" -> "Fxn:mse.backward(input[1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:[torch.randn(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:[torch.rand(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:torch.randn(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:[torch.LongTensor((2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:[torch.LongTensor((1,";
    "Fxn:test_ParallelCriterion" -> "Fxn:torch.randn(2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.ClassNLLCriterion()";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.ClassNLLCriterion()";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.MSECriterion()";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.ParallelCriterion().add(nll,";
    "Fxn:test_ParallelCriterion" -> "Fxn:0.5).add(mse)";
    "Fxn:test_ParallelCriterion" -> "Fxn:nn.ParallelCriterion().add(nll2,";
    "Fxn:test_ParallelCriterion" -> "Fxn:0.4).add(pc)";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc2.forward(input,";
    "Fxn:test_ParallelCriterion" -> "Fxn:nll.forward(input[1][0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:mse.forward(input[1][1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_ParallelCriterion" -> "Fxn:nll2.backward(input[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:target[0]).clone().mul(0.4),";
    "Fxn:test_ParallelCriterion" -> "Fxn:[nll.backward(input[1][1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:target[1][0]).clone().div(2),";
    "Fxn:test_ParallelCriterion" -> "Fxn:mse.backward(input[1][1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc2.backward(input,";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[1][0],";
    "Fxn:test_ParallelCriterion" -> "Fxn:self.assertEqual(gradInput[1][1],";
    "Fxn:test_ParallelCriterion" -> "Fxn:pc.__repr__()";
    "Fxn:test_NarrowTable" -> "Fxn:[torch.Tensor(i)";
    "Fxn:test_NarrowTable" -> "Fxn:nn.NarrowTable(1)";
    "Fxn:test_NarrowTable" -> "Fxn:module.forward(input)";
    "Fxn:test_NarrowTable" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_NarrowTable" -> "Fxn:nn.NarrowTable(2,";
    "Fxn:test_NarrowTable" -> "Fxn:module.forward(input)";
    "Fxn:test_NarrowTable" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_NarrowTable" -> "Fxn:module.__repr__()";
    "Fxn:test_accUpdateGradParameters" -> "Fxn:nn.LookupTable(5,";
    "Fxn:test_accUpdateGradParameters" -> "Fxn:module.weight.fill_(2)";
    "Fxn:test_accUpdateGradParameters" -> "Fxn:torch.LongTensor([1,";
    "Fxn:test_accUpdateGradParameters" -> "Fxn:module.updateOutput(input)";
    "Fxn:test_accUpdateGradParameters" -> "Fxn:module.backwardUpdate(input,";
    "Fxn:test_accUpdateGradParameters" -> "Fxn:self.assertEqual(module.weight[0,";
    "Fxn:test_accUpdateGradParameters" -> "Fxn:self.assertEqual(module.weight[3,";
    "Fxn:_build_net" -> "Fxn:.add(nn.Concat(0)";
    "Fxn:_build_net" -> "Fxn:.add(nn.Linear(2,";
    "Fxn:_build_net" -> "Fxn:.add(nn.Linear(2,";
    "Fxn:_build_net" -> "Fxn:.add(nn.ReLU())";
    "Fxn:_build_net" -> "Fxn:.add(nn.Linear(10,";
    "Fxn:test_parameters" -> "Fxn:self._build_net()";
    "Fxn:test_parameters" -> "Fxn:net.parameters()";
    "Fxn:test_parameters" -> "Fxn:self.assertEqual(len(param),";
    "Fxn:test_parameters" -> "Fxn:self.assertEqual(len(grad),";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[0].weight,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[0].bias,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[1].weight,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[1].bias,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(net.modules[2].weight,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(net.modules[2].bias,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[0].gradWeight,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[0].gradBias,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[1].gradWeight,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(concat.modules[1].gradBias,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(net.modules[2].gradWeight,";
    "Fxn:test_parameters" -> "Fxn:self.assertObjectIn(net.modules[2].gradBias,";
    "Fxn:test_flattenParameters" -> "Fxn:self._build_net()";
    "Fxn:test_flattenParameters" -> "Fxn:net.flattenParameters()";
    "Fxn:test_flattenParameters" -> "Fxn:self.assertEqual(param.dim(),";
    "Fxn:test_flattenParameters" -> "Fxn:self.assertEqual(param.size(0),";
    "Fxn:test_flattenParameters" -> "Fxn:self.assertEqual(grad_param.dim(),";
    "Fxn:test_flattenParameters" -> "Fxn:self.assertEqual(grad_param.size(0),";
    "Fxn:test_findModules" -> "Fxn:self._build_net()";
    "Fxn:test_findModules" -> "Fxn:net.findModules(nn.Linear)";
    "Fxn:test_findModules" -> "Fxn:self.assertEqual(len(modules),";
    "Fxn:test_findModules" -> "Fxn:self.assertEqual(len(modules),";
    "Fxn:test_findModules" -> "Fxn:self.assertObjectIn(net.modules[0].modules[0],";
    "Fxn:test_findModules" -> "Fxn:self.assertObjectIn(net.modules[0].modules[1],";
    "Fxn:test_findModules" -> "Fxn:self.assertObjectIn(net.modules[2],";
    "Fxn:test_findModules" -> "Fxn:self.assertObjectIn(net.modules[0],";
    "Fxn:test_findModules" -> "Fxn:self.assertEqual(containers.count(net.modules[0]),";
    "Fxn:test_findModules" -> "Fxn:self.assertObjectIn(net,";
    "Fxn:test_findModules" -> "Fxn:self.assertObjectIn(m,";
    "Fxn:test_apply" -> "Fxn:self._build_net()";
    "Fxn:callback" -> "Fxn:self.assertNotIn(module,";
    "Fxn:callback" -> "Fxn:seen_modules.add(module)";
    "Fxn:callback" -> "Fxn:net.apply(callback)";
    "Fxn:callback" -> "Fxn:self.assertEqual(len(seen_modules),";
    "Fxn:test_listModules" -> "Fxn:self._build_net()";
    "Fxn:callback" -> "Fxn:module_list.append(module)";
    "Fxn:callback" -> "Fxn:net.apply(callback)";
    "Fxn:callback" -> "Fxn:self.assertEqual(module_list,";
    "Fxn:callback" -> "Fxn:net.listModules())";
    "Fxn:test_replace" -> "Fxn:self._build_net()";
    "Fxn:test_replace" -> "Fxn:self._build_net()";
    "Fxn:callback" -> "Fxn:nn.Tanh()";
    "Fxn:callback" -> "Fxn:net.replace(callback)";
    "Fxn:callback" -> "Fxn:ref_net.listModules()):";
    "Fxn:callback" -> "Fxn:self.assertIsInstance(module,";
    "Fxn:callback" -> "Fxn:self.assertIsInstance(module,";
    "Fxn:callback" -> "Fxn:prepare_tests()";
    "Fxn:callback" -> "Fxn:run_tests()";
    "/test/test_multiprocessing.py" -> "Import:contextlib";
    "/test/test_multiprocessing.py" -> "Import:import";
    "/test/test_multiprocessing.py" -> "Import:import";
    "/test/test_multiprocessing.py" -> "Import:sys";
    "/test/test_multiprocessing.py" -> "Import:time";
    "/test/test_multiprocessing.py" -> "Import:unittest";
    "/test/test_multiprocessing.py" -> "Import:platform";
    "/test/test_multiprocessing.py" -> "Import:torch";
    "/test/test_multiprocessing.py" -> "Import:torch.cuda";
    "/test/test_multiprocessing.py" -> "Import:torch.multiprocessing";
    "/test/test_multiprocessing.py" -> "Import:Variable";
    "/test/test_multiprocessing.py" -> "Import:Parameter";
    "/test/test_multiprocessing.py" -> "Import:TestCase,";
    "/test/test_multiprocessing.py" -> "class:SubProcess(mp.Process):";
    "/test/test_multiprocessing.py" -> "class:leak_checker(object):";
    "/test/test_multiprocessing.py" -> "class:TestMultiprocessing(TestCase):";
    "class:SubProcess(mp.Process):" -> "Fxn:__init__";
    "class:SubProcess(mp.Process):" -> "Fxn:run";
    "class:SubProcess(mp.Process):" -> "Fxn:simple_fill";
    "class:SubProcess(mp.Process):" -> "Fxn:simple_pool_fill";
    "class:SubProcess(mp.Process):" -> "Fxn:send_tensor";
    "class:SubProcess(mp.Process):" -> "Fxn:call_backward";
    "class:SubProcess(mp.Process):" -> "Fxn:sum_tensors";
    "class:SubProcess(mp.Process):" -> "Fxn:queue_get_exception";
    "class:SubProcess(mp.Process):" -> "Fxn:cuda_multiply_two";
    "class:SubProcess(mp.Process):" -> "Fxn:autograd_sharing";
    "class:SubProcess(mp.Process):" -> "Fxn:fs_sharing";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:run" -> "Fxn:self.tensor.add_(3)";
    "Fxn:simple_fill" -> "Fxn:queue.get()";
    "Fxn:simple_fill" -> "Fxn:event.set()";
    "Fxn:simple_pool_fill" -> "Fxn:tensor.fill_(4)";
    "Fxn:simple_pool_fill" -> "Fxn:tensor.add(1)";
    "Fxn:send_tensor" -> "Fxn:torch.ones(5,";
    "Fxn:send_tensor" -> "Fxn:5).type(tp)";
    "Fxn:send_tensor" -> "Fxn:queue.put(t)";
    "Fxn:send_tensor" -> "Fxn:queue.put(t)";
    "Fxn:send_tensor" -> "Fxn:event.wait()";
    "Fxn:call_backward" -> "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:call_backward" -> "Fxn:x.sum().backward()";
    "Fxn:sum_tensors" -> "Fxn:torch.cuda.device(1):";
    "Fxn:sum_tensors" -> "Fxn:inq.get()";
    "Fxn:sum_tensors" -> "Fxn:outq.put((tensor.sum().item(),";
    "Fxn:sum_tensors" -> "Fxn:tensor.get_device(),";
    "Fxn:sum_tensors" -> "Fxn:tensor.numel(),";
    "Fxn:sum_tensors" -> "Fxn:tensor.storage().size()))";
    "Fxn:queue_get_exception" -> "Fxn:os.close(2)";
    "Fxn:queue_get_exception" -> "Fxn:torch.zeros(5,";
    "Fxn:queue_get_exception" -> "Fxn:5).cuda()";
    "Fxn:queue_get_exception" -> "Fxn:outqueue.put(e)";
    "Fxn:queue_get_exception" -> "Fxn:outqueue.put('no";
    "Fxn:cuda_multiply_two" -> "Fxn:ready.set()";
    "Fxn:cuda_multiply_two" -> "Fxn:torch.cuda.stream(torch.cuda.Stream()):";
    "Fxn:cuda_multiply_two" -> "Fxn:queue.get()";
    "Fxn:cuda_multiply_two" -> "Fxn:cuda_event.wait()";
    "Fxn:cuda_multiply_two" -> "Fxn:tensor.mul_(2)";
    "Fxn:cuda_multiply_two" -> "Fxn:cuda_event.record()";
    "Fxn:cuda_multiply_two" -> "Fxn:done.set()";
    "Fxn:autograd_sharing" -> "Fxn:queue.get()";
    "Fxn:autograd_sharing" -> "Fxn:ready.set()";
    "Fxn:autograd_sharing" -> "Fxn:master_modified.wait()";
    "Fxn:autograd_sharing" -> "Fxn:torch.arange(1,";
    "Fxn:autograd_sharing" -> "Fxn:26).view(5,";
    "Fxn:autograd_sharing" -> "Fxn:var.data.equal(expected_var)";
    "Fxn:autograd_sharing" -> "Fxn:torch.ones(5,";
    "Fxn:autograd_sharing" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:autograd_sharing" -> "Fxn:queue.put(is_ok)";
    "Fxn:fs_sharing" -> "Fxn:mp.get_sharing_strategy()";
    "Fxn:fs_sharing" -> "Fxn:mp.set_sharing_strategy('file_system')";
    "Fxn:fs_sharing" -> "Fxn:mp.set_sharing_strategy(prev_strategy)";
    "class:leak_checker(object):" -> "Fxn:__init__";
    "class:leak_checker(object):" -> "Fxn:__enter__";
    "class:leak_checker(object):" -> "Fxn:__exit__";
    "class:leak_checker(object):" -> "Fxn:check_pid";
    "class:leak_checker(object):" -> "Fxn:_get_next_fds";
    "class:leak_checker(object):" -> "Fxn:has_shm_files";
    "class:leak_checker(object):" -> "Fxn:_has_shm_files";
    "Fxn:__init__" -> "Fxn:[os.getpid()]";
    "Fxn:__enter__" -> "Fxn:self._get_next_fds(10)";
    "Fxn:__exit__" -> "Fxn:self._get_next_fds(10)";
    "Fxn:__exit__" -> "Fxn:self.test_case.assertLessEqual(";
    "Fxn:__exit__" -> "Fxn:self.test_case.assertFalse(self.has_shm_files())";
    "Fxn:check_pid" -> "Fxn:self.checked_pids.append(pid)";
    "Fxn:_get_next_fds" -> "Fxn:[os.dup(0)";
    "Fxn:_get_next_fds" -> "Fxn:os.close(fd)";
    "Fxn:has_shm_files" -> "Fxn:self._has_shm_files()";
    "Fxn:has_shm_files" -> "Fxn:mp.get_sharing_strategy()";
    "Fxn:has_shm_files" -> "Fxn:time.sleep(0.5)";
    "Fxn:has_shm_files" -> "Fxn:self._has_shm_files()";
    "Fxn:_has_shm_files" -> "Fxn:gc.collect()";
    "Fxn:_has_shm_files" -> "Fxn:os.listdir('/dev/shm'):";
    "Fxn:_has_shm_files" -> "Fxn:filename.startswith(name):";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:_test_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fill";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_receive";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:_test_preserve_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:do_test";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:_test_pool";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:do_test";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fd_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fd_preserve_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fd_pool";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fs_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fs_preserve_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fs_pool";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fs";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:queue_put";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_inherit_tensor";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_cuda";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_cuda_small_tensors";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_cuda_bad_call";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_event";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:_test_autograd_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_variable_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_parameter_sharing";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_empty_shared";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:_test_is_shared";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_is_shared";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_fs_is_shared";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_is_shared_cuda";
    "class:TestMultiprocessing(TestCase):" -> "Fxn:test_backwards_fork";
    "Fxn:test_fill" -> "Fxn:torch.zeros(5,";
    "Fxn:test_fill" -> "Fxn:5).type(type)";
    "Fxn:test_fill" -> "Fxn:ctx.Queue()";
    "Fxn:test_fill" -> "Fxn:ctx.Event()";
    "Fxn:test_fill" -> "Fxn:q.put(data)";
    "Fxn:test_fill" -> "Fxn:ctx.Process(target=simple_fill,";
    "Fxn:test_fill" -> "Fxn:args=(q,";
    "Fxn:test_fill" -> "Fxn:lc.check_pid(p.pid)";
    "Fxn:test_fill" -> "Fxn:p.start()";
    "Fxn:test_fill" -> "Fxn:e.wait(10)";
    "Fxn:test_fill" -> "Fxn:self.assertTrue(e.is_set())";
    "Fxn:test_fill" -> "Fxn:self.assertTrue(data[0].eq(4).all())";
    "Fxn:test_fill" -> "Fxn:self.assertTrue(data[1].eq(4).all())";
    "Fxn:test_fill" -> "Fxn:p.join(1)";
    "Fxn:test_fill" -> "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_receive" -> "Fxn:ctx.Queue()";
    "Fxn:test_receive" -> "Fxn:ctx.Event()";
    "Fxn:test_receive" -> "Fxn:ctx.Process(target=send_tensor,";
    "Fxn:test_receive" -> "Fxn:args=(q,";
    "Fxn:test_receive" -> "Fxn:lc.check_pid(p.pid)";
    "Fxn:test_receive" -> "Fxn:p.start()";
    "Fxn:test_receive" -> "Fxn:q.get()";
    "Fxn:test_receive" -> "Fxn:q.get()";
    "Fxn:test_receive" -> "Fxn:self.assertTrue(t1.eq(1).all())";
    "Fxn:test_receive" -> "Fxn:self.assertTrue(id(t1.storage())";
    "Fxn:test_receive" -> "Fxn:e.set()";
    "Fxn:test_receive" -> "Fxn:p.join(1)";
    "Fxn:test_receive" -> "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_receive" -> "Fxn:leak_checker(self)";
    "Fxn:test_receive" -> "Fxn:test_fill()";
    "Fxn:test_receive" -> "Fxn:test_receive()";
    "Fxn:do_test" -> "Fxn:torch.randn(5,";
    "Fxn:do_test" -> "Fxn:[x.storage(),";
    "Fxn:do_test" -> "Fxn:x.storage()[1:4],";
    "Fxn:do_test" -> "Fxn:ctx.Queue()";
    "Fxn:do_test" -> "Fxn:q.put(data)";
    "Fxn:do_test" -> "Fxn:q.get(timeout=1)";
    "Fxn:do_test" -> "Fxn:self.assertEqual(new_data,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(new_data[0]._cdata,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(t.storage()._cdata,";
    "Fxn:do_test" -> "Fxn:new_data[0].fill_(10)";
    "Fxn:do_test" -> "Fxn:self.assertEqual(new_data[1],";
    "Fxn:do_test" -> "Fxn:leak_checker(self):";
    "Fxn:do_test" -> "Fxn:do_test()";
    "Fxn:do_test" -> "Fxn:ctx.Pool(2)";
    "Fxn:do_test" -> "Fxn:lc.check_pid(proc.pid)";
    "Fxn:do_test" -> "Fxn:[torch.zeros(2,";
    "Fxn:do_test" -> "Fxn:p.map(simple_pool_fill,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(len(results),";
    "Fxn:do_test" -> "Fxn:self.assertEqual(r,";
    "Fxn:do_test" -> "Fxn:torch.ones(2,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(b,";
    "Fxn:do_test" -> "Fxn:torch.ones(2,";
    "Fxn:do_test" -> "Fxn:p.close()";
    "Fxn:do_test" -> "Fxn:p.join()";
    "Fxn:do_test" -> "Fxn:leak_checker(self)";
    "Fxn:do_test" -> "Fxn:do_test()";
    "Fxn:do_test" -> "Fxn:@unittest.skipIf(platform";
    "Fxn:do_test" -> "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fd_sharing" -> "Fxn:self._test_sharing(repeat=TEST_REPEATS)";
    "Fxn:test_fd_sharing" -> "Fxn:@unittest.skipIf(platform";
    "Fxn:test_fd_sharing" -> "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fd_preserve_sharing" -> "Fxn:self._test_preserve_sharing(repeat=TEST_REPEATS)";
    "Fxn:test_fd_preserve_sharing" -> "Fxn:@unittest.skipIf(platform";
    "Fxn:test_fd_pool" -> "Fxn:self._test_pool(repeat=TEST_REPEATS)";
    "Fxn:test_fd_pool" -> "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fs_sharing" -> "Fxn:fs_sharing():";
    "Fxn:test_fs_sharing" -> "Fxn:self._test_sharing(repeat=TEST_REPEATS)";
    "Fxn:test_fs_sharing" -> "Fxn:@unittest.skipIf(TEST_WITH_ASAN,";
    "Fxn:test_fs_preserve_sharing" -> "Fxn:fs_sharing():";
    "Fxn:test_fs_preserve_sharing" -> "Fxn:self._test_preserve_sharing(repeat=TEST_REPEATS)";
    "Fxn:test_fs_pool" -> "Fxn:fs_sharing():";
    "Fxn:test_fs_pool" -> "Fxn:self._test_pool(repeat=TEST_REPEATS)";
    "Fxn:test_fs_pool" -> "Fxn:@unittest.skipIf(not";
    "Fxn:queue_put" -> "Fxn:torch.DoubleStorage(4)";
    "Fxn:queue_put" -> "Fxn:mp.Queue()";
    "Fxn:queue_put" -> "Fxn:self.assertFalse(lc.has_shm_files())";
    "Fxn:queue_put" -> "Fxn:q.put(x)";
    "Fxn:queue_put" -> "Fxn:time.sleep(0.05)";
    "Fxn:queue_put" -> "Fxn:self.assertTrue(lc.has_shm_files(wait=False))";
    "Fxn:queue_put" -> "Fxn:q.get()";
    "Fxn:queue_put" -> "Fxn:fs_sharing(),";
    "Fxn:queue_put" -> "Fxn:leak_checker(self)";
    "Fxn:queue_put" -> "Fxn:queue_put()";
    "Fxn:test_inherit_tensor" -> "Fxn:torch.zeros(5,";
    "Fxn:test_inherit_tensor" -> "Fxn:SubProcess(t.share_memory_())";
    "Fxn:test_inherit_tensor" -> "Fxn:p.start()";
    "Fxn:test_inherit_tensor" -> "Fxn:p.join(1)";
    "Fxn:test_inherit_tensor" -> "Fxn:self.assertEqual(t,";
    "Fxn:test_inherit_tensor" -> "Fxn:torch.ones(5,";
    "Fxn:test_inherit_tensor" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda" -> "Fxn:torch.cuda.FloatTensor([1])";
    "Fxn:test_cuda" -> "Fxn:self._test_sharing(mp.get_context('spawn'),";
    "Fxn:test_cuda" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_small_tensors" -> "Fxn:mp.get_context('spawn')";
    "Fxn:test_cuda_small_tensors" -> "Fxn:[torch.arange(i";
    "Fxn:test_cuda_small_tensors" -> "Fxn:5).cuda(device)]";
    "Fxn:test_cuda_small_tensors" -> "Fxn:ctx.Queue()";
    "Fxn:test_cuda_small_tensors" -> "Fxn:ctx.Queue()";
    "Fxn:test_cuda_small_tensors" -> "Fxn:inq.put(tensors)";
    "Fxn:test_cuda_small_tensors" -> "Fxn:ctx.Process(target=sum_tensors,";
    "Fxn:test_cuda_small_tensors" -> "Fxn:args=(inq,";
    "Fxn:test_cuda_small_tensors" -> "Fxn:p.start()";
    "Fxn:test_cuda_small_tensors" -> "Fxn:results.append(outq.get())";
    "Fxn:test_cuda_small_tensors" -> "Fxn:p.join()";
    "Fxn:test_cuda_small_tensors" -> "Fxn:self.assertEqual(v,";
    "Fxn:test_cuda_small_tensors" -> "Fxn:torch.arange(i";
    "Fxn:test_cuda_small_tensors" -> "Fxn:5).sum())";
    "Fxn:test_cuda_small_tensors" -> "Fxn:self.assertEqual(device,";
    "Fxn:test_cuda_small_tensors" -> "Fxn:self.assertEqual(tensor_size,";
    "Fxn:test_cuda_small_tensors" -> "Fxn:self.assertEqual(storage_size,";
    "Fxn:test_cuda_small_tensors" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_cuda_small_tensors" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_small_tensors" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_cuda_bad_call" -> "Fxn:torch.zeros(5,";
    "Fxn:test_cuda_bad_call" -> "Fxn:5).cuda().cpu()";
    "Fxn:test_cuda_bad_call" -> "Fxn:mp.Queue()";
    "Fxn:test_cuda_bad_call" -> "Fxn:mp.Queue()";
    "Fxn:test_cuda_bad_call" -> "Fxn:mp.Process(target=queue_get_exception,";
    "Fxn:test_cuda_bad_call" -> "Fxn:args=(inq,";
    "Fxn:test_cuda_bad_call" -> "Fxn:p.start()";
    "Fxn:test_cuda_bad_call" -> "Fxn:inq.put(t)";
    "Fxn:test_cuda_bad_call" -> "Fxn:p.join()";
    "Fxn:test_cuda_bad_call" -> "Fxn:self.assertIsInstance(outq.get(),";
    "Fxn:test_cuda_bad_call" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_event" -> "Fxn:mp.get_context('spawn')";
    "Fxn:test_event" -> "Fxn:ctx.Queue()";
    "Fxn:test_event" -> "Fxn:ctx.Event()";
    "Fxn:test_event" -> "Fxn:ctx.Event()";
    "Fxn:test_event" -> "Fxn:ctx.Process(target=cuda_multiply_two,";
    "Fxn:test_event" -> "Fxn:args=(queue,";
    "Fxn:test_event" -> "Fxn:p.start()";
    "Fxn:test_event" -> "Fxn:ready.wait()";
    "Fxn:test_event" -> "Fxn:torch.cuda.stream(torch.cuda.Stream()):";
    "Fxn:test_event" -> "Fxn:torch.cuda.FloatTensor([1,";
    "Fxn:test_event" -> "Fxn:torch.cuda.Event(interprocess=True)";
    "Fxn:test_event" -> "Fxn:torch.cuda._sleep(20000000)";
    "Fxn:test_event" -> "Fxn:tensor.add_(1)";
    "Fxn:test_event" -> "Fxn:event.record()";
    "Fxn:test_event" -> "Fxn:queue.put((event,";
    "Fxn:test_event" -> "Fxn:done.wait()";
    "Fxn:test_event" -> "Fxn:event.synchronize()";
    "Fxn:test_event" -> "Fxn:self.assertEqual(list(tensor),";
    "Fxn:test_event" -> "Fxn:p.join()";
    "Fxn:_test_autograd_sharing" -> "Fxn:mp.Event()";
    "Fxn:_test_autograd_sharing" -> "Fxn:mp.Event()";
    "Fxn:_test_autograd_sharing" -> "Fxn:mp.Queue()";
    "Fxn:_test_autograd_sharing" -> "Fxn:mp.Process(target=autograd_sharing,";
    "Fxn:_test_autograd_sharing" -> "Fxn:args=(queue,";
    "Fxn:_test_autograd_sharing" -> "Fxn:p.start()";
    "Fxn:_test_autograd_sharing" -> "Fxn:Variable(torch.zeros(5,";
    "Fxn:_test_autograd_sharing" -> "Fxn:queue.put(var)";
    "Fxn:_test_autograd_sharing" -> "Fxn:ready.wait()";
    "Fxn:_test_autograd_sharing" -> "Fxn:torch.ones(5,";
    "Fxn:_test_autograd_sharing" -> "Fxn:master_modified.set()";
    "Fxn:_test_autograd_sharing" -> "Fxn:queue.get()";
    "Fxn:_test_autograd_sharing" -> "Fxn:self.assertTrue(worker_ok)";
    "Fxn:_test_autograd_sharing" -> "Fxn:self.assertEqual(var.data,";
    "Fxn:_test_autograd_sharing" -> "Fxn:torch.ones(5,";
    "Fxn:_test_autograd_sharing" -> "Fxn:self.assertEqual(var.grad.data,";
    "Fxn:_test_autograd_sharing" -> "Fxn:torch.ones(5,";
    "Fxn:_test_autograd_sharing" -> "Fxn:p.join(1)";
    "Fxn:_test_autograd_sharing" -> "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_variable_sharing" -> "Fxn:Variable(torch.arange(1,";
    "Fxn:test_variable_sharing" -> "Fxn:26).view(5,";
    "Fxn:test_variable_sharing" -> "Fxn:self._test_autograd_sharing(var)";
    "Fxn:test_parameter_sharing" -> "Fxn:Parameter(torch.arange(1,";
    "Fxn:test_parameter_sharing" -> "Fxn:26).view(5,";
    "Fxn:test_parameter_sharing" -> "Fxn:self._test_autograd_sharing(param)";
    "Fxn:test_empty_shared" -> "Fxn:torch.Tensor()";
    "Fxn:test_empty_shared" -> "Fxn:t.share_memory_()";
    "Fxn:_test_is_shared" -> "Fxn:torch.randn(5,";
    "Fxn:_test_is_shared" -> "Fxn:self.assertFalse(t.is_shared())";
    "Fxn:_test_is_shared" -> "Fxn:t.share_memory_()";
    "Fxn:_test_is_shared" -> "Fxn:self.assertTrue(t.is_shared())";
    "Fxn:_test_is_shared" -> "Fxn:@unittest.skipIf(platform";
    "Fxn:test_is_shared" -> "Fxn:self._test_is_shared()";
    "Fxn:test_fs_is_shared" -> "Fxn:fs_sharing():";
    "Fxn:test_fs_is_shared" -> "Fxn:self._test_is_shared()";
    "Fxn:test_fs_is_shared" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_fs_is_shared" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_is_shared_cuda" -> "Fxn:torch.randn(5,";
    "Fxn:test_is_shared_cuda" -> "Fxn:5).cuda()";
    "Fxn:test_is_shared_cuda" -> "Fxn:self.assertTrue(t.is_shared())";
    "Fxn:test_backwards_fork" -> "Fxn:r"backwards()";
    "Fxn:test_backwards_fork" -> "Fxn:call_backward()";
    "Fxn:test_backwards_fork" -> "Fxn:mp.Process(target=call_backward)";
    "Fxn:test_backwards_fork" -> "Fxn:p.start()";
    "Fxn:test_backwards_fork" -> "Fxn:p.join(1)";
    "Fxn:test_backwards_fork" -> "Fxn:self.assertFalse(p.is_alive())";
    "Fxn:test_backwards_fork" -> "Fxn:run_tests()";
    "/test/test_nccl.py" -> "Import:unittest";
    "/test/test_nccl.py" -> "Import:torch";
    "/test/test_nccl.py" -> "Import:torch.cuda.nccl";
    "/test/test_nccl.py" -> "Import:torch.cuda";
    "/test/test_nccl.py" -> "Import:TestCase,";
    "/test/test_nccl.py" -> "class:TestNCCL(TestCase):";
    "class:TestNCCL(TestCase):" -> "Fxn:test_unique_id";
    "class:TestNCCL(TestCase):" -> "Fxn:test_broadcast";
    "class:TestNCCL(TestCase):" -> "Fxn:test_reduce";
    "class:TestNCCL(TestCase):" -> "Fxn:test_all_reduce";
    "class:TestNCCL(TestCase):" -> "Fxn:test_all_gather";
    "class:TestNCCL(TestCase):" -> "Fxn:test_reduce_scatter";
    "Fxn:test_unique_id" -> "Fxn:nccl.unique_id()";
    "Fxn:test_unique_id" -> "Fxn:self.assertIsInstance(uid,";
    "Fxn:test_unique_id" -> "Fxn:self.assertGreater(len(uid),";
    "Fxn:test_unique_id" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_unique_id" -> "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_broadcast" -> "Fxn:torch.FloatTensor(128).uniform_()";
    "Fxn:test_broadcast" -> "Fxn:[expected.cuda()]";
    "Fxn:test_broadcast" -> "Fxn:torch.cuda.device_count()):";
    "Fxn:test_broadcast" -> "Fxn:torch.cuda.device(device):";
    "Fxn:test_broadcast" -> "Fxn:tensors.append(torch.cuda.FloatTensor(128))";
    "Fxn:test_broadcast" -> "Fxn:nccl.broadcast(tensors)";
    "Fxn:test_broadcast" -> "Fxn:self.assertEqual(tensors[i],";
    "Fxn:test_broadcast" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_broadcast" -> "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_reduce" -> "Fxn:[torch.FloatTensor(128).uniform_()";
    "Fxn:test_reduce" -> "Fxn:torch.FloatTensor(128).zero_()";
    "Fxn:test_reduce" -> "Fxn:expected.add_(t)";
    "Fxn:test_reduce" -> "Fxn:[tensors[i].cuda(i)";
    "Fxn:test_reduce" -> "Fxn:nccl.reduce(tensors)";
    "Fxn:test_reduce" -> "Fxn:self.assertEqual(tensors[0],";
    "Fxn:test_reduce" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_reduce" -> "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_all_reduce" -> "Fxn:[torch.FloatTensor(128).uniform_()";
    "Fxn:test_all_reduce" -> "Fxn:torch.FloatTensor(128).zero_()";
    "Fxn:test_all_reduce" -> "Fxn:expected.add_(t)";
    "Fxn:test_all_reduce" -> "Fxn:[tensors[i].cuda(i)";
    "Fxn:test_all_reduce" -> "Fxn:nccl.all_reduce(tensors)";
    "Fxn:test_all_reduce" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_all_reduce" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_all_reduce" -> "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_all_gather" -> "Fxn:[torch.FloatTensor(128).uniform_()";
    "Fxn:test_all_gather" -> "Fxn:torch.cat(inputs,";
    "Fxn:test_all_gather" -> "Fxn:[inputs[i].cuda(i)";
    "Fxn:test_all_gather" -> "Fxn:[torch.cuda.FloatTensor(128";
    "Fxn:test_all_gather" -> "Fxn:nccl.all_gather(inputs,";
    "Fxn:test_all_gather" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_all_gather" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_all_gather" -> "Fxn:@unittest.skipIf(nGPUs";
    "Fxn:test_reduce_scatter" -> "Fxn:[torch.FloatTensor(in_size).uniform_()";
    "Fxn:test_reduce_scatter" -> "Fxn:torch.FloatTensor(in_size).zero_()";
    "Fxn:test_reduce_scatter" -> "Fxn:expected.add_(t)";
    "Fxn:test_reduce_scatter" -> "Fxn:expected.view(nGPUs,";
    "Fxn:test_reduce_scatter" -> "Fxn:[inputs[i].cuda(i)";
    "Fxn:test_reduce_scatter" -> "Fxn:[torch.cuda.FloatTensor(out_size,";
    "Fxn:test_reduce_scatter" -> "Fxn:nccl.reduce_scatter(inputs,";
    "Fxn:test_reduce_scatter" -> "Fxn:self.assertEqual(outputs[i],";
    "Fxn:test_reduce_scatter" -> "Fxn:run_tests()";
    "/test/test_nn.py" -> "Import:math";
    "/test/test_nn.py" -> "Import:random";
    "/test/test_nn.py" -> "Import:string";
    "/test/test_nn.py" -> "Import:unittest";
    "/test/test_nn.py" -> "Import:itertools";
    "/test/test_nn.py" -> "Import:contextlib";
    "/test/test_nn.py" -> "Import:warnings";
    "/test/test_nn.py" -> "Import:pickle";
    "/test/test_nn.py" -> "Import:deepcopy";
    "/test/test_nn.py" -> "Import:repeat,";
    "/test/test_nn.py" -> "Import:wraps,";
    "/test/test_nn.py" -> "Import:mul";
    "/test/test_nn.py" -> "Import:OrderedDict";
    "/test/test_nn.py" -> "Import:torch";
    "/test/test_nn.py" -> "Import:torch.backends.cudnn";
    "/test/test_nn.py" -> "Import:torch.nn";
    "/test/test_nn.py" -> "Import:torch.nn.functional";
    "/test/test_nn.py" -> "Import:torch.nn.parallel";
    "/test/test_nn.py" -> "Import:torch.nn.init";
    "/test/test_nn.py" -> "Import:torch.nn.utils.rnn";
    "/test/test_nn.py" -> "Import:torch.legacy.nn";
    "/test/test_nn.py" -> "Import:clip_grad_norm";
    "/test/test_nn.py" -> "Import:parameters_to_vector,";
    "/test/test_nn.py" -> "Import:Variable,";
    "/test/test_nn.py" -> "Import:gradgradcheck";
    "/test/test_nn.py" -> "Import:Parameter";
    "/test/test_nn.py" -> "Import:Broadcast";
    "/test/test_nn.py" -> "Import:NNTestCase,";
    "/test/test_nn.py" -> "Import:freeze_rng_state,";
    "/test/test_nn.py" -> "Import:stats";
    "/test/test_nn.py" -> "class:PackedSequenceTest(TestCase):";
    "/test/test_nn.py" -> "class:InputVariableMixin(object):";
    "/test/test_nn.py" -> "class:NewModuleTest(InputVariableMixin,";
    "/test/test_nn.py" -> "class:NewCriterionTest(InputVariableMixin,";
    "/test/test_nn.py" -> "class:TestNN(NNTestCase):";
    "/test/test_nn.py" -> "Import:SourceChangeWarning";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:TestModule(nn.Module):";
    "/test/test_nn.py" -> "Import:class";
    "/test/test_nn.py" -> "class:Model(nn.Module):";
    "/test/test_nn.py" -> "class:Layer(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Net(nn.Module):";
    "/test/test_nn.py" -> "class:Model(nn.Module):";
    "/test/test_nn.py" -> "Import:sys";
    "/test/test_nn.py" -> "Import:cPickle";
    "/test/test_nn.py" -> "Import:pickle";
    "/test/test_nn.py" -> "class:TestNNInit(TestCase):";
    "/test/test_nn.py" -> "class:FunctionalModule(nn.Module):";
    "/test/test_nn.py" -> "class:UnpoolingNet(nn.Module):";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:__init__";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:_ordered_sequence";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:_padded_sequence";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:test_type_casts";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:test_cuda_mask";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:default_tensor_type";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:decorator";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:wrapper";
    "class:PackedSequenceTest(TestCase):" -> "Fxn:_assertGradAndGradgradChecks";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:_ordered_sequence" -> "Fxn:[tensor_type(random.randint(1,";
    "Fxn:_ordered_sequence" -> "Fxn:[Variable(s.random_())";
    "Fxn:_padded_sequence" -> "Fxn:self._ordered_sequence(tensor_type)";
    "Fxn:_padded_sequence" -> "Fxn:rnn_utils.pad_sequence(ordered)";
    "Fxn:test_type_casts" -> "Fxn:self._type_by_name.items():";
    "Fxn:test_type_casts" -> "Fxn:self._type_by_name.items():";
    "Fxn:test_type_casts" -> "Fxn:self._padded_sequence(input_type)";
    "Fxn:test_type_casts" -> "Fxn:rnn_utils.pack_padded_sequence(padded,";
    "Fxn:test_type_casts" -> "Fxn:cast_str)()";
    "Fxn:test_type_casts" -> "Fxn:rnn_utils.pad_packed_sequence(masked)";
    "Fxn:test_type_casts" -> "Fxn:self.assertEqual(unpacked.type(),";
    "Fxn:test_type_casts" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cuda_mask" -> "Fxn:self._padded_sequence(tensor_type)";
    "Fxn:test_cuda_mask" -> "Fxn:rnn_utils.pack_padded_sequence(padded,";
    "Fxn:test_cuda_mask" -> "Fxn:self.assertFalse(packed.is_cuda)";
    "Fxn:test_cuda_mask" -> "Fxn:packed.cuda()";
    "Fxn:test_cuda_mask" -> "Fxn:self.assertTrue(packed.is_cuda)";
    "Fxn:test_cuda_mask" -> "Fxn:rnn_utils.pad_packed_sequence(packed)";
    "Fxn:test_cuda_mask" -> "Fxn:self.assertEqual(unpacked.type(),";
    "Fxn:default_tensor_type" -> "Fxn:torch.typename(type)";
    "Fxn:decorator" -> "Fxn:@wraps(fn)";
    "Fxn:wrapper" -> "Fxn:torch.Tensor().type()";
    "Fxn:wrapper" -> "Fxn:torch.set_default_tensor_type(type_str)";
    "Fxn:wrapper" -> "Fxn:fn(*args,";
    "Fxn:wrapper" -> "Fxn:torch.set_default_tensor_type(old_type)";
    "Fxn:_assertGradAndGradgradChecks" -> "Fxn:test_case.assertTrue(gradcheck(apply_fn,";
    "Fxn:_assertGradAndGradgradChecks" -> "Fxn:test_case.assertTrue(gradgradcheck(apply_fn,";
    "class:InputVariableMixin(object):" -> "Fxn:_get_input";
    "class:InputVariableMixin(object):" -> "Fxn:map_variables";
    "Fxn:_get_input" -> "Fxn:TestBase._get_input(self,";
    "Fxn:map_variables" -> "Fxn:i.is_floating_point():";
    "Fxn:map_variables" -> "Fxn:map_variables(input)";
    "class:NewModuleTest(InputVariableMixin," -> "Fxn:__init__";
    "class:NewModuleTest(InputVariableMixin," -> "Fxn:_do_test";
    "class:NewModuleTest(InputVariableMixin," -> "Fxn:_get_target";
    "class:NewModuleTest(InputVariableMixin," -> "Fxn:constructor_args";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__init__" -> "Fxn:kwargs.get('cudnn',";
    "Fxn:__init__" -> "Fxn:kwargs.get('check_inplace',";
    "Fxn:__init__" -> "Fxn:kwargs.get('check_gradgrad',";
    "Fxn:_do_test" -> "Fxn:test_case.check_jacobian(module,";
    "Fxn:_do_test" -> "Fxn:module.parameters())";
    "Fxn:_do_test" -> "Fxn:_assertGradAndGradgradChecks(test_case,";
    "Fxn:_do_test" -> "Fxn:test_case._forward(module,";
    "Fxn:_do_test" -> "Fxn:module.__repr__()";
    "Fxn:_do_test" -> "Fxn:self.constructor(*self.constructor_args,";
    "Fxn:_do_test" -> "Fxn:freeze_rng_state():";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(input._version,";
    "Fxn:_do_test" -> "Fxn:deepcopy(input)";
    "Fxn:_do_test" -> "Fxn:input_ip.clone()";
    "Fxn:_do_test" -> "Fxn:freeze_rng_state():";
    "Fxn:_do_test" -> "Fxn:module_ip(input_ip_clone)";
    "Fxn:_do_test" -> "Fxn:test_case.assertNotEqual(input_ip_clone._version,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(output,";
    "Fxn:_do_test" -> "Fxn:output.data.clone().normal_()";
    "Fxn:_do_test" -> "Fxn:input.grad.data.zero_()";
    "Fxn:_do_test" -> "Fxn:output.backward(grad)";
    "Fxn:_do_test" -> "Fxn:output_ip.backward(grad)";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(input.grad,";
    "Fxn:_do_test" -> "Fxn:cuda()";
    "Fxn:_do_test" -> "Fxn:input.cuda()";
    "Fxn:_do_test" -> "Fxn:module.float().cuda()";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:_do_test" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_do_test" -> "Fxn:input.cuda(1)";
    "Fxn:_do_test" -> "Fxn:module.cuda(1)";
    "Fxn:_do_test" -> "Fxn:torch.cuda.device(1):";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:_do_test" -> "Fxn:input.float()";
    "Fxn:_do_test" -> "Fxn:module.float()";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:input.double()";
    "Fxn:_do_test" -> "Fxn:module.double()";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:cuda()";
    "Fxn:_do_test" -> "Fxn:input.float().cuda()";
    "Fxn:_do_test" -> "Fxn:module.float().cuda()";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:_do_test" -> "Fxn:input.cpu()";
    "Fxn:_do_test" -> "Fxn:module.cpu()";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:input.cuda()";
    "Fxn:_do_test" -> "Fxn:module.cuda()";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:_do_test" -> "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:_do_test" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_do_test" -> "Fxn:input.cuda(1)";
    "Fxn:_do_test" -> "Fxn:module.cuda(1)";
    "Fxn:_do_test" -> "Fxn:torch.cuda.device(1):";
    "Fxn:_do_test" -> "Fxn:module(input)";
    "Fxn:_do_test" -> "Fxn:module.parameters():";
    "Fxn:_do_test" -> "Fxn:test_case.assertIsInstance(p,";
    "Fxn:_do_test" -> "Fxn:test_case.assertEqual(p.get_device(),";
    "Fxn:_get_target" -> "Fxn:self._get_arg('target',";
    "Fxn:constructor_args" -> "Fxn:self._get_arg('constructor_args',";
    "class:NewCriterionTest(InputVariableMixin," -> "Fxn:__init__";
    "class:NewCriterionTest(InputVariableMixin," -> "Fxn:_do_extra_tests";
    "class:NewCriterionTest(InputVariableMixin," -> "Fxn:apply_fn";
    "class:NewCriterionTest(InputVariableMixin," -> "Fxn:apply_fn";
    "class:NewCriterionTest(InputVariableMixin," -> "Fxn:_get_target";
    "class:NewCriterionTest(InputVariableMixin," -> "Fxn:constructor_args";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__init__" -> "Fxn:kwargs.get('check_gradgrad',";
    "Fxn:_do_extra_tests" -> "Fxn:test_case.assertFalse(target.requires_grad)";
    "Fxn:_do_extra_tests" -> "Fxn:module.parameters())";
    "Fxn:apply_fn" -> "Fxn:module(input,";
    "Fxn:apply_fn" -> "Fxn:module(input1,";
    "Fxn:apply_fn" -> "Fxn:gradcheck(apply_fn,";
    "Fxn:apply_fn" -> "Fxn:gradgradcheck(apply_fn,";
    "Fxn:_get_target" -> "Fxn:self._get_arg('target',";
    "Fxn:constructor_args" -> "Fxn:self._get_arg('constructor_args',";
    "class:TestNN(NNTestCase):" -> "Fxn:_forward";
    "class:TestNN(NNTestCase):" -> "Fxn:_backward";
    "class:TestNN(NNTestCase):" -> "Fxn:_forward_criterion";
    "class:TestNN(NNTestCase):" -> "Fxn:_backward_criterion";
    "class:TestNN(NNTestCase):" -> "Fxn:_zero_grad_parameters";
    "class:TestNN(NNTestCase):" -> "Fxn:_get_parameters";
    "class:TestNN(NNTestCase):" -> "Fxn:test_module_backcompat";
    "class:TestNN(NNTestCase):" -> "Fxn:test_hooks";
    "class:TestNN(NNTestCase):" -> "Fxn:fw_hook";
    "class:TestNN(NNTestCase):" -> "Fxn:bw_hook";
    "class:TestNN(NNTestCase):" -> "Fxn:test_hook_cpp";
    "class:TestNN(NNTestCase):" -> "Fxn:hook";
    "class:TestNN(NNTestCase):" -> "Fxn:test_hook_fail";
    "class:TestNN(NNTestCase):" -> "Fxn:fw_fail1";
    "class:TestNN(NNTestCase):" -> "Fxn:fw_fail2";
    "class:TestNN(NNTestCase):" -> "Fxn:bw_fail1";
    "class:TestNN(NNTestCase):" -> "Fxn:bw_fail2";
    "class:TestNN(NNTestCase):" -> "Fxn:test_hook_writeable";
    "class:TestNN(NNTestCase):" -> "Fxn:bw_hook";
    "class:TestNN(NNTestCase):" -> "Fxn:test_zero_grad";
    "class:TestNN(NNTestCase):" -> "Fxn:test_no_grad";
    "class:TestNN(NNTestCase):" -> "Fxn:_test_dropout";
    "class:TestNN(NNTestCase):" -> "Fxn:test_parameters";
    "class:TestNN(NNTestCase):" -> "Fxn:num_params";
    "Fxn:_forward" -> "Fxn:freeze_rng_state():";
    "Fxn:_forward" -> "Fxn:module(input)";
    "Fxn:_backward" -> "Fxn:output.backward(grad_output,";
    "Fxn:_forward_criterion" -> "Fxn:criterion(*args)";
    "Fxn:_forward_criterion" -> "Fxn:criterion(input,";
    "Fxn:_forward_criterion" -> "Fxn:output.item()";
    "Fxn:_backward_criterion" -> "Fxn:i.grad.data.zero_()";
    "Fxn:_backward_criterion" -> "Fxn:criterion(*args).backward()";
    "Fxn:_zero_grad_parameters" -> "Fxn:module.weight.grad.data.zero_()";
    "Fxn:_zero_grad_parameters" -> "Fxn:module.weight.grad.detach_()";
    "Fxn:_zero_grad_parameters" -> "Fxn:module.bias.grad.data.zero_()";
    "Fxn:_zero_grad_parameters" -> "Fxn:module.bias.grad.detach_()";
    "Fxn:_get_parameters" -> "Fxn:module.parameters():";
    "Fxn:_get_parameters" -> "Fxn:torch.zeros_like(p)";
    "Fxn:_get_parameters" -> "Fxn:params.append(p)";
    "Fxn:_get_parameters" -> "Fxn:d_params.append(p.grad)";
    "Fxn:test_module_backcompat" -> "Fxn:download_file('https://download.pytorch.org/test_data/linear.pt')";
    "Fxn:test_module_backcompat" -> "Fxn:warnings.catch_warnings():";
    "Fxn:test_module_backcompat" -> "Fxn:warnings.simplefilter('ignore',";
    "Fxn:test_module_backcompat" -> "Fxn:torch.load(path)";
    "Fxn:test_module_backcompat" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_module_backcompat" -> "Fxn:3).float())";
    "Fxn:test_module_backcompat" -> "Fxn:self.assertEqual(m(input).size(),";
    "Fxn:test_hooks" -> "Fxn:nn.Sigmoid()";
    "Fxn:test_hooks" -> "Fxn:Variable(torch.ones(5,";
    "Fxn:fw_hook" -> "Fxn:self.assertIsInstance(input,";
    "Fxn:fw_hook" -> "Fxn:self.assertIsInstance(output,";
    "Fxn:fw_hook" -> "Fxn:self.assertTrue(h_module";
    "Fxn:fw_hook" -> "Fxn:self.assertEqual(input[0].data,";
    "Fxn:fw_hook" -> "Fxn:torch.ones(5,";
    "Fxn:fw_hook" -> "Fxn:self.assertEqual(output.data,";
    "Fxn:fw_hook" -> "Fxn:torch.Tensor(5,";
    "Fxn:fw_hook" -> "Fxn:5).fill_(1";
    "Fxn:bw_hook" -> "Fxn:self.assertIsInstance(grad_input,";
    "Fxn:bw_hook" -> "Fxn:self.assertIsInstance(grad_output,";
    "Fxn:bw_hook" -> "Fxn:self.assertTrue(h_module";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(grad_output[0].data,";
    "Fxn:bw_hook" -> "Fxn:torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:module.register_forward_hook(lambda";
    "Fxn:bw_hook" -> "Fxn:fw_hook(1,";
    "Fxn:bw_hook" -> "Fxn:module(input)";
    "Fxn:bw_hook" -> "Fxn:module(input)";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:module.register_backward_hook(";
    "Fxn:bw_hook" -> "Fxn:bw_hook(1,";
    "Fxn:bw_hook" -> "Fxn:module(input)";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:output.backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:output.backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:module.register_forward_hook(lambda";
    "Fxn:bw_hook" -> "Fxn:fw_hook(2,";
    "Fxn:bw_hook" -> "Fxn:module(input)";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:module.register_backward_hook(lambda";
    "Fxn:bw_hook" -> "Fxn:bw_hook(2,";
    "Fxn:bw_hook" -> "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:test2_bwd.remove()";
    "Fxn:bw_hook" -> "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:test2_fwd.remove()";
    "Fxn:bw_hook" -> "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['forwards'],";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(counter['backwards'],";
    "Fxn:bw_hook" -> "Fxn:test_fwd.remove()";
    "Fxn:bw_hook" -> "Fxn:test_bwd.remove()";
    "Fxn:test_hook_cpp" -> "Fxn:nn.BatchNorm1d(5)";
    "Fxn:hook" -> "Fxn:self.assertEqual(len(grad_inputs),";
    "Fxn:hook" -> "Fxn:self.assertEqual(len(grad_outputs),";
    "Fxn:hook" -> "Fxn:self.assertEqual(module,";
    "Fxn:hook" -> "Fxn:bn.register_backward_hook(hook)";
    "Fxn:hook" -> "Fxn:bn(Variable(torch.randn(5,";
    "Fxn:hook" -> "Fxn:output.sum().backward()";
    "Fxn:test_hook_fail" -> "Fxn:nn.Sigmoid()";
    "Fxn:test_hook_fail" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:bw_fail2" -> "Fxn:module.register_forward_hook(fw_fail1):";
    "Fxn:bw_fail2" -> "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:bw_fail2" -> "Fxn:module(input)";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("fw_fail",";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("didn't";
    "Fxn:bw_fail2" -> "Fxn:module.register_forward_hook(fw_fail2):";
    "Fxn:bw_fail2" -> "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:bw_fail2" -> "Fxn:module(input)";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("fw_fail2",";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("didn't";
    "Fxn:bw_fail2" -> "Fxn:module.register_backward_hook(bw_fail1):";
    "Fxn:bw_fail2" -> "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:bw_fail2" -> "Fxn:module(input).sum().backward()";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("bw_fail",";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("got";
    "Fxn:bw_fail2" -> "Fxn:module.register_backward_hook(bw_fail2):";
    "Fxn:bw_fail2" -> "Fxn:self.assertRaises(RuntimeError)";
    "Fxn:bw_fail2" -> "Fxn:module(input).sum().backward()";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("bw_fail2",";
    "Fxn:bw_fail2" -> "Fxn:self.assertIn("got";
    "Fxn:test_hook_writeable" -> "Fxn:nn.Linear(5,";
    "Fxn:test_hook_writeable" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:bw_hook" -> "Fxn:self.assertIsInstance(grad,";
    "Fxn:bw_hook" -> "Fxn:self.assertIsInstance(grad,";
    "Fxn:bw_hook" -> "Fxn:module.register_backward_hook(bw_hook)";
    "Fxn:bw_hook" -> "Fxn:module(input).backward(torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:torch.ones(5,";
    "Fxn:bw_hook" -> "Fxn:5).mm(module.weight.data)";
    "Fxn:bw_hook" -> "Fxn:self.assertEqual(input.grad.data,";
    "Fxn:test_zero_grad" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_zero_grad" -> "Fxn:nn.Linear(5,";
    "Fxn:test_zero_grad" -> "Fxn:module.parameters():";
    "Fxn:test_zero_grad" -> "Fxn:module.zero_grad()";
    "Fxn:test_zero_grad" -> "Fxn:module.zero_grad()";
    "Fxn:test_zero_grad" -> "Fxn:self.assertIsNone(module.weight.grad)";
    "Fxn:test_zero_grad" -> "Fxn:module(i).sum().backward()";
    "Fxn:test_zero_grad" -> "Fxn:self.assertIsNotNone(module.weight.grad)";
    "Fxn:test_zero_grad" -> "Fxn:self.assertGreater(module.weight.grad.data.abs().sum(),";
    "Fxn:test_zero_grad" -> "Fxn:module.zero_grad()";
    "Fxn:test_zero_grad" -> "Fxn:self.assertEqual(module.weight.grad.data,";
    "Fxn:test_zero_grad" -> "Fxn:module.weight.data.clone().zero_())";
    "Fxn:test_zero_grad" -> "Fxn:module.zero_grad()";
    "Fxn:test_zero_grad" -> "Fxn:self.assertIsNotNone(module.weight.grad)";
    "Fxn:test_zero_grad" -> "Fxn:self.assertIsNone(module.bias.grad)";
    "Fxn:test_zero_grad" -> "Fxn:module(i).sum().backward()";
    "Fxn:test_zero_grad" -> "Fxn:self.assertIsNotNone(module.weight.grad)";
    "Fxn:test_zero_grad" -> "Fxn:self.assertIsNotNone(module.bias.grad)";
    "Fxn:test_zero_grad" -> "Fxn:self.assertGreater(module.weight.grad.data.abs().sum(),";
    "Fxn:test_zero_grad" -> "Fxn:self.assertGreater(module.bias.grad.data.abs().sum(),";
    "Fxn:test_zero_grad" -> "Fxn:module.zero_grad()";
    "Fxn:test_zero_grad" -> "Fxn:self.assertEqual(module.weight.grad.data,";
    "Fxn:test_zero_grad" -> "Fxn:module.weight.data.clone().zero_())";
    "Fxn:test_zero_grad" -> "Fxn:self.assertEqual(module.bias.grad.data,";
    "Fxn:test_zero_grad" -> "Fxn:module.bias.data.clone().zero_())";
    "Fxn:test_no_grad" -> "Fxn:nn.Conv2d(2,";
    "Fxn:test_no_grad" -> "Fxn:torch.randn(1,";
    "Fxn:test_no_grad" -> "Fxn:Variable(input)";
    "Fxn:test_no_grad" -> "Fxn:Variable(input.clone())";
    "Fxn:test_no_grad" -> "Fxn:module(x)";
    "Fxn:test_no_grad" -> "Fxn:self.assertTrue(output.requires_grad)";
    "Fxn:test_no_grad" -> "Fxn:output.backward(torch.ones(1,";
    "Fxn:test_no_grad" -> "Fxn:torch.no_grad():";
    "Fxn:test_no_grad" -> "Fxn:module(y)";
    "Fxn:test_no_grad" -> "Fxn:self.assertFalse(output2.requires_grad)";
    "Fxn:test_no_grad" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_no_grad" -> "Fxn:output2.backward(torch.ones(1,";
    "Fxn:_test_dropout" -> "Fxn:input.fill_(1";
    "Fxn:_test_dropout" -> "Fxn:cls(p)";
    "Fxn:_test_dropout" -> "Fxn:Variable(input,";
    "Fxn:_test_dropout" -> "Fxn:module(input_var)";
    "Fxn:_test_dropout" -> "Fxn:self.assertLess(abs(output.data.mean()";
    "Fxn:_test_dropout" -> "Fxn:output.backward(input)";
    "Fxn:_test_dropout" -> "Fxn:self.assertLess(abs(input_var.grad.data.mean()";
    "Fxn:_test_dropout" -> "Fxn:cls(p,";
    "Fxn:_test_dropout" -> "Fxn:Variable(input.clone(),";
    "Fxn:_test_dropout" -> "Fxn:module(input_var";
    "Fxn:_test_dropout" -> "Fxn:self.assertLess(abs(output.data.mean()";
    "Fxn:_test_dropout" -> "Fxn:output.backward(input)";
    "Fxn:_test_dropout" -> "Fxn:self.assertLess(abs(input_var.grad.data.mean()";
    "Fxn:_test_dropout" -> "Fxn:module.__repr__()";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:test_named_parameters";
    "class:Net(nn.Module):" -> "Fxn:num_params";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(3,";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:Net()";
    "Fxn:__init__" -> "Fxn:nn.Sequential(n,";
    "Fxn:__init__" -> "Fxn:self.assertEqual(num_params(l),";
    "Fxn:__init__" -> "Fxn:self.assertEqual(num_params(n),";
    "Fxn:__init__" -> "Fxn:self.assertEqual(num_params(s),";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:test_call_supports_python_dict_output";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(3,";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:Net()";
    "Fxn:__init__" -> "Fxn:nn.Sequential(n,";
    "Fxn:__init__" -> "Fxn:self.assertTrue(name";
    "Fxn:__init__" -> "Fxn:self.assertTrue(name";
    "Fxn:__init__" -> "Fxn:self.assertTrue(name";
    "Fxn:__init__" -> "Fxn:self.assertEqual(num_params(l),";
    "Fxn:__init__" -> "Fxn:self.assertEqual(num_params(n),";
    "Fxn:__init__" -> "Fxn:self.assertEqual(num_params(s),";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:hook";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_children";
    "class:Net(nn.Module):" -> "Fxn:test_dir";
    "class:Net(nn.Module):" -> "Fxn:test_dir_digit";
    "class:Net(nn.Module):" -> "Fxn:test_named_children";
    "class:Net(nn.Module):" -> "Fxn:test_modules";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:self.register_backward_hook(self.hook)";
    "Fxn:forward" -> "Fxn:self.l1(inputs).sum()}";
    "Fxn:forward" -> "Fxn:Net()";
    "Fxn:forward" -> "Fxn:net(Variable(torch.randn([5,";
    "Fxn:forward" -> "Fxn:model_output["output"].backward()";
    "Fxn:forward" -> "Fxn:self.assertTrue(net.check_backward_hook_flag)";
    "Fxn:test_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_children" -> "Fxn:nn.Sequential(l3,";
    "Fxn:test_children" -> "Fxn:nn.Sequential(l1,";
    "Fxn:test_children" -> "Fxn:self.assertEqual(list(s.children()),";
    "Fxn:test_dir" -> "Fxn:nn.Linear(2,";
    "Fxn:test_dir" -> "Fxn:nn.Linear(2,";
    "Fxn:test_dir" -> "Fxn:Parameter(torch.Tensor(2,";
    "Fxn:test_dir" -> "Fxn:linear.register_buffer('_test_buffer',";
    "Fxn:test_dir" -> "Fxn:torch.Tensor(2,";
    "Fxn:test_dir" -> "Fxn:self.assertIn('_test_submodule',";
    "Fxn:test_dir" -> "Fxn:self.assertIn('_test_parameter',";
    "Fxn:test_dir" -> "Fxn:self.assertIn('_test_buffer',";
    "Fxn:test_dir" -> "Fxn:self.assertTrue(hasattr(linear,";
    "Fxn:test_dir_digit" -> "Fxn:nn.Sequential(nn.Linear(2,";
    "Fxn:test_dir_digit" -> "Fxn:self.assertNotIn('0',";
    "Fxn:test_named_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_named_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_named_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_named_children" -> "Fxn:nn.Linear(2,";
    "Fxn:test_named_children" -> "Fxn:nn.Sequential(l3,";
    "Fxn:test_named_children" -> "Fxn:nn.Sequential()";
    "Fxn:test_named_children" -> "Fxn:s.add_module('layer1',";
    "Fxn:test_named_children" -> "Fxn:s.add_module('layer2',";
    "Fxn:test_named_children" -> "Fxn:s.add_module('layer3',";
    "Fxn:test_named_children" -> "Fxn:s.add_module('layer4',";
    "Fxn:test_named_children" -> "Fxn:s.add_module('subnet',";
    "Fxn:test_named_children" -> "Fxn:self.assertEqual(list(s.named_children()),";
    "Fxn:test_named_children" -> "Fxn:[('layer1',";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:test_named_modules";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Variable(torch.Tensor(3,";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:Net()";
    "Fxn:__init__" -> "Fxn:nn.Sequential(n,";
    "Fxn:__init__" -> "Fxn:self.assertEqual(list(s.modules()),";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:test_register_buffer_raises_error_if_attr_exists";
    "class:Net(nn.Module):" -> "Fxn:test_register_buffer_raises_error_if_not_tensor";
    "class:Net(nn.Module):" -> "Fxn:test_register_buffer_allows_overwriting_with_same_name";
    "class:Net(nn.Module):" -> "Fxn:test_register_parameter_raises_error_if_attr_exists";
    "class:Net(nn.Module):" -> "Fxn:test_register_parameter_allows_overwriting_with_same_name";
    "class:Net(nn.Module):" -> "Fxn:test_add_module_raises_error_if_attr_exists";
    "class:Net(nn.Module):" -> "Fxn:test_Sequential_getitem";
    "class:Net(nn.Module):" -> "Fxn:test_Sequential_setitem";
    "class:Net(nn.Module):" -> "Fxn:test_Sequential_setitem_named";
    "class:Net(nn.Module):" -> "Fxn:test_Sequential_delitem";
    "class:Net(nn.Module):" -> "Fxn:test_ModuleList";
    "class:Net(nn.Module):" -> "Fxn:check";
    "class:Net(nn.Module):" -> "Fxn:test_ParameterList";
    "class:Net(nn.Module):" -> "Fxn:make_param";
    "class:Net(nn.Module):" -> "Fxn:check";
    "class:Net(nn.Module):" -> "Fxn:test_add_module";
    "class:Net(nn.Module):" -> "Fxn:test_type";
    "class:Net(nn.Module):" -> "Fxn:test_non_leaf_parameters";
    "class:Net(nn.Module):" -> "Fxn:assign_weight";
    "class:Net(nn.Module):" -> "Fxn:test_clip_grad_norm";
    "class:Net(nn.Module):" -> "Fxn:compute_norm";
    "class:Net(nn.Module):" -> "Fxn:compare_scaling";
    "class:Net(nn.Module):" -> "Fxn:test_parameters_to_vector";
    "class:Net(nn.Module):" -> "Fxn:test_vector_to_parameters";
    "class:Net(nn.Module):" -> "Fxn:test_weight_norm";
    "class:Net(nn.Module):" -> "Fxn:test_weight_norm_pickle";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_sparse_basic";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_padding_idx";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_max_norm";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_max_norm_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_from_pretrained";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_functional";
    "class:Net(nn.Module):" -> "Fxn:_test_gumbel_softmax_st";
    "class:Net(nn.Module):" -> "Fxn:test_gumbel_softmax_st";
    "class:Net(nn.Module):" -> "Fxn:test_gumbel_softmax_st_cuda";
    "class:Net(nn.Module):" -> "Fxn:_test_EmbeddingBag";
    "class:Net(nn.Module):" -> "Fxn:_test_vs_Embedding";
    "class:Net(nn.Module):" -> "Fxn:test_pool3d_size_one_feature_dim";
    "class:Net(nn.Module):" -> "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_contig_wrong_stride_cudnn";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_bag";
    "class:Net(nn.Module):" -> "Fxn:test_embedding_bag_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_fractional_max_pool2d";
    "class:Net(nn.Module):" -> "Fxn:func";
    "class:Net(nn.Module):" -> "Fxn:test_Dropout";
    "class:Net(nn.Module):" -> "Fxn:test_Dropout2d";
    "class:Net(nn.Module):" -> "Fxn:test_Dropout3d";
    "class:Net(nn.Module):" -> "Fxn:test_AlphaDropout";
    "class:Net(nn.Module):" -> "Fxn:_test_InstanceNorm_general";
    "class:Net(nn.Module):" -> "Fxn:_test_InstanceNorm_cuda_half";
    "class:Net(nn.Module):" -> "Fxn:test_InstanceNorm1d_general";
    "class:Net(nn.Module):" -> "Fxn:test_InstanceNorm1d_general_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_InstanceNorm2d_general";
    "class:Net(nn.Module):" -> "Fxn:test_InstanceNorm2d_general_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_InstanceNorm3d_general";
    "class:Net(nn.Module):" -> "Fxn:test_InstanceNorm3d_general_cuda";
    "class:Net(nn.Module):" -> "Fxn:_test_LayerNorm_general";
    "class:Net(nn.Module):" -> "Fxn:_test_LayerNorm_cuda_half";
    "class:Net(nn.Module):" -> "Fxn:test_LayerNorm_general";
    "class:Net(nn.Module):" -> "Fxn:test_LayerNorm_general_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_pad";
    "class:Net(nn.Module):" -> "Fxn:test_pad_scalar_error";
    "class:Net(nn.Module):" -> "Fxn:test_normalize";
    "class:Net(nn.Module):" -> "Fxn:_test_maxpool_indices";
    "class:Net(nn.Module):" -> "Fxn:expected_indices";
    "class:Net(nn.Module):" -> "Fxn:expected_grad";
    "class:Net(nn.Module):" -> "Fxn:expected_output";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_naive_groups";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_naive_groups_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_batchnorm_eval";
    "class:Net(nn.Module):" -> "Fxn:test_batchnorm_eval_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_MaxPool1d_indices";
    "class:Net(nn.Module):" -> "Fxn:test_MaxPool1d_indices_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_MaxPool2d_indices";
    "class:Net(nn.Module):" -> "Fxn:test_MaxPool2d_indices_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_MaxPool3d_indices";
    "class:Net(nn.Module):" -> "Fxn:test_MaxPool3d_indices_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_AdaptiveMaxPool1d_indices";
    "class:Net(nn.Module):" -> "Fxn:test_AdaptiveMaxPool1d_indices_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_AdaptiveMaxPool2d_indices";
    "class:Net(nn.Module):" -> "Fxn:test_AdaptiveMaxPool2d_indices_cuda";
    "class:Net(nn.Module):" -> "Fxn:test_AdaptiveMaxPool3d_indices";
    "class:Net(nn.Module):" -> "Fxn:test_AdaptiveMaxPool3d_indices_cuda";
    "class:Net(nn.Module):" -> "Fxn:_test_scatter";
    "class:Net(nn.Module):" -> "Fxn:test_scatter_cpu";
    "class:Net(nn.Module):" -> "Fxn:test_scatter_gpu";
    "class:Net(nn.Module):" -> "Fxn:_test_gather";
    "class:Net(nn.Module):" -> "Fxn:test_gather_cpu";
    "class:Net(nn.Module):" -> "Fxn:test_gather_gpu";
    "class:Net(nn.Module):" -> "Fxn:_test_broadcast_double_backwards";
    "class:Net(nn.Module):" -> "Fxn:test_broadcast_double_backwards_gpu";
    "class:Net(nn.Module):" -> "Fxn:test_broadcast_not_requiring_grad";
    "class:Net(nn.Module):" -> "Fxn:test_replicate";
    "class:Net(nn.Module):" -> "Fxn:test_replicate_buffers";
    "class:Net(nn.Module):" -> "Fxn:test_parallel_apply";
    "class:Net(nn.Module):" -> "Fxn:test_data_parallel_multiple_input";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Variable(torch.Tensor(3,";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:nn.Sequential()";
    "Fxn:__init__" -> "Fxn:block.add_module('linear1',";
    "Fxn:__init__" -> "Fxn:block.add_module('linear2',";
    "Fxn:__init__" -> "Fxn:Net()";
    "Fxn:__init__" -> "Fxn:nn.Sequential(n,";
    "Fxn:__init__" -> "Fxn:self.assertEqual(list(s.named_modules()),";
    "Fxn:__init__" -> "Fxn:[('',";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:nn.Module()";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:m.register_buffer('attribute_name',";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:torch.rand(5))";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:m.register_parameter('attribute_name',";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:nn.Parameter())";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:m.register_buffer('attribute_name',";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:torch.rand(5))";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:m.add_module('attribute_name',";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:nn.Module())";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:m.register_buffer('attribute_name',";
    "Fxn:test_register_buffer_raises_error_if_attr_exists" -> "Fxn:torch.rand(5))";
    "Fxn:test_register_buffer_raises_error_if_not_tensor" -> "Fxn:nn.Module()";
    "Fxn:test_register_buffer_raises_error_if_not_tensor" -> "Fxn:self.assertRaises(TypeError):";
    "Fxn:test_register_buffer_raises_error_if_not_tensor" -> "Fxn:m.register_buffer('attribute_name',";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:nn.Module()";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:torch.rand(5)";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:m.register_buffer('buffer_name',";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:self.assertEqual(m.buffer_name,";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:m.register_buffer('buffer_name',";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:self.assertEqual(m.buffer_name,";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:m.register_buffer('buffer_name',";
    "Fxn:test_register_buffer_allows_overwriting_with_same_name" -> "Fxn:self.assertEqual(m.buffer_name,";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:nn.Module()";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:m.register_parameter('attribute_name',";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:nn.Parameter())";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:m.register_buffer('attribute_name',";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:torch.rand(5))";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:m.register_parameter('attribute_name',";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:nn.Parameter())";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:m.add_module('attribute_name',";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:nn.Module())";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:m.register_parameter('attribute_name',";
    "Fxn:test_register_parameter_raises_error_if_attr_exists" -> "Fxn:nn.Parameter())";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:nn.Module()";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:nn.Parameter(torch.rand(5))";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:nn.Parameter(param1.data";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:m.register_parameter('param_name',";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:self.assertEqual(m.param_name,";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:m.register_parameter('param_name',";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:self.assertEqual(m.param_name,";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:m.register_parameter('param_name',";
    "Fxn:test_register_parameter_allows_overwriting_with_same_name" -> "Fxn:self.assertEqual(m.param_name,";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:nn.Module()";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:m.add_module('attribute_name',";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:nn.Module())";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:m.register_buffer('attribute_name',";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:torch.rand(5))";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:m.add_module('attribute_name',";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:nn.Module())";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:m.register_parameter('attribute_name',";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:nn.Parameter())";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:self.assertRaises(KeyError):";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:m.add_module('attribute_name',";
    "Fxn:test_add_module_raises_error_if_attr_exists" -> "Fxn:nn.Module())";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Linear(10,";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Linear(20,";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Linear(30,";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Linear(40,";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Sequential(l1,";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertIs(n[0],";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertIs(n[1],";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertIs(n[2],";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertIs(n[3],";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertIs(n[torch.tensor(3,";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertEqual(n[1:],";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Sequential(l2,";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertEqual(n[3:],";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Sequential(l4))";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertEqual(n[:-1],";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Sequential(l1,";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertEqual(n[:-3],";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Sequential(l1))";
    "Fxn:test_Sequential_getitem" -> "Fxn:self.assertEqual(n[::-1],";
    "Fxn:test_Sequential_getitem" -> "Fxn:nn.Sequential(l4,";
    "Fxn:test_Sequential_setitem" -> "Fxn:nn.Linear(10,";
    "Fxn:test_Sequential_setitem" -> "Fxn:nn.Linear(20,";
    "Fxn:test_Sequential_setitem" -> "Fxn:nn.Linear(30,";
    "Fxn:test_Sequential_setitem" -> "Fxn:nn.Linear(40,";
    "Fxn:test_Sequential_setitem" -> "Fxn:nn.Sequential(l1,";
    "Fxn:test_Sequential_setitem" -> "Fxn:n[torch.tensor(1,";
    "Fxn:test_Sequential_setitem" -> "Fxn:self.assertIs(n[0],";
    "Fxn:test_Sequential_setitem" -> "Fxn:self.assertIs(n[1],";
    "Fxn:test_Sequential_setitem" -> "Fxn:self.assertIs(n[2],";
    "Fxn:test_Sequential_setitem_named" -> "Fxn:nn.Linear(10,";
    "Fxn:test_Sequential_setitem_named" -> "Fxn:nn.Linear(20,";
    "Fxn:test_Sequential_setitem_named" -> "Fxn:nn.Linear(30,";
    "Fxn:test_Sequential_setitem_named" -> "Fxn:nn.Linear(40,";
    "Fxn:test_Sequential_setitem_named" -> "Fxn:nn.Sequential(OrderedDict([";
    "Fxn:test_Sequential_setitem_named" -> "Fxn:self.assertEqual(n.linear1,";
    "Fxn:test_Sequential_setitem_named" -> "Fxn:self.assertEqual(n.linear3,";
    "Fxn:test_Sequential_delitem" -> "Fxn:nn.Linear(10,";
    "Fxn:test_Sequential_delitem" -> "Fxn:nn.Linear(20,";
    "Fxn:test_Sequential_delitem" -> "Fxn:nn.Linear(30,";
    "Fxn:test_Sequential_delitem" -> "Fxn:nn.Linear(40,";
    "Fxn:test_Sequential_delitem" -> "Fxn:nn.Sequential(l1,";
    "Fxn:test_Sequential_delitem" -> "Fxn:self.assertEqual(n,";
    "Fxn:test_Sequential_delitem" -> "Fxn:nn.Sequential(l1,";
    "Fxn:test_Sequential_delitem" -> "Fxn:self.assertEqual(n,";
    "Fxn:test_Sequential_delitem" -> "Fxn:nn.Sequential(l1,";
    "Fxn:test_ModuleList" -> "Fxn:[nn.ReLU(),";
    "Fxn:test_ModuleList" -> "Fxn:nn.Linear(5,";
    "Fxn:test_ModuleList" -> "Fxn:nn.ModuleList(modules)";
    "Fxn:check" -> "Fxn:self.assertEqual(len(module_list),";
    "Fxn:check" -> "Fxn:self.assertIs(m1,";
    "Fxn:check" -> "Fxn:module_list.children()):";
    "Fxn:check" -> "Fxn:self.assertIs(m1,";
    "Fxn:check" -> "Fxn:self.assertIs(module_list[i],";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:[nn.Conv2d(3,";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:modules.append(nn.Tanh())";
    "Fxn:check" -> "Fxn:module_list.append(modules[-1])";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:[nn.Linear(5,";
    "Fxn:check" -> "Fxn:nn.Sigmoid()]";
    "Fxn:check" -> "Fxn:modules.extend(next_modules)";
    "Fxn:check" -> "Fxn:module_list.extend(next_modules)";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:nn.Conv2d(5,";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:torch.tensor(2,";
    "Fxn:check" -> "Fxn:nn.Conv2d(5,";
    "Fxn:check" -> "Fxn:self.assertIs(module_list[idx],";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:self.assertEqual(module_list[1:],";
    "Fxn:check" -> "Fxn:nn.ModuleList(modules[1:]))";
    "Fxn:check" -> "Fxn:self.assertEqual(module_list[3:],";
    "Fxn:check" -> "Fxn:nn.ModuleList(modules[3:]))";
    "Fxn:check" -> "Fxn:self.assertEqual(module_list[:-1],";
    "Fxn:check" -> "Fxn:nn.ModuleList(modules[:-1]))";
    "Fxn:check" -> "Fxn:self.assertEqual(module_list[:-3],";
    "Fxn:check" -> "Fxn:nn.ModuleList(modules[:-3]))";
    "Fxn:check" -> "Fxn:self.assertEqual(module_list[::-1],";
    "Fxn:check" -> "Fxn:nn.ModuleList(modules[::-1]))";
    "Fxn:check" -> "Fxn:self.assertEqual(module_list,";
    "Fxn:check" -> "Fxn:nn.ModuleList(modules[:-1]))";
    "Fxn:check" -> "Fxn:self.assertEqual(module_list,";
    "Fxn:check" -> "Fxn:nn.ModuleList(modules[:-1][0::2]))";
    "Fxn:check" -> "Fxn:self.assertRaises(TypeError):";
    "Fxn:check" -> "Fxn:nn.ReLU()";
    "Fxn:check" -> "Fxn:self.assertRaises(TypeError):";
    "Fxn:check" -> "Fxn:module_list.extend(nn.ReLU())";
    "Fxn:check" -> "Fxn:nn.Linear(1,";
    "Fxn:check" -> "Fxn:nn.Linear(2,";
    "Fxn:check" -> "Fxn:nn.Linear(3,";
    "Fxn:check" -> "Fxn:nn.Linear(2,";
    "Fxn:check" -> "Fxn:nn.Sequential(l3,";
    "Fxn:check" -> "Fxn:nn.Sequential(";
    "Fxn:check" -> "Fxn:OrderedDict([";
    "Fxn:check" -> "Fxn:nn.ModuleList()";
    "Fxn:check" -> "Fxn:module_list.extend(s.modules())";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:make_param" -> "Fxn:Parameter(torch.randn(10,";
    "Fxn:make_param" -> "Fxn:[make_param(),";
    "Fxn:make_param" -> "Fxn:make_param()]";
    "Fxn:make_param" -> "Fxn:nn.ParameterList(parameters)";
    "Fxn:check" -> "Fxn:self.assertEqual(len(parameters),";
    "Fxn:check" -> "Fxn:self.assertIs(p1,";
    "Fxn:check" -> "Fxn:param_list.parameters()):";
    "Fxn:check" -> "Fxn:self.assertIs(p1,";
    "Fxn:check" -> "Fxn:self.assertIs(parameters[i],";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:[make_param()]";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:parameters.append(make_param())";
    "Fxn:check" -> "Fxn:param_list.append(parameters[-1])";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:[make_param(),";
    "Fxn:check" -> "Fxn:make_param()]";
    "Fxn:check" -> "Fxn:parameters.extend(next_params)";
    "Fxn:check" -> "Fxn:param_list.extend(next_params)";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:make_param()";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:torch.tensor(2,";
    "Fxn:check" -> "Fxn:make_param()";
    "Fxn:check" -> "Fxn:self.assertIs(param_list[idx],";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:check" -> "Fxn:self.assertEqual(param_list[1:],";
    "Fxn:check" -> "Fxn:nn.ParameterList(parameters[1:]))";
    "Fxn:check" -> "Fxn:self.assertEqual(param_list[3:],";
    "Fxn:check" -> "Fxn:nn.ParameterList(parameters[3:]))";
    "Fxn:check" -> "Fxn:self.assertEqual(param_list[:-1],";
    "Fxn:check" -> "Fxn:nn.ParameterList(parameters[:-1]))";
    "Fxn:check" -> "Fxn:self.assertEqual(param_list[:-3],";
    "Fxn:check" -> "Fxn:nn.ParameterList(parameters[:-3]))";
    "Fxn:check" -> "Fxn:self.assertEqual(param_list[::-1],";
    "Fxn:check" -> "Fxn:nn.ParameterList(parameters[::-1]))";
    "Fxn:check" -> "Fxn:self.assertRaises(TypeError):";
    "Fxn:check" -> "Fxn:make_param()";
    "Fxn:check" -> "Fxn:self.assertRaises(TypeError):";
    "Fxn:check" -> "Fxn:param_list.extend(make_param())";
    "Fxn:check" -> "Fxn:nn.Linear(1,";
    "Fxn:check" -> "Fxn:nn.Linear(2,";
    "Fxn:check" -> "Fxn:nn.Linear(3,";
    "Fxn:check" -> "Fxn:nn.Linear(2,";
    "Fxn:check" -> "Fxn:nn.Sequential(l3,";
    "Fxn:check" -> "Fxn:nn.Sequential(";
    "Fxn:check" -> "Fxn:OrderedDict([";
    "Fxn:check" -> "Fxn:nn.ParameterList()";
    "Fxn:check" -> "Fxn:param_list.extend(s.parameters())";
    "Fxn:check" -> "Fxn:check()";
    "Fxn:test_add_module" -> "Fxn:nn.Linear(10,";
    "Fxn:test_add_module" -> "Fxn:nn.Module()";
    "Fxn:test_add_module" -> "Fxn:net.add_module('empty',";
    "Fxn:test_add_module" -> "Fxn:self.assertEqual(net.l,";
    "Fxn:test_add_module" -> "Fxn:self.assertEqual(net.l2,";
    "Fxn:test_add_module" -> "Fxn:self.assertEqual(net.empty,";
    "Fxn:test_add_module" -> "Fxn:net.add_module('l3',";
    "Fxn:test_add_module" -> "Fxn:self.assertEqual(net.l3,";
    "Fxn:test_add_module" -> "Fxn:nn.Linear(20,";
    "Fxn:test_add_module" -> "Fxn:net.add_module('l',";
    "Fxn:test_add_module" -> "Fxn:self.assertEqual(net.l,";
    "Fxn:test_add_module" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_add_module" -> "Fxn:net.add_module('x',";
    "Fxn:test_type" -> "Fxn:nn.Linear(10,";
    "Fxn:test_type" -> "Fxn:nn.Module()";
    "Fxn:test_type" -> "Fxn:net.add_module('empty',";
    "Fxn:test_type" -> "Fxn:net.register_buffer('indices',";
    "Fxn:test_type" -> "Fxn:torch.LongTensor(1))";
    "Fxn:test_type" -> "Fxn:net.float()";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(net.indices,";
    "Fxn:test_type" -> "Fxn:net.double()";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(net.indices,";
    "Fxn:test_type" -> "Fxn:net.float().cuda()";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(net.indices,";
    "Fxn:test_type" -> "Fxn:net.type(torch.FloatTensor)";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:test_type" -> "Fxn:net.type(torch.DoubleTensor)";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:test_type" -> "Fxn:net.type(torch.cuda.FloatTensor)";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.weight.data,";
    "Fxn:test_type" -> "Fxn:self.assertIsInstance(l.bias.data,";
    "Fxn:test_non_leaf_parameters" -> "Fxn:nn.Linear(10,";
    "Fxn:test_non_leaf_parameters" -> "Fxn:nn.Linear(10,";
    "Fxn:assign_weight" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:assign_weight" -> "Fxn:Parameter(torch.randn(10,";
    "Fxn:test_clip_grad_norm" -> "Fxn:nn.Linear(10,";
    "Fxn:compute_norm" -> "Fxn:l.parameters():";
    "Fxn:compute_norm" -> "Fxn:p.grad.data.abs().pow(norm_type).sum()";
    "Fxn:compute_norm" -> "Fxn:l.parameters())";
    "Fxn:compare_scaling" -> "Fxn:[p.grad.data.div(g).view(-1)";
    "Fxn:compare_scaling" -> "Fxn:torch.cat(p_scale)";
    "Fxn:compare_scaling" -> "Fxn:self.assertEqual(scale.std(),";
    "Fxn:compare_scaling" -> "Fxn:torch.arange(1,";
    "Fxn:compare_scaling" -> "Fxn:101).view(10,";
    "Fxn:compare_scaling" -> "Fxn:torch.ones(10).div(1000)";
    "Fxn:compare_scaling" -> "Fxn:Variable(g.clone().view_as(p.data))";
    "Fxn:compare_scaling" -> "Fxn:compute_norm(norm_type)";
    "Fxn:compare_scaling" -> "Fxn:clip_grad_norm(l.parameters(),";
    "Fxn:compare_scaling" -> "Fxn:compute_norm(norm_type)";
    "Fxn:compare_scaling" -> "Fxn:self.assertEqual(norm,";
    "Fxn:compare_scaling" -> "Fxn:self.assertEqual(norm_after,";
    "Fxn:compare_scaling" -> "Fxn:self.assertLessEqual(norm_after,";
    "Fxn:compare_scaling" -> "Fxn:compare_scaling(grads)";
    "Fxn:compare_scaling" -> "Fxn:torch.rand(10,";
    "Fxn:compare_scaling" -> "Fxn:10).div(10000),";
    "Fxn:compare_scaling" -> "Fxn:torch.ones(10).div(500)";
    "Fxn:compare_scaling" -> "Fxn:p.grad.data.copy_(g)";
    "Fxn:compare_scaling" -> "Fxn:compute_norm(norm_type)";
    "Fxn:compare_scaling" -> "Fxn:clip_grad_norm(l.parameters(),";
    "Fxn:compare_scaling" -> "Fxn:compute_norm(norm_type)";
    "Fxn:compare_scaling" -> "Fxn:self.assertEqual(norm,";
    "Fxn:compare_scaling" -> "Fxn:self.assertEqual(norm_before,";
    "Fxn:compare_scaling" -> "Fxn:self.assertLessEqual(norm_after,";
    "Fxn:compare_scaling" -> "Fxn:compare_scaling(grads)";
    "Fxn:compare_scaling" -> "Fxn:self.assertEqual(scale,";
    "Fxn:test_parameters_to_vector" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_parameters_to_vector" -> "Fxn:nn.Linear(10,";
    "Fxn:test_parameters_to_vector" -> "Fxn:nn.Sequential(conv1,";
    "Fxn:test_parameters_to_vector" -> "Fxn:parameters_to_vector(model.parameters())";
    "Fxn:test_parameters_to_vector" -> "Fxn:self.assertEqual(vec.size(0),";
    "Fxn:test_vector_to_parameters" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_vector_to_parameters" -> "Fxn:nn.Linear(10,";
    "Fxn:test_vector_to_parameters" -> "Fxn:nn.Sequential(conv1,";
    "Fxn:test_vector_to_parameters" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:test_vector_to_parameters" -> "Fxn:vector_to_parameters(vec,";
    "Fxn:test_vector_to_parameters" -> "Fxn:model.parameters())";
    "Fxn:test_vector_to_parameters" -> "Fxn:self.assertTrue(torch.equal(sample.data,";
    "Fxn:test_weight_norm" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_weight_norm" -> "Fxn:nn.Linear(5,";
    "Fxn:test_weight_norm" -> "Fxn:torch.nn.utils.weight_norm(m)";
    "Fxn:test_weight_norm" -> "Fxn:self.assertEqual(m.weight_v.size(),";
    "Fxn:test_weight_norm" -> "Fxn:m.weight.size())";
    "Fxn:test_weight_norm" -> "Fxn:self.assertEqual(m.weight_g.size(),";
    "Fxn:test_weight_norm" -> "Fxn:self.assertEqual(m(input),";
    "Fxn:test_weight_norm" -> "Fxn:torch.nn.utils.remove_weight_norm(m)";
    "Fxn:test_weight_norm" -> "Fxn:self.assertFalse(hasattr(m,";
    "Fxn:test_weight_norm" -> "Fxn:self.assertFalse(hasattr(m,";
    "Fxn:test_weight_norm" -> "Fxn:self.assertEqual(m(input),";
    "Fxn:test_weight_norm" -> "Fxn:torch.nn.utils.weight_norm(m,";
    "Fxn:test_weight_norm" -> "Fxn:self.assertEqual(m.weight_v.size(),";
    "Fxn:test_weight_norm" -> "Fxn:m.weight.size())";
    "Fxn:test_weight_norm" -> "Fxn:self.assertEqual(m.weight_g.size(),";
    "Fxn:test_weight_norm" -> "Fxn:self.assertEqual(m(input),";
    "Fxn:test_weight_norm_pickle" -> "Fxn:torch.nn.utils.weight_norm(nn.Linear(5,";
    "Fxn:test_weight_norm_pickle" -> "Fxn:pickle.loads(pickle.dumps(m))";
    "Fxn:test_weight_norm_pickle" -> "Fxn:self.assertIsInstance(m,";
    "Fxn:test_embedding_sparse_basic" -> "Fxn:nn.Embedding(10,";
    "Fxn:test_embedding_sparse_basic" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:test_embedding_sparse_basic" -> "Fxn:embedding(input).sum().backward()";
    "Fxn:test_embedding_sparse_basic" -> "Fxn:self.assertTrue(embedding.weight.grad.is_sparse)";
    "Fxn:test_embedding_sparse_basic" -> "Fxn:self.assertEqual(embedding.weight.grad.shape,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:nn.Embedding(10,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:embedding(input)";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[0][0].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[1][2].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:nn.Embedding(10,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:embedding(input)";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[0][0].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[1][2].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:nn.Embedding(10,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:embedding(input)";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[0][2].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[1][1].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:nn.Embedding(10,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:Variable(torch.LongTensor([[0,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:embedding(input)";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[0][2].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertEqual(output[1][1].sum(),";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertRaises(AssertionError,";
    "Fxn:test_embedding_padding_idx" -> "Fxn:self.assertRaises(AssertionError,";
    "Fxn:test_embedding_max_norm" -> "Fxn:nn.Embedding(22,";
    "Fxn:test_embedding_max_norm" -> "Fxn:Variable(torch.LongTensor([2,";
    "Fxn:test_embedding_max_norm" -> "Fxn:embedding(input)";
    "Fxn:test_embedding_max_norm" -> "Fxn:self.assertEqual(output[1],";
    "Fxn:test_embedding_max_norm" -> "Fxn:self.assertTrue(output.data.norm(p=2,";
    "Fxn:test_embedding_max_norm" -> "Fxn:dim=1).le(1).all())";
    "Fxn:test_embedding_max_norm" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:nn.Embedding(22,";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:max_norm=1.0).cuda()";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:Variable(torch.LongTensor([2,";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:6])).cuda()";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:embedding(input)";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:self.assertEqual(output[1],";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:self.assertTrue(output.data.norm(p=2,";
    "Fxn:test_embedding_max_norm_cuda" -> "Fxn:dim=1).le(1).all())";
    "Fxn:test_embedding_from_pretrained" -> "Fxn:torch.Tensor([[1,";
    "Fxn:test_embedding_from_pretrained" -> "Fxn:nn.Embedding.from_pretrained(a)";
    "Fxn:test_embedding_from_pretrained" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_embedding_from_pretrained" -> "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:test_embedding_from_pretrained" -> "Fxn:embedding(input)";
    "Fxn:test_embedding_from_pretrained" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_embedding_functional" -> "Fxn:Variable(torch.LongTensor([";
    "Fxn:test_embedding_functional" -> "Fxn:Variable(torch.rand(4,";
    "Fxn:test_embedding_functional" -> "Fxn:torch.nn.Embedding(4,";
    "Fxn:test_embedding_functional" -> "Fxn:embed_old(a)";
    "Fxn:test_embedding_functional" -> "Fxn:F.embedding(a,";
    "Fxn:test_embedding_functional" -> "Fxn:self.assertEqual(res_old,";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:torch.FloatTensor([[0.2,";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:torch.nn.functional.softmax(Variable(logits),";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:torch.zeros(num_draws,";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:torch.zeros(num_draws)";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:logits.cuda()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:y_draws.cuda()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:preds.cuda()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:Variable(logits,";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:torch.nn.functional.gumbel_softmax(";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:y_draw.size()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:logits.size()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:Variable(logits.new([[0,";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:err).sum()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:loss.backward()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:logits_var.grad.data.std()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:logits_var.grad.data.std()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:y_draw.max(1)";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:1).int().sum()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:0).int().sum()";
    "Fxn:_test_gumbel_softmax_st" -> "Fxn:1).int().sum()";
    "Fxn:test_gumbel_softmax_st" -> "Fxn:self._test_gumbel_softmax_st(False)";
    "Fxn:test_gumbel_softmax_st" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gumbel_softmax_st_cuda" -> "Fxn:self._test_gumbel_softmax_st(True)";
    "Fxn:_test_EmbeddingBag" -> "Fxn:nn.EmbeddingBag(5,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:es.weight.data.copy_(torch.arange(1,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:11).resize_as_(es.weight.data))";
    "Fxn:_test_EmbeddingBag" -> "Fxn:Variable(torch.LongTensor([3,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:Variable(torch.LongTensor([0,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:torch.arange(1,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:5).view(2,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:2).type(torch.Tensor)";
    "Fxn:_test_EmbeddingBag" -> "Fxn:torch.Tensor(";
    "Fxn:_test_EmbeddingBag" -> "Fxn:torch.Tensor(";
    "Fxn:_test_EmbeddingBag" -> "Fxn:torch.Tensor(";
    "Fxn:_test_EmbeddingBag" -> "Fxn:torch.Tensor(";
    "Fxn:_test_EmbeddingBag" -> "Fxn:es.cuda()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:input.cuda()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:offsets.cuda()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:grad_output.cuda()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:expected_output.cuda()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:expected_grad_weight.cuda()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:es(input,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:output.backward(grad_output)";
    "Fxn:_test_EmbeddingBag" -> "Fxn:es.weight.grad.data.to_dense()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:self.assertEqual(output.data,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:self.assertEqual(es_weight_grad,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:Variable(input.data.view(2,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:es.zero_grad()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:es(input)";
    "Fxn:_test_EmbeddingBag" -> "Fxn:output.backward(grad_output)";
    "Fxn:_test_EmbeddingBag" -> "Fxn:es.weight.grad.data.to_dense()";
    "Fxn:_test_EmbeddingBag" -> "Fxn:self.assertEqual(output.data,";
    "Fxn:_test_EmbeddingBag" -> "Fxn:self.assertEqual(es_weight_grad,";
    "Fxn:_test_vs_Embedding" -> "Fxn:nn.EmbeddingBag(N,";
    "Fxn:_test_vs_Embedding" -> "Fxn:nn.Embedding(N,";
    "Fxn:_test_vs_Embedding" -> "Fxn:e.weight.data.copy_(es.weight.data)";
    "Fxn:_test_vs_Embedding" -> "Fxn:Variable(torch.rand(B,";
    "Fxn:_test_vs_Embedding" -> "Fxn:L).mul(N).long())";
    "Fxn:_test_vs_Embedding" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:_test_vs_Embedding" -> "Fxn:B).mul(L).long())";
    "Fxn:_test_vs_Embedding" -> "Fxn:torch.rand(B,";
    "Fxn:_test_vs_Embedding" -> "Fxn:D).type(torch.Tensor)";
    "Fxn:_test_vs_Embedding" -> "Fxn:es.cuda()";
    "Fxn:_test_vs_Embedding" -> "Fxn:e.cuda()";
    "Fxn:_test_vs_Embedding" -> "Fxn:input.cuda()";
    "Fxn:_test_vs_Embedding" -> "Fxn:offsets.cuda()";
    "Fxn:_test_vs_Embedding" -> "Fxn:grad_output.cuda()";
    "Fxn:_test_vs_Embedding" -> "Fxn:es(input.view(-1),";
    "Fxn:_test_vs_Embedding" -> "Fxn:e(input).sum(1)";
    "Fxn:_test_vs_Embedding" -> "Fxn:e(input).mean(1)";
    "Fxn:_test_vs_Embedding" -> "Fxn:self.assertEqual(output,";
    "Fxn:_test_vs_Embedding" -> "Fxn:output.backward(grad_output)";
    "Fxn:_test_vs_Embedding" -> "Fxn:ref_output.backward(grad_output)";
    "Fxn:_test_vs_Embedding" -> "Fxn:es.weight.grad.data.to_dense()";
    "Fxn:_test_vs_Embedding" -> "Fxn:self.assertEqual(es_weight_grad,";
    "Fxn:_test_vs_Embedding" -> "Fxn:random.randint(1,";
    "Fxn:_test_vs_Embedding" -> "Fxn:random.randint(1,";
    "Fxn:_test_vs_Embedding" -> "Fxn:random.randint(1,";
    "Fxn:_test_vs_Embedding" -> "Fxn:random.randint(1,";
    "Fxn:_test_vs_Embedding" -> "Fxn:_test_vs_Embedding(N,";
    "Fxn:_test_vs_Embedding" -> "Fxn:itertools.product([1,";
    "Fxn:_test_vs_Embedding" -> "Fxn:_test_vs_Embedding(*p)";
    "Fxn:_test_vs_Embedding" -> "Fxn:nn.EmbeddingBag(10,";
    "Fxn:_test_vs_Embedding" -> "Fxn:Variable(torch.ones(3,";
    "Fxn:_test_vs_Embedding" -> "Fxn:Variable(torch.arange(0,";
    "Fxn:_test_vs_Embedding" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:_test_vs_Embedding" -> "Fxn:es(input,";
    "Fxn:_test_vs_Embedding" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:_test_vs_Embedding" -> "Fxn:es(input.view(-1)))";
    "Fxn:_test_vs_Embedding" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:_test_vs_Embedding" -> "Fxn:es(input.view(-1),";
    "Fxn:_test_vs_Embedding" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:_test_vs_Embedding" -> "Fxn:es(input.view(-1),";
    "Fxn:_test_vs_Embedding" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:Variable(torch.randn(7,";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:2).cuda())";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:x.as_strided(x.size(),";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:x.cpu().as_strided(x.size(),";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:F.max_pool3d(t,";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:stride=(5,";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:F.avg_pool3d(t,";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:stride=(5,";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:to_test.items():";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:fn(y)";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:fn(x)";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:self.assertEqual(out_y,";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:out_x.cuda(),";
    "Fxn:test_pool3d_size_one_feature_dim" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:4).cuda(),";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:F.avg_pool3d(x,";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:torch.randn(y.size()).cuda()";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:grad.set_(grad.storage(),";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:grad.size(),";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:grad.is_contiguous()";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:y.backward(grad)";
    "Fxn:test_AvgPool3d_backward_after_cat_dim1_cuda" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:torch.randn(1,";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:5).cuda()";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:x.set_(x.storage(),";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:x.size(),";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:self.assertTrue(x.is_contiguous())";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:F.conv_transpose2d(Variable(x),";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:Variable(torch.randn(16,";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:1)).cuda())";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:F.conv2d(Variable(x),";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_contig_wrong_stride_cudnn" -> "Fxn:1)).cuda())";
    "Fxn:test_embedding_bag" -> "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:test_embedding_bag" -> "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:test_embedding_bag" -> "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:test_embedding_bag" -> "Fxn:self._test_EmbeddingBag(False,";
    "Fxn:test_embedding_bag" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_embedding_bag_cuda" -> "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:test_embedding_bag_cuda" -> "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:test_embedding_bag_cuda" -> "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:test_embedding_bag_cuda" -> "Fxn:self._test_EmbeddingBag(True,";
    "Fxn:test_fractional_max_pool2d" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_fractional_max_pool2d" -> "Fxn:x.new(1,";
    "Fxn:test_fractional_max_pool2d" -> "Fxn:2).uniform_()";
    "Fxn:func" -> "Fxn:F.fractional_max_pool2d(";
    "Fxn:func" -> "Fxn:output_size=(3,";
    "Fxn:func" -> "Fxn:self.assertEqual(func(x).shape,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:func" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:func" -> "Fxn:x.new(2,";
    "Fxn:func" -> "Fxn:2).uniform_()";
    "Fxn:func" -> "Fxn:self.assertEqual(func(x).shape,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_Dropout" -> "Fxn:torch.Tensor(1000)";
    "Fxn:test_Dropout" -> "Fxn:self._test_dropout(nn.Dropout,";
    "Fxn:test_Dropout2d" -> "Fxn:random.randint(1,";
    "Fxn:test_Dropout2d" -> "Fxn:random.randint(1,";
    "Fxn:test_Dropout2d" -> "Fxn:random.randint(1,";
    "Fxn:test_Dropout2d" -> "Fxn:torch.Tensor(num_features,";
    "Fxn:test_Dropout2d" -> "Fxn:self._test_dropout(nn.Dropout2d,";
    "Fxn:test_Dropout3d" -> "Fxn:random.randint(1,";
    "Fxn:test_Dropout3d" -> "Fxn:random.randint(1,";
    "Fxn:test_Dropout3d" -> "Fxn:random.randint(1,";
    "Fxn:test_Dropout3d" -> "Fxn:random.randint(1,";
    "Fxn:test_Dropout3d" -> "Fxn:torch.Tensor(num_features,";
    "Fxn:test_Dropout3d" -> "Fxn:self._test_dropout(nn.Dropout3d,";
    "Fxn:test_AlphaDropout" -> "Fxn:torch.randn(5000)";
    "Fxn:test_AlphaDropout" -> "Fxn:input.mean()";
    "Fxn:test_AlphaDropout" -> "Fxn:input.std()";
    "Fxn:test_AlphaDropout" -> "Fxn:nn.AlphaDropout(p)";
    "Fxn:test_AlphaDropout" -> "Fxn:Variable(input,";
    "Fxn:test_AlphaDropout" -> "Fxn:module(input_var)";
    "Fxn:test_AlphaDropout" -> "Fxn:self.assertLess(abs(output.data.mean()";
    "Fxn:test_AlphaDropout" -> "Fxn:self.assertLess(abs(output.data.std()";
    "Fxn:test_AlphaDropout" -> "Fxn:output.backward(input)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input.size(0),";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input.size(1)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:Variable(input.type(type),";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:cls(c,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:eps=0).type(type)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN(input_var)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:output.view(b";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:out_reshaped.mean(1)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:out_reshaped.var(1,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(mean.data).mean(),";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(var.data).mean(),";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:output.data.clone().normal_()";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:output.data.clone()";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:output.backward(grad_out)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input_var.grad.data.clone()";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN.eval()";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN(input_var)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:output.backward(grad_out)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:self.assertEqual(grad1,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:cls(c,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:track_running_stats=True).type(type)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN(input_var.type(type))";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input_var.transpose(1,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:0).contiguous().view(c,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input_reshaped.mean(1)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input_var.transpose(1,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:0).contiguous().view(c,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input_reshaped.var(2,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(mean.data";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN.running_mean).mean(),";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(var.data.mean(1)";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN.running_var).mean(),";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN.eval()";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:torch.arange(c).type(type)).view(-1,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:input.dim())])";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:IN(input_var";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:Variable(delta))";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:self.assertEqual(output.transpose(0,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:1).contiguous().view(c,";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:-1).mean(1),";
    "Fxn:_test_InstanceNorm_general" -> "Fxn:torch.arange(c))";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:Variable(input.cuda().half().random_(1,";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:cls(input.size(1),";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:track_running_stats=True).cuda().half()";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:thnn_output.sum().backward()";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:input.grad.data.clone()";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:self.assertEqual(thnn_output.type(),";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:input.type())";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:m.float()";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:cudnn_output.sum().backward()";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:input.grad.data.clone()";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:self.assertEqual(cudnn_output.type(),";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:input.type())";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:self.assertAlmostEqual(cudnn_output,";
    "Fxn:_test_InstanceNorm_cuda_half" -> "Fxn:self.assertAlmostEqual(cudnn_input_grad,";
    "Fxn:test_InstanceNorm1d_general" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm1d_general" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm1d_general" -> "Fxn:random.randint(8,";
    "Fxn:test_InstanceNorm1d_general" -> "Fxn:torch.Tensor(b,";
    "Fxn:test_InstanceNorm1d_general" -> "Fxn:d).uniform_()";
    "Fxn:test_InstanceNorm1d_general" -> "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm1d,";
    "Fxn:test_InstanceNorm1d_general" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_InstanceNorm1d_general_cuda" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm1d_general_cuda" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm1d_general_cuda" -> "Fxn:random.randint(8,";
    "Fxn:test_InstanceNorm1d_general_cuda" -> "Fxn:torch.Tensor(b,";
    "Fxn:test_InstanceNorm1d_general_cuda" -> "Fxn:d).uniform_()";
    "Fxn:test_InstanceNorm1d_general_cuda" -> "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm1d,";
    "Fxn:test_InstanceNorm1d_general_cuda" -> "Fxn:self._test_InstanceNorm_cuda_half(nn.InstanceNorm1d,";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:random.randint(6,";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:torch.Tensor(b,";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:w).uniform_()";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm2d,";
    "Fxn:test_InstanceNorm2d_general" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:random.randint(6,";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:torch.Tensor(b,";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:w).uniform_()";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm2d,";
    "Fxn:test_InstanceNorm2d_general_cuda" -> "Fxn:self._test_InstanceNorm_cuda_half(nn.InstanceNorm2d,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:random.randint(2,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:random.randint(2,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:random.randint(2,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:torch.Tensor(b,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:d).uniform_()";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm3d,";
    "Fxn:test_InstanceNorm3d_general" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:random.randint(3,";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:random.randint(2,";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:random.randint(2,";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:random.randint(2,";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:random.randint(2,";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:torch.Tensor(b,";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:d).uniform_()";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:self._test_InstanceNorm_general(nn.InstanceNorm3d,";
    "Fxn:test_InstanceNorm3d_general_cuda" -> "Fxn:self._test_InstanceNorm_cuda_half(nn.InstanceNorm3d,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:torch.LongTensor(i).random_(3,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:6).tolist()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:Variable(type(*shape).uniform_(0,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:random.randint(1,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:nn.LayerNorm(normalized_shape,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:eps=0).type(type)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.weight.data.fill_(1)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.bias.data.fill_(0)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln(x)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:output.view(*(unnormalized_shape";
    "Fxn:_test_LayerNorm_general" -> "Fxn:out_reshaped.mean(-1)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:out_reshaped.var(-1,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(mean.data).mean(),";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(var.data).mean(),";
    "Fxn:_test_LayerNorm_general" -> "Fxn:torch.FloatTensor(2).uniform_(0.2,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:2).tolist()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.weight.data.fill_(scale)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.bias.data.fill_(bias)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln(x)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:output.view(*(unnormalized_shape";
    "Fxn:_test_LayerNorm_general" -> "Fxn:out_reshaped.mean(-1)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:out_reshaped.var(-1,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(mean.data).mean(),";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(var.data).mean(),";
    "Fxn:_test_LayerNorm_general" -> "Fxn:nn.LayerNorm(normalized_shape,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:track_running_stats=True).type(type)";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln(x).data.clone()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:x.view(*(unnormalized_shape";
    "Fxn:_test_LayerNorm_general" -> "Fxn:input_reshaped.mean(-1).mean()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:input_reshaped.var(-1,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:unbiased=True).mean()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(mean.data";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.running_mean).mean(),";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertAlmostEqual(torch.abs(var.data";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.running_var).mean(),";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.eval()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.running_mean.clone()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.running_var.clone()";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln(x";
    "Fxn:_test_LayerNorm_general" -> "Fxn:ln.running_var.sqrt()[0]";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertAlmostEqual((output_new";
    "Fxn:_test_LayerNorm_general" -> "Fxn:output_ref).mean(),";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertEqual(old_running_mean,";
    "Fxn:_test_LayerNorm_general" -> "Fxn:self.assertEqual(old_running_var,";
    "Fxn:_test_LayerNorm_cuda_half" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:_test_LayerNorm_cuda_half" -> "Fxn:2).cuda().half().random_(1,";
    "Fxn:_test_LayerNorm_cuda_half" -> "Fxn:nn.LayerNorm([3,";
    "Fxn:_test_LayerNorm_cuda_half" -> "Fxn:2]).cuda().half()";
    "Fxn:_test_LayerNorm_cuda_half" -> "Fxn:output.sum().backward()";
    "Fxn:_test_LayerNorm_cuda_half" -> "Fxn:self.assertEqual(output.type(),";
    "Fxn:_test_LayerNorm_cuda_half" -> "Fxn:input.type())";
    "Fxn:test_LayerNorm_general" -> "Fxn:self._test_LayerNorm_general(torch.FloatTensor)";
    "Fxn:test_LayerNorm_general" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_LayerNorm_general_cuda" -> "Fxn:self._test_LayerNorm_general(torch.cuda.FloatTensor)";
    "Fxn:test_LayerNorm_general_cuda" -> "Fxn:self._test_LayerNorm_cuda_half()";
    "Fxn:test_pad" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_pad" -> "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:test_pad" -> "Fxn:F.pad(x,";
    "Fxn:test_pad" -> "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:test_pad" -> "Fxn:F.pad(x,";
    "Fxn:test_pad" -> "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:test_pad" -> "Fxn:F.pad(x,";
    "Fxn:test_pad" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_pad" -> "Fxn:F.pad(x,";
    "Fxn:test_pad" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_pad" -> "Fxn:F.pad(x,";
    "Fxn:test_pad" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_pad" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_pad" -> "Fxn:F.pad(x,";
    "Fxn:test_pad_scalar_error" -> "Fxn:torch.tensor(0,";
    "Fxn:test_pad_scalar_error" -> "Fxn:self.assertRaises(AssertionError,";
    "Fxn:test_pad_scalar_error" -> "Fxn:F.pad(inputs,";
    "Fxn:test_pad_scalar_error" -> "Fxn:self.assertRaises(AssertionError,";
    "Fxn:test_pad_scalar_error" -> "Fxn:F.pad(inputs,";
    "Fxn:test_normalize" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_normalize" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_normalize" -> "Fxn:F.normalize(x,";
    "Fxn:test_normalize" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_normalize" -> "Fxn:F.normalize(x,";
    "Fxn:test_normalize" -> "Fxn:torch.randn((),";
    "Fxn:test_normalize" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_normalize" -> "Fxn:F.normalize(x,";
    "Fxn:expected_indices" -> "Fxn:torch.DoubleTensor([1,";
    "Fxn:expected_indices" -> "Fxn:3]).repeat(2,";
    "Fxn:expected_indices" -> "Fxn:torch.DoubleTensor([[5,";
    "Fxn:expected_indices" -> "Fxn:15]]).repeat(2,";
    "Fxn:expected_grad" -> "Fxn:torch.DoubleTensor([0,";
    "Fxn:expected_grad" -> "Fxn:1]).repeat(2,";
    "Fxn:expected_grad" -> "Fxn:expected_grad(dim";
    "Fxn:expected_grad" -> "Fxn:torch.zeros(grad.size())";
    "Fxn:expected_grad" -> "Fxn:torch.stack((zero,";
    "Fxn:expected_output" -> "Fxn:torch.arange(2,";
    "Fxn:expected_output" -> "Fxn:2).view(2,";
    "Fxn:expected_output" -> "Fxn:torch.arange(6,";
    "Fxn:expected_output" -> "Fxn:torch.stack([col,";
    "Fxn:expected_output" -> "Fxn:1).view(2,";
    "Fxn:expected_output" -> "Fxn:'AdaptiveMaxPool{}d'.format(num_dim)";
    "Fxn:expected_output" -> "Fxn:'MaxPool{}d'.format(num_dim)";
    "Fxn:expected_output" -> "Fxn:module_cls(2,";
    "Fxn:expected_output" -> "Fxn:return_indices=True).type(type)";
    "Fxn:expected_output" -> "Fxn:torch.arange(1,";
    "Fxn:expected_output" -> "Fxn:1).view(2,";
    "Fxn:expected_output" -> "Fxn:*repeat(4,";
    "Fxn:expected_output" -> "Fxn:num_dim)).type(type)";
    "Fxn:expected_output" -> "Fxn:Variable(input,";
    "Fxn:expected_output" -> "Fxn:module(input_var)";
    "Fxn:expected_output" -> "Fxn:expected_indices(num_dim)";
    "Fxn:expected_output" -> "Fxn:expected_output(num_dim)";
    "Fxn:expected_output" -> "Fxn:self.assertEqual(indices.dim(),";
    "Fxn:expected_output" -> "Fxn:input.dim())";
    "Fxn:expected_output" -> "Fxn:self.assertEqual(indices.data.squeeze(),";
    "Fxn:expected_output" -> "Fxn:self.assertEqual(output.data.squeeze(),";
    "Fxn:expected_output" -> "Fxn:self.assertTrue(output.requires_grad)";
    "Fxn:expected_output" -> "Fxn:self.assertFalse(indices.requires_grad)";
    "Fxn:expected_output" -> "Fxn:torch.ones(output.size()).type(type)";
    "Fxn:expected_output" -> "Fxn:output.backward(grad_output,";
    "Fxn:expected_output" -> "Fxn:expected_grad(num_dim)";
    "Fxn:expected_output" -> "Fxn:self.assertEqual(input_var.grad.data,";
    "Fxn:expected_output" -> "Fxn:expected_grad.view_as(input))";
    "Fxn:expected_output" -> "Fxn:indices.add_(1)";
    "Fxn:expected_output" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:expected_output" -> "Fxn:output.backward(grad_output))";
    "Fxn:test_Conv2d_naive_groups" -> "Fxn:self._test_Conv2d_naive_groups()";
    "Fxn:test_Conv2d_naive_groups" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_naive_groups_cuda" -> "Fxn:self._test_Conv2d_naive_groups(torch.cuda.FloatTensor)";
    "Fxn:test_batchnorm_eval" -> "Fxn:self._test_batchnorm_eval()";
    "Fxn:test_batchnorm_eval" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_batchnorm_eval_cuda" -> "Fxn:self._test_batchnorm_eval(torch.cuda.FloatTensor)";
    "Fxn:test_MaxPool1d_indices" -> "Fxn:self._test_maxpool_indices(1)";
    "Fxn:test_MaxPool1d_indices" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_MaxPool1d_indices_cuda" -> "Fxn:self._test_maxpool_indices(1,";
    "Fxn:test_MaxPool2d_indices" -> "Fxn:self._test_maxpool_indices(2)";
    "Fxn:test_MaxPool2d_indices" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_MaxPool2d_indices_cuda" -> "Fxn:self._test_maxpool_indices(2,";
    "Fxn:test_MaxPool3d_indices" -> "Fxn:self._test_maxpool_indices(3)";
    "Fxn:test_MaxPool3d_indices" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_MaxPool3d_indices_cuda" -> "Fxn:self._test_maxpool_indices(3,";
    "Fxn:test_AdaptiveMaxPool1d_indices" -> "Fxn:self._test_maxpool_indices(1,";
    "Fxn:test_AdaptiveMaxPool1d_indices" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_AdaptiveMaxPool1d_indices_cuda" -> "Fxn:self._test_maxpool_indices(1,";
    "Fxn:test_AdaptiveMaxPool2d_indices" -> "Fxn:self._test_maxpool_indices(2,";
    "Fxn:test_AdaptiveMaxPool2d_indices" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_AdaptiveMaxPool2d_indices_cuda" -> "Fxn:self._test_maxpool_indices(2,";
    "Fxn:test_AdaptiveMaxPool3d_indices" -> "Fxn:self._test_maxpool_indices(3,";
    "Fxn:test_AdaptiveMaxPool3d_indices" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_AdaptiveMaxPool3d_indices_cuda" -> "Fxn:self._test_maxpool_indices(3,";
    "Fxn:_test_scatter" -> "Fxn:Variable(tensor,";
    "Fxn:_test_scatter" -> "Fxn:dp.scatter(x,";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(len(result),";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(result[0],";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(result[0].get_device(),";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(result[1],";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(result[1].get_device(),";
    "Fxn:_test_scatter" -> "Fxn:result[0].data.clone().fill_(2)";
    "Fxn:_test_scatter" -> "Fxn:result[0].backward(grad)";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(x.grad.data[:2],";
    "Fxn:_test_scatter" -> "Fxn:self.assertEqual(x.grad.data[2:],";
    "Fxn:_test_scatter" -> "Fxn:grad.clone().zero_())";
    "Fxn:_test_scatter" -> "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:_test_scatter" -> "Fxn:dp.scatter(y,";
    "Fxn:_test_scatter" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_scatter_cpu" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_cpu" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_scatter_gpu" -> "Fxn:self._test_scatter(torch.randn(4,";
    "Fxn:test_scatter_gpu" -> "Fxn:4).cuda())";
    "Fxn:_test_gather" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:_test_gather" -> "Fxn:4).cuda(0),";
    "Fxn:_test_gather" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:_test_gather" -> "Fxn:4).cuda(1),";
    "Fxn:_test_gather" -> "Fxn:dp.gather(inputs,";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result.size(),";
    "Fxn:_test_gather" -> "Fxn:torch.Size([4,";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result[:2],";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result[2:],";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(result.get_device(),";
    "Fxn:_test_gather" -> "Fxn:self.assertFalse(result.is_cuda)";
    "Fxn:_test_gather" -> "Fxn:torch.randn(4,";
    "Fxn:_test_gather" -> "Fxn:grad.cuda(output_device)";
    "Fxn:_test_gather" -> "Fxn:result.backward(grad)";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(inputs[0].grad.data,";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(inputs[1].grad.data,";
    "Fxn:_test_gather" -> "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:_test_gather" -> "Fxn:dp.gather((x,";
    "Fxn:_test_gather" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gather_cpu" -> "Fxn:self._test_gather(-1)";
    "Fxn:test_gather_cpu" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gather_gpu" -> "Fxn:self._test_gather(0)";
    "Fxn:_test_broadcast_double_backwards" -> "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:_test_broadcast_double_backwards" -> "Fxn:Broadcast.apply((0,";
    "Fxn:_test_broadcast_double_backwards" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_broadcast_double_backwards_gpu" -> "Fxn:self._test_broadcast_double_backwards(torch.randn(4,";
    "Fxn:test_broadcast_double_backwards_gpu" -> "Fxn:4).cuda(),";
    "Fxn:test_broadcast_double_backwards_gpu" -> "Fxn:torch.randn(4,";
    "Fxn:test_broadcast_double_backwards_gpu" -> "Fxn:4).cuda(),";
    "Fxn:test_broadcast_double_backwards_gpu" -> "Fxn:torch.randn(4,";
    "Fxn:test_broadcast_double_backwards_gpu" -> "Fxn:4).cuda())";
    "Fxn:test_broadcast_double_backwards_gpu" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:2).cuda(),";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:2).cuda(),";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:2).cuda(),";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:2).cuda(),";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:2).cuda(),";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:Broadcast.apply((0,";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:self.assertEqual(input_var.requires_grad,";
    "Fxn:test_broadcast_not_requiring_grad" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_replicate" -> "Fxn:nn.Linear(10,";
    "Fxn:test_replicate" -> "Fxn:5).float().cuda()";
    "Fxn:test_replicate" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_replicate" -> "Fxn:10).float().cuda())";
    "Fxn:test_replicate" -> "Fxn:module(input).data";
    "Fxn:test_replicate" -> "Fxn:dp.replicate(module,";
    "Fxn:test_replicate" -> "Fxn:replica.parameters():";
    "Fxn:test_replicate" -> "Fxn:self.assertEqual(p.get_device(),";
    "Fxn:test_replicate" -> "Fxn:input.cuda(i)";
    "Fxn:test_replicate" -> "Fxn:self.assertEqual(replica(replica_input).data,";
    "Fxn:test_replicate" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_replicate_buffers" -> "Fxn:nn.Module()";
    "Fxn:test_replicate_buffers" -> "Fxn:nn.BatchNorm2d(10)";
    "Fxn:test_replicate_buffers" -> "Fxn:net.cuda()";
    "Fxn:test_replicate_buffers" -> "Fxn:dp.replicate(net,";
    "Fxn:test_replicate_buffers" -> "Fxn:self.assertEqual(replica.bn.running_mean.get_device(),";
    "Fxn:test_replicate_buffers" -> "Fxn:self.assertEqual(replica.bn.running_var.get_device(),";
    "Fxn:test_replicate_buffers" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_parallel_apply" -> "Fxn:nn.Linear(10,";
    "Fxn:test_parallel_apply" -> "Fxn:5).float().cuda(0)";
    "Fxn:test_parallel_apply" -> "Fxn:nn.Linear(10,";
    "Fxn:test_parallel_apply" -> "Fxn:5).float().cuda(1)";
    "Fxn:test_parallel_apply" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_parallel_apply" -> "Fxn:10).float().cuda(0))";
    "Fxn:test_parallel_apply" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_parallel_apply" -> "Fxn:10).float().cuda(1))";
    "Fxn:test_parallel_apply" -> "Fxn:l1(i1).data";
    "Fxn:test_parallel_apply" -> "Fxn:l2(i2).data";
    "Fxn:test_parallel_apply" -> "Fxn:dp.parallel_apply(modules,";
    "Fxn:test_parallel_apply" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:test_parallel_apply" -> "Fxn:Variable(i2.data.new()))";
    "Fxn:test_parallel_apply" -> "Fxn:expected2.new())";
    "Fxn:test_parallel_apply" -> "Fxn:@unittest.skipIf(not";
    "class:TestModule(nn.Module):" -> "Fxn:forward";
    "class:TestModule(nn.Module):" -> "Fxn:local_test";
    "class:TestModule(nn.Module):" -> "Fxn:test_data_parallel_small_back";
    "class:TestModule(nn.Module):" -> "Fxn:test_data_parallel_model_no_refcycles";
    "Fxn:forward" -> "Fxn:TestModule()";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:forward" -> "Fxn:5).float(),";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:forward" -> "Fxn:5).float(),";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:forward" -> "Fxn:5).float(),";
    "Fxn:forward" -> "Fxn:torch.randn(1).item()";
    "Fxn:forward" -> "Fxn:expected.sum()";
    "Fxn:forward" -> "Fxn:loss.backward()";
    "Fxn:forward" -> "Fxn:var1.grad.clone()";
    "Fxn:forward" -> "Fxn:var2.grad.clone()";
    "Fxn:local_test" -> "Fxn:var1.grad.data.fill_(0.0)";
    "Fxn:local_test" -> "Fxn:var2.grad.data.fill_(0.0)";
    "Fxn:local_test" -> "Fxn:out.sum()";
    "Fxn:local_test" -> "Fxn:loss.backward()";
    "Fxn:local_test" -> "Fxn:self.assertEqual(out,";
    "Fxn:local_test" -> "Fxn:self.assertEqual(gvar1_exp,";
    "Fxn:local_test" -> "Fxn:self.assertEqual(gvar2_exp,";
    "Fxn:local_test" -> "Fxn:dp.data_parallel(m,";
    "Fxn:local_test" -> "Fxn:local_test(out)";
    "Fxn:local_test" -> "Fxn:dp.data_parallel(m,";
    "Fxn:local_test" -> "Fxn:local_test(out)";
    "Fxn:local_test" -> "Fxn:dp.data_parallel(m,";
    "Fxn:local_test" -> "Fxn:local_test(out)";
    "Fxn:local_test" -> "Fxn:var1.grad.data.fill_(0.0)";
    "Fxn:local_test" -> "Fxn:var2.grad.data.fill_(0.0)";
    "Fxn:local_test" -> "Fxn:expected.sum()";
    "Fxn:local_test" -> "Fxn:loss.backward()";
    "Fxn:local_test" -> "Fxn:var1.grad.clone()";
    "Fxn:local_test" -> "Fxn:var2.grad.clone()";
    "Fxn:local_test" -> "Fxn:nn.DataParallel(TestModule())";
    "Fxn:local_test" -> "Fxn:dpm(var1,";
    "Fxn:local_test" -> "Fxn:local_test(out)";
    "Fxn:local_test" -> "Fxn:nn.DataParallel(TestModule(),";
    "Fxn:local_test" -> "Fxn:dpm(var1,";
    "Fxn:local_test" -> "Fxn:local_test(out)";
    "Fxn:local_test" -> "Fxn:dp.data_parallel(";
    "Fxn:local_test" -> "Fxn:local_test(out)";
    "Fxn:local_test" -> "Fxn:dp.data_parallel(";
    "Fxn:local_test" -> "Fxn:local_test(out)";
    "Fxn:local_test" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_small_back" -> "Fxn:nn.Linear(10,";
    "Fxn:test_data_parallel_small_back" -> "Fxn:5).float().cuda()";
    "Fxn:test_data_parallel_small_back" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:test_data_parallel_small_back" -> "Fxn:10).float().cuda())";
    "Fxn:test_data_parallel_small_back" -> "Fxn:dp.data_parallel(l,";
    "Fxn:test_data_parallel_small_back" -> "Fxn:self.assertEqual(out,";
    "Fxn:test_data_parallel_small_back" -> "Fxn:l(i))";
    "Fxn:test_data_parallel_small_back" -> "Fxn:@unittest.skipIf(not";
    "class:Model(nn.Module):" -> "Fxn:__init__";
    "class:Model(nn.Module):" -> "Fxn:forward";
    "class:Model(nn.Module):" -> "Fxn:test_data_parallel_no_grad";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Linear(1,";
    "Fxn:forward" -> "Fxn:self.linear(x)";
    "Fxn:forward" -> "Fxn:gc.collect()";
    "Fxn:forward" -> "Fxn:nn.DataParallel(Model().cuda())";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(1).cuda())";
    "Fxn:forward" -> "Fxn:model(data)";
    "Fxn:forward" -> "Fxn:gc.collect()";
    "Fxn:forward" -> "Fxn:self.assertEqual(refcycles,";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "class:Layer(nn.Module):" -> "Fxn:forward";
    "class:Layer(nn.Module):" -> "Fxn:test_data_parallel";
    "class:Layer(nn.Module):" -> "Fxn:test_data_parallel_sparse";
    "class:Layer(nn.Module):" -> "Fxn:test_data_parallel_nested_output";
    "class:Layer(nn.Module):" -> "Fxn:fn";
    "Fxn:forward" -> "Fxn:test.assertFalse(torch.is_grad_enabled())";
    "Fxn:forward" -> "Fxn:Layer()";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:forward" -> "Fxn:10).float().cuda())";
    "Fxn:forward" -> "Fxn:torch.no_grad():";
    "Fxn:forward" -> "Fxn:dp.data_parallel(l,";
    "Fxn:forward" -> "Fxn:self.assertRaises(AssertionError,";
    "Fxn:forward" -> "Fxn:dp.data_parallel(l,";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel" -> "Fxn:nn.Linear(10,";
    "Fxn:test_data_parallel" -> "Fxn:5).float().cuda()";
    "Fxn:test_data_parallel" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:test_data_parallel" -> "Fxn:10).float().cuda(1))";
    "Fxn:test_data_parallel" -> "Fxn:l.cuda(1)";
    "Fxn:test_data_parallel" -> "Fxn:l(i)";
    "Fxn:test_data_parallel" -> "Fxn:expected_out.sum()";
    "Fxn:test_data_parallel" -> "Fxn:loss.backward()";
    "Fxn:test_data_parallel" -> "Fxn:l.parameters():";
    "Fxn:test_data_parallel" -> "Fxn:expected_grads.append(param.grad.clone())";
    "Fxn:test_data_parallel" -> "Fxn:[(0,";
    "Fxn:test_data_parallel" -> "Fxn:torch.cuda.device(dev_id[0]):";
    "Fxn:test_data_parallel" -> "Fxn:l.cuda()";
    "Fxn:test_data_parallel" -> "Fxn:l.zero_grad()";
    "Fxn:test_data_parallel" -> "Fxn:dp.data_parallel(l,";
    "Fxn:test_data_parallel" -> "Fxn:out.sum()";
    "Fxn:test_data_parallel" -> "Fxn:loss.backward()";
    "Fxn:test_data_parallel" -> "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:test_data_parallel" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:test_data_parallel" -> "Fxn:l.parameters()):";
    "Fxn:test_data_parallel" -> "Fxn:self.assertEqual(param.grad.data,";
    "Fxn:test_data_parallel" -> "Fxn:l.cuda()";
    "Fxn:test_data_parallel" -> "Fxn:dp.data_parallel(l,";
    "Fxn:test_data_parallel" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_sparse" -> "Fxn:nn.Embedding(10,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:sparse=True).cuda(1)";
    "Fxn:test_data_parallel_sparse" -> "Fxn:Variable(torch.LongTensor(20,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:5).random_(0,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:10).cuda(1))";
    "Fxn:test_data_parallel_sparse" -> "Fxn:l(i)";
    "Fxn:test_data_parallel_sparse" -> "Fxn:expected_out.sum()";
    "Fxn:test_data_parallel_sparse" -> "Fxn:loss.backward()";
    "Fxn:test_data_parallel_sparse" -> "Fxn:l.parameters():";
    "Fxn:test_data_parallel_sparse" -> "Fxn:expected_grads.append(param.grad.clone())";
    "Fxn:test_data_parallel_sparse" -> "Fxn:[(0,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:torch.cuda.device(dev_id[0]):";
    "Fxn:test_data_parallel_sparse" -> "Fxn:l.cuda()";
    "Fxn:test_data_parallel_sparse" -> "Fxn:l.zero_grad()";
    "Fxn:test_data_parallel_sparse" -> "Fxn:dp.data_parallel(l,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:out.sum()";
    "Fxn:test_data_parallel_sparse" -> "Fxn:loss.backward()";
    "Fxn:test_data_parallel_sparse" -> "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:test_data_parallel_sparse" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:l.parameters()):";
    "Fxn:test_data_parallel_sparse" -> "Fxn:self.assertEqual(param.grad.data,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:l.cuda()";
    "Fxn:test_data_parallel_sparse" -> "Fxn:dp.data_parallel(l,";
    "Fxn:test_data_parallel_sparse" -> "Fxn:@unittest.skipIf(not";
    "Fxn:fn" -> "Fxn:input.cos(),";
    "Fxn:fn" -> "Fxn:[input.add(1)]),";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_data_parallel_nested_input";
    "class:Net(nn.Module):" -> "Fxn:fn";
    "Fxn:forward" -> "Fxn:fn(input)";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:forward" -> "Fxn:2).float().cuda(1))";
    "Fxn:forward" -> "Fxn:dp.data_parallel(Net(),";
    "Fxn:forward" -> "Fxn:self.assertEqual(output,";
    "Fxn:forward" -> "Fxn:fn(i))";
    "Fxn:forward" -> "Fxn:self.assertIsInstance(output[0],";
    "Fxn:forward" -> "Fxn:self.assertIsInstance(output[1],";
    "Fxn:forward" -> "Fxn:self.assertIsInstance(output[1][0],";
    "Fxn:forward" -> "Fxn:self.assertIsInstance(output[1][1],";
    "Fxn:forward" -> "Fxn:self.assertIsInstance(output[1][2],";
    "Fxn:forward" -> "Fxn:self.assertIsInstance(output[1][2][0],";
    "Fxn:forward" -> "Fxn:self.assertIsInstance(output[2],";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_data_parallel_module";
    "class:Net(nn.Module):" -> "Fxn:test_data_parallel_module_kwargs_only";
    "Fxn:forward" -> "Fxn:fn(input)";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:forward" -> "Fxn:3).float().cuda(1))";
    "Fxn:forward" -> "Fxn:i.sin())";
    "Fxn:forward" -> "Fxn:dp.data_parallel(Net(),";
    "Fxn:forward" -> "Fxn:self.assertEqual(output,";
    "Fxn:forward" -> "Fxn:fn(input))";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_data_parallel_module" -> "Fxn:nn.Linear(10,";
    "Fxn:test_data_parallel_module" -> "Fxn:5).float().cuda()";
    "Fxn:test_data_parallel_module" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:test_data_parallel_module" -> "Fxn:10).float().cuda())";
    "Fxn:test_data_parallel_module" -> "Fxn:l(i).data";
    "Fxn:test_data_parallel_module" -> "Fxn:nn.DataParallel(l)";
    "Fxn:test_data_parallel_module" -> "Fxn:net(i)";
    "Fxn:test_data_parallel_module" -> "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:test_data_parallel_module" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:test_data_parallel_module" -> "Fxn:@unittest.skipIf(not";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_data_parallel_module_kwargs_only_empty_list";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:self.l(input)";
    "Fxn:forward" -> "Fxn:nn.Linear(10,";
    "Fxn:forward" -> "Fxn:5).float().cuda()";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:forward" -> "Fxn:10).float().cuda())";
    "Fxn:forward" -> "Fxn:l(i).data";
    "Fxn:forward" -> "Fxn:nn.DataParallel(Net())";
    "Fxn:forward" -> "Fxn:n(input=i)";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_data_parallel_module_kwargs_only_empty_dict";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:self.l(input['data'])";
    "Fxn:forward" -> "Fxn:nn.Linear(10,";
    "Fxn:forward" -> "Fxn:5).float().cuda()";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:forward" -> "Fxn:10).float().cuda())";
    "Fxn:forward" -> "Fxn:l(i).data";
    "Fxn:forward" -> "Fxn:nn.DataParallel(Net())";
    "Fxn:forward" -> "Fxn:n(input={'data':";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_data_parallel_module_kwargs_only_empty_tuple";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:self.l(input['data'])";
    "Fxn:forward" -> "Fxn:nn.Linear(10,";
    "Fxn:forward" -> "Fxn:5).float().cuda()";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:forward" -> "Fxn:10).float().cuda())";
    "Fxn:forward" -> "Fxn:l(i).data";
    "Fxn:forward" -> "Fxn:nn.DataParallel(Net())";
    "Fxn:forward" -> "Fxn:n(input={'data':";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:forward" -> "Fxn:@unittest.skipIf(not";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "class:Net(nn.Module):" -> "Fxn:forward";
    "class:Net(nn.Module):" -> "Fxn:test_state_dict";
    "class:Net(nn.Module):" -> "Fxn:test_load_state_dict";
    "class:Net(nn.Module):" -> "Fxn:test_parameter_assignment";
    "class:Net(nn.Module):" -> "Fxn:num_params";
    "class:Net(nn.Module):" -> "Fxn:assign_var";
    "class:Net(nn.Module):" -> "Fxn:test_assignment";
    "class:Net(nn.Module):" -> "Fxn:test_assignments";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_inconsistent_types";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_deterministic_cudnn";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_missing_argument";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_backward_twice";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_large_workspace";
    "class:Net(nn.Module):" -> "Fxn:run_test";
    "class:Net(nn.Module):" -> "Fxn:test_conv_modules_raise_error_on_incorrect_input_size";
    "class:Net(nn.Module):" -> "Fxn:test_conv_shapecheck";
    "class:Net(nn.Module):" -> "Fxn:test";
    "class:Net(nn.Module):" -> "Fxn:test_ConvTranspose2d_output_size";
    "class:Net(nn.Module):" -> "Fxn:_test_Conv2d_naive_groups";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_groups_nobias";
    "class:Net(nn.Module):" -> "Fxn:test_Conv2d_depthwise_naive_groups";
    "class:Net(nn.Module):" -> "Fxn:test_MaxUnpool2d_output_size";
    "class:Net(nn.Module):" -> "Fxn:test_container_copy";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:self.l(input['data'])";
    "Fxn:forward" -> "Fxn:nn.Linear(10,";
    "Fxn:forward" -> "Fxn:5).float().cuda()";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(20,";
    "Fxn:forward" -> "Fxn:10).float().cuda())";
    "Fxn:forward" -> "Fxn:l(i).data";
    "Fxn:forward" -> "Fxn:nn.DataParallel(Net())";
    "Fxn:forward" -> "Fxn:n(input={'data':";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.get_device(),";
    "Fxn:forward" -> "Fxn:self.assertEqual(out.data,";
    "Fxn:test_state_dict" -> "Fxn:nn.Linear(5,";
    "Fxn:test_state_dict" -> "Fxn:nn.Module()";
    "Fxn:test_state_dict" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_state_dict" -> "Fxn:nn.Module()";
    "Fxn:test_state_dict" -> "Fxn:nn.BatchNorm2d(2)";
    "Fxn:test_state_dict" -> "Fxn:net.add_module('empty',";
    "Fxn:test_state_dict" -> "Fxn:net.state_dict()";
    "Fxn:test_state_dict" -> "Fxn:self.assertEqual(len(state_dict),";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('linear1.weight',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('linear1.bias',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('linear2.weight',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('linear2.bias',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('block.conv.weight',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('block.conv.weight',";
    "Fxn:test_state_dict" -> "Fxn:self.assertNotIn('block.conv.bias',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('bn.weight',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('bn.bias',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('bn.running_var',";
    "Fxn:test_state_dict" -> "Fxn:self.assertIn('bn.running_mean',";
    "Fxn:test_state_dict" -> "Fxn:self.assertFalse(any(map(lambda";
    "Fxn:test_state_dict" -> "Fxn:k.startswith('empty'),";
    "Fxn:test_state_dict" -> "Fxn:state_dict.keys())))";
    "Fxn:test_state_dict" -> "Fxn:state_dict.items():";
    "Fxn:test_state_dict" -> "Fxn:k.split('.'):";
    "Fxn:test_state_dict" -> "Fxn:self.assertEqual(v.data_ptr(),";
    "Fxn:test_state_dict" -> "Fxn:param.data_ptr())";
    "Fxn:test_state_dict" -> "Fxn:nn.Linear(5,";
    "Fxn:test_state_dict" -> "Fxn:l.state_dict()";
    "Fxn:test_state_dict" -> "Fxn:self.assertEqual(len(state_dict),";
    "Fxn:test_state_dict" -> "Fxn:self.assertEqual(state_dict['weight'].data_ptr(),";
    "Fxn:test_state_dict" -> "Fxn:l.weight.data_ptr())";
    "Fxn:test_state_dict" -> "Fxn:self.assertEqual(state_dict['bias'].data_ptr(),";
    "Fxn:test_state_dict" -> "Fxn:l.bias.data_ptr())";
    "Fxn:test_load_state_dict" -> "Fxn:nn.Linear(5,";
    "Fxn:test_load_state_dict" -> "Fxn:nn.Module()";
    "Fxn:test_load_state_dict" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_load_state_dict" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_load_state_dict" -> "Fxn:nn.Module()";
    "Fxn:test_load_state_dict" -> "Fxn:nn.BatchNorm2d(2)";
    "Fxn:test_load_state_dict" -> "Fxn:net.add_module('empty',";
    "Fxn:test_load_state_dict" -> "Fxn:net.state_dict()";
    "Fxn:test_load_state_dict" -> "Fxn:state_dict.update({";
    "Fxn:test_load_state_dict" -> "Fxn:torch.ones(5,";
    "Fxn:test_load_state_dict" -> "Fxn:torch.arange(1,";
    "Fxn:test_load_state_dict" -> "Fxn:torch.randn(2),";
    "Fxn:test_load_state_dict" -> "Fxn:net.load_state_dict(state_dict)";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertEqual(net.linear1.weight.data,";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertEqual(net.block.conv1.bias.data,";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertEqual(net.bn.running_mean,";
    "Fxn:test_load_state_dict" -> "Fxn:net.state_dict()";
    "Fxn:test_load_state_dict" -> "Fxn:state_dict.update({'extra':";
    "Fxn:test_load_state_dict" -> "Fxn:torch.ones(5)})";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertRaises(KeyError,";
    "Fxn:test_load_state_dict" -> "Fxn:net.load_state_dict(state_dict))";
    "Fxn:test_load_state_dict" -> "Fxn:net.state_dict()";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertRaises(KeyError,";
    "Fxn:test_load_state_dict" -> "Fxn:net.load_state_dict(state_dict))";
    "Fxn:test_load_state_dict" -> "Fxn:net.state_dict()";
    "Fxn:test_load_state_dict" -> "Fxn:state_dict.update({'bn.running_mean':";
    "Fxn:test_load_state_dict" -> "Fxn:torch.rand(14,";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_load_state_dict" -> "Fxn:net.load_state_dict(state_dict))";
    "Fxn:test_load_state_dict" -> "Fxn:net.state_dict()";
    "Fxn:test_load_state_dict" -> "Fxn:deepcopy(state_dict)";
    "Fxn:test_load_state_dict" -> "Fxn:torch.ones(5,";
    "Fxn:test_load_state_dict" -> "Fxn:torch.arange(1,";
    "Fxn:test_load_state_dict" -> "Fxn:torch.randn(2),";
    "Fxn:test_load_state_dict" -> "Fxn:torch.rand(3)";
    "Fxn:test_load_state_dict" -> "Fxn:net.load_state_dict(state_dict,";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertEqual(net.linear1.weight.data,";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertEqual(net.block.conv1.bias.data,";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertEqual(net.bn.running_mean,";
    "Fxn:test_load_state_dict" -> "Fxn:net.state_dict()";
    "Fxn:test_load_state_dict" -> "Fxn:old_state_dict.items():";
    "Fxn:test_load_state_dict" -> "Fxn:self.assertTrue(v.equal(new_state_dict[k]))";
    "Fxn:test_parameter_assignment" -> "Fxn:nn.Linear(5,";
    "Fxn:num_params" -> "Fxn:self.assertEqual(num_params(),";
    "Fxn:num_params" -> "Fxn:Parameter(torch.randn(5,";
    "Fxn:num_params" -> "Fxn:self.assertEqual(num_params(),";
    "Fxn:num_params" -> "Fxn:self.assertObjectIn(new_param,";
    "Fxn:num_params" -> "Fxn:l.parameters())";
    "Fxn:num_params" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:num_params" -> "Fxn:self.assertEqual(num_params(),";
    "Fxn:num_params" -> "Fxn:self.assertNotIn(id(var),";
    "Fxn:num_params" -> "Fxn:l.parameters()))";
    "Fxn:num_params" -> "Fxn:Variable(torch.Tensor(5,";
    "Fxn:num_params" -> "Fxn:self.assertEqual(num_params(),";
    "Fxn:num_params" -> "Fxn:Parameter(torch.Tensor(5,";
    "Fxn:num_params" -> "Fxn:self.assertEqual(num_params(),";
    "Fxn:assign_var" -> "Fxn:Variable(torch.Tensor(5,";
    "Fxn:assign_var" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:assign_var" -> "Fxn:self.assertEqual(num_params(),";
    "Fxn:test_assignment" -> "Fxn:nn.Module()";
    "Fxn:test_assignment" -> "Fxn:nn.Parameter(torch.randn(2))";
    "Fxn:test_assignment" -> "Fxn:nn.Parameter(torch.randn(3))";
    "Fxn:test_assignment" -> "Fxn:nn.Parameter(torch.randn(4))";
    "Fxn:test_assignment" -> "Fxn:nn.Linear(4,";
    "Fxn:test_assignment" -> "Fxn:nn.Linear(5,";
    "Fxn:test_assignment" -> "Fxn:nn.Linear(6,";
    "Fxn:test_assignments" -> "Fxn:self.assertIsNone(l.a)";
    "Fxn:test_assignments" -> "Fxn:self.assertIn('a',";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.a,";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(get_list(),";
    "Fxn:test_assignments" -> "Fxn:self.assertNotIn('a',";
    "Fxn:test_assignments" -> "Fxn:self.assertIsNone(l.b)";
    "Fxn:test_assignments" -> "Fxn:self.assertIn('b',";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.b,";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(get_list(),";
    "Fxn:test_assignments" -> "Fxn:self.assertNotIn('b',";
    "Fxn:test_assignments" -> "Fxn:self.assertIsNone(l.a)";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(get_list(),";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.a,";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(get_list(),";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.a,";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(get_list(),";
    "Fxn:test_assignments" -> "Fxn:self.assertFalse(hasattr(l,";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.a,";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(get_list(),";
    "Fxn:test_assignments" -> "Fxn:test_assignments(lambda:";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(list(l.parameters()),";
    "Fxn:test_assignments" -> "Fxn:test_assignments(lambda:";
    "Fxn:test_assignments" -> "Fxn:self.assertEqual(list(l.children()),";
    "Fxn:test_assignments" -> "Fxn:torch.randn(10)";
    "Fxn:test_assignments" -> "Fxn:l.register_buffer('buf',";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.buf,";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.buf,";
    "Fxn:test_assignments" -> "Fxn:self.assertNotIn('buf',";
    "Fxn:test_assignments" -> "Fxn:self.assertIn('buf',";
    "Fxn:test_assignments" -> "Fxn:l.state_dict())";
    "Fxn:test_assignments" -> "Fxn:self.assertIs(l.state_dict()['buf'],";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:7).float())";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:3).double())";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:nn.functional.conv2d(inputs.float(),";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:weights.float())";
    "Fxn:test_Conv2d_inconsistent_types" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:7).float().cuda())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:3).double().cuda())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:Variable(torch.randn(1).double().cuda())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:weights.float(),";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:nn.functional.conv2d(inputs.float(),";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:weights.float(),";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:bias.float())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_without_cudnn" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:7).float().cuda())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:3).double().cuda())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:Variable(torch.randn(1).double().cuda())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:torch.backends.cudnn.flags(enabled=True):";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:nn.functional.conv2d(inputs,";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:weights.float(),";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:nn.functional.conv2d(inputs.float(),";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:weights.float(),";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:bias.float())";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_inconsistent_types_on_GPU_with_cudnn" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:5).type(dtype),";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:cudnn.flags(enabled=True,";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:torch.nn.Conv2d(3,";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:3).type(dtype)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:torch.nn.Conv2d(3,";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:3).type(dtype)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:conv2.bias.data.copy_(conv1.bias.data)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:conv2.weight.data.copy_(conv1.weight.data)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:conv1(inputs)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:conv2(inputs)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:self.assertEqual(out1,";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:torch.randn(out1.size()).type(dtype)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:out1.backward(y)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:out2.backward(y)";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:self.assertEqual(conv1.bias.grad.data,";
    "Fxn:test_Conv2d_deterministic_cudnn" -> "Fxn:self.assertEqual(conv1.weight.grad.data,";
    "Fxn:test_Conv2d_missing_argument" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_Conv2d_missing_argument" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_Conv2d_missing_argument" -> "Fxn:c(None))";
    "Fxn:test_Conv2d_backward_twice" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_Conv2d_backward_twice" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_Conv2d_backward_twice" -> "Fxn:c(input)";
    "Fxn:test_Conv2d_backward_twice" -> "Fxn:o1.sum().backward()";
    "Fxn:test_Conv2d_backward_twice" -> "Fxn:self.assertRaisesRegex(RuntimeError,";
    "Fxn:test_Conv2d_backward_twice" -> "Fxn:o1.sum().backward())";
    "Fxn:test_Conv2d_backward_twice" -> "Fxn:@unittest.skipIf(not";
    "Fxn:run_test" -> "Fxn:torch.backends.cudnn.flags(benchmark=benchmark):";
    "Fxn:run_test" -> "Fxn:torch.nn.Conv2d(256,";
    "Fxn:run_test" -> "Fxn:padding=1).type(dtype)";
    "Fxn:run_test" -> "Fxn:torch.randn(size).type(dtype)";
    "Fxn:run_test" -> "Fxn:conv(Variable(x,";
    "Fxn:run_test" -> "Fxn:out.backward(torch.ones(out.size()).type(dtype))";
    "Fxn:run_test" -> "Fxn:run_test(benchmark=False)";
    "Fxn:run_test" -> "Fxn:run_test(benchmark=True)";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:[nn.Conv1d(3,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:nn.ConvTranspose1d(3,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:nn.ConvTranspose2d(3,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:nn.Conv3d(3,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:nn.ConvTranspose3d(3,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:[(2,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:Variable(torch.Tensor(torch.Size((3,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_conv_modules_raise_error_on_incorrect_input_size" -> "Fxn:module(input))";
    "Fxn:test" -> "Fxn:Variable(torch.Tensor(3,";
    "Fxn:test" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test" -> "Fxn:module(input))";
    "Fxn:test" -> "Fxn:module(input)";
    "Fxn:test" -> "Fxn:test(True,";
    "Fxn:test" -> "Fxn:nn.Conv1d(1,";
    "Fxn:test" -> "Fxn:test(True,";
    "Fxn:test" -> "Fxn:nn.Conv1d(1,";
    "Fxn:test" -> "Fxn:test(False,";
    "Fxn:test" -> "Fxn:nn.Conv1d(1,";
    "Fxn:test" -> "Fxn:test(False,";
    "Fxn:test" -> "Fxn:nn.Conv1d(1,";
    "Fxn:test" -> "Fxn:test(False,";
    "Fxn:test" -> "Fxn:nn.Conv1d(1,";
    "Fxn:test" -> "Fxn:test(True,";
    "Fxn:test" -> "Fxn:nn.Conv2d(1,";
    "Fxn:test" -> "Fxn:test(False,";
    "Fxn:test" -> "Fxn:nn.Conv2d(1,";
    "Fxn:test" -> "Fxn:test(False,";
    "Fxn:test" -> "Fxn:nn.Conv2d(1,";
    "Fxn:test" -> "Fxn:test(True,";
    "Fxn:test" -> "Fxn:nn.Conv3d(1,";
    "Fxn:test" -> "Fxn:test(False,";
    "Fxn:test" -> "Fxn:nn.Conv3d(1,";
    "Fxn:test" -> "Fxn:test(False,";
    "Fxn:test" -> "Fxn:nn.Conv3d(1,";
    "Fxn:test_ConvTranspose2d_output_size" -> "Fxn:nn.ConvTranspose2d(3,";
    "Fxn:test_ConvTranspose2d_output_size" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_ConvTranspose2d_output_size" -> "Fxn:output_size=(h,";
    "Fxn:test_ConvTranspose2d_output_size" -> "Fxn:self.assertEqual(output.size()[2:],";
    "Fxn:test_ConvTranspose2d_output_size" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:nn.Conv2d(4,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:groups=2).type(test_type)";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:6).type(test_type),";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:torch.randn(2,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:4).type(test_type)";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:output.backward(grad_output)";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:nn.Conv2d(2,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:kernel_size=3).type(test_type)";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:m1.weight.data.copy_(m.weight.data[:2])";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:m1.bias.data.copy_(m.bias.data[:2])";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:Variable(i.data[:,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn::2].contiguous(),";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:output1.backward(grad_output[:,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn::2].contiguous())";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:nn.Conv2d(2,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:kernel_size=3).type(test_type)";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:m2.weight.data.copy_(m.weight.data[2:])";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:m2.bias.data.copy_(m.bias.data[2:])";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:Variable(i.data[:,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:2:].contiguous(),";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:output2.backward(grad_output[:,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:2:].contiguous())";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:self.assertEqual(output,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:torch.cat([output1,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:self.assertEqual(i.grad.data,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:torch.cat([i1.grad.data,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:self.assertEqual(m.bias.grad.data,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:torch.cat([m1.bias.grad.data,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:self.assertEqual(m.weight.grad.data,";
    "Fxn:_test_Conv2d_naive_groups" -> "Fxn:torch.cat([m1.weight.grad.data,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:nn.Conv2d(4,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:bias=False).type(tp)";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:6).type(tp),";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:torch.randn(2,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:4).type(tp)";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:output.backward(grad_output)";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:nn.Conv2d(2,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:bias=False).type(tp)";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:m1.weight.data.copy_(m.weight.data[:2])";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:Variable(i.data[:,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn::2].contiguous(),";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:output1.backward(grad_output[:,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn::2].contiguous())";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:nn.Conv2d(2,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:bias=False).type(tp)";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:m2.weight.data.copy_(m.weight.data[2:])";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:Variable(i.data[:,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:2:].contiguous(),";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:output2.backward(grad_output[:,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:2:].contiguous())";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:torch.cat([output1,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:self.assertEqual(i.grad.data,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:torch.cat([i1.grad.data,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:self.assertEqual(m.weight.grad.data,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:torch.cat([m1.weight.grad.data,";
    "Fxn:test_Conv2d_groups_nobias" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:nn.Conv2d(2,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:groups=2).type(tp)";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:6).type(tp)";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:torch.randn(2,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:4).type(tp)";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:output.backward(grad_output)";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:nn.Conv2d(1,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:kernel_size=3).type(tp)";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:m.weight.data[:offset].clone()";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:m.bias.data[:offset].clone()";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:Variable(i.data[:,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn::1].contiguous(),";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:output1.backward(grad_output[:,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn::offset].contiguous())";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:nn.Conv2d(1,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:kernel_size=3).type(tp)";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:m2.weight.data.copy_(m.weight.data[offset:])";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:m2.bias.data.copy_(m.bias.data[offset:])";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:Variable(i.data[:,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:1:].contiguous(),";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:output2.backward(grad_output[:,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:offset:].contiguous())";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:torch.cat([output1,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:self.assertEqual(i.grad.data,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:torch.cat([i1.grad.data,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:self.assertEqual(m.bias.grad.data,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:torch.cat([m1.bias.grad.data,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:self.assertEqual(m.weight.grad.data,";
    "Fxn:test_Conv2d_depthwise_naive_groups" -> "Fxn:torch.cat([m1.weight.grad.data,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:nn.MaxPool2d(3,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:nn.MaxUnpool2d(3,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:torch.rand(1,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:mu(output_big,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:torch.rand(1,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:torch.LongStorage(size)";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:torch.LongStorage((1,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:mu(output_small,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_MaxUnpool2d_output_size" -> "Fxn:mu(output_small,";
    "class:Model(nn.Module):" -> "Fxn:__init__";
    "class:Model(nn.Module):" -> "Fxn:forward";
    "class:Model(nn.Module):" -> "Fxn:test_RNN_cell";
    "class:Model(nn.Module):" -> "Fxn:_test_loss_equal_input_target_shape";
    "class:Model(nn.Module):" -> "Fxn:test_loss_equal_input_target_shape";
    "class:Model(nn.Module):" -> "Fxn:test_RNN_cell_no_broadcasting";
    "class:Model(nn.Module):" -> "Fxn:test";
    "class:Model(nn.Module):" -> "Fxn:test_all";
    "class:Model(nn.Module):" -> "Fxn:test_invalid_dropout_p";
    "class:Model(nn.Module):" -> "Fxn:test_pad_sequence";
    "class:Model(nn.Module):" -> "Fxn:pad";
    "class:Model(nn.Module):" -> "Fxn:test_pack_sequence";
    "class:Model(nn.Module):" -> "Fxn:_compatibility_test";
    "class:Model(nn.Module):" -> "Fxn:test_pack_padded_sequence";
    "class:Model(nn.Module):" -> "Fxn:pad";
    "class:Model(nn.Module):" -> "Fxn:_test_variable_sequence";
    "class:Model(nn.Module):" -> "Fxn:pad";
    "class:Model(nn.Module):" -> "Fxn:test_variable_sequence";
    "class:Model(nn.Module):" -> "Fxn:test_variable_sequence_cuda";
    "class:Model(nn.Module):" -> "Fxn:test_LSTM_cell";
    "class:Model(nn.Module):" -> "Fxn:test_cudnn_weight_format";
    "class:Model(nn.Module):" -> "Fxn:test_cudnn_weight_tying";
    "class:Model(nn.Module):" -> "Fxn:test_cuda_rnn_fused";
    "class:Model(nn.Module):" -> "Fxn:copy_rnn";
    "class:Model(nn.Module):" -> "Fxn:check_rnn_grads";
    "class:Model(nn.Module):" -> "Fxn:test_rnn_args_check";
    "class:Model(nn.Module):" -> "Fxn:test";
    "class:Model(nn.Module):" -> "Fxn:update_tuple";
    "class:Model(nn.Module):" -> "Fxn:get_inputs";
    "class:Model(nn.Module):" -> "Fxn:test_rnn_initial_hidden_state";
    "class:Model(nn.Module):" -> "Fxn:_test_rnn_retain_variables";
    "class:Model(nn.Module):" -> "Fxn:test_rnn_retain_variables";
    "class:Model(nn.Module):" -> "Fxn:test_rnn_retain_variables_cuda";
    "class:Model(nn.Module):" -> "Fxn:_test_RNN_cpu_vs_cudnn";
    "class:Model(nn.Module):" -> "Fxn:forward_backward";
    "class:Model(nn.Module):" -> "Fxn:make_noncontig";
    "class:Model(nn.Module):" -> "Fxn:compare_cpu_gpu";
    "class:Model(nn.Module):" -> "Fxn:test_RNN_cpu_vs_cudnn_no_dropout";
    "class:Model(nn.Module):" -> "Fxn:test_RNN_cpu_vs_cudnn_with_dropout";
    "class:Model(nn.Module):" -> "Fxn:test_RNN_dropout";
    "class:Model(nn.Module):" -> "Fxn:test_RNN_dropout_state";
    "class:Model(nn.Module):" -> "Fxn:test_RNN_change_dropout";
    "class:Model(nn.Module):" -> "Fxn:_verify_pixel_shuffle";
    "class:Model(nn.Module):" -> "Fxn:test_inplace_thnn";
    "class:Model(nn.Module):" -> "Fxn:test_noncontig_conv_grad";
    "class:Model(nn.Module):" -> "Fxn:test_pixel_shuffle";
    "class:Model(nn.Module):" -> "Fxn:test_elu_inplace_view";
    "class:Model(nn.Module):" -> "Fxn:func";
    "class:Model(nn.Module):" -> "Fxn:test_relu_inplace_view";
    "class:Model(nn.Module):" -> "Fxn:func";
    "class:Model(nn.Module):" -> "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size";
    "class:Model(nn.Module):" -> "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss";
    "class:Model(nn.Module):" -> "Fxn:test_bce_with_logits_has_correct_grad_at_zero";
    "class:Model(nn.Module):" -> "Fxn:test_bce_with_logits_broadcasts_weights";
    "class:Model(nn.Module):" -> "Fxn:test_bce_loss_broadcasts_weights";
    "class:Model(nn.Module):" -> "Fxn:test_elu_inplace_gradgrad";
    "class:Model(nn.Module):" -> "Fxn:func";
    "class:Model(nn.Module):" -> "Fxn:test_hardtanh_inplace_gradgrad";
    "class:Model(nn.Module):" -> "Fxn:func";
    "class:Model(nn.Module):" -> "Fxn:test_batchnorm_cudnn_half";
    "class:Model(nn.Module):" -> "Fxn:_test_batchnorm_update_stats";
    "class:Model(nn.Module):" -> "Fxn:test_batchnorm_update_stats";
    "class:Model(nn.Module):" -> "Fxn:test_batchnorm_update_stats_cuda";
    "class:Model(nn.Module):" -> "Fxn:test_batchnorm_raises_error_if_running_mean_is_not_same_size_as_input";
    "class:Model(nn.Module):" -> "Fxn:test_batchnorm_raises_error_if_running_var_is_not_same_size_as_input";
    "class:Model(nn.Module):" -> "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input";
    "class:Model(nn.Module):" -> "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input";
    "class:Model(nn.Module):" -> "Fxn:_test_batchnorm_eval";
    "class:Model(nn.Module):" -> "Fxn:test_pairwise_distance";
    "class:Model(nn.Module):" -> "Fxn:test_cosine_embedding_loss_no_reduce";
    "class:Model(nn.Module):" -> "Fxn:test_cosine_embedding_loss_margin_no_reduce";
    "class:Model(nn.Module):" -> "Fxn:test_triplet_margin_loss";
    "class:Model(nn.Module):" -> "Fxn:test_triplet_margin_swap_loss";
    "class:Model(nn.Module):" -> "Fxn:test_cosine_similarity";
    "class:Model(nn.Module):" -> "Fxn:test_grid_sample";
    "class:Model(nn.Module):" -> "Fxn:test_cpu_against_cuda";
    "class:Model(nn.Module):" -> "Fxn:test_shape";
    "class:Model(nn.Module):" -> "Fxn:test_grid_sample_3d";
    "class:Model(nn.Module):" -> "Fxn:test_cpu_against_cuda";
    "class:Model(nn.Module):" -> "Fxn:test_shape";
    "class:Model(nn.Module):" -> "Fxn:test_affine_grid";
    "class:Model(nn.Module):" -> "Fxn:test_upsamplingNearest1d";
    "class:Model(nn.Module):" -> "Fxn:test_upsamplingLinear1d";
    "class:Model(nn.Module):" -> "Fxn:test_upsamplingNearest2d";
    "class:Model(nn.Module):" -> "Fxn:test_upsamplingBilinear2d";
    "class:Model(nn.Module):" -> "Fxn:test_upsamplingNearest3d";
    "class:Model(nn.Module):" -> "Fxn:test_upsamplingTrilinear3d";
    "class:Model(nn.Module):" -> "Fxn:test_linear_broadcasting";
    "class:Model(nn.Module):" -> "Fxn:test_bilinear";
    "class:Model(nn.Module):" -> "Fxn:test_conv_tbc";
    "class:Model(nn.Module):" -> "Fxn:run_conv_double_back_test";
    "class:Model(nn.Module):" -> "Fxn:func";
    "class:Model(nn.Module):" -> "Fxn:test_conv_double_backward";
    "class:Model(nn.Module):" -> "Fxn:test_conv_double_backward_no_bias";
    "class:Model(nn.Module):" -> "Fxn:test_conv_double_backward_groups";
    "class:Model(nn.Module):" -> "Fxn:test_conv_double_backward_stride";
    "class:Model(nn.Module):" -> "Fxn:test_cudnn_noncontiguous_weight";
    "class:Model(nn.Module):" -> "Fxn:test_conv_double_backward_cuda";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Linear(4,";
    "Fxn:forward" -> "Fxn:self.linear(input)";
    "Fxn:forward" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:forward" -> "Fxn:Model()";
    "Fxn:forward" -> "Fxn:deepcopy(model)";
    "Fxn:forward" -> "Fxn:self.assertEqual(model(input).data,";
    "Fxn:forward" -> "Fxn:model_cp(input).data)";
    "Fxn:forward" -> "Fxn:self.assertNotEqual(model(input).data,";
    "Fxn:forward" -> "Fxn:model_cp(input).data)";
    "Fxn:test_RNN_cell" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_RNN_cell" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_RNN_cell" -> "Fxn:module(10,";
    "Fxn:test_RNN_cell" -> "Fxn:cell(input,";
    "Fxn:test_RNN_cell" -> "Fxn:hx.sum().backward()";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:F.mse_loss(x,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:F.l1_loss(x,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:F.smooth_l1_loss(x,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:F.kl_div(x,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:F.poisson_nll_loss(x,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:Variable(cast(torch.randn(3,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:Variable(cast(torch.randn(5,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:losses.items():";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:self.assertRaises(Exception,";
    "Fxn:_test_loss_equal_input_target_shape" -> "Fxn:fn(input,";
    "Fxn:test_loss_equal_input_target_shape" -> "Fxn:self._test_loss_equal_input_target_shape(lambda";
    "Fxn:test" -> "Fxn:cell_module(input_size,";
    "Fxn:test" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test" -> "Fxn:cell(input,";
    "Fxn:test_all" -> "Fxn:test(nn.RNNCell,";
    "Fxn:test_all" -> "Fxn:test(nn.GRUCell,";
    "Fxn:test_all" -> "Fxn:test(nn.LSTMCell,";
    "Fxn:test_all" -> "Fxn:test(nn.LSTMCell,";
    "Fxn:test_all" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_all" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_all" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_all" -> "Fxn:test_all(hidden_size,";
    "Fxn:test_all" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_all" -> "Fxn:test_all(hidden_size,";
    "Fxn:test_all" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_all" -> "Fxn:test_all(hidden_size,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:Variable(torch.ones(1))";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:nn.Dropout(-0.1))";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:nn.Dropout(1.1))";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:nn.Dropout2d(-0.1))";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:nn.Dropout2d(1.1))";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:nn.Dropout3d(-0.1))";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:nn.Dropout3d(1.1))";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:F.dropout(v,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_invalid_dropout_p" -> "Fxn:F.dropout(v,";
    "Fxn:pad" -> "Fxn:torch.cat(";
    "Fxn:pad" -> "Fxn:tensor.data.new(";
    "Fxn:pad" -> "Fxn:tensor.size(0),";
    "Fxn:pad" -> "Fxn:*tensor.size()[1:]).zero_()])";
    "Fxn:pad" -> "Fxn:Variable(torch.Tensor([1,";
    "Fxn:pad" -> "Fxn:Variable(torch.Tensor([4,";
    "Fxn:pad" -> "Fxn:Variable(torch.Tensor([6]))";
    "Fxn:pad" -> "Fxn:Variable(torch.Tensor([[1,";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_sequence([a,";
    "Fxn:pad" -> "Fxn:self.assertEqual(padded,";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_sequence([a,";
    "Fxn:pad" -> "Fxn:self.assertEqual(padded,";
    "Fxn:pad" -> "Fxn:expected.transpose(0,";
    "Fxn:pad" -> "Fxn:Variable(torch.Tensor([[1,";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_sequence([a,";
    "Fxn:pad" -> "Fxn:self.assertEqual(padded,";
    "Fxn:pad" -> "Fxn:sequences.append(Variable(torch.rand(seq_len,";
    "Fxn:pad" -> "Fxn:expected.append(pad(seq,";
    "Fxn:pad" -> "Fxn:Variable(torch.stack(expected))";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_sequence(sequences,";
    "Fxn:pad" -> "Fxn:self.assertEqual(padded,";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_sequence(sequences)";
    "Fxn:pad" -> "Fxn:self.assertEqual(padded,";
    "Fxn:pad" -> "Fxn:expected.transpose(0,";
    "Fxn:pad" -> "Fxn:self.assertRaises(";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_sequence([b,";
    "Fxn:_compatibility_test" -> "Fxn:rnn_utils.pad_sequence(sequences,";
    "Fxn:_compatibility_test" -> "Fxn:rnn_utils.pack_sequence(sequences)";
    "Fxn:_compatibility_test" -> "Fxn:rnn_utils.pad_packed_sequence(packed,";
    "Fxn:_compatibility_test" -> "Fxn:self.assertEqual(padded,";
    "Fxn:_compatibility_test" -> "Fxn:rnn_utils.pack_padded_sequence(padded,";
    "Fxn:_compatibility_test" -> "Fxn:self.assertEqual(packed,";
    "Fxn:_compatibility_test" -> "Fxn:Variable(torch.Tensor([1,";
    "Fxn:_compatibility_test" -> "Fxn:Variable(torch.Tensor([4,";
    "Fxn:_compatibility_test" -> "Fxn:Variable(torch.Tensor([6]))";
    "Fxn:_compatibility_test" -> "Fxn:rnn_utils.pack_sequence([a,";
    "Fxn:_compatibility_test" -> "Fxn:torch.Tensor([1,";
    "Fxn:_compatibility_test" -> "Fxn:self.assertEqual(packed.batch_sizes,";
    "Fxn:_compatibility_test" -> "Fxn:self.assertEqual(packed.data.data,";
    "Fxn:_compatibility_test" -> "Fxn:lengths.append(seq_len)";
    "Fxn:_compatibility_test" -> "Fxn:sequences.append(Variable(torch.rand(seq_len,";
    "Fxn:_compatibility_test" -> "Fxn:_compatibility_test(sequences,";
    "Fxn:pad" -> "Fxn:torch.cat([tensor,";
    "Fxn:pad" -> "Fxn:tensor.new(length";
    "Fxn:pad" -> "Fxn:tensor.size(0),";
    "Fxn:pad" -> "Fxn:*tensor.size()[1:]).zero_()])";
    "Fxn:pad" -> "Fxn:[sum(map(bool,";
    "Fxn:pad" -> "Fxn:torch.cat([pad(i";
    "Fxn:pad" -> "Fxn:torch.arange(1,";
    "Fxn:pad" -> "Fxn:1).view(l,";
    "Fxn:pad" -> "Fxn:Variable(padded,";
    "Fxn:pad" -> "Fxn:[[torch.arange(1,";
    "Fxn:pad" -> "Fxn:torch.stack(expected_data,";
    "Fxn:pad" -> "Fxn:src.transpose(0,";
    "Fxn:pad" -> "Fxn:rnn_utils.pack_padded_sequence(src,";
    "Fxn:pad" -> "Fxn:self.assertEqual(packed.data.data,";
    "Fxn:pad" -> "Fxn:self.assertEqual(packed.batch_sizes,";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_packed_sequence(packed,";
    "Fxn:pad" -> "Fxn:self.assertEqual(unpacked,";
    "Fxn:pad" -> "Fxn:self.assertEqual(unpacked_len,";
    "Fxn:pad" -> "Fxn:padded.grad.data.zero_()";
    "Fxn:pad" -> "Fxn:unpacked.data.clone().normal_()";
    "Fxn:pad" -> "Fxn:unpacked.backward(grad_output)";
    "Fxn:pad" -> "Fxn:grad_output.transpose_(0,";
    "Fxn:pad" -> "Fxn:self.assertEqual(padded.grad.data[:l,";
    "Fxn:pad" -> "Fxn:self.assertEqual(padded.grad.data[l:,";
    "Fxn:pad" -> "Fxn:i].abs().sum(),";
    "Fxn:pad" -> "Fxn:var.size(0)";
    "Fxn:pad" -> "Fxn:torch.cat([var,";
    "Fxn:pad" -> "Fxn:Variable(var.data.new(length";
    "Fxn:pad" -> "Fxn:var.size(0),";
    "Fxn:pad" -> "Fxn:*var.size()[1:]).zero_())])";
    "Fxn:pad" -> "Fxn:Variable(torch.randn(max_length,";
    "Fxn:pad" -> "Fxn:nn.LSTM(3,";
    "Fxn:pad" -> "Fxn:deepcopy(lstm)";
    "Fxn:pad" -> "Fxn:x_leaf.cuda()";
    "Fxn:pad" -> "Fxn:lstm.cuda()";
    "Fxn:pad" -> "Fxn:lstm2.cuda()";
    "Fxn:pad" -> "Fxn:lstm2(x[:l,";
    "Fxn:pad" -> "Fxn:pad(out,";
    "Fxn:pad" -> "Fxn:seq_outs.append(out_pad)";
    "Fxn:pad" -> "Fxn:seq_hiddens.append(hid)";
    "Fxn:pad" -> "Fxn:torch.cat(seq_outs,";
    "Fxn:pad" -> "Fxn:rnn_utils.pack_padded_sequence(x,";
    "Fxn:pad" -> "Fxn:lstm(packed)";
    "Fxn:pad" -> "Fxn:rnn_utils.pad_packed_sequence(packed_out)";
    "Fxn:pad" -> "Fxn:self.assertEqual(packed_hidden,";
    "Fxn:pad" -> "Fxn:self.assertEqual(unpacked,";
    "Fxn:pad" -> "Fxn:self.assertEqual(unpacked_len,";
    "Fxn:pad" -> "Fxn:seq_out.sum().backward()";
    "Fxn:pad" -> "Fxn:x_leaf.grad.data.clone()";
    "Fxn:pad" -> "Fxn:x_leaf.grad.data.zero_()";
    "Fxn:pad" -> "Fxn:unpacked.sum().backward()";
    "Fxn:pad" -> "Fxn:self.assertEqual(x_leaf.grad.data,";
    "Fxn:pad" -> "Fxn:lstm2.parameters()):";
    "Fxn:pad" -> "Fxn:self.assertEqual(p1.grad,";
    "Fxn:test_variable_sequence" -> "Fxn:self._test_variable_sequence(False)";
    "Fxn:test_variable_sequence" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_variable_sequence_cuda" -> "Fxn:self._test_variable_sequence(True)";
    "Fxn:test_LSTM_cell" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_LSTM_cell" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_LSTM_cell" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_LSTM_cell" -> "Fxn:nn.LSTMCell(10,";
    "Fxn:test_LSTM_cell" -> "Fxn:lstm(input,";
    "Fxn:test_LSTM_cell" -> "Fxn:cx).sum().backward()";
    "Fxn:test_LSTM_cell" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cudnn_weight_format" -> "Fxn:nn.LSTM(10,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:nn.GRU(10,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:nn.RNN(10,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:rnn.cuda()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:10).cuda(),";
    "Fxn:test_cudnn_weight_format" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:20).cuda(),";
    "Fxn:test_cudnn_weight_format" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:20).cuda(),";
    "Fxn:test_cudnn_weight_format" -> "Fxn:rnn(input,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:output[0].sum().backward()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:[v.grad.data.clone()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:v.grad.data.zero_()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:weight.data.clone()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:weight.data.set_(weight_data)";
    "Fxn:test_cudnn_weight_format" -> "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:test_cudnn_weight_format" -> "Fxn:rnn(input,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:self.assertEqual(len(w),";
    "Fxn:test_cudnn_weight_format" -> "Fxn:self.assertIn('weights";
    "Fxn:test_cudnn_weight_format" -> "Fxn:output_noncontig[0].sum().backward()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:[v.grad.data.clone()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:v.grad.data.zero_()";
    "Fxn:test_cudnn_weight_format" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:self.assertEqual(grads_noncontig,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:self.assertEqual(weight_data,";
    "Fxn:test_cudnn_weight_format" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:nn.LSTM(10,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:nn.GRU(10,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:nn.RNN(10,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:rnn.cuda()";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:10).cuda(),";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:20).cuda(),";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:torch.optim.SGD(rnn.parameters(),";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:opt.zero_grad()";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:20).cuda(),";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:rnn(input,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:output[0].sum().backward()";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:opt.step()";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:rnn(input,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:rnn.cpu()";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:hx[1].cpu())";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:hx.cpu()";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:rnn(input.cpu(),";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:self.assertEqual(output_cuda,";
    "Fxn:test_cudnn_weight_tying" -> "Fxn:@unittest.skipIf(not";
    "Fxn:copy_rnn" -> "Fxn:x.data.copy_(y.data)";
    "Fxn:check_rnn_grads" -> "Fxn:self.assertEqual(x.grad,";
    "Fxn:check_rnn_grads" -> "Fxn:torch.randn(seq_length,";
    "Fxn:check_rnn_grads" -> "Fxn:torch.randn(seq_length,";
    "Fxn:check_rnn_grads" -> "Fxn:torch.randn(num_layers,";
    "Fxn:check_rnn_grads" -> "Fxn:torch.randn(num_layers,";
    "Fxn:check_rnn_grads" -> "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:check_rnn_grads" -> "Fxn:module(input_size,";
    "Fxn:check_rnn_grads" -> "Fxn:module(input_size,";
    "Fxn:check_rnn_grads" -> "Fxn:bias=bias).cuda()";
    "Fxn:check_rnn_grads" -> "Fxn:copy_rnn(rnn,";
    "Fxn:check_rnn_grads" -> "Fxn:Variable(hx_val.clone().add(1),";
    "Fxn:check_rnn_grads" -> "Fxn:Variable(hx_val.clone().cuda().add(1),";
    "Fxn:check_rnn_grads" -> "Fxn:Variable(hx_val.clone(),";
    "Fxn:check_rnn_grads" -> "Fxn:Variable(hx_val.clone().cuda(),";
    "Fxn:check_rnn_grads" -> "Fxn:Variable(input_val.clone(),";
    "Fxn:check_rnn_grads" -> "Fxn:Variable(input_val.clone().cuda(),";
    "Fxn:check_rnn_grads" -> "Fxn:rnn(inp,";
    "Fxn:check_rnn_grads" -> "Fxn:rnn_cuda(inp_cu,";
    "Fxn:check_rnn_grads" -> "Fxn:torch.autograd.backward(";
    "Fxn:check_rnn_grads" -> "Fxn:torch.autograd.backward(";
    "Fxn:check_rnn_grads" -> "Fxn:[grad_output.cuda(),";
    "Fxn:check_rnn_grads" -> "Fxn:grad_hy.cuda(),";
    "Fxn:check_rnn_grads" -> "Fxn:1).cuda()]";
    "Fxn:check_rnn_grads" -> "Fxn:torch.autograd.backward([output1,";
    "Fxn:check_rnn_grads" -> "Fxn:torch.autograd.backward([output2,";
    "Fxn:check_rnn_grads" -> "Fxn:[grad_output.cuda(),";
    "Fxn:check_rnn_grads" -> "Fxn:grad_hy.cuda()])";
    "Fxn:check_rnn_grads" -> "Fxn:self.assertEqual(output1,";
    "Fxn:check_rnn_grads" -> "Fxn:self.assertEqual(hy1,";
    "Fxn:check_rnn_grads" -> "Fxn:check_rnn_grads(rnn,";
    "Fxn:check_rnn_grads" -> "Fxn:self.assertEqual(inp.grad.data,";
    "Fxn:check_rnn_grads" -> "Fxn:self.assertEqual(hx[0].grad.data,";
    "Fxn:check_rnn_grads" -> "Fxn:self.assertEqual(hx[1].grad.data,";
    "Fxn:check_rnn_grads" -> "Fxn:self.assertEqual(hx.grad.data,";
    "Fxn:test" -> "Fxn:get_inputs(input_shape,";
    "Fxn:test" -> "Fxn:mode)(input_size,";
    "Fxn:test" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test" -> "Fxn:model(input,";
    "Fxn:get_inputs" -> "Fxn:Variable(torch.randn(input_shape))";
    "Fxn:get_inputs" -> "Fxn:Variable(torch.randn(hidden_shape))";
    "Fxn:get_inputs" -> "Fxn:[(input,";
    "Fxn:get_inputs" -> "Fxn:[(input,";
    "Fxn:get_inputs" -> "Fxn:Variable(torch.randn(correct_hidden_shape))";
    "Fxn:get_inputs" -> "Fxn:update_tuple(correct_input_shape,";
    "Fxn:get_inputs" -> "Fxn:test(input_shape,";
    "Fxn:get_inputs" -> "Fxn:update_tuple(correct_hidden_shape,";
    "Fxn:get_inputs" -> "Fxn:test(input_shape,";
    "Fxn:get_inputs" -> "Fxn:update_tuple(correct_input_shape,";
    "Fxn:get_inputs" -> "Fxn:test(input_shape,";
    "Fxn:get_inputs" -> "Fxn:update_tuple(correct_hidden_shape,";
    "Fxn:get_inputs" -> "Fxn:test(input_shape,";
    "Fxn:get_inputs" -> "Fxn:update_tuple(correct_hidden_shape,";
    "Fxn:get_inputs" -> "Fxn:test(input_shape,";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:mode)(30,";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:Variable(torch.Tensor(2,";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:20).zero_())";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:rnn(input,";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:rnn(input)";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:self.assertEqual(output1,";
    "Fxn:test_rnn_initial_hidden_state" -> "Fxn:self.assertEqual(hidden1,";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:[nn.LSTM(10,";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:num_layers=2).type(dtype),";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:nn.GRU(10,";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:num_layers=2).type(dtype),";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:nn.RNN(10,";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:num_layers=2).type(dtype)]";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:10).type(dtype),";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:rnn(input)";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:output[0].sum().backward(retain_graph=True)";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:[input.grad.data.clone()]";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:[p.grad.data.clone()";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:rnn.parameters()]";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:rnn.zero_grad()";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:input.grad.data.zero_()";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:output[0].sum().backward(retain_graph=True)";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:rnn.parameters()]";
    "Fxn:_test_rnn_retain_variables" -> "Fxn:self.assertEqual(grads,";
    "Fxn:test_rnn_retain_variables" -> "Fxn:self._test_rnn_retain_variables(torch.DoubleTensor)";
    "Fxn:test_rnn_retain_variables" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_rnn_retain_variables_cuda" -> "Fxn:torch.backends.cudnn.flags(enabled=False):";
    "Fxn:test_rnn_retain_variables_cuda" -> "Fxn:self._test_rnn_retain_variables(torch.cuda.FloatTensor)";
    "Fxn:test_rnn_retain_variables_cuda" -> "Fxn:self._test_rnn_retain_variables(torch.cuda.FloatTensor)";
    "Fxn:forward_backward" -> "Fxn:x.data.copy_(y.data)";
    "Fxn:forward_backward" -> "Fxn:rnn_utils.PackedSequence(";
    "Fxn:forward_backward" -> "Fxn:Variable(input_val.data.data,";
    "Fxn:forward_backward" -> "Fxn:Variable(input_val.clone(),";
    "Fxn:forward_backward" -> "Fxn:Variable(hx_val.add(1),";
    "Fxn:forward_backward" -> "Fxn:Variable(hx_val.clone(),";
    "Fxn:forward_backward" -> "Fxn:rnn.cuda()";
    "Fxn:forward_backward" -> "Fxn:input_var.data.cuda()";
    "Fxn:forward_backward" -> "Fxn:hx[0].data.cuda()";
    "Fxn:forward_backward" -> "Fxn:hx[1].data.cuda()";
    "Fxn:forward_backward" -> "Fxn:hx.data.cuda()";
    "Fxn:forward_backward" -> "Fxn:grad_hy.cuda()";
    "Fxn:forward_backward" -> "Fxn:grad_output.cuda()";
    "Fxn:forward_backward" -> "Fxn:rnn(input,";
    "Fxn:forward_backward" -> "Fxn:torch.autograd.backward([output,";
    "Fxn:forward_backward" -> "Fxn:torch.autograd.backward([output,";
    "Fxn:make_noncontig" -> "Fxn:tensor.dim()";
    "Fxn:make_noncontig" -> "Fxn:torch.stack([tensor.clone().zero_(),";
    "Fxn:make_noncontig" -> "Fxn:ndim).select(ndim,";
    "Fxn:compare_cpu_gpu" -> "Fxn:self.assertEqual(list(outputs_cpu.keys()),";
    "Fxn:compare_cpu_gpu" -> "Fxn:outputs_cpu.keys():";
    "Fxn:compare_cpu_gpu" -> "Fxn:self.assertEqual(outputs_cpu[key],";
    "Fxn:compare_cpu_gpu" -> "Fxn:self.assertEqual(cpu_weight.grad.data,";
    "Fxn:compare_cpu_gpu" -> "Fxn:product((True,";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(batch,";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(batch,";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(seq_length,";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(seq_length,";
    "Fxn:compare_cpu_gpu" -> "Fxn:make_noncontig(grad_output)";
    "Fxn:compare_cpu_gpu" -> "Fxn:make_noncontig(grad_hy)";
    "Fxn:compare_cpu_gpu" -> "Fxn:make_noncontig(input_val)";
    "Fxn:compare_cpu_gpu" -> "Fxn:make_noncontig(hx_val)";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(num_layers";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(num_layers";
    "Fxn:compare_cpu_gpu" -> "Fxn:Variable(torch.LongTensor(lengths))";
    "Fxn:compare_cpu_gpu" -> "Fxn:Variable(input_val)";
    "Fxn:compare_cpu_gpu" -> "Fxn:Variable(grad_output)";
    "Fxn:compare_cpu_gpu" -> "Fxn:rnn_utils.pack_padded_sequence(input_val,";
    "Fxn:compare_cpu_gpu" -> "Fxn:rnn_utils.pack_padded_sequence(grad_output,";
    "Fxn:compare_cpu_gpu" -> "Fxn:module(input_size,";
    "Fxn:compare_cpu_gpu" -> "Fxn:forward_backward(";
    "Fxn:compare_cpu_gpu" -> "Fxn:module(input_size,";
    "Fxn:compare_cpu_gpu" -> "Fxn:forward_backward(";
    "Fxn:compare_cpu_gpu" -> "Fxn:compare_cpu_gpu(outputs_cpu,";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(num_layers,";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(seq_length,";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.randn(";
    "Fxn:compare_cpu_gpu" -> "Fxn:nn.RNN(input_size,";
    "Fxn:compare_cpu_gpu" -> "Fxn:forward_backward(False,";
    "Fxn:compare_cpu_gpu" -> "Fxn:nn.RNN(input_size,";
    "Fxn:compare_cpu_gpu" -> "Fxn:forward_backward(True,";
    "Fxn:compare_cpu_gpu" -> "Fxn:compare_cpu_gpu(outputs_cpu,";
    "Fxn:compare_cpu_gpu" -> "Fxn:@unittest.skipIf(not";
    "Fxn:compare_cpu_gpu" -> "Fxn:@default_tensor_type(torch.FloatTensor)";
    "Fxn:compare_cpu_gpu" -> "Fxn:torch.cuda.DoubleTensor.sum()";
    "Fxn:test_RNN_cpu_vs_cudnn_no_dropout" -> "Fxn:self._test_RNN_cpu_vs_cudnn(0)";
    "Fxn:test_RNN_cpu_vs_cudnn_no_dropout" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_RNN_cpu_vs_cudnn_no_dropout" -> "Fxn:@default_tensor_type(torch.FloatTensor)";
    "Fxn:test_RNN_cpu_vs_cudnn_no_dropout" -> "Fxn:torch.cuda.DoubleTensor.sum()";
    "Fxn:test_RNN_cpu_vs_cudnn_with_dropout" -> "Fxn:self._test_RNN_cpu_vs_cudnn(1)";
    "Fxn:test_RNN_cpu_vs_cudnn_with_dropout" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_RNN_dropout" -> "Fxn:nn.RNN(10,";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn.cuda()";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn.train()";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn.eval()";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn.weight_ih_l0.data.fill_(1)";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn.weight_hh_l0.data.fill_(1)";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn.weight_ih_l1.data.fill_(1)";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn.weight_hh_l1.data.fill_(1)";
    "Fxn:test_RNN_dropout" -> "Fxn:Variable(torch.Tensor(1,";
    "Fxn:test_RNN_dropout" -> "Fxn:10).fill_(1))";
    "Fxn:test_RNN_dropout" -> "Fxn:Variable(torch.Tensor(2,";
    "Fxn:test_RNN_dropout" -> "Fxn:1000).fill_(0))";
    "Fxn:test_RNN_dropout" -> "Fxn:input.cuda()";
    "Fxn:test_RNN_dropout" -> "Fxn:hx.cuda()";
    "Fxn:test_RNN_dropout" -> "Fxn:rnn(input,";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertEqual(output.data.min(),";
    "Fxn:test_RNN_dropout" -> "Fxn:output.data.max())";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertEqual(output_val,";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertEqual(output_val,";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertGreater(output_val,";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertLess(output_val,";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertLess(min(denorm_mod,";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertEqual(hy[0].data.min(),";
    "Fxn:test_RNN_dropout" -> "Fxn:hy[0].data.max())";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertEqual(hy[1].data.min(),";
    "Fxn:test_RNN_dropout" -> "Fxn:hy[1].data.max())";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertEqual(hy.data[0][0][0],";
    "Fxn:test_RNN_dropout" -> "Fxn:self.assertEqual(hy.data[1][0][0],";
    "Fxn:test_RNN_dropout" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_RNN_dropout_state" -> "Fxn:nn.RNN(100,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:rnn.cuda()";
    "Fxn:test_RNN_dropout_state" -> "Fxn:rnn.train()";
    "Fxn:test_RNN_dropout_state" -> "Fxn:rnn.eval()";
    "Fxn:test_RNN_dropout_state" -> "Fxn:Variable(torch.Tensor(1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:100).uniform_())";
    "Fxn:test_RNN_dropout_state" -> "Fxn:Variable(torch.Tensor(2,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:100).uniform_())";
    "Fxn:test_RNN_dropout_state" -> "Fxn:input.cuda()";
    "Fxn:test_RNN_dropout_state" -> "Fxn:hx.cuda()";
    "Fxn:test_RNN_dropout_state" -> "Fxn:rnn(input,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:rnn(input,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:pickle.dumps(rnn)";
    "Fxn:test_RNN_dropout_state" -> "Fxn:pickle.loads(rnn_pickle)";
    "Fxn:test_RNN_dropout_state" -> "Fxn:rnn2.flatten_parameters()";
    "Fxn:test_RNN_dropout_state" -> "Fxn:rnn2(input,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertEqual(output1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertEqual(output1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertEqual(hy1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertEqual(hy1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertNotEqual(output1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertNotEqual(output1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertNotEqual(hy1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:self.assertNotEqual(hy1,";
    "Fxn:test_RNN_dropout_state" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_RNN_change_dropout" -> "Fxn:product((True,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:nn.RNN(100,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:Variable(torch.Tensor(3,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:100).uniform_())";
    "Fxn:test_RNN_change_dropout" -> "Fxn:input.data.cuda()";
    "Fxn:test_RNN_change_dropout" -> "Fxn:rnn.cuda()";
    "Fxn:test_RNN_change_dropout" -> "Fxn:rnn.train()";
    "Fxn:test_RNN_change_dropout" -> "Fxn:rnn.eval()";
    "Fxn:test_RNN_change_dropout" -> "Fxn:rnn(input)";
    "Fxn:test_RNN_change_dropout" -> "Fxn:rnn(input)";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertEqual(output1,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertEqual(hy1,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertNotEqual(output1,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertNotEqual(hy1,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertEqual(output1.data,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertEqual(output2.data,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertNotEqual(output1.data,";
    "Fxn:test_RNN_change_dropout" -> "Fxn:self.assertNotEqual(output2.data,";
    "Fxn:_verify_pixel_shuffle" -> "Fxn:self.assertEqual(output[:,";
    "Fxn:test_inplace_thnn" -> "Fxn:mod(inplace=True)";
    "Fxn:test_inplace_thnn" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:test_inplace_thnn" -> "Fxn:r(input";
    "Fxn:test_inplace_thnn" -> "Fxn:torch.randn(5,";
    "Fxn:test_inplace_thnn" -> "Fxn:grad_output.clone()";
    "Fxn:test_inplace_thnn" -> "Fxn:output.backward(grad_output)";
    "Fxn:test_inplace_thnn" -> "Fxn:self.assertEqual(grad_output,";
    "Fxn:test_inplace_thnn" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:nn.Conv2d(3,";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:padding=1).cuda()";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:10).cuda(),";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:module(input)";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:torch.randn(2,";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:10).cuda()[:,";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:grad.is_contiguous()";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:output.backward(grad,";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:self.assertIsNotNone(input.grad)";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:input.grad.data.clone()";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:input.grad.data.zero_()";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:output.backward(grad.contiguous())";
    "Fxn:test_noncontig_conv_grad" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_pixel_shuffle" -> "Fxn:random.randint(1,";
    "Fxn:test_pixel_shuffle" -> "Fxn:random.randint(2,";
    "Fxn:test_pixel_shuffle" -> "Fxn:random.randint(1,";
    "Fxn:test_pixel_shuffle" -> "Fxn:random.randint(5,";
    "Fxn:test_pixel_shuffle" -> "Fxn:random.randint(5,";
    "Fxn:test_pixel_shuffle" -> "Fxn:Variable(torch.Tensor(batch_size,";
    "Fxn:test_pixel_shuffle" -> "Fxn:width).uniform_(),";
    "Fxn:test_pixel_shuffle" -> "Fxn:nn.PixelShuffle(upscale_factor)";
    "Fxn:test_pixel_shuffle" -> "Fxn:ps(input)";
    "Fxn:test_pixel_shuffle" -> "Fxn:self._verify_pixel_shuffle(input.data,";
    "Fxn:test_pixel_shuffle" -> "Fxn:output.backward(output.data)";
    "Fxn:test_pixel_shuffle" -> "Fxn:self.assertEqual(input.data,";
    "Fxn:test_elu_inplace_view" -> "Fxn:Variable(torch.Tensor([1.0,";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:x.narrow(0,";
    "Fxn:func" -> "Fxn:F.elu(view,";
    "Fxn:func" -> "Fxn:self.assertIs(res,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_relu_inplace_view" -> "Fxn:Variable(torch.Tensor([1.0,";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:x.narrow(0,";
    "Fxn:func" -> "Fxn:F.relu(view,";
    "Fxn:func" -> "Fxn:self.assertIs(res,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:Variable(torch.rand(5))";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:Variable(torch.rand(5,";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:nn.BCEWithLogitsLoss()(input,";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:Variable(torch.rand(5,";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:Variable(torch.rand(5))";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_bce_with_logits_raises_if_target_and_input_are_different_size" -> "Fxn:nn.BCEWithLogitsLoss()(input,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:nn.Sigmoid()";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:Variable(torch.rand(64,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:Variable(torch.rand(64,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:self.assertEqual(nn.BCEWithLogitsLoss()(output,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:nn.BCELoss()(sigmoid(output),";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:torch.rand(4)";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:self.assertEqual(nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:Variable(torch.FloatTensor(4,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:1).fill_(0))";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:Variable(torch.FloatTensor(4,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:1).fill_(-100))";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:self.assertEqual(nn.BCEWithLogitsLoss()(output,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:nn.BCELoss()(sigmoid(output),";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:self.assertEqual(nn.BCEWithLogitsLoss(reduce=False)(output,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:nn.BCELoss(reduce=False)(sigmoid(output),";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:torch.FloatTensor(1).uniform_()";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:self.assertEqual(nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:test_bce_with_logits_gives_same_result_as_sigmoid_and_bce_loss" -> "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero" -> "Fxn:Variable(torch.zeros(3,";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero" -> "Fxn:Variable(torch.zeros(3,";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero" -> "Fxn:nn.BCEWithLogitsLoss(size_average=False)(output,";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero" -> "Fxn:target).backward()";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero" -> "Fxn:Variable(torch.Tensor(3,";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero" -> "Fxn:1).fill_(0.5))";
    "Fxn:test_bce_with_logits_has_correct_grad_at_zero" -> "Fxn:self.assertEqual(output.grad,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:Variable(torch.rand(16,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:Variable(torch.rand(16,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:torch.rand(4)";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:weight.expand(16,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:4).contiguous()";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:self.assertEqual(out1,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:torch.rand(16,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:weight.expand(16,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:4).contiguous()";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:nn.BCEWithLogitsLoss(weight)(output,";
    "Fxn:test_bce_with_logits_broadcasts_weights" -> "Fxn:self.assertEqual(out1,";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:nn.Sigmoid()";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:Variable(torch.rand(16,";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:Variable(torch.rand(16,";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:torch.rand(4)";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:weight.expand(16,";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:4).contiguous()";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:self.assertEqual(out1,";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:torch.rand(16,";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:weight.expand(16,";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:4).contiguous()";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:nn.BCELoss(weight)(sigmoid(output),";
    "Fxn:test_bce_loss_broadcasts_weights" -> "Fxn:self.assertEqual(out1,";
    "Fxn:test_elu_inplace_gradgrad" -> "Fxn:Variable(torch.randn(8),";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:F.elu(x,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_hardtanh_inplace_gradgrad" -> "Fxn:Variable(torch.randn(8),";
    "Fxn:func" -> "Fxn:root.clone()";
    "Fxn:func" -> "Fxn:F.hardtanh(x,";
    "Fxn:func" -> "Fxn:gradcheck(func,";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:func" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:2).half().cuda().random_(1,";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:nn.BatchNorm2d(3).half().cuda()";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:thnn_output.sum().backward()";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:input.grad.data.clone()";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:self.assertEqual(thnn_output.type(),";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:input.type())";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:m.float()";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:cudnn_output.sum().backward()";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:input.grad.data.clone()";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:self.assertEqual(cudnn_output.type(),";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:input.type())";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:self.assertEqual(cudnn_output,";
    "Fxn:test_batchnorm_cudnn_half" -> "Fxn:self.assertAlmostEqual(cudnn_input_grad,";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:nn.BatchNorm1d(3).type(test_type)";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:Variable(torch.rand(4,";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:3).type(test_type))";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:module.running_mean.clone()";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:module.running_var.clone()";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:module(data)";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:self.assertNotEqual(old_running_mean,";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:self.assertNotEqual(old_running_var,";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:module.eval()";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:module.running_mean.clone()";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:module.running_var.clone()";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:module(data)";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:self.assertEqual(old_running_mean,";
    "Fxn:_test_batchnorm_update_stats" -> "Fxn:self.assertEqual(old_running_var,";
    "Fxn:test_batchnorm_update_stats" -> "Fxn:self._test_batchnorm_update_stats()";
    "Fxn:test_batchnorm_update_stats" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_batchnorm_update_stats_cuda" -> "Fxn:self._test_batchnorm_update_stats(torch.cuda.FloatTensor)";
    "Fxn:test_batchnorm_raises_error_if_running_mean_is_not_same_size_as_input" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:test_batchnorm_raises_error_if_running_mean_is_not_same_size_as_input" -> "Fxn:torch.rand(10)";
    "Fxn:test_batchnorm_raises_error_if_running_mean_is_not_same_size_as_input" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_batchnorm_raises_error_if_running_mean_is_not_same_size_as_input" -> "Fxn:F.batch_norm(input,";
    "Fxn:test_batchnorm_raises_error_if_running_mean_is_not_same_size_as_input" -> "Fxn:torch.rand(size),";
    "Fxn:test_batchnorm_raises_error_if_running_var_is_not_same_size_as_input" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:test_batchnorm_raises_error_if_running_var_is_not_same_size_as_input" -> "Fxn:torch.rand(10)";
    "Fxn:test_batchnorm_raises_error_if_running_var_is_not_same_size_as_input" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_batchnorm_raises_error_if_running_var_is_not_same_size_as_input" -> "Fxn:F.batch_norm(input,";
    "Fxn:test_batchnorm_raises_error_if_running_var_is_not_same_size_as_input" -> "Fxn:torch.rand(size))";
    "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input" -> "Fxn:torch.rand(10)";
    "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input" -> "Fxn:torch.rand(10)";
    "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input" -> "Fxn:F.batch_norm(input,";
    "Fxn:test_batchnorm_raises_error_if_weight_is_not_same_size_as_input" -> "Fxn:weight=Parameter(torch.rand(size)))";
    "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input" -> "Fxn:torch.rand(10)";
    "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input" -> "Fxn:torch.rand(10)";
    "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input" -> "Fxn:F.batch_norm(input,";
    "Fxn:test_batchnorm_raises_error_if_bias_is_not_same_size_as_input" -> "Fxn:bias=Parameter(torch.rand(size)))";
    "Fxn:_test_batchnorm_eval" -> "Fxn:nn.BatchNorm1d(3).type(test_type)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:module.eval()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:Variable(torch.rand(4,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:3).type(test_type),";
    "Fxn:_test_batchnorm_eval" -> "Fxn:torch.rand(4,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:3).type(test_type)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:module(data)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:res1.backward(grad)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:data.grad.data.clone()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:data.grad.data.zero_()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:module(data)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:res2.backward(grad)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:data.grad.data.clone()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:self.assertEqual(grad1,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:nn.BatchNorm1d(3,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:track_running_stats=False).type(test_type)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:Variable(torch.rand(4,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:3).type(test_type),";
    "Fxn:_test_batchnorm_eval" -> "Fxn:torch.rand(4,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:3).type(test_type)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:module(data)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:res1.backward(grad)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:data.grad.data.clone()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:module.eval()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:data.grad.data.zero_()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:module(data)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:res2.backward(grad)";
    "Fxn:_test_batchnorm_eval" -> "Fxn:data.grad.data.clone()";
    "Fxn:_test_batchnorm_eval" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_batchnorm_eval" -> "Fxn:self.assertEqual(grad1,";
    "Fxn:test_pairwise_distance" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_pairwise_distance" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_pairwise_distance" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_pairwise_distance" -> "Fxn:F.pairwise_distance(x,";
    "Fxn:test_cosine_embedding_loss_no_reduce" -> "Fxn:Variable(torch.randn(15,";
    "Fxn:test_cosine_embedding_loss_no_reduce" -> "Fxn:Variable(torch.randn(15,";
    "Fxn:test_cosine_embedding_loss_no_reduce" -> "Fxn:Variable(torch.randn(15).sign())";
    "Fxn:test_cosine_embedding_loss_no_reduce" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cosine_embedding_loss_no_reduce" -> "Fxn:F.cosine_embedding_loss(";
    "Fxn:test_cosine_embedding_loss_no_reduce" -> "Fxn:self.assertEqual(F.cosine_embedding_loss(input1,";
    "Fxn:test_cosine_embedding_loss_no_reduce" -> "Fxn:loss_reference_fns['CosineEmbeddingLoss'](input1,";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce" -> "Fxn:Variable(torch.randn(15,";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce" -> "Fxn:Variable(torch.randn(15,";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce" -> "Fxn:Variable(torch.randn(15).sign())";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce" -> "Fxn:F.cosine_embedding_loss(";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce" -> "Fxn:self.assertEqual(F.cosine_embedding_loss(input1,";
    "Fxn:test_cosine_embedding_loss_margin_no_reduce" -> "Fxn:loss_reference_fns['CosineEmbeddingLoss'](input1,";
    "Fxn:test_triplet_margin_loss" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_triplet_margin_loss" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_triplet_margin_loss" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_triplet_margin_loss" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_triplet_margin_loss" -> "Fxn:F.triplet_margin_loss(";
    "Fxn:test_triplet_margin_swap_loss" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_triplet_margin_swap_loss" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_triplet_margin_swap_loss" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_triplet_margin_swap_loss" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_triplet_margin_swap_loss" -> "Fxn:F.triplet_margin_loss(";
    "Fxn:test_cosine_similarity" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_cosine_similarity" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_cosine_similarity" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cosine_similarity" -> "Fxn:F.cosine_similarity(x,";
    "Fxn:test_cosine_similarity" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_cosine_similarity" -> "Fxn:Variable(torch.randn(4,";
    "Fxn:test_cosine_similarity" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cosine_similarity" -> "Fxn:F.cosine_similarity(x,";
    "Fxn:test_cosine_similarity" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cosine_similarity" -> "Fxn:F.cosine_similarity(x,";
    "Fxn:test_cosine_similarity" -> "Fxn:torch.randn((),";
    "Fxn:test_cosine_similarity" -> "Fxn:torch.randn((),";
    "Fxn:test_cosine_similarity" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cosine_similarity" -> "Fxn:F.cosine_similarity(x,";
    "Fxn:test_cosine_similarity" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_cosine_similarity" -> "Fxn:F.cosine_similarity(x,";
    "Fxn:test_cosine_similarity" -> "Fxn:Variable(torch.randn(input_size),";
    "Fxn:test_cosine_similarity" -> "Fxn:Variable(torch.randn(input_size),";
    "Fxn:test_cosine_similarity" -> "Fxn:self.assertEqual(F.cosine_similarity(input1,";
    "Fxn:test_cosine_similarity" -> "Fxn:dim=1).size(),";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(C,";
    "Fxn:test_shape" -> "Fxn:IW).transpose(0,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(H,";
    "Fxn:test_shape" -> "Fxn:2).transpose(0,";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cpu,";
    "Fxn:test_shape" -> "Fxn:self.assertTrue(out_cpu.size()";
    "Fxn:test_shape" -> "Fxn:torch.Size([N,";
    "Fxn:test_shape" -> "Fxn:Variable(input_cpu.data.transpose(0,";
    "Fxn:test_shape" -> "Fxn:1).cuda().transpose(0,";
    "Fxn:test_shape" -> "Fxn:Variable(grid_cpu.data.transpose(0,";
    "Fxn:test_shape" -> "Fxn:1).cuda().transpose(0,";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cuda,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(out_cpu,";
    "Fxn:test_shape" -> "Fxn:out_cpu.data.new(out_cpu.size()).normal_()";
    "Fxn:test_shape" -> "Fxn:out_cpu.backward(gradients)";
    "Fxn:test_shape" -> "Fxn:out_cuda.backward(gradients.cuda())";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(input_cpu.grad,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(grid_cpu.grad,";
    "Fxn:test_shape" -> "Fxn:torch.randn(C,";
    "Fxn:test_shape" -> "Fxn:Variable(base_input.expand(input_cuda.size()),";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cpu,";
    "Fxn:test_shape" -> "Fxn:Variable(base_input.cuda().expand(input_cuda.size()),";
    "Fxn:test_shape" -> "Fxn:Variable(grid_cpu.data.cuda(),";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cuda,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(out_cpu,";
    "Fxn:test_shape" -> "Fxn:test_shape(N,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(IH";
    "Fxn:test_shape" -> "Fxn:random.randint(IW";
    "Fxn:test_shape" -> "Fxn:test_shape(N,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:test_shape(N,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.arange(1,";
    "Fxn:test_shape" -> "Fxn:11).view(1,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.Tensor(";
    "Fxn:test_shape" -> "Fxn:0.5]]).view(1,";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input,";
    "Fxn:test_shape" -> "Fxn:torch.Tensor(";
    "Fxn:test_shape" -> "Fxn:7.0000]]).view(1,";
    "Fxn:test_shape" -> "Fxn:torch.Tensor(";
    "Fxn:test_shape" -> "Fxn:8.7500]]).view(1,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(output.data,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_shape" -> "Fxn:self.assertTrue(gradcheck(";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(inp,";
    "Fxn:test_shape" -> "Fxn:test_cpu_against_cuda(N,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(C,";
    "Fxn:test_shape" -> "Fxn:IW).transpose(0,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(D,";
    "Fxn:test_shape" -> "Fxn:3).transpose(0,";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cpu,";
    "Fxn:test_shape" -> "Fxn:self.assertTrue(out_cpu.size()";
    "Fxn:test_shape" -> "Fxn:torch.Size([N,";
    "Fxn:test_shape" -> "Fxn:Variable(input_cpu.data.transpose(0,";
    "Fxn:test_shape" -> "Fxn:1).cuda().transpose(0,";
    "Fxn:test_shape" -> "Fxn:Variable(grid_cpu.data.transpose(0,";
    "Fxn:test_shape" -> "Fxn:1).cuda().transpose(0,";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cuda,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(out_cpu,";
    "Fxn:test_shape" -> "Fxn:out_cpu.data.new(out_cpu.size()).normal_()";
    "Fxn:test_shape" -> "Fxn:out_cpu.backward(gradients)";
    "Fxn:test_shape" -> "Fxn:out_cuda.backward(gradients.cuda())";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(input_cpu.grad,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(grid_cpu.grad,";
    "Fxn:test_shape" -> "Fxn:torch.randn(C,";
    "Fxn:test_shape" -> "Fxn:Variable(base_input.expand(input_cuda.size()),";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cpu,";
    "Fxn:test_shape" -> "Fxn:Variable(base_input.cuda().expand(input_cuda.size()),";
    "Fxn:test_shape" -> "Fxn:Variable(grid_cpu.data.cuda(),";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(input_cuda,";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(out_cpu,";
    "Fxn:test_shape" -> "Fxn:test_shape(N,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(ID";
    "Fxn:test_shape" -> "Fxn:random.randint(IH";
    "Fxn:test_shape" -> "Fxn:random.randint(IW";
    "Fxn:test_shape" -> "Fxn:test_shape(N,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:test_shape(N,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:random.randint(1,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_shape" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_shape" -> "Fxn:self.assertTrue(gradcheck(";
    "Fxn:test_shape" -> "Fxn:F.grid_sample(inp,";
    "Fxn:test_shape" -> "Fxn:test_cpu_against_cuda(N,";
    "Fxn:test_affine_grid" -> "Fxn:Variable(torch.arange(1,";
    "Fxn:test_affine_grid" -> "Fxn:7).view(1,";
    "Fxn:test_affine_grid" -> "Fxn:F.affine_grid(input,";
    "Fxn:test_affine_grid" -> "Fxn:torch.Size([1,";
    "Fxn:test_affine_grid" -> "Fxn:torch.Tensor(";
    "Fxn:test_affine_grid" -> "Fxn:15]]]).view(1,";
    "Fxn:test_affine_grid" -> "Fxn:self.assertEqual(output.data,";
    "Fxn:test_affine_grid" -> "Fxn:random.randint(1,";
    "Fxn:test_affine_grid" -> "Fxn:random.randint(1,";
    "Fxn:test_affine_grid" -> "Fxn:random.randint(1,";
    "Fxn:test_affine_grid" -> "Fxn:random.randint(1,";
    "Fxn:test_affine_grid" -> "Fxn:torch.Size([N,";
    "Fxn:test_affine_grid" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_affine_grid" -> "Fxn:self.assertTrue(gradcheck(lambda";
    "Fxn:test_affine_grid" -> "Fxn:F.affine_grid(inp,";
    "Fxn:test_affine_grid" -> "Fxn:Variable(torch.randn(N,";
    "Fxn:test_affine_grid" -> "Fxn:F.affine_grid(input_cpu,";
    "Fxn:test_affine_grid" -> "Fxn:torch.randn(out_cpu.size())";
    "Fxn:test_affine_grid" -> "Fxn:out_cpu.backward(gradients)";
    "Fxn:test_affine_grid" -> "Fxn:Variable(input_cpu.data.cuda(),";
    "Fxn:test_affine_grid" -> "Fxn:F.affine_grid(input_gpu,";
    "Fxn:test_affine_grid" -> "Fxn:out_cuda.backward(gradients.cuda())";
    "Fxn:test_affine_grid" -> "Fxn:self.assertEqual(out_cpu,";
    "Fxn:test_affine_grid" -> "Fxn:self.assertEqual(input_cpu.grad,";
    "Fxn:test_upsamplingNearest1d" -> "Fxn:nn.Upsample(size=4,";
    "Fxn:test_upsamplingNearest1d" -> "Fxn:torch.ones(1,";
    "Fxn:test_upsamplingNearest1d" -> "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:test_upsamplingNearest1d" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_upsamplingNearest1d" -> "Fxn:gradcheck(lambda";
    "Fxn:test_upsamplingNearest1d" -> "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingLinear1d" -> "Fxn:nn.Upsample(size=4,";
    "Fxn:test_upsamplingLinear1d" -> "Fxn:torch.ones(1,";
    "Fxn:test_upsamplingLinear1d" -> "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:test_upsamplingLinear1d" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_upsamplingLinear1d" -> "Fxn:gradcheck(lambda";
    "Fxn:test_upsamplingLinear1d" -> "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:nn.Upsample(size=4,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:torch.ones(1,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:self.assertEqual(";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:F.upsample(input,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:F.upsample(input,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:gradcheck(lambda";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:gradgradcheck(lambda";
    "Fxn:test_upsamplingNearest2d" -> "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingBilinear2d" -> "Fxn:nn.Upsample(size=4,";
    "Fxn:test_upsamplingBilinear2d" -> "Fxn:torch.ones(1,";
    "Fxn:test_upsamplingBilinear2d" -> "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:test_upsamplingBilinear2d" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_upsamplingBilinear2d" -> "Fxn:gradcheck(lambda";
    "Fxn:test_upsamplingBilinear2d" -> "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingNearest3d" -> "Fxn:nn.Upsample(size=4,";
    "Fxn:test_upsamplingNearest3d" -> "Fxn:torch.ones(1,";
    "Fxn:test_upsamplingNearest3d" -> "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:test_upsamplingNearest3d" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_upsamplingNearest3d" -> "Fxn:gradcheck(lambda";
    "Fxn:test_upsamplingNearest3d" -> "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:nn.Upsample(size=4,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:torch.ones(1,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:self.assertEqual(torch.ones(1,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:Variable(torch.randn(1,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:self.assertEqual(";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:F.upsample(input,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:F.upsample(input,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:gradcheck(lambda";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:F.upsample(x,";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:gradgradcheck(lambda";
    "Fxn:test_upsamplingTrilinear3d" -> "Fxn:F.upsample(x,";
    "Fxn:test_linear_broadcasting" -> "Fxn:nn.Linear(5,";
    "Fxn:test_linear_broadcasting" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:test_linear_broadcasting" -> "Fxn:5)).view(2,";
    "Fxn:test_linear_broadcasting" -> "Fxn:self.assertEqual(expected,";
    "Fxn:test_bilinear" -> "Fxn:nn.Bilinear(10,";
    "Fxn:test_bilinear" -> "Fxn:legacy.Bilinear(10,";
    "Fxn:test_bilinear" -> "Fxn:module_legacy.weight.copy_(module.weight.data)";
    "Fxn:test_bilinear" -> "Fxn:module_legacy.bias.copy_(module.bias.data)";
    "Fxn:test_bilinear" -> "Fxn:torch.randn(4,";
    "Fxn:test_bilinear" -> "Fxn:torch.randn(4,";
    "Fxn:test_bilinear" -> "Fxn:module(Variable(input1),";
    "Fxn:test_bilinear" -> "Fxn:Variable(input2))";
    "Fxn:test_bilinear" -> "Fxn:module_legacy.forward([input1,";
    "Fxn:test_bilinear" -> "Fxn:self.assertEqual(output.data,";
    "Fxn:test_bilinear" -> "Fxn:Variable(input1,";
    "Fxn:test_bilinear" -> "Fxn:Variable(input2,";
    "Fxn:test_bilinear" -> "Fxn:module.zero_grad()";
    "Fxn:test_bilinear" -> "Fxn:module_legacy.zeroGradParameters()";
    "Fxn:test_bilinear" -> "Fxn:module(input1_1,";
    "Fxn:test_bilinear" -> "Fxn:torch.randn(*output.size())";
    "Fxn:test_bilinear" -> "Fxn:module_legacy.backward([input1,";
    "Fxn:test_bilinear" -> "Fxn:output.backward(grad_output)";
    "Fxn:test_bilinear" -> "Fxn:input1_1.grad.data.clone()";
    "Fxn:test_bilinear" -> "Fxn:input2_1.grad.data.clone()";
    "Fxn:test_bilinear" -> "Fxn:self.assertEqual(gi1,";
    "Fxn:test_bilinear" -> "Fxn:self.assertEqual(gi2,";
    "Fxn:test_bilinear" -> "Fxn:self.assertEqual(module.weight.grad.data,";
    "Fxn:test_bilinear" -> "Fxn:self.assertEqual(module.bias.grad.data,";
    "Fxn:test_bilinear" -> "Fxn:_assertGradAndGradgradChecks(self,";
    "Fxn:test_bilinear" -> "Fxn:F.bilinear(x1,";
    "Fxn:test_conv_tbc" -> "Fxn:Variable(torch.randn(9,";
    "Fxn:test_conv_tbc" -> "Fxn:Variable(torch.randn(3,";
    "Fxn:test_conv_tbc" -> "Fxn:Variable(torch.randn(6),";
    "Fxn:test_conv_tbc" -> "Fxn:gradcheck(lambda";
    "Fxn:test_conv_tbc" -> "Fxn:F.conv_tbc(i,";
    "Fxn:run_conv_double_back_test" -> "Fxn:torch.Tensor(1)";
    "Fxn:run_conv_double_back_test" -> "Fxn:tensor.cuda()";
    "Fxn:run_conv_double_back_test" -> "Fxn:Variable(tensor.new(batch_size,";
    "Fxn:run_conv_double_back_test" -> "Fxn:x.data.normal_()";
    "Fxn:run_conv_double_back_test" -> "Fxn:Variable(tensor.new(chan_out,";
    "Fxn:run_conv_double_back_test" -> "Fxn:weight.data.normal_()";
    "Fxn:run_conv_double_back_test" -> "Fxn:Variable(tensor.new(chan_out),";
    "Fxn:run_conv_double_back_test" -> "Fxn:bias.data.normal_()";
    "Fxn:func" -> "Fxn:cudnn.flags(enabled=False):";
    "Fxn:func" -> "Fxn:F.conv2d(lx,";
    "Fxn:func" -> "Fxn:func(*inputs)";
    "Fxn:func" -> "Fxn:Variable(tensor.new(dummy_out.size()),";
    "Fxn:func" -> "Fxn:grad_y.data.normal_()";
    "Fxn:func" -> "Fxn:gradgradcheck(func,";
    "Fxn:test_conv_double_backward" -> "Fxn:[(3,";
    "Fxn:test_conv_double_backward" -> "Fxn:product([1,";
    "Fxn:test_conv_double_backward" -> "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:test_conv_double_backward" -> "Fxn:self.assertTrue(result,";
    "Fxn:test_conv_double_backward_no_bias" -> "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:test_conv_double_backward_no_bias" -> "Fxn:self.assertTrue(result,";
    "Fxn:test_conv_double_backward_groups" -> "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:test_conv_double_backward_groups" -> "Fxn:self.assertTrue(result,";
    "Fxn:test_conv_double_backward_stride" -> "Fxn:[(3,";
    "Fxn:test_conv_double_backward_stride" -> "Fxn:product([2],";
    "Fxn:test_conv_double_backward_stride" -> "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:test_conv_double_backward_stride" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:contiguous()";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:Variable(torch.cuda.DoubleTensor([1,";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:1]).view(1,";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:Variable(torch.cuda.DoubleTensor([1]).expand(1,";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:Variable(torch.cuda.DoubleTensor([1]).expand(1,";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:2)).contiguous()";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:self.assertEqual(F.conv1d(input,";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:F.conv1d(input,";
    "Fxn:test_cudnn_noncontiguous_weight" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_conv_double_backward_cuda" -> "Fxn:[(3,";
    "Fxn:test_conv_double_backward_cuda" -> "Fxn:product([1],";
    "Fxn:test_conv_double_backward_cuda" -> "Fxn:self.run_conv_double_back_test(kern,";
    "Fxn:test_conv_double_backward_cuda" -> "Fxn:self.assertTrue(result,";
    "class:TestNNInit(TestCase):" -> "Fxn:setUp";
    "class:TestNNInit(TestCase):" -> "Fxn:_is_normal";
    "class:TestNNInit(TestCase):" -> "Fxn:_is_uniform";
    "class:TestNNInit(TestCase):" -> "Fxn:_create_random_nd_tensor";
    "class:TestNNInit(TestCase):" -> "Fxn:_random_float";
    "class:TestNNInit(TestCase):" -> "Fxn:test_calculate_gain_linear";
    "class:TestNNInit(TestCase):" -> "Fxn:test_calculate_gain_nonlinear";
    "class:TestNNInit(TestCase):" -> "Fxn:test_calculate_gain_leaky_relu";
    "class:TestNNInit(TestCase):" -> "Fxn:test_calculate_gain_leaky_relu_only_accepts_numbers";
    "class:TestNNInit(TestCase):" -> "Fxn:test_calculate_gain_only_accepts_valid_nonlinearities";
    "class:TestNNInit(TestCase):" -> "Fxn:test_uniform";
    "class:TestNNInit(TestCase):" -> "Fxn:test_normal";
    "class:TestNNInit(TestCase):" -> "Fxn:test_constant";
    "class:TestNNInit(TestCase):" -> "Fxn:test_eye";
    "class:TestNNInit(TestCase):" -> "Fxn:test_eye_only_works_on_2d_inputs";
    "class:TestNNInit(TestCase):" -> "Fxn:test_dirac_properties";
    "class:TestNNInit(TestCase):" -> "Fxn:test_dirac_identity";
    "class:TestNNInit(TestCase):" -> "Fxn:test_dirac_only_works_on_3_4_5d_inputs";
    "class:TestNNInit(TestCase):" -> "Fxn:test_xavier_uniform_errors_on_inputs_smaller_than_2d";
    "class:TestNNInit(TestCase):" -> "Fxn:test_xavier_normal_errors_on_inputs_smaller_than_2d";
    "class:TestNNInit(TestCase):" -> "Fxn:test_xavier_uniform";
    "class:TestNNInit(TestCase):" -> "Fxn:test_xavier_normal";
    "class:TestNNInit(TestCase):" -> "Fxn:test_kaiming_uniform_errors_on_inputs_smaller_than_2d";
    "class:TestNNInit(TestCase):" -> "Fxn:test_kaiming_normal_errors_on_inputs_smaller_than_2d";
    "class:TestNNInit(TestCase):" -> "Fxn:test_kaiming_uniform";
    "class:TestNNInit(TestCase):" -> "Fxn:test_kaiming_normal";
    "class:TestNNInit(TestCase):" -> "Fxn:test_sparse_only_works_on_2d_inputs";
    "class:TestNNInit(TestCase):" -> "Fxn:test_sparse_default_std";
    "class:TestNNInit(TestCase):" -> "Fxn:test_orthogonal";
    "class:TestNNInit(TestCase):" -> "Fxn:_rand_tensor_non_equal";
    "class:TestNNInit(TestCase):" -> "Fxn:add_test";
    "class:TestNNInit(TestCase):" -> "Fxn:wrap_functional";
    "Fxn:setUp" -> "Fxn:self).setUp()";
    "Fxn:setUp" -> "Fxn:random.seed(123)";
    "Fxn:_is_normal" -> "Fxn:tensor.view(-1).tolist()";
    "Fxn:_is_normal" -> "Fxn:stats.kstest(samples,";
    "Fxn:_is_normal" -> "Fxn:args=(mean,";
    "Fxn:_is_uniform" -> "Fxn:tensor.view(-1).tolist()";
    "Fxn:_is_uniform" -> "Fxn:stats.kstest(samples,";
    "Fxn:_is_uniform" -> "Fxn:args=(a,";
    "Fxn:_create_random_nd_tensor" -> "Fxn:[random.randint(size_min,";
    "Fxn:_create_random_nd_tensor" -> "Fxn:torch.zeros(size)";
    "Fxn:_create_random_nd_tensor" -> "Fxn:Variable(tensor)";
    "Fxn:_random_float" -> "Fxn:random.random()";
    "Fxn:test_calculate_gain_linear" -> "Fxn:init.calculate_gain(fn)";
    "Fxn:test_calculate_gain_linear" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_nonlinear" -> "Fxn:init.calculate_gain(fn)";
    "Fxn:test_calculate_gain_nonlinear" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_nonlinear" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_nonlinear" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_nonlinear" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_leaky_relu" -> "Fxn:init.calculate_gain('leaky_relu',";
    "Fxn:test_calculate_gain_leaky_relu" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_leaky_relu" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_leaky_relu" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_leaky_relu" -> "Fxn:self.assertEqual(gain,";
    "Fxn:test_calculate_gain_leaky_relu_only_accepts_numbers" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_calculate_gain_leaky_relu_only_accepts_numbers" -> "Fxn:init.calculate_gain('leaky_relu',";
    "Fxn:test_calculate_gain_only_accepts_valid_nonlinearities" -> "Fxn:''.join([random.choice(string.ascii_lowercase)";
    "Fxn:test_calculate_gain_only_accepts_valid_nonlinearities" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_calculate_gain_only_accepts_valid_nonlinearities" -> "Fxn:init.calculate_gain(random_string)";
    "Fxn:test_calculate_gain_only_accepts_valid_nonlinearities" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_uniform" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_uniform" -> "Fxn:self._random_float(-3,";
    "Fxn:test_uniform" -> "Fxn:self._random_float(1,";
    "Fxn:test_uniform" -> "Fxn:init.uniform(input_tensor,";
    "Fxn:test_uniform" -> "Fxn:self._is_uniform(input_tensor,";
    "Fxn:test_uniform" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_normal" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_normal" -> "Fxn:self._random_float(-3,";
    "Fxn:test_normal" -> "Fxn:self._random_float(1,";
    "Fxn:test_normal" -> "Fxn:init.normal(input_tensor,";
    "Fxn:test_normal" -> "Fxn:self._is_normal(input_tensor,";
    "Fxn:test_constant" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_constant" -> "Fxn:self._random_float(1,";
    "Fxn:test_constant" -> "Fxn:init.constant(input_tensor,";
    "Fxn:test_constant" -> "Fxn:self.assertEqual(input_tensor,";
    "Fxn:test_constant" -> "Fxn:input_tensor.clone().fill_(val))";
    "Fxn:test_eye" -> "Fxn:self._create_random_nd_tensor(2,";
    "Fxn:test_eye" -> "Fxn:init.eye(input_tensor)";
    "Fxn:test_eye_only_works_on_2d_inputs" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_eye_only_works_on_2d_inputs" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_eye_only_works_on_2d_inputs" -> "Fxn:init.eye(tensor)";
    "Fxn:test_dirac_properties" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_dirac_properties" -> "Fxn:init.dirac(input_tensor)";
    "Fxn:test_dirac_properties" -> "Fxn:input_tensor.size(0),";
    "Fxn:test_dirac_properties" -> "Fxn:input_tensor.size(1)";
    "Fxn:test_dirac_properties" -> "Fxn:torch.nonzero(input_tensor).size(0)";
    "Fxn:test_dirac_properties" -> "Fxn:self.assertEqual(input_tensor.sum(),";
    "Fxn:test_dirac_identity" -> "Fxn:Variable(torch.randn(batch,";
    "Fxn:test_dirac_identity" -> "Fxn:Variable(torch.zeros(out_c,";
    "Fxn:test_dirac_identity" -> "Fxn:init.dirac(filter_var)";
    "Fxn:test_dirac_identity" -> "Fxn:F.conv1d(input_var,";
    "Fxn:test_dirac_identity" -> "Fxn:self.assertEqual(input_tensor[:,";
    "Fxn:test_dirac_identity" -> "Fxn:torch.nonzero(output_tensor[:,";
    "Fxn:test_dirac_identity" -> "Fxn::]).numel()";
    "Fxn:test_dirac_identity" -> "Fxn:Variable(torch.randn(batch,";
    "Fxn:test_dirac_identity" -> "Fxn:Variable(torch.zeros(out_c,";
    "Fxn:test_dirac_identity" -> "Fxn:init.dirac(filter_var)";
    "Fxn:test_dirac_identity" -> "Fxn:F.conv2d(input_var,";
    "Fxn:test_dirac_identity" -> "Fxn:self.assertEqual(input_tensor[:,";
    "Fxn:test_dirac_identity" -> "Fxn:torch.nonzero(output_tensor[:,";
    "Fxn:test_dirac_identity" -> "Fxn::]).numel()";
    "Fxn:test_dirac_identity" -> "Fxn:Variable(torch.randn(batch,";
    "Fxn:test_dirac_identity" -> "Fxn:Variable(torch.zeros(out_c,";
    "Fxn:test_dirac_identity" -> "Fxn:init.dirac(filter_var)";
    "Fxn:test_dirac_identity" -> "Fxn:F.conv3d(input_var,";
    "Fxn:test_dirac_identity" -> "Fxn:self.assertEqual(input_tensor[:,";
    "Fxn:test_dirac_identity" -> "Fxn:torch.nonzero(output_tensor[:,";
    "Fxn:test_dirac_identity" -> "Fxn::]).numel()";
    "Fxn:test_dirac_only_works_on_3_4_5d_inputs" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_dirac_only_works_on_3_4_5d_inputs" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_dirac_only_works_on_3_4_5d_inputs" -> "Fxn:init.dirac(tensor)";
    "Fxn:test_xavier_uniform_errors_on_inputs_smaller_than_2d" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_xavier_uniform_errors_on_inputs_smaller_than_2d" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_xavier_uniform_errors_on_inputs_smaller_than_2d" -> "Fxn:init.xavier_uniform(tensor)";
    "Fxn:test_xavier_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_xavier_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_xavier_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:init.xavier_normal(tensor)";
    "Fxn:test_xavier_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_xavier_uniform" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_xavier_uniform" -> "Fxn:self._random_float(0.1,";
    "Fxn:test_xavier_uniform" -> "Fxn:init.xavier_uniform(input_tensor,";
    "Fxn:test_xavier_uniform" -> "Fxn:init.xavier_uniform(input_tensor)";
    "Fxn:test_xavier_uniform" -> "Fxn:input_tensor.size(1)";
    "Fxn:test_xavier_uniform" -> "Fxn:input_tensor.size(0)";
    "Fxn:test_xavier_uniform" -> "Fxn:input_tensor.dim()";
    "Fxn:test_xavier_uniform" -> "Fxn:0].numel()";
    "Fxn:test_xavier_uniform" -> "Fxn:0].numel()";
    "Fxn:test_xavier_uniform" -> "Fxn:math.sqrt(2.0";
    "Fxn:test_xavier_uniform" -> "Fxn:math.sqrt(3)";
    "Fxn:test_xavier_uniform" -> "Fxn:self._is_uniform(input_tensor,";
    "Fxn:test_xavier_uniform" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_xavier_normal" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_xavier_normal" -> "Fxn:self._random_float(0.1,";
    "Fxn:test_xavier_normal" -> "Fxn:init.xavier_normal(input_tensor,";
    "Fxn:test_xavier_normal" -> "Fxn:init.xavier_normal(input_tensor)";
    "Fxn:test_xavier_normal" -> "Fxn:input_tensor.size(1)";
    "Fxn:test_xavier_normal" -> "Fxn:input_tensor.size(0)";
    "Fxn:test_xavier_normal" -> "Fxn:input_tensor.dim()";
    "Fxn:test_xavier_normal" -> "Fxn:0].numel()";
    "Fxn:test_xavier_normal" -> "Fxn:0].numel()";
    "Fxn:test_xavier_normal" -> "Fxn:math.sqrt(2.0";
    "Fxn:test_xavier_normal" -> "Fxn:self._is_normal(input_tensor,";
    "Fxn:test_kaiming_uniform_errors_on_inputs_smaller_than_2d" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_kaiming_uniform_errors_on_inputs_smaller_than_2d" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_kaiming_uniform_errors_on_inputs_smaller_than_2d" -> "Fxn:init.kaiming_uniform(tensor)";
    "Fxn:test_kaiming_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_kaiming_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_kaiming_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:init.kaiming_normal(tensor)";
    "Fxn:test_kaiming_normal_errors_on_inputs_smaller_than_2d" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_kaiming_uniform" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_kaiming_uniform" -> "Fxn:self._random_float(0.1,";
    "Fxn:test_kaiming_uniform" -> "Fxn:init.kaiming_uniform(input_tensor,";
    "Fxn:test_kaiming_uniform" -> "Fxn:init.kaiming_uniform(input_tensor,";
    "Fxn:test_kaiming_uniform" -> "Fxn:input_tensor.size(1)";
    "Fxn:test_kaiming_uniform" -> "Fxn:input_tensor.size(0)";
    "Fxn:test_kaiming_uniform" -> "Fxn:input_tensor.dim()";
    "Fxn:test_kaiming_uniform" -> "Fxn:0].numel()";
    "Fxn:test_kaiming_uniform" -> "Fxn:0].numel()";
    "Fxn:test_kaiming_uniform" -> "Fxn:math.sqrt(2.0";
    "Fxn:test_kaiming_uniform" -> "Fxn:math.sqrt(3.0)";
    "Fxn:test_kaiming_uniform" -> "Fxn:self._is_uniform(input_tensor,";
    "Fxn:test_kaiming_uniform" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_kaiming_normal" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_kaiming_normal" -> "Fxn:self._random_float(0.1,";
    "Fxn:test_kaiming_normal" -> "Fxn:init.kaiming_normal(input_tensor,";
    "Fxn:test_kaiming_normal" -> "Fxn:init.kaiming_normal(input_tensor,";
    "Fxn:test_kaiming_normal" -> "Fxn:input_tensor.size(1)";
    "Fxn:test_kaiming_normal" -> "Fxn:input_tensor.size(0)";
    "Fxn:test_kaiming_normal" -> "Fxn:input_tensor.dim()";
    "Fxn:test_kaiming_normal" -> "Fxn:0].numel()";
    "Fxn:test_kaiming_normal" -> "Fxn:0].numel()";
    "Fxn:test_kaiming_normal" -> "Fxn:math.sqrt(2.0";
    "Fxn:test_kaiming_normal" -> "Fxn:self._is_normal(input_tensor,";
    "Fxn:test_sparse_only_works_on_2d_inputs" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_sparse_only_works_on_2d_inputs" -> "Fxn:self._random_float(0.1,";
    "Fxn:test_sparse_only_works_on_2d_inputs" -> "Fxn:self._create_random_nd_tensor(dims,";
    "Fxn:test_sparse_only_works_on_2d_inputs" -> "Fxn:init.sparse(tensor,";
    "Fxn:test_sparse_only_works_on_2d_inputs" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_sparse_default_std" -> "Fxn:self._create_random_nd_tensor(2,";
    "Fxn:test_sparse_default_std" -> "Fxn:input_tensor.size(0),";
    "Fxn:test_sparse_default_std" -> "Fxn:input_tensor.size(1)";
    "Fxn:test_sparse_default_std" -> "Fxn:self._random_float(0.1,";
    "Fxn:test_sparse_default_std" -> "Fxn:self._random_float(0.01,";
    "Fxn:test_sparse_default_std" -> "Fxn:init.sparse(input_tensor,";
    "Fxn:test_sparse_default_std" -> "Fxn:init.sparse(input_tensor,";
    "Fxn:test_sparse_default_std" -> "Fxn:0].nelement()";
    "Fxn:test_sparse_default_std" -> "Fxn:math.ceil(sparsity";
    "Fxn:test_sparse_default_std" -> "Fxn:self._is_normal(input_tensor[input_tensor";
    "Fxn:test_orthogonal" -> "Fxn:torch.zeros(tensor_size)";
    "Fxn:test_orthogonal" -> "Fxn:Variable(input_tensor)";
    "Fxn:test_orthogonal" -> "Fxn:self._random_float(0.1,";
    "Fxn:test_orthogonal" -> "Fxn:init.orthogonal(input_tensor,";
    "Fxn:test_orthogonal" -> "Fxn:init.orthogonal(input_tensor)";
    "Fxn:test_orthogonal" -> "Fxn:reduce(mul,";
    "Fxn:test_orthogonal" -> "Fxn:input_tensor.view(rows,";
    "Fxn:test_orthogonal" -> "Fxn:self.assertEqual(torch.mm(flattened_tensor.t(),";
    "Fxn:test_orthogonal" -> "Fxn:torch.eye(cols)";
    "Fxn:test_orthogonal" -> "Fxn:self.assertEqual(torch.mm(flattened_tensor,";
    "Fxn:test_orthogonal" -> "Fxn:flattened_tensor.t()),";
    "Fxn:test_orthogonal" -> "Fxn:torch.eye(rows)";
    "Fxn:_rand_tensor_non_equal" -> "Fxn:reduce(mul,";
    "Fxn:_rand_tensor_non_equal" -> "Fxn:torch.randperm(total).view(*size).double()";
    "Fxn:add_test" -> "Fxn:test.get_name()";
    "Fxn:add_test" -> "Fxn:RuntimeError('Found";
    "Fxn:add_test" -> "Fxn:RuntimeError('Found";
    "Fxn:add_test" -> "Fxn:test(self))";
    "Fxn:add_test" -> "Fxn:test_name.startswith("test_Hardshrink"):";
    "Fxn:add_test" -> "Fxn:test.test_cuda(self))";
    "class:FunctionalModule(nn.Module):" -> "Fxn:forward";
    "class:FunctionalModule(nn.Module):" -> "Fxn:poissonnllloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:bceloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:bceloss_no_reduce_scalar_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:bceloss_weights_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:bceloss_weights_no_reduce_scalar_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:bce_with_logistic_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:bce_with_logistic_no_reduce_scalar_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:kldivloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:kldivloss_no_reduce_scalar_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:l1loss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:l1loss_no_reduce_scalar_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:mseloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:mseloss_no_reduce_scalar_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss_no_reduce_ignore_index_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss_no_reduce_weights_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:kwargs";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss_no_reduce_weights_ignore_index_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:kwargs";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss_no_reduce_weights_ignore_index_neg_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:kwargs";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss2d_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss2d_no_reduce_ignore_index_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nllloss2d_no_reduce_weights_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:kwargs";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nlllossNd_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nlllossNd_no_reduce_ignore_index_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:nlllossNd_no_reduce_weights_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:kwargs";
    "class:FunctionalModule(nn.Module):" -> "Fxn:smoothl1loss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:smoothl1loss_no_reduce_scalar_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multilabelmarginloss_1d_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multilabelmarginloss_index_neg_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multilabelmarginloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:hingeembeddingloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:hingeembeddingloss_margin_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:softmarginloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multilabelsoftmarginloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multilabelsoftmarginloss_weights_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multimarginloss_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multimarginloss_1d_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multimarginloss_p_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multimarginloss_margin_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:multimarginloss_weights_no_reduce_test";
    "class:FunctionalModule(nn.Module):" -> "Fxn:gen_eval_constructor";
    "class:FunctionalModule(nn.Module):" -> "Fxn:eval_constructor";
    "class:FunctionalModule(nn.Module):" -> "Fxn:gen_no_size_average_constructor";
    "class:FunctionalModule(nn.Module):" -> "Fxn:no_size_average_constructor";
    "Fxn:forward" -> "Fxn:fn(*args,";
    "Fxn:forward" -> "Fxn:torch.rand(15,";
    "Fxn:forward" -> "Fxn:10).clamp_(1e-2,";
    "Fxn:forward" -> "Fxn:torch.randn(15,";
    "Fxn:forward" -> "Fxn:10).gt(0).double()";
    "Fxn:forward" -> "Fxn:constructor_args=(torch.rand(10),),";
    "Fxn:forward" -> "Fxn:torch.rand(15,";
    "Fxn:forward" -> "Fxn:10).clamp_(1e-2,";
    "Fxn:forward" -> "Fxn:torch.randn(15,";
    "Fxn:forward" -> "Fxn:10).gt(0).double(),";
    "Fxn:forward" -> "Fxn:constructor_args=(torch.rand(()),),";
    "Fxn:forward" -> "Fxn:torch.rand(()).clamp_(1e-2,";
    "Fxn:forward" -> "Fxn:torch.randn(()).gt(0).double(),";
    "Fxn:forward" -> "Fxn:input_size=(2,";
    "Fxn:forward" -> "Fxn:torch.rand(2,";
    "Fxn:forward" -> "Fxn:5).mul(3).floor().long(),";
    "Fxn:forward" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:forward" -> "Fxn:size_average=get_size_average(m)),";
    "Fxn:forward" -> "Fxn:input_size=(2,";
    "Fxn:forward" -> "Fxn:target=torch.rand(2,";
    "Fxn:forward" -> "Fxn:5).mul(3).floor().long(),";
    "Fxn:forward" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:forward" -> "Fxn:weight=get_weight(m)),";
    "Fxn:forward" -> "Fxn:constructor_args=(None,";
    "Fxn:forward" -> "Fxn:input_size=(2,";
    "Fxn:forward" -> "Fxn:torch.rand(2,";
    "Fxn:forward" -> "Fxn:5).mul(3).floor().long(),";
    "Fxn:forward" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:forward" -> "Fxn:input_size=(2,";
    "Fxn:forward" -> "Fxn:torch.rand(2,";
    "Fxn:forward" -> "Fxn:2).mul(3).floor().long(),";
    "Fxn:forward" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:forward" -> "Fxn:size_average=get_size_average(m)),";
    "Fxn:forward" -> "Fxn:input_size=(2,";
    "Fxn:forward" -> "Fxn:torch.rand(2,";
    "Fxn:forward" -> "Fxn:5).mul(3).floor().long(),";
    "Fxn:forward" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:forward" -> "Fxn:size_average=get_size_average(m)),";
    "Fxn:forward" -> "Fxn:input_size=(2,";
    "Fxn:forward" -> "Fxn:torch.randn(2,";
    "Fxn:forward" -> "Fxn:5).floor_().abs_(),";
    "Fxn:forward" -> "Fxn:constructor_args=(False,";
    "Fxn:forward" -> "Fxn:torch.randn(2,";
    "Fxn:forward" -> "Fxn:5).abs_().add_(0.001),";
    "Fxn:forward" -> "Fxn:torch.randn(2,";
    "Fxn:forward" -> "Fxn:5).floor_().abs_(),";
    "Fxn:forward" -> "Fxn:input_size=(),";
    "Fxn:forward" -> "Fxn:target_size=(),";
    "Fxn:forward" -> "Fxn:i.numel()";
    "Fxn:forward" -> "Fxn:t).abs().sum(),";
    "Fxn:forward" -> "Fxn:torch.rand(()).log(),";
    "Fxn:forward" -> "Fxn:torch.rand(()),";
    "Fxn:forward" -> "Fxn:kldivloss_reference(i,";
    "Fxn:forward" -> "Fxn:get_size_average(m),";
    "Fxn:forward" -> "Fxn:input_size=(),";
    "Fxn:forward" -> "Fxn:target_size=(),";
    "Fxn:forward" -> "Fxn:t).abs().pow(2).sum()";
    "Fxn:forward" -> "Fxn:get_size_average(m)";
    "Fxn:forward" -> "Fxn:torch.rand(()).clamp_(1e-2,";
    "Fxn:forward" -> "Fxn:torch.rand(()).gt(0).double(),";
    "Fxn:forward" -> "Fxn:-((t";
    "Fxn:forward" -> "Fxn:i.log()";
    "Fxn:forward" -> "Fxn:i).log())";
    "Fxn:forward" -> "Fxn:get_weight(m)).sum()";
    "Fxn:forward" -> "Fxn:get_size_average(m)";
    "Fxn:forward" -> "Fxn:constructor_args=(0.5,),";
    "Fxn:forward" -> "Fxn:input_size=(),";
    "Fxn:forward" -> "Fxn:torch.randn(()).gt(0).double().mul_(2).sub(1),";
    "Fxn:forward" -> "Fxn:input_size=(),";
    "Fxn:forward" -> "Fxn:target_size=(),";
    "Fxn:forward" -> "Fxn:smoothl1loss_reference(i,";
    "Fxn:forward" -> "Fxn:size_average=get_size_average(m)),";
    "Fxn:forward" -> "Fxn:constructor_args=(torch.rand(10),),";
    "Fxn:forward" -> "Fxn:torch.randn(5,";
    "Fxn:forward" -> "Fxn:torch.rand(5,";
    "Fxn:forward" -> "Fxn:10).mul(2).floor(),";
    "Fxn:forward" -> "Fxn:-((t";
    "Fxn:forward" -> "Fxn:i.sigmoid().log()";
    "Fxn:forward" -> "Fxn:get_weight(m)).sum()";
    "Fxn:forward" -> "Fxn:get_size_average(m)";
    "Fxn:poissonnllloss_no_reduce_test" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:poissonnllloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:poissonnllloss_no_reduce_test" -> "Fxn:F.poisson_nll_loss(i,";
    "Fxn:poissonnllloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:poissonnllloss_no_reduce_test" -> "Fxn:torch.rand(10,";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:Variable(torch.randn(15,";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:10).gt(0).double())";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:F.binary_cross_entropy(i,";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:torch.rand(15,";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:10).clamp_(2.8e-2,";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:-(t";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:i.log()";
    "Fxn:bceloss_no_reduce_test" -> "Fxn:i).log()),";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:torch.randn(()).gt(0).double()";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:F.binary_cross_entropy(i,";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:torch.rand(()).clamp_(2.8e-2,";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:-(t";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:i.log()";
    "Fxn:bceloss_no_reduce_scalar_test" -> "Fxn:i).log()),";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:Variable(torch.randn(15,";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:10).gt(0).double())";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:Variable(torch.rand(10))";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:F.binary_cross_entropy(i,";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:weight=weights.type_as(i),";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:torch.rand(15,";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:10).clamp_(2.8e-2,";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:-(t";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:i.log()";
    "Fxn:bceloss_weights_no_reduce_test" -> "Fxn:i).log())";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:torch.randn(()).double()";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:torch.rand(())";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:F.binary_cross_entropy(i,";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:weight=weights.type_as(i),";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:torch.rand(()).clamp_(2.8e-2,";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:-(t";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:i.log()";
    "Fxn:bceloss_weights_no_reduce_scalar_test" -> "Fxn:i).log())";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:Variable(torch.randn(15,";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:10).gt(0).double())";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:nn.Sigmoid()";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:F.binary_cross_entropy_with_logits(i,";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:torch.rand(15,";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:10).clamp_(2.8e-2,";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:-(t";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:sigmoid(i).log()";
    "Fxn:bce_with_logistic_no_reduce_test" -> "Fxn:sigmoid(i)).log()),";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:torch.randn(()).gt(0).double()";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:nn.Sigmoid()";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:F.binary_cross_entropy_with_logits(i,";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:torch.rand(()).clamp_(2.8e-2,";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:-(t";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:sigmoid(i).log()";
    "Fxn:bce_with_logistic_no_reduce_scalar_test" -> "Fxn:sigmoid(i)).log()),";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:Variable(torch.randn(10,";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:F.kl_div(i,";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:torch.rand(10,";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:10).log(),";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:loss_reference_fns['KLDivLoss'](i,";
    "Fxn:kldivloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:kldivloss_no_reduce_scalar_test" -> "Fxn:torch.randn(())";
    "Fxn:kldivloss_no_reduce_scalar_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:kldivloss_no_reduce_scalar_test" -> "Fxn:F.kl_div(i,";
    "Fxn:kldivloss_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:kldivloss_no_reduce_scalar_test" -> "Fxn:torch.rand(()).log(),";
    "Fxn:kldivloss_no_reduce_scalar_test" -> "Fxn:loss_reference_fns['KLDivLoss'](i,";
    "Fxn:kldivloss_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:l1loss_no_reduce_test" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:l1loss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:l1loss_no_reduce_test" -> "Fxn:F.l1_loss(i,";
    "Fxn:l1loss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:l1loss_no_reduce_test" -> "Fxn:torch.randn(2,";
    "Fxn:l1loss_no_reduce_test" -> "Fxn:t.type_as(i)).abs(),";
    "Fxn:l1loss_no_reduce_scalar_test" -> "Fxn:torch.randn(())";
    "Fxn:l1loss_no_reduce_scalar_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:l1loss_no_reduce_scalar_test" -> "Fxn:F.l1_loss(i,";
    "Fxn:l1loss_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:l1loss_no_reduce_scalar_test" -> "Fxn:torch.randn(()),";
    "Fxn:l1loss_no_reduce_scalar_test" -> "Fxn:t.type_as(i)).abs(),";
    "Fxn:mseloss_no_reduce_test" -> "Fxn:Variable(torch.randn(*input_size))";
    "Fxn:mseloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:mseloss_no_reduce_test" -> "Fxn:F.mse_loss(i,";
    "Fxn:mseloss_no_reduce_test" -> "Fxn:target.type_as(i),";
    "Fxn:mseloss_no_reduce_test" -> "Fxn:target).pow(2),";
    "Fxn:mseloss_no_reduce_scalar_test" -> "Fxn:torch.randn(input_size)";
    "Fxn:mseloss_no_reduce_scalar_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:mseloss_no_reduce_scalar_test" -> "Fxn:F.mse_loss(i,";
    "Fxn:mseloss_no_reduce_scalar_test" -> "Fxn:target.type_as(i),";
    "Fxn:mseloss_no_reduce_scalar_test" -> "Fxn:target).pow(2),";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:F.nll_loss(i,";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:torch.rand(15,";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:10).log(),";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:nllloss_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:F.nll_loss(i,";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:torch.rand(15,";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:10).log(),";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:nllloss_no_reduce_ignore_index_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss_no_reduce_weights_test" -> "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:nllloss_no_reduce_weights_test" -> "Fxn:Variable(torch.rand(10))";
    "Fxn:kwargs" -> "Fxn:weight.type_as(i),";
    "Fxn:kwargs" -> "Fxn:constructor=wrap_functional(";
    "Fxn:kwargs" -> "Fxn:F.nll_loss(i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i))),";
    "Fxn:kwargs" -> "Fxn:torch.rand(15,";
    "Fxn:kwargs" -> "Fxn:10).add(1e-2).log(),";
    "Fxn:kwargs" -> "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i)),";
    "Fxn:nllloss_no_reduce_weights_ignore_index_test" -> "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:nllloss_no_reduce_weights_ignore_index_test" -> "Fxn:Variable(torch.rand(10))";
    "Fxn:kwargs" -> "Fxn:weight.type_as(i),";
    "Fxn:kwargs" -> "Fxn:constructor=wrap_functional(";
    "Fxn:kwargs" -> "Fxn:F.nll_loss(i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i.data))),";
    "Fxn:kwargs" -> "Fxn:torch.rand(15,";
    "Fxn:kwargs" -> "Fxn:10).add(1e-2).log(),";
    "Fxn:kwargs" -> "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i)),";
    "Fxn:nllloss_no_reduce_weights_ignore_index_neg_test" -> "Fxn:Variable(torch.Tensor(15).uniform_().mul(10).floor().long())";
    "Fxn:nllloss_no_reduce_weights_ignore_index_neg_test" -> "Fxn:Variable(torch.rand(10))";
    "Fxn:kwargs" -> "Fxn:weight.type_as(i),";
    "Fxn:kwargs" -> "Fxn:constructor=wrap_functional(";
    "Fxn:kwargs" -> "Fxn:F.nll_loss(i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i))),";
    "Fxn:kwargs" -> "Fxn:input=torch.rand(15,";
    "Fxn:kwargs" -> "Fxn:10).add(1e-2).log(),";
    "Fxn:kwargs" -> "Fxn:loss_reference_fns['NLLLoss'](i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i)),";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:5).mul(3).floor().long())";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:F.nll_loss(i,";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:torch.rand(2,";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:5).log(),";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:nllloss2d_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:5).mul(3).floor().long())";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:F.nll_loss(i,";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:torch.rand(2,";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:5).log(),";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:nllloss2d_no_reduce_ignore_index_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nllloss2d_no_reduce_weights_test" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:nllloss2d_no_reduce_weights_test" -> "Fxn:5).mul(3).floor().long())";
    "Fxn:nllloss2d_no_reduce_weights_test" -> "Fxn:torch.rand(3)";
    "Fxn:kwargs" -> "Fxn:weight.type_as(i),";
    "Fxn:kwargs" -> "Fxn:constructor=wrap_functional(";
    "Fxn:kwargs" -> "Fxn:F.nll_loss(i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i))),";
    "Fxn:kwargs" -> "Fxn:torch.rand(2,";
    "Fxn:kwargs" -> "Fxn:5).log(),";
    "Fxn:kwargs" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i)),";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:2).mul(3).floor().long())";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:F.nll_loss(i,";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:torch.rand(2,";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:2).log(),";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:nlllossNd_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:2).mul(3).floor().long())";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:F.nll_loss(i,";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:torch.rand(2,";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:2).log(),";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:nlllossNd_no_reduce_ignore_index_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:nlllossNd_no_reduce_weights_test" -> "Fxn:Variable(torch.rand(2,";
    "Fxn:nlllossNd_no_reduce_weights_test" -> "Fxn:2).mul(3).floor().long())";
    "Fxn:nlllossNd_no_reduce_weights_test" -> "Fxn:Variable(torch.rand(3))";
    "Fxn:kwargs" -> "Fxn:weight.type_as(i),";
    "Fxn:kwargs" -> "Fxn:constructor=wrap_functional(";
    "Fxn:kwargs" -> "Fxn:F.nll_loss(i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i))),";
    "Fxn:kwargs" -> "Fxn:torch.rand(2,";
    "Fxn:kwargs" -> "Fxn:2).log(),";
    "Fxn:kwargs" -> "Fxn:loss_reference_fns['NLLLossNd'](i,";
    "Fxn:kwargs" -> "Fxn:t.type_as(i).long(),";
    "Fxn:kwargs" -> "Fxn:**kwargs(i)),";
    "Fxn:smoothl1loss_no_reduce_test" -> "Fxn:Variable(torch.randn(2,";
    "Fxn:smoothl1loss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:smoothl1loss_no_reduce_test" -> "Fxn:F.smooth_l1_loss(i,";
    "Fxn:smoothl1loss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:smoothl1loss_no_reduce_test" -> "Fxn:torch.randn(2,";
    "Fxn:smoothl1loss_no_reduce_test" -> "Fxn:loss_reference_fns['SmoothL1Loss'](i,";
    "Fxn:smoothl1loss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:smoothl1loss_no_reduce_scalar_test" -> "Fxn:torch.randn(())";
    "Fxn:smoothl1loss_no_reduce_scalar_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:smoothl1loss_no_reduce_scalar_test" -> "Fxn:F.smooth_l1_loss(i,";
    "Fxn:smoothl1loss_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:smoothl1loss_no_reduce_scalar_test" -> "Fxn:torch.randn(()),";
    "Fxn:smoothl1loss_no_reduce_scalar_test" -> "Fxn:loss_reference_fns['SmoothL1Loss'](i,";
    "Fxn:smoothl1loss_no_reduce_scalar_test" -> "Fxn:t.type_as(i),";
    "Fxn:multilabelmarginloss_1d_no_reduce_test" -> "Fxn:Variable(torch.rand(10).mul(10).floor().long())";
    "Fxn:multilabelmarginloss_1d_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multilabelmarginloss_1d_no_reduce_test" -> "Fxn:F.multilabel_margin_loss(i,";
    "Fxn:multilabelmarginloss_1d_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multilabelmarginloss_1d_no_reduce_test" -> "Fxn:torch.randn(10),";
    "Fxn:multilabelmarginloss_1d_no_reduce_test" -> "Fxn:loss_reference_fns['MultiLabelMarginLoss'](i,";
    "Fxn:multilabelmarginloss_1d_no_reduce_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:Variable(torch.clamp(torch.rand(5,";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:10).add(-.5).mul(20).floor().long(),";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:F.multilabel_margin_loss(i,";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:torch.randn(5,";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:loss_reference_fns['MultiLabelMarginLoss'](i,";
    "Fxn:multilabelmarginloss_index_neg_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:Variable(torch.rand(5,";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:10).mul(10).floor().long())";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:F.multilabel_margin_loss(i,";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:loss_reference_fns['MultiLabelMarginLoss'](i,";
    "Fxn:multilabelmarginloss_no_reduce_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:hingeembeddingloss_no_reduce_test" -> "Fxn:Variable(torch.randn(10).gt(0).double().mul_(2).sub(1))";
    "Fxn:hingeembeddingloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:hingeembeddingloss_no_reduce_test" -> "Fxn:F.hinge_embedding_loss(i,";
    "Fxn:hingeembeddingloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:hingeembeddingloss_no_reduce_test" -> "Fxn:torch.randn(10),";
    "Fxn:hingeembeddingloss_no_reduce_test" -> "Fxn:loss_reference_fns['HingeEmbeddingLoss'](i,";
    "Fxn:hingeembeddingloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:hingeembeddingloss_margin_no_reduce_test" -> "Fxn:Variable(torch.randn(10).gt(0).double().mul_(2).sub(1))";
    "Fxn:hingeembeddingloss_margin_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:hingeembeddingloss_margin_no_reduce_test" -> "Fxn:F.hinge_embedding_loss(i,";
    "Fxn:hingeembeddingloss_margin_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:hingeembeddingloss_margin_no_reduce_test" -> "Fxn:torch.randn(10),";
    "Fxn:hingeembeddingloss_margin_no_reduce_test" -> "Fxn:loss_reference_fns['HingeEmbeddingLoss'](i,";
    "Fxn:hingeembeddingloss_margin_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:softmarginloss_no_reduce_test" -> "Fxn:Variable(torch.randn(5,";
    "Fxn:softmarginloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:softmarginloss_no_reduce_test" -> "Fxn:F.soft_margin_loss(i,";
    "Fxn:softmarginloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:softmarginloss_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:softmarginloss_no_reduce_test" -> "Fxn:loss_reference_fns['SoftMarginLoss'](i,";
    "Fxn:softmarginloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:Variable(torch.rand(5,";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:10).mul(2).floor())";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:F.multilabel_soft_margin_loss(i,";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:i.sigmoid().log()";
    "Fxn:multilabelsoftmarginloss_no_reduce_test" -> "Fxn:get_size_average(m)";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.rand(5,";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:10).mul(2).floor())";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.rand(10))";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:F.multilabel_soft_margin_loss(i,";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:t.type_as(i),";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:weight=weights.type_as(i),";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:i.sigmoid().log()";
    "Fxn:multilabelsoftmarginloss_weights_no_reduce_test" -> "Fxn:get_size_average(m)";
    "Fxn:multimarginloss_no_reduce_test" -> "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:multimarginloss_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multimarginloss_no_reduce_test" -> "Fxn:F.multi_margin_loss(i,";
    "Fxn:multimarginloss_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multimarginloss_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:multimarginloss_no_reduce_test" -> "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:multimarginloss_no_reduce_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_1d_no_reduce_test" -> "Fxn:Variable(torch.rand(1).mul(8).floor().long())";
    "Fxn:multimarginloss_1d_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multimarginloss_1d_no_reduce_test" -> "Fxn:F.multi_margin_loss(i,";
    "Fxn:multimarginloss_1d_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multimarginloss_1d_no_reduce_test" -> "Fxn:torch.randn(10),";
    "Fxn:multimarginloss_1d_no_reduce_test" -> "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:multimarginloss_1d_no_reduce_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:F.multi_margin_loss(i,";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:10).clamp_(1e-2,";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:multimarginloss_p_no_reduce_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_margin_no_reduce_test" -> "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:multimarginloss_margin_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multimarginloss_margin_no_reduce_test" -> "Fxn:F.multi_margin_loss(i,";
    "Fxn:multimarginloss_margin_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multimarginloss_margin_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:multimarginloss_margin_no_reduce_test" -> "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:multimarginloss_margin_no_reduce_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.rand(5).mul(8).floor().long())";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.rand(10))";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:F.multi_margin_loss(i,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:t.type_as(i).long(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:weight=weights.type_as(i),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.randn(5,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:loss_reference_fns['MultiMarginLoss'](i,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:t.data.type_as(i).long(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:poissonnllloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:bceloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:bceloss_weights_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:bce_with_logistic_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:bceloss_no_reduce_scalar_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:bceloss_weights_no_reduce_scalar_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:bce_with_logistic_no_reduce_scalar_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:kldivloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:kldivloss_no_reduce_scalar_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:l1loss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:l1loss_no_reduce_scalar_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:mseloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:mseloss_no_reduce_scalar_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss_no_reduce_ignore_index_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss_no_reduce_weights_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss_no_reduce_weights_ignore_index_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss_no_reduce_weights_ignore_index_neg_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss2d_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss2d_no_reduce_weights_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nllloss2d_no_reduce_ignore_index_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nlllossNd_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nlllossNd_no_reduce_weights_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nlllossNd_no_reduce_ignore_index_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:smoothl1loss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:smoothl1loss_no_reduce_scalar_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multilabelmarginloss_1d_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multilabelmarginloss_index_neg_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multilabelmarginloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:hingeembeddingloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:hingeembeddingloss_margin_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:softmarginloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multilabelsoftmarginloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multilabelsoftmarginloss_weights_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multimarginloss_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multimarginloss_1d_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multimarginloss_p_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multimarginloss_margin_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:multimarginloss_weights_no_reduce_test(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(10,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(5,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(10,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(10,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(5,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=([5],";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=([5],";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=([5],";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=([2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=([2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=([2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv1d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv1d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.ConvTranspose1d(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:stride=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:output_padding=(1,)),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.ConvTranspose1d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:stride=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:output_padding=(1,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv2d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv2d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.ConvTranspose2d(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv2d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv2d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv2d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:stride=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv2d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:padding=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv2d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:dilation=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((2,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(1.5,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.rand(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(1.5,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.rand(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((-1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv3d(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv3d(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Conv3d(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.EmbeddingBag(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Embedding(4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:Variable(torch.randperm(2).repeat(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.FractionalMaxPool2d(";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_random_samples=torch.DoubleTensor(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:2).uniform_()),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.FractionalMaxPool2d((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:output_size=(";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_random_samples=torch.DoubleTensor(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:2).uniform_()),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(12,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((4,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(None,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_rand_tensor_non_equal(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_rand_tensor_non_equal(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_rand_tensor_non_equal(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:_rand_tensor_non_equal(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.rand(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.rand(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.rand(1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(3,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.rand(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=((3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.rand(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(5,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(5,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor=wrap_functional(F.log_softmax,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Unfold((2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Fold((3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Unfold(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:nn.Fold(3,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(0.1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:i.clamp(-1,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(0,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.exp(i).div(torch.exp(i).sum(0,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(0,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.exp(i).div_(torch.exp(i).sum(0,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:False)).log_(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2.,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2.,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(0.5,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:i.sigmoid().log(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(2,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:reference_fn=(lambda";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:-100).type_as(i)";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:-100).type_as(i)";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.log(1";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.exp(2";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(1,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.clamp(i,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.clamp(i,";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:i.div(1";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:torch.abs(i)),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:constructor_args=(0,),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:input_size=(),";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:test_params.pop('module_name')";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:NewModuleTest(**test_params)";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:add_test(test)";
    "Fxn:multimarginloss_weights_no_reduce_test" -> "Fxn:test_params.get('desc',";
    "Fxn:eval_constructor" -> "Fxn:constructor(*args,";
    "Fxn:eval_constructor" -> "Fxn:gen_eval_constructor(test_params['constructor'])";
    "Fxn:eval_constructor" -> "Fxn:NewModuleTest(**test_params)";
    "Fxn:eval_constructor" -> "Fxn:add_test(test)";
    "Fxn:eval_constructor" -> "Fxn:test_params.pop('module_name')";
    "Fxn:eval_constructor" -> "Fxn:NewCriterionTest(**test_params)";
    "Fxn:eval_constructor" -> "Fxn:add_test(test)";
    "Fxn:eval_constructor" -> "Fxn:test_params.get('desc',";
    "Fxn:no_size_average_constructor" -> "Fxn:constructor(*args,";
    "Fxn:no_size_average_constructor" -> "Fxn:gen_no_size_average_constructor(test_params['constructor'])";
    "Fxn:no_size_average_constructor" -> "Fxn:NewCriterionTest(**test_params)";
    "Fxn:no_size_average_constructor" -> "Fxn:add_test(test)";
    "class:UnpoolingNet(nn.Module):" -> "Fxn:__init__";
    "class:UnpoolingNet(nn.Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:self.unpool(*self.pool(input))";
    "Fxn:forward" -> "Fxn:add_test(NewModuleTest(";
    "Fxn:forward" -> "Fxn:UnpoolingNet(";
    "Fxn:forward" -> "Fxn:nn.MaxPool1d(2,";
    "Fxn:forward" -> "Fxn:nn.MaxUnpool1d(2)),";
    "Fxn:forward" -> "Fxn:input_size=(1,";
    "Fxn:forward" -> "Fxn:add_test(NewModuleTest(";
    "Fxn:forward" -> "Fxn:UnpoolingNet(";
    "Fxn:forward" -> "Fxn:nn.MaxPool2d(2,";
    "Fxn:forward" -> "Fxn:nn.MaxUnpool2d(2)),";
    "Fxn:forward" -> "Fxn:input_size=(1,";
    "Fxn:forward" -> "Fxn:add_test(NewModuleTest(";
    "Fxn:forward" -> "Fxn:UnpoolingNet(";
    "Fxn:forward" -> "Fxn:nn.MaxPool3d(2,";
    "Fxn:forward" -> "Fxn:nn.MaxUnpool3d(2)),";
    "Fxn:forward" -> "Fxn:input_size=(1,";
    "Fxn:forward" -> "Fxn:run_tests()";
    "/test/test_optim.py" -> "Import:math";
    "/test/test_optim.py" -> "Import:unittest";
    "/test/test_optim.py" -> "Import:functools";
    "/test/test_optim.py" -> "Import:deepcopy";
    "/test/test_optim.py" -> "Import:torch";
    "/test/test_optim.py" -> "Import:torch.optim";
    "/test/test_optim.py" -> "Import:torch.legacy.optim";
    "/test/test_optim.py" -> "Import:torch.nn.functional";
    "/test/test_optim.py" -> "Import:SGD";
    "/test/test_optim.py" -> "Import:Variable";
    "/test/test_optim.py" -> "Import:sparse";
    "/test/test_optim.py" -> "Import:LambdaLR,";
    "/test/test_optim.py" -> "Import:TestCase,";
    "/test/test_optim.py" -> "Fxn:rosenbrock";
    "/test/test_optim.py" -> "Fxn:drosenbrock";
    "/test/test_optim.py" -> "Fxn:wrap_old_fn";
    "/test/test_optim.py" -> "Fxn:wrapper";
    "/test/test_optim.py" -> "class:TestOptim(TestCase):";
    "/test/test_optim.py" -> "class:SchedulerTestNet(torch.nn.Module):";
    "/test/test_optim.py" -> "class:TestLRScheduler(TestCase):";
    "class:TestOptim(TestCase):" -> "Fxn:_test_rosenbrock";
    "class:TestOptim(TestCase):" -> "Fxn:eval";
    "class:TestOptim(TestCase):" -> "Fxn:_test_rosenbrock_sparse";
    "class:TestOptim(TestCase):" -> "Fxn:eval";
    "class:TestOptim(TestCase):" -> "Fxn:_test_basic_cases_template";
    "class:TestOptim(TestCase):" -> "Fxn:fn";
    "class:TestOptim(TestCase):" -> "Fxn:_test_state_dict";
    "class:TestOptim(TestCase):" -> "Fxn:fn_base";
    "class:TestOptim(TestCase):" -> "Fxn:_test_basic_cases";
    "class:TestOptim(TestCase):" -> "Fxn:_build_params_dict";
    "class:TestOptim(TestCase):" -> "Fxn:_build_params_dict_single";
    "class:TestOptim(TestCase):" -> "Fxn:test_sgd";
    "class:TestOptim(TestCase):" -> "Fxn:test_sgd_sparse";
    "class:TestOptim(TestCase):" -> "Fxn:test_adam";
    "class:TestOptim(TestCase):" -> "Fxn:test_sparse_adam";
    "class:TestOptim(TestCase):" -> "Fxn:test_adadelta";
    "class:TestOptim(TestCase):" -> "Fxn:test_adagrad";
    "class:TestOptim(TestCase):" -> "Fxn:test_adagrad_sparse";
    "class:TestOptim(TestCase):" -> "Fxn:test_adamax";
    "class:TestOptim(TestCase):" -> "Fxn:test_rmsprop";
    "class:TestOptim(TestCase):" -> "Fxn:test_asgd";
    "class:TestOptim(TestCase):" -> "Fxn:test_rprop";
    "class:TestOptim(TestCase):" -> "Fxn:test_lbfgs";
    "class:TestOptim(TestCase):" -> "Fxn:test_invalid_param_type";
    "Fxn:_test_rosenbrock" -> "Fxn:torch.Tensor([1.5,";
    "Fxn:_test_rosenbrock" -> "Fxn:Variable(torch.Tensor([1.5,";
    "Fxn:_test_rosenbrock" -> "Fxn:constructor([params])";
    "Fxn:_test_rosenbrock" -> "Fxn:torch.Tensor([1,";
    "Fxn:_test_rosenbrock" -> "Fxn:params.data.dist(solution)";
    "Fxn:eval" -> "Fxn:optimizer.zero_grad()";
    "Fxn:eval" -> "Fxn:rosenbrock(params)";
    "Fxn:eval" -> "Fxn:loss.backward()";
    "Fxn:eval" -> "Fxn:loss.backward()";
    "Fxn:eval" -> "Fxn:params.grad.data.copy_(drosenbrock(params.data))";
    "Fxn:eval" -> "Fxn:optimizer.step(eval)";
    "Fxn:eval" -> "Fxn:old_fn(lambda";
    "Fxn:eval" -> "Fxn:drosenbrock(params_t)),";
    "Fxn:eval" -> "Fxn:self.assertEqual(params.data,";
    "Fxn:eval" -> "Fxn:self.assertLessEqual(params.data.dist(solution),";
    "Fxn:_test_rosenbrock_sparse" -> "Fxn:torch.Tensor([1.5,";
    "Fxn:_test_rosenbrock_sparse" -> "Fxn:Variable(params_t,";
    "Fxn:_test_rosenbrock_sparse" -> "Fxn:constructor([params])";
    "Fxn:_test_rosenbrock_sparse" -> "Fxn:Variable(params_t.clone(),";
    "Fxn:_test_rosenbrock_sparse" -> "Fxn:constructor([params_c])";
    "Fxn:_test_rosenbrock_sparse" -> "Fxn:torch.Tensor([1,";
    "Fxn:_test_rosenbrock_sparse" -> "Fxn:params.data.dist(solution)";
    "Fxn:eval" -> "Fxn:optimizer.zero_grad()";
    "Fxn:eval" -> "Fxn:rosenbrock(params)";
    "Fxn:eval" -> "Fxn:loss.backward()";
    "Fxn:eval" -> "Fxn:drosenbrock(params.data)";
    "Fxn:eval" -> "Fxn:torch.LongTensor([[0,";
    "Fxn:eval" -> "Fxn:torch.DoubleTensor([x";
    "Fxn:eval" -> "Fxn:torch.LongTensor([[1,";
    "Fxn:eval" -> "Fxn:torch.DoubleTensor([y";
    "Fxn:eval" -> "Fxn:sparse.DoubleTensor(i,";
    "Fxn:eval" -> "Fxn:torch.Size([2]))";
    "Fxn:eval" -> "Fxn:x.to_dense()";
    "Fxn:eval" -> "Fxn:optimizer.step(functools.partial(eval,";
    "Fxn:eval" -> "Fxn:optimizer_c.step(functools.partial(eval,";
    "Fxn:eval" -> "Fxn:self.assertEqual(params.data,";
    "Fxn:eval" -> "Fxn:self.assertLessEqual(params.data.dist(solution),";
    "Fxn:_test_basic_cases_template" -> "Fxn:Variable(weight,";
    "Fxn:_test_basic_cases_template" -> "Fxn:Variable(bias,";
    "Fxn:_test_basic_cases_template" -> "Fxn:Variable(input)";
    "Fxn:_test_basic_cases_template" -> "Fxn:constructor(weight,";
    "Fxn:_test_basic_cases_template" -> "Fxn:optimizer.__repr__()";
    "Fxn:fn" -> "Fxn:optimizer.zero_grad()";
    "Fxn:fn" -> "Fxn:weight.mv(input)";
    "Fxn:fn" -> "Fxn:y.get_device()";
    "Fxn:fn" -> "Fxn:bias.get_device():";
    "Fxn:fn" -> "Fxn:y.cuda(bias.get_device())";
    "Fxn:fn" -> "Fxn:bias).pow(2).sum()";
    "Fxn:fn" -> "Fxn:loss.backward()";
    "Fxn:fn" -> "Fxn:fn().item()";
    "Fxn:fn" -> "Fxn:optimizer.step(fn)";
    "Fxn:fn" -> "Fxn:self.assertLess(fn().item(),";
    "Fxn:_test_state_dict" -> "Fxn:Variable(weight,";
    "Fxn:_test_state_dict" -> "Fxn:Variable(bias,";
    "Fxn:_test_state_dict" -> "Fxn:Variable(input)";
    "Fxn:fn_base" -> "Fxn:optimizer.zero_grad()";
    "Fxn:fn_base" -> "Fxn:bias).pow(2).sum()";
    "Fxn:fn_base" -> "Fxn:loss.backward()";
    "Fxn:fn_base" -> "Fxn:constructor(weight,";
    "Fxn:fn_base" -> "Fxn:functools.partial(fn_base,";
    "Fxn:fn_base" -> "Fxn:optimizer.step(fn)";
    "Fxn:fn_base" -> "Fxn:Variable(weight.data.clone(),";
    "Fxn:fn_base" -> "Fxn:Variable(bias.data.clone(),";
    "Fxn:fn_base" -> "Fxn:constructor(weight_c,";
    "Fxn:fn_base" -> "Fxn:functools.partial(fn_base,";
    "Fxn:fn_base" -> "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:fn_base" -> "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:fn_base" -> "Fxn:optimizer_c.load_state_dict(state_dict_c)";
    "Fxn:fn_base" -> "Fxn:optimizer.step(fn)";
    "Fxn:fn_base" -> "Fxn:optimizer_c.step(fn_c)";
    "Fxn:fn_base" -> "Fxn:self.assertEqual(weight,";
    "Fxn:fn_base" -> "Fxn:self.assertEqual(bias,";
    "Fxn:fn_base" -> "Fxn:self.assertEqual(state_dict,";
    "Fxn:fn_base" -> "Fxn:torch.cuda.is_available():";
    "Fxn:fn_base" -> "Fxn:Variable(input.data.float().cuda())";
    "Fxn:fn_base" -> "Fxn:Variable(weight.data.float().cuda(),";
    "Fxn:fn_base" -> "Fxn:Variable(bias.data.float().cuda(),";
    "Fxn:fn_base" -> "Fxn:constructor(weight_cuda,";
    "Fxn:fn_base" -> "Fxn:functools.partial(fn_base,";
    "Fxn:fn_base" -> "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:fn_base" -> "Fxn:deepcopy(optimizer.state_dict())";
    "Fxn:fn_base" -> "Fxn:optimizer_cuda.load_state_dict(state_dict_c)";
    "Fxn:fn_base" -> "Fxn:self.assertEqual(state_dict,";
    "Fxn:fn_base" -> "Fxn:optimizer.step(fn)";
    "Fxn:fn_base" -> "Fxn:optimizer_cuda.step(fn_cuda)";
    "Fxn:fn_base" -> "Fxn:self.assertEqual(weight,";
    "Fxn:fn_base" -> "Fxn:self.assertEqual(bias,";
    "Fxn:_test_basic_cases" -> "Fxn:self._test_state_dict(";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10,";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(5),";
    "Fxn:_test_basic_cases" -> "Fxn:self._test_basic_cases_template(";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10,";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(5),";
    "Fxn:_test_basic_cases" -> "Fxn:self._test_basic_cases_template(";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10,";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10,";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(5),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.cuda.is_available():";
    "Fxn:_test_basic_cases" -> "Fxn:self._test_basic_cases_template(";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10,";
    "Fxn:_test_basic_cases" -> "Fxn:5).cuda(),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10).cuda(),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(5).cuda(),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_test_basic_cases" -> "Fxn:self._test_basic_cases_template(";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10,";
    "Fxn:_test_basic_cases" -> "Fxn:5).cuda(0),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(10).cuda(1),";
    "Fxn:_test_basic_cases" -> "Fxn:torch.randn(5).cuda(0),";
    "Fxn:_build_params_dict" -> "Fxn:[dict(params=[weight]),";
    "Fxn:_build_params_dict_single" -> "Fxn:[dict(params=bias,";
    "Fxn:test_sgd" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_sgd" -> "Fxn:optim.SGD(params,";
    "Fxn:test_sgd" -> "Fxn:wrap_old_fn(old_optim.sgd,";
    "Fxn:test_sgd" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_sgd" -> "Fxn:optim.SGD(params,";
    "Fxn:test_sgd" -> "Fxn:wrap_old_fn(old_optim.sgd,";
    "Fxn:test_sgd" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_sgd" -> "Fxn:optim.SGD([weight,";
    "Fxn:test_sgd" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_sgd" -> "Fxn:optim.SGD(";
    "Fxn:test_sgd" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_sgd" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_sgd" -> "Fxn:optim.SGD(";
    "Fxn:test_sgd" -> "Fxn:self._build_params_dict_single(weight,";
    "Fxn:test_sgd_sparse" -> "Fxn:self._test_rosenbrock_sparse(";
    "Fxn:test_sgd_sparse" -> "Fxn:optim.SGD(params,";
    "Fxn:test_adam" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adam" -> "Fxn:optim.Adam(params,";
    "Fxn:test_adam" -> "Fxn:wrap_old_fn(old_optim.adam,";
    "Fxn:test_adam" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adam" -> "Fxn:optim.Adam(params,";
    "Fxn:test_adam" -> "Fxn:wrap_old_fn(old_optim.adam,";
    "Fxn:test_adam" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adam" -> "Fxn:optim.Adam([weight,";
    "Fxn:test_adam" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adam" -> "Fxn:optim.Adam(";
    "Fxn:test_adam" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_adam" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adam" -> "Fxn:optim.Adam([weight,";
    "Fxn:test_adam" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adam" -> "Fxn:optim.Adam(";
    "Fxn:test_adam" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_adam" -> "Fxn:self.assertRaisesRegex(ValueError,";
    "Fxn:test_adam" -> "Fxn:optim.Adam(None,";
    "Fxn:test_adam" -> "Fxn:betas=(1.0,";
    "Fxn:test_sparse_adam" -> "Fxn:self._test_rosenbrock_sparse(";
    "Fxn:test_sparse_adam" -> "Fxn:optim.SparseAdam(params,";
    "Fxn:test_adadelta" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adadelta" -> "Fxn:optim.Adadelta(params),";
    "Fxn:test_adadelta" -> "Fxn:wrap_old_fn(old_optim.adadelta)";
    "Fxn:test_adadelta" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adadelta" -> "Fxn:optim.Adadelta(params,";
    "Fxn:test_adadelta" -> "Fxn:wrap_old_fn(old_optim.adadelta,";
    "Fxn:test_adadelta" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adadelta" -> "Fxn:optim.Adadelta(params,";
    "Fxn:test_adadelta" -> "Fxn:wrap_old_fn(old_optim.adadelta,";
    "Fxn:test_adadelta" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adadelta" -> "Fxn:optim.Adadelta([weight,";
    "Fxn:test_adadelta" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adadelta" -> "Fxn:optim.Adadelta(";
    "Fxn:test_adadelta" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_adagrad" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adagrad" -> "Fxn:optim.Adagrad(params,";
    "Fxn:test_adagrad" -> "Fxn:wrap_old_fn(old_optim.adagrad,";
    "Fxn:test_adagrad" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adagrad" -> "Fxn:optim.Adagrad(params,";
    "Fxn:test_adagrad" -> "Fxn:wrap_old_fn(old_optim.adagrad,";
    "Fxn:test_adagrad" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adagrad" -> "Fxn:optim.Adagrad(params,";
    "Fxn:test_adagrad" -> "Fxn:wrap_old_fn(old_optim.adagrad,";
    "Fxn:test_adagrad" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adagrad" -> "Fxn:optim.Adagrad([weight,";
    "Fxn:test_adagrad" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adagrad" -> "Fxn:optim.Adagrad(";
    "Fxn:test_adagrad" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_adagrad_sparse" -> "Fxn:self._test_rosenbrock_sparse(";
    "Fxn:test_adagrad_sparse" -> "Fxn:optim.Adagrad(params,";
    "Fxn:test_adamax" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adamax" -> "Fxn:optim.Adamax(params,";
    "Fxn:test_adamax" -> "Fxn:wrap_old_fn(old_optim.adamax,";
    "Fxn:test_adamax" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adamax" -> "Fxn:optim.Adamax(params,";
    "Fxn:test_adamax" -> "Fxn:wrap_old_fn(old_optim.adamax,";
    "Fxn:test_adamax" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_adamax" -> "Fxn:optim.Adamax(params,";
    "Fxn:test_adamax" -> "Fxn:betas=(0.95,";
    "Fxn:test_adamax" -> "Fxn:wrap_old_fn(old_optim.adamax,";
    "Fxn:test_adamax" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adamax" -> "Fxn:optim.Adagrad([weight,";
    "Fxn:test_adamax" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_adamax" -> "Fxn:optim.Adagrad(";
    "Fxn:test_adamax" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_rmsprop" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_rmsprop" -> "Fxn:optim.RMSprop(params,";
    "Fxn:test_rmsprop" -> "Fxn:wrap_old_fn(old_optim.rmsprop,";
    "Fxn:test_rmsprop" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_rmsprop" -> "Fxn:optim.RMSprop(params,";
    "Fxn:test_rmsprop" -> "Fxn:wrap_old_fn(old_optim.rmsprop,";
    "Fxn:test_rmsprop" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_rmsprop" -> "Fxn:optim.RMSprop(params,";
    "Fxn:test_rmsprop" -> "Fxn:wrap_old_fn(old_optim.rmsprop,";
    "Fxn:test_rmsprop" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_rmsprop" -> "Fxn:optim.Adagrad([weight,";
    "Fxn:test_rmsprop" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_rmsprop" -> "Fxn:optim.Adagrad(";
    "Fxn:test_rmsprop" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_asgd" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_asgd" -> "Fxn:optim.ASGD(params,";
    "Fxn:test_asgd" -> "Fxn:wrap_old_fn(old_optim.asgd,";
    "Fxn:test_asgd" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_asgd" -> "Fxn:optim.ASGD(params,";
    "Fxn:test_asgd" -> "Fxn:wrap_old_fn(old_optim.asgd,";
    "Fxn:test_asgd" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_asgd" -> "Fxn:optim.ASGD(params,";
    "Fxn:test_asgd" -> "Fxn:wrap_old_fn(old_optim.asgd,";
    "Fxn:test_asgd" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_asgd" -> "Fxn:optim.ASGD([weight,";
    "Fxn:test_asgd" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_asgd" -> "Fxn:optim.ASGD(";
    "Fxn:test_asgd" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_rprop" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_rprop" -> "Fxn:optim.Rprop(params,";
    "Fxn:test_rprop" -> "Fxn:wrap_old_fn(old_optim.rprop,";
    "Fxn:test_rprop" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_rprop" -> "Fxn:optim.Rprop(params,";
    "Fxn:test_rprop" -> "Fxn:etas=(0.6,";
    "Fxn:test_rprop" -> "Fxn:wrap_old_fn(old_optim.rprop,";
    "Fxn:test_rprop" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_rprop" -> "Fxn:optim.Rprop(params,";
    "Fxn:test_rprop" -> "Fxn:step_sizes=(1e-4,";
    "Fxn:test_rprop" -> "Fxn:wrap_old_fn(old_optim.rprop,";
    "Fxn:test_rprop" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_rprop" -> "Fxn:optim.Rprop([weight,";
    "Fxn:test_rprop" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_rprop" -> "Fxn:optim.Rprop(";
    "Fxn:test_rprop" -> "Fxn:self._build_params_dict(weight,";
    "Fxn:test_lbfgs" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_lbfgs" -> "Fxn:optim.LBFGS(params),";
    "Fxn:test_lbfgs" -> "Fxn:wrap_old_fn(old_optim.lbfgs)";
    "Fxn:test_lbfgs" -> "Fxn:self._test_rosenbrock(";
    "Fxn:test_lbfgs" -> "Fxn:optim.LBFGS(params,";
    "Fxn:test_lbfgs" -> "Fxn:wrap_old_fn(old_optim.lbfgs,";
    "Fxn:test_lbfgs" -> "Fxn:self._test_basic_cases(";
    "Fxn:test_lbfgs" -> "Fxn:optim.LBFGS([weight,";
    "Fxn:test_invalid_param_type" -> "Fxn:self.assertRaises(TypeError):";
    "Fxn:test_invalid_param_type" -> "Fxn:optim.SGD(Variable(torch.randn(5,";
    "class:SchedulerTestNet(torch.nn.Module):" -> "Fxn:__init__";
    "class:SchedulerTestNet(torch.nn.Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.nn.Conv2d(1,";
    "Fxn:__init__" -> "Fxn:torch.nn.Conv2d(1,";
    "Fxn:forward" -> "Fxn:self.conv2(F.relu(self.conv1(x)))";
    "class:TestLRScheduler(TestCase):" -> "Fxn:setUp";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_step_lr";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_multi_step_lr";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_exp_lr";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_cos_anneal_lr";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau1";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau2";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau3";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau4";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau5";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau6";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau7";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_reduce_lr_on_plateau8";
    "class:TestLRScheduler(TestCase):" -> "Fxn:test_lambda_lr";
    "class:TestLRScheduler(TestCase):" -> "Fxn:_test";
    "class:TestLRScheduler(TestCase):" -> "Fxn:_test_reduce_lr_on_plateau";
    "Fxn:setUp" -> "Fxn:SchedulerTestNet()";
    "Fxn:setUp" -> "Fxn:SGD(";
    "Fxn:setUp" -> "Fxn:self.net.conv1.parameters()},";
    "Fxn:setUp" -> "Fxn:self.net.conv2.parameters(),";
    "Fxn:test_step_lr" -> "Fxn:StepLR(self.opt,";
    "Fxn:test_step_lr" -> "Fxn:self._test(scheduler,";
    "Fxn:test_multi_step_lr" -> "Fxn:MultiStepLR(self.opt,";
    "Fxn:test_multi_step_lr" -> "Fxn:self._test(scheduler,";
    "Fxn:test_exp_lr" -> "Fxn:ExponentialLR(self.opt,";
    "Fxn:test_exp_lr" -> "Fxn:self._test(scheduler,";
    "Fxn:test_cos_anneal_lr" -> "Fxn:math.cos(math.pi";
    "Fxn:test_cos_anneal_lr" -> "Fxn:CosineAnnealingLR(self.opt,";
    "Fxn:test_cos_anneal_lr" -> "Fxn:self._test(scheduler,";
    "Fxn:test_reduce_lr_on_plateau1" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau1" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau2" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau2" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau3" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau3" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau4" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau4" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau5" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau5" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau6" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau6" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau7" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau7" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_reduce_lr_on_plateau8" -> "Fxn:ReduceLROnPlateau(self.opt,";
    "Fxn:test_reduce_lr_on_plateau8" -> "Fxn:self._test_reduce_lr_on_plateau(scheduler,";
    "Fxn:test_lambda_lr" -> "Fxn:LambdaLR(self.opt,";
    "Fxn:test_lambda_lr" -> "Fxn:self._test(scheduler,";
    "Fxn:_test" -> "Fxn:scheduler.step(epoch)";
    "Fxn:_test" -> "Fxn:self.assertAlmostEqual(target[epoch],";
    "Fxn:_test" -> "Fxn:{}'.format(";
    "Fxn:_test_reduce_lr_on_plateau" -> "Fxn:scheduler.step(metrics[epoch])";
    "Fxn:_test_reduce_lr_on_plateau" -> "Fxn:self.assertAlmostEqual(target[epoch],";
    "Fxn:_test_reduce_lr_on_plateau" -> "Fxn:{}'.format(";
    "Fxn:_test_reduce_lr_on_plateau" -> "Fxn:run_tests()";
    "/test/test_sparse.py" -> "Import:torch";
    "/test/test_sparse.py" -> "Import:sparse";
    "/test/test_sparse.py" -> "Import:itertools";
    "/test/test_sparse.py" -> "Import:random";
    "/test/test_sparse.py" -> "Import:unittest";
    "/test/test_sparse.py" -> "Import:TestCase,";
    "/test/test_sparse.py" -> "Import:TEST_CUDA";
    "/test/test_sparse.py" -> "Import:TestTorch";
    "/test/test_sparse.py" -> "Import:Number";
    "/test/test_sparse.py" -> "Fxn:cpu_only";
    "/test/test_sparse.py" -> "Fxn:outer";
    "/test/test_sparse.py" -> "Fxn:cuda_only";
    "/test/test_sparse.py" -> "Fxn:outer";
    "/test/test_sparse.py" -> "class:TestSparse(TestCase):";
    "/test/test_sparse.py" -> "Import:Variable";
    "/test/test_sparse.py" -> "class:TestUncoalescedSparse(TestSparse):";
    "/test/test_sparse.py" -> "class:TestCudaSparse(TestSparse):";
    "/test/test_sparse.py" -> "class:TestCudaUncoalescedSparse(TestCudaSparse):";
    "class:TestSparse(TestCase):" -> "Fxn:setUp";
    "class:TestSparse(TestCase):" -> "Fxn:_gen_sparse";
    "class:TestSparse(TestCase):" -> "Fxn:assert_uncoalesced";
    "class:TestSparse(TestCase):" -> "Fxn:randn";
    "class:TestSparse(TestCase):" -> "Fxn:test_basic";
    "class:TestSparse(TestCase):" -> "Fxn:test_ctor_size_checks";
    "class:TestSparse(TestCase):" -> "Fxn:test_to_dense";
    "class:TestSparse(TestCase):" -> "Fxn:test_shared";
    "class:TestSparse(TestCase):" -> "Fxn:test_to_dense_hybrid";
    "class:TestSparse(TestCase):" -> "Fxn:test_contig";
    "class:TestSparse(TestCase):" -> "Fxn:test_contig_hybrid";
    "class:TestSparse(TestCase):" -> "Fxn:test_clone";
    "class:TestSparse(TestCase):" -> "Fxn:test_cuda_empty";
    "class:TestSparse(TestCase):" -> "Fxn:test_transpose";
    "class:TestSparse(TestCase):" -> "Fxn:test_transpose_coalesce_invariant";
    "class:TestSparse(TestCase):" -> "Fxn:test_mm";
    "class:TestSparse(TestCase):" -> "Fxn:test_shape";
    "class:TestSparse(TestCase):" -> "Fxn:test_saddmm";
    "class:TestSparse(TestCase):" -> "Fxn:test_shape";
    "class:TestSparse(TestCase):" -> "Fxn:test_dsmm";
    "class:TestSparse(TestCase):" -> "Fxn:test_shape";
    "class:TestSparse(TestCase):" -> "Fxn:test_hsmm";
    "class:TestSparse(TestCase):" -> "Fxn:test_shape";
    "class:TestSparse(TestCase):" -> "Fxn:_test_spadd_shape";
    "class:TestSparse(TestCase):" -> "Fxn:test_spadd";
    "class:TestSparse(TestCase):" -> "Fxn:test_spadd_hybrid";
    "class:TestSparse(TestCase):" -> "Fxn:test_norm";
    "class:TestSparse(TestCase):" -> "Fxn:_test_basic_ops_shape";
    "class:TestSparse(TestCase):" -> "Fxn:test_basic_ops";
    "class:TestSparse(TestCase):" -> "Fxn:test_basic_ops_hybrid";
    "class:TestSparse(TestCase):" -> "Fxn:_test_sparse_mask_shape";
    "class:TestSparse(TestCase):" -> "Fxn:_test_sparse_mask_fixed";
    "class:TestSparse(TestCase):" -> "Fxn:test_sparse_mask";
    "class:TestSparse(TestCase):" -> "Fxn:_test_zeros";
    "class:TestSparse(TestCase):" -> "Fxn:test_zeros";
    "class:TestSparse(TestCase):" -> "Fxn:_test_zeros_like";
    "class:TestSparse(TestCase):" -> "Fxn:test_zeros_like";
    "class:TestSparse(TestCase):" -> "Fxn:_test_sparse_mask_hybrid_fixed";
    "class:TestSparse(TestCase):" -> "Fxn:test_sparse_variable_methods";
    "class:TestSparse(TestCase):" -> "Fxn:test_sparse_mask_hybrid";
    "class:TestSparse(TestCase):" -> "Fxn:test_sparse_add_coalesce";
    "class:TestSparse(TestCase):" -> "Fxn:test_storage_not_null";
    "class:TestSparse(TestCase):" -> "Fxn:test_same_gpu";
    "class:TestSparse(TestCase):" -> "Fxn:_test_new_device";
    "class:TestSparse(TestCase):" -> "Fxn:test_new_device_single_gpu";
    "class:TestSparse(TestCase):" -> "Fxn:test_new_device_multi_gpu";
    "class:TestSparse(TestCase):" -> "Fxn:test_new";
    "class:TestSparse(TestCase):" -> "Fxn:test_dtypes";
    "class:TestSparse(TestCase):" -> "Fxn:test_empty_full";
    "class:TestSparse(TestCase):" -> "Fxn:test_is_sparse";
    "class:TestSparse(TestCase):" -> "Fxn:test_resize_as";
    "class:TestSparse(TestCase):" -> "Fxn:do_test";
    "Fxn:setUp" -> "Fxn:self).setUp()";
    "Fxn:_gen_sparse" -> "Fxn:torch.randn(*v_size)";
    "Fxn:_gen_sparse" -> "Fxn:torch.rand(d,";
    "Fxn:_gen_sparse" -> "Fxn:torch.cat([r,";
    "Fxn:_gen_sparse" -> "Fxn:torch.Tensor(with_size[:d]).repeat(nnz";
    "Fxn:_gen_sparse" -> "Fxn:1).transpose(0,";
    "Fxn:_gen_sparse" -> "Fxn:i.type(torch.LongTensor)";
    "Fxn:_gen_sparse" -> "Fxn:torch.sparse.DoubleTensor(i,";
    "Fxn:_gen_sparse" -> "Fxn:torch.Size(with_size))";
    "Fxn:_gen_sparse" -> "Fxn:self.assert_uncoalesced(x)";
    "Fxn:_gen_sparse" -> "Fxn:torch.randn(*v_size)";
    "Fxn:_gen_sparse" -> "Fxn:torch.rand(d,";
    "Fxn:_gen_sparse" -> "Fxn:torch.Tensor(with_size[:d]).repeat(nnz,";
    "Fxn:_gen_sparse" -> "Fxn:1).transpose(0,";
    "Fxn:_gen_sparse" -> "Fxn:i.type(torch.LongTensor)";
    "Fxn:_gen_sparse" -> "Fxn:torch.sparse.DoubleTensor(i,";
    "Fxn:_gen_sparse" -> "Fxn:torch.Size(with_size))";
    "Fxn:_gen_sparse" -> "Fxn:x.cuda(),";
    "Fxn:_gen_sparse" -> "Fxn:i.cuda(),";
    "Fxn:_gen_sparse" -> "Fxn:v.cuda()";
    "Fxn:_gen_sparse" -> "Fxn:i.clone(),";
    "Fxn:_gen_sparse" -> "Fxn:v.clone()";
    "Fxn:assert_uncoalesced" -> "Fxn:x.is_coalesced()";
    "Fxn:assert_uncoalesced" -> "Fxn:x._indices().clone()";
    "Fxn:assert_uncoalesced" -> "Fxn:x._values().clone().fill_(1)";
    "Fxn:assert_uncoalesced" -> "Fxn:torch.sparse.DoubleTensor(i,";
    "Fxn:assert_uncoalesced" -> "Fxn:x.size())";
    "Fxn:assert_uncoalesced" -> "Fxn:self.safeCoalesce(y)";
    "Fxn:assert_uncoalesced" -> "Fxn:1).sum()";
    "Fxn:randn" -> "Fxn:self.ValueTensor(*args,";
    "Fxn:randn" -> "Fxn:**kwargs).normal_()";
    "Fxn:test_basic" -> "Fxn:self._gen_sparse(3,";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(i,";
    "Fxn:test_basic" -> "Fxn:x._indices())";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(v,";
    "Fxn:test_basic" -> "Fxn:x._values())";
    "Fxn:test_basic" -> "Fxn:self._gen_sparse(3,";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(i,";
    "Fxn:test_basic" -> "Fxn:x._indices())";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(v,";
    "Fxn:test_basic" -> "Fxn:x._values())";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(x.ndimension(),";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(self.safeCoalesce(x)._nnz(),";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(x.size(i),";
    "Fxn:test_basic" -> "Fxn:self.IndexTensor([[9,";
    "Fxn:test_basic" -> "Fxn:self.ValueTensor([[idx**2,";
    "Fxn:test_basic" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_basic" -> "Fxn:torch.Size([10,";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(self.safeCoalesce(x)._nnz(),";
    "Fxn:test_basic" -> "Fxn:self.SparseTensor()";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(x._indices().numel(),";
    "Fxn:test_basic" -> "Fxn:self.assertEqual(x._values().numel(),";
    "Fxn:test_ctor_size_checks" -> "Fxn:self.IndexTensor([";
    "Fxn:test_ctor_size_checks" -> "Fxn:self.ValueTensor([2,";
    "Fxn:test_ctor_size_checks" -> "Fxn:self.assertRaises(";
    "Fxn:test_ctor_size_checks" -> "Fxn:self.SparseTensor(indices,";
    "Fxn:test_ctor_size_checks" -> "Fxn:torch.Size([2,";
    "Fxn:test_ctor_size_checks" -> "Fxn:self.ValueTensor([";
    "Fxn:test_ctor_size_checks" -> "Fxn:self.assertRaises(";
    "Fxn:test_ctor_size_checks" -> "Fxn:self.SparseTensor(indices,";
    "Fxn:test_ctor_size_checks" -> "Fxn:torch.Size([2,";
    "Fxn:test_to_dense" -> "Fxn:self.IndexTensor([";
    "Fxn:test_to_dense" -> "Fxn:self.ValueTensor([2,";
    "Fxn:test_to_dense" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_to_dense" -> "Fxn:torch.Size([3,";
    "Fxn:test_to_dense" -> "Fxn:self.ValueTensor([";
    "Fxn:test_to_dense" -> "Fxn:x.to_dense()";
    "Fxn:test_to_dense" -> "Fxn:x.to_dense()";
    "Fxn:test_to_dense" -> "Fxn:x.to_dense()";
    "Fxn:test_to_dense" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_to_dense" -> "Fxn:x.to_dense())";
    "Fxn:test_to_dense" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_to_dense" -> "Fxn:self.safeToDense(x))";
    "Fxn:test_shared" -> "Fxn:self.IndexTensor([[2]])";
    "Fxn:test_shared" -> "Fxn:self.ValueTensor([5])";
    "Fxn:test_shared" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_shared" -> "Fxn:torch.Size([3]))";
    "Fxn:test_shared" -> "Fxn:self.assertEqual(self.ValueTensor([0,";
    "Fxn:test_shared" -> "Fxn:self.safeToDense(x))";
    "Fxn:test_shared" -> "Fxn:self.assertEqual(self.ValueTensor([6,";
    "Fxn:test_shared" -> "Fxn:self.safeToDense(x))";
    "Fxn:test_to_dense_hybrid" -> "Fxn:self.IndexTensor([";
    "Fxn:test_to_dense_hybrid" -> "Fxn:self.ValueTensor([[2,";
    "Fxn:test_to_dense_hybrid" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_to_dense_hybrid" -> "Fxn:torch.Size([3,";
    "Fxn:test_to_dense_hybrid" -> "Fxn:self.ValueTensor([";
    "Fxn:test_to_dense_hybrid" -> "Fxn:x.to_dense()";
    "Fxn:test_to_dense_hybrid" -> "Fxn:x.to_dense()";
    "Fxn:test_to_dense_hybrid" -> "Fxn:x.to_dense()";
    "Fxn:test_to_dense_hybrid" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_to_dense_hybrid" -> "Fxn:x.to_dense())";
    "Fxn:test_to_dense_hybrid" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_to_dense_hybrid" -> "Fxn:self.safeToDense(x))";
    "Fxn:test_contig" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig" -> "Fxn:self.ValueTensor([1,";
    "Fxn:test_contig" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_contig" -> "Fxn:torch.Size([100,";
    "Fxn:test_contig" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig" -> "Fxn:self.ValueTensor([2,";
    "Fxn:test_contig" -> "Fxn:self.safeCoalesce(x)";
    "Fxn:test_contig" -> "Fxn:self.assertEqual(exp_i,";
    "Fxn:test_contig" -> "Fxn:x._indices())";
    "Fxn:test_contig" -> "Fxn:self.assertEqual(exp_v,";
    "Fxn:test_contig" -> "Fxn:x._values())";
    "Fxn:test_contig" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig" -> "Fxn:self.ValueTensor([3,";
    "Fxn:test_contig" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_contig" -> "Fxn:torch.Size([3,";
    "Fxn:test_contig" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig" -> "Fxn:self.ValueTensor([2,";
    "Fxn:test_contig" -> "Fxn:self.safeCoalesce(x)";
    "Fxn:test_contig" -> "Fxn:self.assertEqual(exp_i,";
    "Fxn:test_contig" -> "Fxn:x._indices())";
    "Fxn:test_contig" -> "Fxn:self.assertEqual(exp_v,";
    "Fxn:test_contig" -> "Fxn:x._values())";
    "Fxn:test_contig" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig" -> "Fxn:self.ValueTensor([3,";
    "Fxn:test_contig" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_contig" -> "Fxn:torch.Size([3,";
    "Fxn:test_contig" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig" -> "Fxn:self.ValueTensor([6,";
    "Fxn:test_contig" -> "Fxn:self.safeCoalesce(x)";
    "Fxn:test_contig" -> "Fxn:self.assertEqual(exp_i,";
    "Fxn:test_contig" -> "Fxn:x._indices())";
    "Fxn:test_contig" -> "Fxn:self.assertEqual(exp_v,";
    "Fxn:test_contig" -> "Fxn:x._values())";
    "Fxn:test_contig_hybrid" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.ValueTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_contig_hybrid" -> "Fxn:torch.Size([100,";
    "Fxn:test_contig_hybrid" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.ValueTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.safeCoalesce(x)";
    "Fxn:test_contig_hybrid" -> "Fxn:self.assertEqual(exp_i,";
    "Fxn:test_contig_hybrid" -> "Fxn:x._indices())";
    "Fxn:test_contig_hybrid" -> "Fxn:self.assertEqual(exp_v,";
    "Fxn:test_contig_hybrid" -> "Fxn:x._values())";
    "Fxn:test_contig_hybrid" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.ValueTensor([[3,";
    "Fxn:test_contig_hybrid" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_contig_hybrid" -> "Fxn:torch.Size([3,";
    "Fxn:test_contig_hybrid" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.ValueTensor([[2,";
    "Fxn:test_contig_hybrid" -> "Fxn:self.safeCoalesce(x)";
    "Fxn:test_contig_hybrid" -> "Fxn:self.assertEqual(exp_i,";
    "Fxn:test_contig_hybrid" -> "Fxn:x._indices())";
    "Fxn:test_contig_hybrid" -> "Fxn:self.assertEqual(exp_v,";
    "Fxn:test_contig_hybrid" -> "Fxn:x._values())";
    "Fxn:test_contig_hybrid" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.ValueTensor([[3,";
    "Fxn:test_contig_hybrid" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_contig_hybrid" -> "Fxn:torch.Size([3,";
    "Fxn:test_contig_hybrid" -> "Fxn:self.IndexTensor([";
    "Fxn:test_contig_hybrid" -> "Fxn:self.ValueTensor([[6,";
    "Fxn:test_contig_hybrid" -> "Fxn:self.safeCoalesce(x)";
    "Fxn:test_contig_hybrid" -> "Fxn:self.assertEqual(exp_i,";
    "Fxn:test_contig_hybrid" -> "Fxn:x._indices())";
    "Fxn:test_contig_hybrid" -> "Fxn:self.assertEqual(exp_v,";
    "Fxn:test_contig_hybrid" -> "Fxn:x._values())";
    "Fxn:test_clone" -> "Fxn:self._gen_sparse(4,";
    "Fxn:test_clone" -> "Fxn:self.assertFalse(x.is_coalesced())";
    "Fxn:test_clone" -> "Fxn:x.clone()";
    "Fxn:test_clone" -> "Fxn:self.assertFalse(y.is_coalesced())";
    "Fxn:test_clone" -> "Fxn:x.coalesce()";
    "Fxn:test_clone" -> "Fxn:self.assertTrue(x.is_coalesced())";
    "Fxn:test_clone" -> "Fxn:x.clone()";
    "Fxn:test_clone" -> "Fxn:self.assertTrue(y.is_coalesced())";
    "Fxn:test_cuda_empty" -> "Fxn:torch.sparse.FloatTensor(2,";
    "Fxn:test_cuda_empty" -> "Fxn:x.cuda(0)";
    "Fxn:test_cuda_empty" -> "Fxn:self.assertEqual(x._dimI(),";
    "Fxn:test_cuda_empty" -> "Fxn:y._dimI())";
    "Fxn:test_cuda_empty" -> "Fxn:self.assertEqual(x._dimV(),";
    "Fxn:test_cuda_empty" -> "Fxn:y._dimV())";
    "Fxn:test_cuda_empty" -> "Fxn:y.cpu()";
    "Fxn:test_cuda_empty" -> "Fxn:self.assertEqual(y._dimI(),";
    "Fxn:test_cuda_empty" -> "Fxn:x._dimI())";
    "Fxn:test_cuda_empty" -> "Fxn:self.assertEqual(y._dimV(),";
    "Fxn:test_cuda_empty" -> "Fxn:x._dimV())";
    "Fxn:test_transpose" -> "Fxn:self._gen_sparse(4,";
    "Fxn:test_transpose" -> "Fxn:self.safeToDense(x)";
    "Fxn:test_transpose" -> "Fxn:itertools.combinations(range(4),";
    "Fxn:test_transpose" -> "Fxn:x.transpose_(i,";
    "Fxn:test_transpose" -> "Fxn:y.transpose(i,";
    "Fxn:test_transpose" -> "Fxn:self.assertEqual(self.safeToDense(x),";
    "Fxn:test_transpose" -> "Fxn:x.transpose(i,";
    "Fxn:test_transpose" -> "Fxn:y.transpose(i,";
    "Fxn:test_transpose" -> "Fxn:self.assertEqual(self.safeToDense(x),";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self._gen_sparse(2,";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:4)[0].coalesce()";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:x_coalesced._indices()";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:x_coalesced._values()";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self.SparseTensor(";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:torch.cat([x_indices,";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:torch.cat([x_values,";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:x_coalesced.size())";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self.assertTrue(x_coalesced.is_coalesced())";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self.assertFalse(y_uncoalesced.is_coalesced())";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self.assertTrue(x_coalesced.transpose(0,";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:1).is_coalesced())";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self.assertFalse(y_uncoalesced.transpose(0,";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:1).is_coalesced())";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:x_coalesced.transpose_(0,";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:y_uncoalesced.transpose_(0,";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self.assertTrue(x_coalesced.is_coalesced())";
    "Fxn:test_transpose_coalesce_invariant" -> "Fxn:self.assertFalse(y_uncoalesced.is_coalesced())";
    "Fxn:test_shape" -> "Fxn:self._gen_sparse(2,";
    "Fxn:test_shape" -> "Fxn:torch.randn(di,";
    "Fxn:test_shape" -> "Fxn:torch.randn(dj,";
    "Fxn:test_shape" -> "Fxn:random.random()";
    "Fxn:test_shape" -> "Fxn:random.random()";
    "Fxn:test_shape" -> "Fxn:torch.addmm(alpha,";
    "Fxn:test_shape" -> "Fxn:torch.addmm(alpha,";
    "Fxn:test_shape" -> "Fxn:self.safeToDense(x),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_shape" -> "Fxn:torch.addmm(t,";
    "Fxn:test_shape" -> "Fxn:torch.addmm(t,";
    "Fxn:test_shape" -> "Fxn:self.safeToDense(x),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_shape" -> "Fxn:torch.mm(x,";
    "Fxn:test_shape" -> "Fxn:torch.mm(self.safeToDense(x),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_shape" -> "Fxn:test_shape(10,";
    "Fxn:test_shape" -> "Fxn:test_shape(100,";
    "Fxn:test_shape" -> "Fxn:test_shape(64,";
    "Fxn:test_shape" -> "Fxn:self._gen_sparse(2,";
    "Fxn:test_shape" -> "Fxn:self._gen_sparse(2,";
    "Fxn:test_shape" -> "Fxn:torch.randn(dj,";
    "Fxn:test_shape" -> "Fxn:random.random()";
    "Fxn:test_shape" -> "Fxn:random.random()";
    "Fxn:test_shape" -> "Fxn:torch.saddmm(alpha,";
    "Fxn:test_shape" -> "Fxn:torch.addmm(alpha,";
    "Fxn:test_shape" -> "Fxn:self.safeToDense(t),";
    "Fxn:test_shape" -> "Fxn:self.safeToDense(x),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(self.safeToDense(res),";
    "Fxn:test_shape" -> "Fxn:torch.saddmm(t,";
    "Fxn:test_shape" -> "Fxn:torch.addmm(self.safeToDense(t),";
    "Fxn:test_shape" -> "Fxn:self.safeToDense(x),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(self.safeToDense(res),";
    "Fxn:test_shape" -> "Fxn:torch.smm(x,";
    "Fxn:test_shape" -> "Fxn:torch.mm(self.safeToDense(x),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(self.safeToDense(res),";
    "Fxn:test_shape" -> "Fxn:test_shape(7,";
    "Fxn:test_shape" -> "Fxn:test_shape(1000,";
    "Fxn:test_shape" -> "Fxn:test_shape(3000,";
    "Fxn:test_shape" -> "Fxn:self._gen_sparse(2,";
    "Fxn:test_shape" -> "Fxn:self.randn(dj,";
    "Fxn:test_shape" -> "Fxn:torch.dsmm(x,";
    "Fxn:test_shape" -> "Fxn:torch.mm(self.safeToDense(x),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_shape" -> "Fxn:test_shape(7,";
    "Fxn:test_shape" -> "Fxn:test_shape(1000,";
    "Fxn:test_shape" -> "Fxn:test_shape(3000,";
    "Fxn:test_shape" -> "Fxn:self._gen_sparse(2,";
    "Fxn:test_shape" -> "Fxn:self.randn(dj,";
    "Fxn:test_shape" -> "Fxn:torch.hsmm(x,";
    "Fxn:test_shape" -> "Fxn:self.safeToDense(),";
    "Fxn:test_shape" -> "Fxn:torch.mm(x.to_dense(),";
    "Fxn:test_shape" -> "Fxn:self.assertEqual(res.to_dense(),";
    "Fxn:test_shape" -> "Fxn:test_shape(7,";
    "Fxn:test_shape" -> "Fxn:test_shape(1000,";
    "Fxn:test_shape" -> "Fxn:test_shape(3000,";
    "Fxn:_test_spadd_shape" -> "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:_test_spadd_shape" -> "Fxn:self.randn(*shape)";
    "Fxn:_test_spadd_shape" -> "Fxn:random.random()";
    "Fxn:_test_spadd_shape" -> "Fxn:torch.add(y,";
    "Fxn:_test_spadd_shape" -> "Fxn:self.safeToDense(x)";
    "Fxn:_test_spadd_shape" -> "Fxn:self.assertEqual(res,";
    "Fxn:_test_spadd_shape" -> "Fxn:self.randn(*s)";
    "Fxn:_test_spadd_shape" -> "Fxn:y.transpose_(0,";
    "Fxn:_test_spadd_shape" -> "Fxn:random.random()";
    "Fxn:_test_spadd_shape" -> "Fxn:torch.add(y,";
    "Fxn:_test_spadd_shape" -> "Fxn:self.safeToDense(x)";
    "Fxn:_test_spadd_shape" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_spadd" -> "Fxn:self._test_spadd_shape([5,";
    "Fxn:test_spadd" -> "Fxn:self._test_spadd_shape([10,";
    "Fxn:test_spadd" -> "Fxn:self._test_spadd_shape([50,";
    "Fxn:test_spadd" -> "Fxn:self._test_spadd_shape([5,";
    "Fxn:test_spadd_hybrid" -> "Fxn:self._test_spadd_shape([5,";
    "Fxn:test_spadd_hybrid" -> "Fxn:self._test_spadd_shape([10,";
    "Fxn:test_spadd_hybrid" -> "Fxn:self._test_spadd_shape([50,";
    "Fxn:test_spadd_hybrid" -> "Fxn:self._test_spadd_shape([5,";
    "Fxn:test_norm" -> "Fxn:self._gen_sparse(3,";
    "Fxn:test_norm" -> "Fxn:x.coalesce()";
    "Fxn:test_norm" -> "Fxn:self.assertEqual(x.norm(),";
    "Fxn:test_norm" -> "Fxn:y._values().norm())";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y2.add_(x2)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x1)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x2)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y2.sub_(x2)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x1)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x2)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y2.mul_(x2)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x1)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x2)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y2.mul_(37.5)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x1)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y2.div_(37.5)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x1)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y2.pow(2)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.safeToDense(x1)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y.zero_()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:torch.zeros(x1.size())";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(self.safeToDense(y),";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertFalse(x1.is_coalesced())";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.coalesce()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:x1.coalesce()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertFalse(x1.is_coalesced())";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertTrue(y.is_coalesced())";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(x1,";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y._values().add_(1)";
    "Fxn:_test_basic_ops_shape" -> "Fxn:self.assertEqual(z._values()";
    "Fxn:_test_basic_ops_shape" -> "Fxn:y._values())";
    "Fxn:test_basic_ops" -> "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:test_basic_ops" -> "Fxn:self._test_basic_ops_shape([10,";
    "Fxn:test_basic_ops" -> "Fxn:self._test_basic_ops_shape([50,";
    "Fxn:test_basic_ops" -> "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:test_basic_ops_hybrid" -> "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:test_basic_ops_hybrid" -> "Fxn:self._test_basic_ops_shape([10,";
    "Fxn:test_basic_ops_hybrid" -> "Fxn:self._test_basic_ops_shape([50,";
    "Fxn:test_basic_ops_hybrid" -> "Fxn:self._test_basic_ops_shape([5,";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:self._gen_sparse(len(shape_i),";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:x1.clone()";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:y2.add_(x2)";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:self.safeToDense(x1)";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:self.safeToDense(x2)";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:self.assertEqual(self.safeToDense(y1),";
    "Fxn:_test_sparse_mask_shape" -> "Fxn:self.assertEqual(self.safeToDense(y2),";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:self.IndexTensor([";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:self.ValueTensor([1,";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:self.SparseTensor(i,";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:torch.Size([5,";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:4])).coalesce()";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:self.ValueTensor([";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:self.ValueTensor([7,";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:dense._sparse_mask(x)";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:self.SparseTensor(i,";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:torch.Size([5,";
    "Fxn:_test_sparse_mask_fixed" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_sparse_mask" -> "Fxn:self._test_sparse_mask_fixed()";
    "Fxn:test_sparse_mask" -> "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:test_sparse_mask" -> "Fxn:self._test_sparse_mask_shape([10,";
    "Fxn:test_sparse_mask" -> "Fxn:self._test_sparse_mask_shape([50,";
    "Fxn:test_sparse_mask" -> "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:_test_zeros" -> "Fxn:self._gen_sparse(len(out_shape_i),";
    "Fxn:_test_zeros" -> "Fxn:torch.zeros(*shape,";
    "Fxn:_test_zeros" -> "Fxn:self.assertEqual(tuple(out.size()),";
    "Fxn:_test_zeros" -> "Fxn:self.assertTrue(out._indices().numel()";
    "Fxn:_test_zeros" -> "Fxn:out._values().numel()";
    "Fxn:_test_zeros" -> "Fxn:self.assertEqual(out._nnz(),";
    "Fxn:_test_zeros" -> "Fxn:self.assertEqual(out._dimI(),";
    "Fxn:_test_zeros" -> "Fxn:self.assertEqual(out._dimV(),";
    "Fxn:test_zeros" -> "Fxn:self._test_zeros([2,";
    "Fxn:_test_zeros_like" -> "Fxn:self._gen_sparse(len(template_shape_i),";
    "Fxn:_test_zeros_like" -> "Fxn:torch.zeros_like(t)";
    "Fxn:_test_zeros_like" -> "Fxn:self.assertEqual(tuple(res.size()),";
    "Fxn:_test_zeros_like" -> "Fxn:self.assertTrue(res._indices().numel()";
    "Fxn:_test_zeros_like" -> "Fxn:res._values().numel()";
    "Fxn:_test_zeros_like" -> "Fxn:self.assertEqual(res._nnz(),";
    "Fxn:_test_zeros_like" -> "Fxn:self.assertEqual(res._dimI(),";
    "Fxn:_test_zeros_like" -> "Fxn:self.assertEqual(res._dimV(),";
    "Fxn:test_zeros_like" -> "Fxn:self._test_zeros_like(i_shapes[:i_dim],";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:self.IndexTensor([";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:self.ValueTensor([[1,";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:self.SparseTensor(i,";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:torch.Size([5,";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:2])).coalesce()";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:self.ValueTensor([";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:dense._sparse_mask(x)";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:self.ValueTensor([[7,";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:self.SparseTensor(i,";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:torch.Size([5,";
    "Fxn:_test_sparse_mask_hybrid_fixed" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.IndexTensor([[0,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.ValueTensor([3,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:torch.Size([2,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:Variable(sparse_mat)";
    "Fxn:test_sparse_variable_methods" -> "Fxn:torch.zeros_like(x),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.transpose(0,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.transpose(0,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.t(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.t_(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.div(2),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.div_(2),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.pow(2),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x._nnz(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.is_coalesced(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.coalesce(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.to_dense(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x._dimI(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x._dimV(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.norm(),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:to_test_one_arg.items():";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_var.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_mat.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:test_fn(var1)";
    "Fxn:test_sparse_variable_methods" -> "Fxn:test_fn(tensor1)";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.assertEqual(out_var,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.assertEqual(test_fn(var1).data,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:test_fn(tensor1),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.IndexTensor([[0,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.ValueTensor([3,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:torch.Size([2,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:Variable(sparse_mat2)";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.sub(y),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.sub_(y),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.mul(y),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:x.mul_(y),";
    "Fxn:test_sparse_variable_methods" -> "Fxn:to_test_two_arg.items():";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_var.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_var2.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_mat.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_mat2.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.assertEqual(test_fn(var1,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:test_fn(tensor1,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sp.sspaddmm(sp,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sp.sspaddmm(2,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sp.sspaddmm(3,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:de.addmm(sp,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:de.addmm(sp,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:torch.mm(sp,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:torch.mm(sp,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.IndexTensor([[0,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.ValueTensor([3,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:torch.Size([3,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:Variable(sparse_mat)";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_mat.to_dense().random_(0,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:Variable(dense_mat)";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_var.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:dense_var.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:sparse_mat.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:dense_mat.clone()";
    "Fxn:test_sparse_variable_methods" -> "Fxn:self.assertEqual(test_fn(sp_var,";
    "Fxn:test_sparse_variable_methods" -> "Fxn:test_fn(sp_mat,";
    "Fxn:test_sparse_mask_hybrid" -> "Fxn:self._test_sparse_mask_hybrid_fixed()";
    "Fxn:test_sparse_mask_hybrid" -> "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:test_sparse_mask_hybrid" -> "Fxn:self._test_sparse_mask_shape([10,";
    "Fxn:test_sparse_mask_hybrid" -> "Fxn:self._test_sparse_mask_shape([50,";
    "Fxn:test_sparse_mask_hybrid" -> "Fxn:self._test_sparse_mask_shape([5,";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:self.IndexTensor([[1,";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:self.ValueTensor([3,";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:torch.Size([3]))";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:torch.Size([3]))";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:self.assertFalse(z._indices().numel()";
    "Fxn:test_sparse_add_coalesce" -> "Fxn:z.is_coalesced())";
    "Fxn:test_storage_not_null" -> "Fxn:torch.cuda.sparse.FloatTensor(2)";
    "Fxn:test_storage_not_null" -> "Fxn:self.assertNotEqual(x.get_device(),";
    "Fxn:test_storage_not_null" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_same_gpu" -> "Fxn:self.IndexTensor([[2]]).cuda(1)";
    "Fxn:test_same_gpu" -> "Fxn:self.ValueTensor([5]).cuda(1)";
    "Fxn:test_same_gpu" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_same_gpu" -> "Fxn:torch.Size([3]),";
    "Fxn:test_same_gpu" -> "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:test_same_gpu" -> "Fxn:self.assertEqual(x._values().get_device(),";
    "Fxn:test_same_gpu" -> "Fxn:self.assertEqual(x._indices().get_device(),";
    "Fxn:test_same_gpu" -> "Fxn:self.SparseTensor(3,";
    "Fxn:test_same_gpu" -> "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:test_same_gpu" -> "Fxn:self.assertEqual(x._values().get_device(),";
    "Fxn:test_same_gpu" -> "Fxn:self.assertEqual(x._indices().get_device(),";
    "Fxn:test_same_gpu" -> "Fxn:self.ValueTensor([5]).cuda(0)";
    "Fxn:test_same_gpu" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_same_gpu" -> "Fxn:self.SparseTensor(i,";
    "Fxn:test_same_gpu" -> "Fxn:torch.Size([3])))";
    "Fxn:_test_new_device" -> "Fxn:torch.cuda.device(device):";
    "Fxn:_test_new_device" -> "Fxn:torch.cuda.sparse.DoubleTensor(*size)";
    "Fxn:_test_new_device" -> "Fxn:self.assertEqual(x.get_device(),";
    "Fxn:_test_new_device" -> "Fxn:x.new()";
    "Fxn:_test_new_device" -> "Fxn:x.new(2,";
    "Fxn:_test_new_device" -> "Fxn:self.assertEqual(x1.get_device(),";
    "Fxn:_test_new_device" -> "Fxn:self.assertEqual(x2.get_device(),";
    "Fxn:test_new_device_single_gpu" -> "Fxn:self._test_new_device((),";
    "Fxn:test_new_device_single_gpu" -> "Fxn:self._test_new_device((30,";
    "Fxn:test_new_device_single_gpu" -> "Fxn:self._test_new_device((30,";
    "Fxn:test_new_device_single_gpu" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_new_device_multi_gpu" -> "Fxn:self._test_new_device((),";
    "Fxn:test_new_device_multi_gpu" -> "Fxn:self._test_new_device((30,";
    "Fxn:test_new_device_multi_gpu" -> "Fxn:self._test_new_device((30,";
    "Fxn:test_new" -> "Fxn:self._gen_sparse(3,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(indices,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(indices,";
    "Fxn:test_new" -> "Fxn:x.size()),";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.sparse.uint8,";
    "Fxn:test_new" -> "Fxn:x.new(dtype=torch.sparse.uint8).dtype)";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.sparse.uint8,";
    "Fxn:test_new" -> "Fxn:x.new(1,";
    "Fxn:test_dtypes" -> "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:test_dtypes" -> "Fxn:TestTorch._test_dtypes(self,";
    "Fxn:test_empty_full" -> "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:test_empty_full" -> "Fxn:TestTorch._test_empty_full(self,";
    "Fxn:test_is_sparse" -> "Fxn:torch.randn(3,";
    "Fxn:test_is_sparse" -> "Fxn:self.assertFalse(x.is_sparse)";
    "Fxn:test_is_sparse" -> "Fxn:self.SparseTensor()";
    "Fxn:test_is_sparse" -> "Fxn:self.assertTrue(x.is_sparse)";
    "Fxn:do_test" -> "Fxn:t.new().resize_as_(t).zero_()";
    "Fxn:do_test" -> "Fxn:self.assertEqual(y.shape,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(t,";
    "Fxn:do_test" -> "Fxn:do_test(self.SparseTensor())";
    "class:TestUncoalescedSparse(TestSparse):" -> "Fxn:setUp";
    "Fxn:setUp" -> "Fxn:self).setUp()";
    "Fxn:setUp" -> "Fxn:@unittest.skipIf(not";
    "class:TestCudaSparse(TestSparse):" -> "Fxn:setUp";
    "Fxn:setUp" -> "Fxn:self).setUp()";
    "Fxn:setUp" -> "Fxn:@unittest.skipIf(not";
    "class:TestCudaUncoalescedSparse(TestCudaSparse):" -> "Fxn:setUp";
    "Fxn:setUp" -> "Fxn:self).setUp()";
    "Fxn:setUp" -> "Fxn:run_tests()";
    "/test/test_torch.py" -> "Import:sys";
    "/test/test_torch.py" -> "Import:import";
    "/test/test_torch.py" -> "Import:import";
    "/test/test_torch.py" -> "Import:math";
    "/test/test_torch.py" -> "Import:random";
    "/test/test_torch.py" -> "Import:operator";
    "/test/test_torch.py" -> "Import:copy";
    "/test/test_torch.py" -> "Import:torch";
    "/test/test_torch.py" -> "Import:torch.cuda";
    "/test/test_torch.py" -> "Import:tempfile";
    "/test/test_torch.py" -> "Import:unittest";
    "/test/test_torch.py" -> "Import:warnings";
    "/test/test_torch.py" -> "Import:pickle";
    "/test/test_torch.py" -> "Import:from_dlpack,";
    "/test/test_torch.py" -> "Import:product,";
    "/test/test_torch.py" -> "Import:reduce";
    "/test/test_torch.py" -> "Import:TestCase,";
    "/test/test_torch.py" -> "Import:numpy";
    "/test/test_torch.py" -> "Import:signal";
    "/test/test_torch.py" -> "class:FilelikeMock(object):";
    "/test/test_torch.py" -> "class:BytesIOContext(io.BytesIO):";
    "/test/test_torch.py" -> "class:TestTorch(TestCase):";
    "/test/test_torch.py" -> "Import:digamma";
    "/test/test_torch.py" -> "Import:polygamma";
    "/test/test_torch.py" -> "Import:numpy";
    "/test/test_torch.py" -> "Import:deepcopy";
    "/test/test_torch.py" -> "Import:deepcopy";
    "/test/test_torch.py" -> "Import:copy";
    "/test/test_torch.py" -> "Import:cPickle";
    "/test/test_torch.py" -> "Import:pickle";
    "/test/test_torch.py" -> "Import:importlib.util";
    "/test/test_torch.py" -> "Import:imp";
    "class:FilelikeMock(object):" -> "Fxn:__init__";
    "class:FilelikeMock(object):" -> "Fxn:trace";
    "class:FilelikeMock(object):" -> "Fxn:result";
    "class:FilelikeMock(object):" -> "Fxn:fileno_opt";
    "class:FilelikeMock(object):" -> "Fxn:readinto_opt";
    "class:FilelikeMock(object):" -> "Fxn:was_called";
    "Fxn:__init__" -> "Fxn:io.BytesIO(data)";
    "Fxn:result" -> "Fxn:self.calls.add(name)";
    "Fxn:result" -> "Fxn:fn(*args,";
    "Fxn:result" -> "Fxn:trace(getattr(self.bytesio,";
    "Fxn:fileno_opt" -> "Fxn:io.UnsupportedOperation('Not";
    "Fxn:readinto_opt" -> "Fxn:self.calls.add('readinto')";
    "Fxn:readinto_opt" -> "Fxn:self.bytesio.readinto(view)";
    "class:BytesIOContext(io.BytesIO):" -> "Fxn:__enter__";
    "class:BytesIOContext(io.BytesIO):" -> "Fxn:__exit__";
    "class:TestTorch(TestCase):" -> "Fxn:test_dot";
    "class:TestTorch(TestCase):" -> "Fxn:test_ger";
    "class:TestTorch(TestCase):" -> "Fxn:test_addr";
    "class:TestTorch(TestCase):" -> "Fxn:run_test";
    "class:TestTorch(TestCase):" -> "Fxn:test_addmv";
    "class:TestTorch(TestCase):" -> "Fxn:test_addmm";
    "class:TestTorch(TestCase):" -> "Fxn:test_linear_algebra_scalar_raises";
    "class:TestTorch(TestCase):" -> "Fxn:_testMath";
    "class:TestTorch(TestCase):" -> "Fxn:_testMathByName";
    "class:TestTorch(TestCase):" -> "Fxn:test_sin";
    "class:TestTorch(TestCase):" -> "Fxn:test_sinh";
    "class:TestTorch(TestCase):" -> "Fxn:test_lgamma";
    "class:TestTorch(TestCase):" -> "Fxn:test_digamma";
    "class:TestTorch(TestCase):" -> "Fxn:test_polygamma";
    "class:TestTorch(TestCase):" -> "Fxn:test_asin";
    "class:TestTorch(TestCase):" -> "Fxn:test_cos";
    "class:TestTorch(TestCase):" -> "Fxn:test_cosh";
    "class:TestTorch(TestCase):" -> "Fxn:test_acos";
    "class:TestTorch(TestCase):" -> "Fxn:test_tan";
    "class:TestTorch(TestCase):" -> "Fxn:test_tanh";
    "class:TestTorch(TestCase):" -> "Fxn:test_atan";
    "class:TestTorch(TestCase):" -> "Fxn:test_log";
    "class:TestTorch(TestCase):" -> "Fxn:test_sqrt";
    "class:TestTorch(TestCase):" -> "Fxn:test_erf";
    "class:TestTorch(TestCase):" -> "Fxn:test_erfinv";
    "class:TestTorch(TestCase):" -> "Fxn:checkType";
    "class:TestTorch(TestCase):" -> "Fxn:test_exp";
    "class:TestTorch(TestCase):" -> "Fxn:test_expm1";
    "class:TestTorch(TestCase):" -> "Fxn:test_floor";
    "class:TestTorch(TestCase):" -> "Fxn:test_ceil";
    "class:TestTorch(TestCase):" -> "Fxn:test_rsqrt";
    "class:TestTorch(TestCase):" -> "Fxn:test_sigmoid";
    "class:TestTorch(TestCase):" -> "Fxn:checkType";
    "class:TestTorch(TestCase):" -> "Fxn:test_frac";
    "class:TestTorch(TestCase):" -> "Fxn:test_trunc";
    "class:TestTorch(TestCase):" -> "Fxn:test_round";
    "class:TestTorch(TestCase):" -> "Fxn:test_has_storage";
    "class:TestTorch(TestCase):" -> "Fxn:test_has_storage_numpy";
    "class:TestTorch(TestCase):" -> "Fxn:_testSelection";
    "class:TestTorch(TestCase):" -> "Fxn:test_max";
    "class:TestTorch(TestCase):" -> "Fxn:test_min";
    "class:TestTorch(TestCase):" -> "Fxn:_test_dim_reduction";
    "class:TestTorch(TestCase):" -> "Fxn:normfn_attr";
    "class:TestTorch(TestCase):" -> "Fxn:fn";
    "class:TestTorch(TestCase):" -> "Fxn:fn_tuple";
    "class:TestTorch(TestCase):" -> "Fxn:test_multidim";
    "class:TestTorch(TestCase):" -> "Fxn:test_dim_reduction";
    "class:TestTorch(TestCase):" -> "Fxn:_testCSelection";
    "class:TestTorch(TestCase):" -> "Fxn:test_max_elementwise";
    "class:TestTorch(TestCase):" -> "Fxn:test_min_elementwise";
    "class:TestTorch(TestCase):" -> "Fxn:test_lerp";
    "class:TestTorch(TestCase):" -> "Fxn:TH_lerp";
    "class:TestTorch(TestCase):" -> "Fxn:test_all_any";
    "class:TestTorch(TestCase):" -> "Fxn:test";
    "class:TestTorch(TestCase):" -> "Fxn:test_all_any_empty";
    "class:TestTorch(TestCase):" -> "Fxn:test_all_any_empty_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:test_mv";
    "class:TestTorch(TestCase):" -> "Fxn:test_add";
    "class:TestTorch(TestCase):" -> "Fxn:test_csub";
    "class:TestTorch(TestCase):" -> "Fxn:_test_neg";
    "class:TestTorch(TestCase):" -> "Fxn:test_neg";
    "class:TestTorch(TestCase):" -> "Fxn:test_reciprocal";
    "class:TestTorch(TestCase):" -> "Fxn:test_mul";
    "class:TestTorch(TestCase):" -> "Fxn:test_div";
    "class:TestTorch(TestCase):" -> "Fxn:test_fmod";
    "class:TestTorch(TestCase):" -> "Fxn:test_remainder";
    "class:TestTorch(TestCase):" -> "Fxn:test_mm";
    "class:TestTorch(TestCase):" -> "Fxn:matrixmultiply";
    "class:TestTorch(TestCase):" -> "Fxn:_test_btrifact";
    "class:TestTorch(TestCase):" -> "Fxn:test_btrifact";
    "class:TestTorch(TestCase):" -> "Fxn:_test_btrisolve";
    "class:TestTorch(TestCase):" -> "Fxn:test_btrisolve";
    "class:TestTorch(TestCase):" -> "Fxn:test_bmm";
    "class:TestTorch(TestCase):" -> "Fxn:test_addbmm";
    "class:TestTorch(TestCase):" -> "Fxn:test_baddbmm";
    "class:TestTorch(TestCase):" -> "Fxn:test_clamp";
    "class:TestTorch(TestCase):" -> "Fxn:test_pow";
    "class:TestTorch(TestCase):" -> "Fxn:test_rpow";
    "class:TestTorch(TestCase):" -> "Fxn:_test_int_pow";
    "class:TestTorch(TestCase):" -> "Fxn:check_against_np";
    "class:TestTorch(TestCase):" -> "Fxn:test_int_pow";
    "class:TestTorch(TestCase):" -> "Fxn:_test_cop";
    "class:TestTorch(TestCase):" -> "Fxn:reference_implementation";
    "class:TestTorch(TestCase):" -> "Fxn:test_cdiv";
    "class:TestTorch(TestCase):" -> "Fxn:test_cfmod";
    "class:TestTorch(TestCase):" -> "Fxn:test_cremainder";
    "class:TestTorch(TestCase):" -> "Fxn:test_cmul";
    "class:TestTorch(TestCase):" -> "Fxn:test_cpow";
    "class:TestTorch(TestCase):" -> "Fxn:test_sum";
    "class:TestTorch(TestCase):" -> "Fxn:test_prod";
    "class:TestTorch(TestCase):" -> "Fxn:test_cumsum";
    "class:TestTorch(TestCase):" -> "Fxn:test_cumprod";
    "class:TestTorch(TestCase):" -> "Fxn:test_cross";
    "class:TestTorch(TestCase):" -> "Fxn:test_zeros";
    "class:TestTorch(TestCase):" -> "Fxn:test_zeros_like";
    "class:TestTorch(TestCase):" -> "Fxn:test_zeros_like_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:test_zeros_like_multiple_device";
    "class:TestTorch(TestCase):" -> "Fxn:test_histc";
    "class:TestTorch(TestCase):" -> "Fxn:test_ones";
    "class:TestTorch(TestCase):" -> "Fxn:test_ones_like";
    "class:TestTorch(TestCase):" -> "Fxn:test_ones_like_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:test_ones_like_multiple_device";
    "class:TestTorch(TestCase):" -> "Fxn:_test_dtypes";
    "class:TestTorch(TestCase):" -> "Fxn:test_dtypes";
    "class:TestTorch(TestCase):" -> "Fxn:_test_empty_full";
    "class:TestTorch(TestCase):" -> "Fxn:check_value";
    "class:TestTorch(TestCase):" -> "Fxn:get_int64_dtype";
    "class:TestTorch(TestCase):" -> "Fxn:test_empty_full";
    "class:TestTorch(TestCase):" -> "Fxn:test_dtype_out_match";
    "class:TestTorch(TestCase):" -> "Fxn:test_constructor_dtypes";
    "class:TestTorch(TestCase):" -> "Fxn:test_tensor_factory";
    "class:TestTorch(TestCase):" -> "Fxn:test_new_tensor";
    "class:TestTorch(TestCase):" -> "Fxn:test_diag";
    "class:TestTorch(TestCase):" -> "Fxn:_test_diagonal";
    "class:TestTorch(TestCase):" -> "Fxn:test_diagonal";
    "class:TestTorch(TestCase):" -> "Fxn:_test_diagflat";
    "class:TestTorch(TestCase):" -> "Fxn:test_diagflat";
    "class:TestTorch(TestCase):" -> "Fxn:test_eye";
    "class:TestTorch(TestCase):" -> "Fxn:test_renorm";
    "class:TestTorch(TestCase):" -> "Fxn:renorm";
    "class:TestTorch(TestCase):" -> "Fxn:_test_multinomial";
    "class:TestTorch(TestCase):" -> "Fxn:make_prob_dist";
    "class:TestTorch(TestCase):" -> "Fxn:test_multinomial";
    "class:TestTorch(TestCase):" -> "Fxn:test_range";
    "class:TestTorch(TestCase):" -> "Fxn:test_arange";
    "class:TestTorch(TestCase):" -> "Fxn:_select_broadcastable_dims";
    "class:TestTorch(TestCase):" -> "Fxn:_test_broadcast";
    "class:TestTorch(TestCase):" -> "Fxn:tensorfn";
    "class:TestTorch(TestCase):" -> "Fxn:torchfn";
    "class:TestTorch(TestCase):" -> "Fxn:tensorfn_inplace";
    "class:TestTorch(TestCase):" -> "Fxn:broadcastable";
    "class:TestTorch(TestCase):" -> "Fxn:_test_in_place_broadcastable";
    "class:TestTorch(TestCase):" -> "Fxn:test_broadcast";
    "class:TestTorch(TestCase):" -> "Fxn:_test_contiguous";
    "class:TestTorch(TestCase):" -> "Fxn:test_contiguous";
    "class:TestTorch(TestCase):" -> "Fxn:test_scalars_as_floats";
    "class:TestTorch(TestCase):" -> "Fxn:_test_broadcast_fused_matmul";
    "class:TestTorch(TestCase):" -> "Fxn:dims_full_for_fn";
    "class:TestTorch(TestCase):" -> "Fxn:test_broadcast_fused_matmul";
    "class:TestTorch(TestCase):" -> "Fxn:_test_broadcast_batched_matmul";
    "class:TestTorch(TestCase):" -> "Fxn:verify_batched_matmul";
    "class:TestTorch(TestCase):" -> "Fxn:maybe_squeeze_result";
    "class:TestTorch(TestCase):" -> "Fxn:test_broadcast_batched_matmul";
    "class:TestTorch(TestCase):" -> "Fxn:test_copy_broadcast";
    "class:TestTorch(TestCase):" -> "Fxn:test_randperm";
    "class:TestTorch(TestCase):" -> "Fxn:test_random";
    "class:TestTorch(TestCase):" -> "Fxn:assertIsOrdered";
    "class:TestTorch(TestCase):" -> "Fxn:check_order";
    "class:TestTorch(TestCase):" -> "Fxn:check_order";
    "class:TestTorch(TestCase):" -> "Fxn:test_sort";
    "class:TestTorch(TestCase):" -> "Fxn:test_topk";
    "class:TestTorch(TestCase):" -> "Fxn:topKViaSort";
    "class:TestTorch(TestCase):" -> "Fxn:compareTensors";
    "class:TestTorch(TestCase):" -> "Fxn:compare";
    "class:TestTorch(TestCase):" -> "Fxn:test_topk_arguments";
    "class:TestTorch(TestCase):" -> "Fxn:test_kthvalue";
    "class:TestTorch(TestCase):" -> "Fxn:test_median";
    "class:TestTorch(TestCase):" -> "Fxn:test_mode";
    "class:TestTorch(TestCase):" -> "Fxn:test_tril";
    "class:TestTorch(TestCase):" -> "Fxn:test_triu";
    "class:TestTorch(TestCase):" -> "Fxn:test_cat";
    "class:TestTorch(TestCase):" -> "Fxn:test_cat_bad_input_sizes";
    "class:TestTorch(TestCase):" -> "Fxn:test_cat_scalars";
    "class:TestTorch(TestCase):" -> "Fxn:test_stack";
    "class:TestTorch(TestCase):" -> "Fxn:test_stack_out";
    "class:TestTorch(TestCase):" -> "Fxn:test_unbind";
    "class:TestTorch(TestCase):" -> "Fxn:test_linspace";
    "class:TestTorch(TestCase):" -> "Fxn:test_logspace";
    "class:TestTorch(TestCase):" -> "Fxn:test_rand";
    "class:TestTorch(TestCase):" -> "Fxn:test_randn";
    "class:TestTorch(TestCase):" -> "Fxn:test_slice";
    "class:TestTorch(TestCase):" -> "Fxn:test_is_signed";
    "class:TestTorch(TestCase):" -> "Fxn:test_is_signed_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:test_gesv";
    "class:TestTorch(TestCase):" -> "Fxn:test_qr";
    "class:TestTorch(TestCase):" -> "Fxn:canonicalize";
    "class:TestTorch(TestCase):" -> "Fxn:canon_and_check";
    "class:TestTorch(TestCase):" -> "Fxn:check_qr";
    "class:TestTorch(TestCase):" -> "Fxn:test_ormqr";
    "class:TestTorch(TestCase):" -> "Fxn:test_trtrs";
    "class:TestTorch(TestCase):" -> "Fxn:test_gels";
    "class:TestTorch(TestCase):" -> "Fxn:_test_underdetermined";
    "class:TestTorch(TestCase):" -> "Fxn:_test_overdetermined";
    "class:TestTorch(TestCase):" -> "Fxn:check_norm";
    "class:TestTorch(TestCase):" -> "Fxn:test_eig";
    "class:TestTorch(TestCase):" -> "Fxn:test_symeig";
    "class:TestTorch(TestCase):" -> "Fxn:test_svd";
    "class:TestTorch(TestCase):" -> "Fxn:_test_window_function";
    "class:TestTorch(TestCase):" -> "Fxn:test_hann_window";
    "class:TestTorch(TestCase):" -> "Fxn:test_hamming_window";
    "class:TestTorch(TestCase):" -> "Fxn:test_bartlett_window";
    "class:TestTorch(TestCase):" -> "Fxn:test_inverse";
    "class:TestTorch(TestCase):" -> "Fxn:_test_det_logdet_slogdet";
    "class:TestTorch(TestCase):" -> "Fxn:reference_det";
    "class:TestTorch(TestCase):" -> "Fxn:test_single_det";
    "class:TestTorch(TestCase):" -> "Fxn:test";
    "class:TestTorch(TestCase):" -> "Fxn:get_random_mat_scale";
    "class:TestTorch(TestCase):" -> "Fxn:test_det_logdet_slogdet";
    "class:TestTorch(TestCase):" -> "Fxn:_test_stft";
    "class:TestTorch(TestCase):" -> "Fxn:naive_stft";
    "class:TestTorch(TestCase):" -> "Fxn:_test";
    "class:TestTorch(TestCase):" -> "Fxn:test_stft";
    "class:TestTorch(TestCase):" -> "Fxn:test_conv2";
    "class:TestTorch(TestCase):" -> "Fxn:test_conv3";
    "class:TestTorch(TestCase):" -> "Fxn:_test_conv_corr_eq";
    "class:TestTorch(TestCase):" -> "Fxn:test_xcorr3_xcorr2_eq";
    "class:TestTorch(TestCase):" -> "Fxn:reference";
    "class:TestTorch(TestCase):" -> "Fxn:test_xcorr3_xcorr2_eq_full";
    "class:TestTorch(TestCase):" -> "Fxn:reference";
    "class:TestTorch(TestCase):" -> "Fxn:test_conv3_conv2_eq_valid";
    "class:TestTorch(TestCase):" -> "Fxn:reference";
    "class:TestTorch(TestCase):" -> "Fxn:test_fconv3_fconv2_eq";
    "class:TestTorch(TestCase):" -> "Fxn:reference";
    "class:TestTorch(TestCase):" -> "Fxn:test_logical";
    "class:TestTorch(TestCase):" -> "Fxn:test_isnan";
    "class:TestTorch(TestCase):" -> "Fxn:test_RNGState";
    "class:TestTorch(TestCase):" -> "Fxn:test_RNGStateAliasing";
    "class:TestTorch(TestCase):" -> "Fxn:test_boxMullerState";
    "class:TestTorch(TestCase):" -> "Fxn:test_manual_seed";
    "class:TestTorch(TestCase):" -> "Fxn:test_cholesky";
    "class:TestTorch(TestCase):" -> "Fxn:test_potrs";
    "class:TestTorch(TestCase):" -> "Fxn:tset_potri";
    "class:TestTorch(TestCase):" -> "Fxn:test_pstrf";
    "class:TestTorch(TestCase):" -> "Fxn:checkPsdCholesky";
    "class:TestTorch(TestCase):" -> "Fxn:test_numel";
    "class:TestTorch(TestCase):" -> "Fxn:_consecutive";
    "class:TestTorch(TestCase):" -> "Fxn:_test_index";
    "class:TestTorch(TestCase):" -> "Fxn:consec";
    "class:TestTorch(TestCase):" -> "Fxn:test_index";
    "class:TestTorch(TestCase):" -> "Fxn:_test_advancedindex";
    "class:TestTorch(TestCase):" -> "Fxn:consec";
    "class:TestTorch(TestCase):" -> "Fxn:ri";
    "class:TestTorch(TestCase):" -> "Fxn:tensor_indices_to_np";
    "class:TestTorch(TestCase):" -> "Fxn:get_numpy";
    "class:TestTorch(TestCase):" -> "Fxn:set_numpy";
    "class:TestTorch(TestCase):" -> "Fxn:assert_get_eq";
    "class:TestTorch(TestCase):" -> "Fxn:assert_set_eq";
    "class:TestTorch(TestCase):" -> "Fxn:get_set_tensor";
    "class:TestTorch(TestCase):" -> "Fxn:test_advancedindex";
    "class:TestTorch(TestCase):" -> "Fxn:_test_advancedindex_big";
    "class:TestTorch(TestCase):" -> "Fxn:test_advancedindex_big";
    "class:TestTorch(TestCase):" -> "Fxn:test_newaxis_numpy_comparison";
    "class:TestTorch(TestCase):" -> "Fxn:run_test";
    "class:TestTorch(TestCase):" -> "Fxn:test_newindex";
    "class:TestTorch(TestCase):" -> "Fxn:checkPartialAssign";
    "class:TestTorch(TestCase):" -> "Fxn:test_index_copy";
    "class:TestTorch(TestCase):" -> "Fxn:test_index_add";
    "class:TestTorch(TestCase):" -> "Fxn:test_index_select";
    "class:TestTorch(TestCase):" -> "Fxn:test_take";
    "class:TestTorch(TestCase):" -> "Fxn:check";
    "class:TestTorch(TestCase):" -> "Fxn:test_put_";
    "class:TestTorch(TestCase):" -> "Fxn:check";
    "class:TestTorch(TestCase):" -> "Fxn:test_put_accumulate";
    "class:TestTorch(TestCase):" -> "Fxn:_fill_indices";
    "class:TestTorch(TestCase):" -> "Fxn:_test_gather";
    "class:TestTorch(TestCase):" -> "Fxn:test_gather";
    "class:TestTorch(TestCase):" -> "Fxn:_test_scatter_base";
    "class:TestTorch(TestCase):" -> "Fxn:test_scatter";
    "class:TestTorch(TestCase):" -> "Fxn:test_scatterAdd";
    "class:TestTorch(TestCase):" -> "Fxn:test_scatterFill";
    "class:TestTorch(TestCase):" -> "Fxn:test_masked_scatter";
    "class:TestTorch(TestCase):" -> "Fxn:test_masked_select";
    "class:TestTorch(TestCase):" -> "Fxn:test_masked_fill";
    "class:TestTorch(TestCase):" -> "Fxn:test_abs";
    "class:TestTorch(TestCase):" -> "Fxn:test_unbiased";
    "class:TestTorch(TestCase):" -> "Fxn:test_var_stability";
    "class:TestTorch(TestCase):" -> "Fxn:_test_view";
    "class:TestTorch(TestCase):" -> "Fxn:test_view";
    "class:TestTorch(TestCase):" -> "Fxn:test_reshape";
    "class:TestTorch(TestCase):" -> "Fxn:test_expand";
    "class:TestTorch(TestCase):" -> "Fxn:test_repeat";
    "class:TestTorch(TestCase):" -> "Fxn:test_repeat_tile";
    "class:TestTorch(TestCase):" -> "Fxn:_generate_noncontiguous_input";
    "class:TestTorch(TestCase):" -> "Fxn:test_is_same_size";
    "class:TestTorch(TestCase):" -> "Fxn:test_is_set_to";
    "class:TestTorch(TestCase):" -> "Fxn:test_tensor_set";
    "class:TestTorch(TestCase):" -> "Fxn:test_equal";
    "class:TestTorch(TestCase):" -> "Fxn:test_element_size";
    "class:TestTorch(TestCase):" -> "Fxn:test_split";
    "class:TestTorch(TestCase):" -> "Fxn:test_chunk";
    "class:TestTorch(TestCase):" -> "Fxn:test_tolist";
    "class:TestTorch(TestCase):" -> "Fxn:test_permute";
    "class:TestTorch(TestCase):" -> "Fxn:test_storage";
    "class:TestTorch(TestCase):" -> "Fxn:test_storageview";
    "class:TestTorch(TestCase):" -> "Fxn:test_nonzero";
    "class:TestTorch(TestCase):" -> "Fxn:test_deepcopy";
    "class:TestTorch(TestCase):" -> "Fxn:test_deepcopy_scalar";
    "class:TestTorch(TestCase):" -> "Fxn:test_copy";
    "class:TestTorch(TestCase):" -> "Fxn:test_pickle";
    "class:TestTorch(TestCase):" -> "Fxn:test_norm_fastpaths";
    "class:TestTorch(TestCase):" -> "Fxn:test_bernoulli";
    "class:TestTorch(TestCase):" -> "Fxn:isBinary";
    "class:TestTorch(TestCase):" -> "Fxn:test_normal";
    "class:TestTorch(TestCase):" -> "Fxn:_test_serialization";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_filelike";
    "class:TestTorch(TestCase):" -> "Fxn:_test_serialization_offset";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_offset";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_offset_filelike";
    "class:TestTorch(TestCase):" -> "Fxn:test_half_tensor";
    "class:TestTorch(TestCase):" -> "Fxn:test_half_tensor_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:_test_serialization_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_cuda_filelike";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_backwards_compat";
    "class:TestTorch(TestCase):" -> "Fxn:_test_serialization_container";
    "class:TestTorch(TestCase):" -> "Fxn:import_module";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_container";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_container_filelike";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_map_location";
    "class:TestTorch(TestCase):" -> "Fxn:map_location";
    "class:TestTorch(TestCase):" -> "Fxn:load_bytes";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_filelike_api_requirements";
    "class:TestTorch(TestCase):" -> "Fxn:_test_serialization_filelike";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_filelike_missing_attrs";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_filelike_stress";
    "class:TestTorch(TestCase):" -> "Fxn:test_serialization_filelike_uses_readinto";
    "class:TestTorch(TestCase):" -> "Fxn:test_from_buffer";
    "class:TestTorch(TestCase):" -> "Fxn:test_from_file";
    "class:TestTorch(TestCase):" -> "Fxn:test_print";
    "class:TestTorch(TestCase):" -> "Fxn:test_sizeof";
    "class:TestTorch(TestCase):" -> "Fxn:test_unsqueeze";
    "class:TestTorch(TestCase):" -> "Fxn:test_iter";
    "class:TestTorch(TestCase):" -> "Fxn:test_accreal_type";
    "class:TestTorch(TestCase):" -> "Fxn:test_assertEqual";
    "class:TestTorch(TestCase):" -> "Fxn:test_new";
    "class:TestTorch(TestCase):" -> "Fxn:test_empty_like";
    "class:TestTorch(TestCase):" -> "Fxn:test_pin_memory";
    "class:TestTorch(TestCase):" -> "Fxn:test_numpy_unresizable";
    "class:TestTorch(TestCase):" -> "Fxn:test_toNumpy";
    "class:TestTorch(TestCase):" -> "Fxn:check2d";
    "class:TestTorch(TestCase):" -> "Fxn:test_dlpack_conversion";
    "class:TestTorch(TestCase):" -> "Fxn:test_dlpack_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:test_from_numpy";
    "class:TestTorch(TestCase):" -> "Fxn:test_ctor_with_numpy_array";
    "class:TestTorch(TestCase):" -> "Fxn:test_numpy_index";
    "class:TestTorch(TestCase):" -> "Fxn:test_numpy_array_interface";
    "class:TestTorch(TestCase):" -> "Fxn:test_error_msg_type_translation";
    "class:TestTorch(TestCase):" -> "Fxn:test_comparison_ops";
    "class:TestTorch(TestCase):" -> "Fxn:test_bitwise_ops";
    "class:TestTorch(TestCase):" -> "Fxn:test_invert";
    "class:TestTorch(TestCase):" -> "Fxn:test_apply";
    "class:TestTorch(TestCase):" -> "Fxn:test_map";
    "class:TestTorch(TestCase):" -> "Fxn:test_map2";
    "class:TestTorch(TestCase):" -> "Fxn:test_Size";
    "class:TestTorch(TestCase):" -> "Fxn:test_big_transpose";
    "class:TestTorch(TestCase):" -> "Fxn:test_inplace_division";
    "class:TestTorch(TestCase):" -> "Fxn:test_simple_scalar_cast";
    "class:TestTorch(TestCase):" -> "Fxn:test_offset_scalar_cast";
    "class:TestTorch(TestCase):" -> "Fxn:test_set_flush_denormal";
    "class:TestTorch(TestCase):" -> "Fxn:test_unique_cpu";
    "class:TestTorch(TestCase):" -> "Fxn:test_unique_cuda";
    "class:TestTorch(TestCase):" -> "Fxn:make_neg_dim_test";
    "class:TestTorch(TestCase):" -> "Fxn:neg_dim_test";
    "class:TestTorch(TestCase):" -> "Fxn:idx_tensor";
    "Fxn:test_dot" -> "Fxn:types.items():";
    "Fxn:test_dot" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_dot" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_dot" -> "Fxn:torch.dot(v1,";
    "Fxn:test_dot" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_dot" -> "Fxn:types.items():";
    "Fxn:test_dot" -> "Fxn:torch.randn(1).type(tname).expand(100)";
    "Fxn:test_dot" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_dot" -> "Fxn:torch.dot(v1,";
    "Fxn:test_dot" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ger" -> "Fxn:types.items():";
    "Fxn:test_ger" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_ger" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_ger" -> "Fxn:torch.ger(v1,";
    "Fxn:test_ger" -> "Fxn:torch.zeros(100,";
    "Fxn:test_ger" -> "Fxn:100).type(tname)";
    "Fxn:test_ger" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ger" -> "Fxn:types.items():";
    "Fxn:test_ger" -> "Fxn:torch.randn(1).type(tname).expand(100)";
    "Fxn:test_ger" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_ger" -> "Fxn:torch.ger(v1,";
    "Fxn:test_ger" -> "Fxn:torch.zeros(100,";
    "Fxn:test_ger" -> "Fxn:100).type(tname)";
    "Fxn:test_ger" -> "Fxn:self.assertEqual(res1,";
    "Fxn:run_test" -> "Fxn:m_transform(m.clone())";
    "Fxn:run_test" -> "Fxn:m.clone()";
    "Fxn:run_test" -> "Fxn:torch.addr(m,";
    "Fxn:run_test" -> "Fxn:self.assertEqual(m,";
    "Fxn:run_test" -> "Fxn:types.items():";
    "Fxn:run_test" -> "Fxn:[(100,";
    "Fxn:run_test" -> "Fxn:torch.randn(h,";
    "Fxn:run_test" -> "Fxn:w).type(tname)";
    "Fxn:run_test" -> "Fxn:torch.randn(h).type(tname)";
    "Fxn:run_test" -> "Fxn:torch.randn(w).type(tname)";
    "Fxn:run_test" -> "Fxn:run_test(m,";
    "Fxn:run_test" -> "Fxn:run_test(m,";
    "Fxn:run_test" -> "Fxn:x.transpose(0,";
    "Fxn:run_test" -> "Fxn:torch.randn(1).type(tname).expand(h)";
    "Fxn:run_test" -> "Fxn:run_test(m,";
    "Fxn:run_test" -> "Fxn:run_test(m,";
    "Fxn:run_test" -> "Fxn:x.transpose(0,";
    "Fxn:test_addmv" -> "Fxn:types.items():";
    "Fxn:test_addmv" -> "Fxn:torch.randn(10).type(tname)";
    "Fxn:test_addmv" -> "Fxn:torch.randn(10,";
    "Fxn:test_addmv" -> "Fxn:100).type(tname)";
    "Fxn:test_addmv" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_addmv" -> "Fxn:torch.addmv(t,";
    "Fxn:test_addmv" -> "Fxn:torch.zeros(10).type(tname)";
    "Fxn:test_addmv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_addmv" -> "Fxn:types.items():";
    "Fxn:test_addmv" -> "Fxn:torch.randn(1).type(tname).expand(10)";
    "Fxn:test_addmv" -> "Fxn:torch.randn(10,";
    "Fxn:test_addmv" -> "Fxn:1).type(tname).expand(10,";
    "Fxn:test_addmv" -> "Fxn:torch.randn(100).type(tname)";
    "Fxn:test_addmv" -> "Fxn:torch.addmv(t,";
    "Fxn:test_addmv" -> "Fxn:torch.zeros(10).type(tname)";
    "Fxn:test_addmv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_addmm" -> "Fxn:types.items():";
    "Fxn:test_addmm" -> "Fxn:torch.randn(10,";
    "Fxn:test_addmm" -> "Fxn:25).type(tname)";
    "Fxn:test_addmm" -> "Fxn:torch.randn(10,";
    "Fxn:test_addmm" -> "Fxn:50).type(tname)";
    "Fxn:test_addmm" -> "Fxn:torch.randn(50,";
    "Fxn:test_addmm" -> "Fxn:25).type(tname)";
    "Fxn:test_addmm" -> "Fxn:torch.addmm(M,";
    "Fxn:test_addmm" -> "Fxn:torch.zeros(10,";
    "Fxn:test_addmm" -> "Fxn:25).type(tname)";
    "Fxn:test_addmm" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_addmm" -> "Fxn:types.items():";
    "Fxn:test_addmm" -> "Fxn:torch.randn(10,";
    "Fxn:test_addmm" -> "Fxn:1).type(tname).expand(10,";
    "Fxn:test_addmm" -> "Fxn:torch.randn(10,";
    "Fxn:test_addmm" -> "Fxn:1).type(tname).expand(10,";
    "Fxn:test_addmm" -> "Fxn:torch.randn(50,";
    "Fxn:test_addmm" -> "Fxn:25).type(tname)";
    "Fxn:test_addmm" -> "Fxn:torch.addmm(M,";
    "Fxn:test_addmm" -> "Fxn:torch.zeros(10,";
    "Fxn:test_addmm" -> "Fxn:25).type(tname)";
    "Fxn:test_addmm" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.randn(5,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.randn(5)";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.tensor(7)";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.mv(m,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.addmv(v,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.ger(v,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.ger(s,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.addr(m,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_linear_algebra_scalar_raises" -> "Fxn:torch.addr(m,";
    "Fxn:_testMath" -> "Fxn:torch.randn(*size)";
    "Fxn:_testMath" -> "Fxn:torchfn(m1[4])";
    "Fxn:_testMath" -> "Fxn:res1.clone().zero_()";
    "Fxn:_testMath" -> "Fxn:mathfn(v.item())";
    "Fxn:_testMath" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_testMath" -> "Fxn:torch.randn(*size)";
    "Fxn:_testMath" -> "Fxn:torchfn(m1[:,";
    "Fxn:_testMath" -> "Fxn:res1.clone().zero_()";
    "Fxn:_testMath" -> "Fxn:mathfn(v.item())";
    "Fxn:_testMath" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_testMathByName" -> "Fxn:self._testMath(torchfn,";
    "Fxn:test_sin" -> "Fxn:self._testMathByName('sin')";
    "Fxn:test_sinh" -> "Fxn:self._testMathByName('sinh')";
    "Fxn:test_lgamma" -> "Fxn:self._testMathByName('lgamma')";
    "Fxn:test_lgamma" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_digamma" -> "Fxn:self._testMath(torch.digamma,";
    "Fxn:test_digamma" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_polygamma" -> "Fxn:self._testMath(lambda";
    "Fxn:test_polygamma" -> "Fxn:torch.polygamma(n,";
    "Fxn:test_polygamma" -> "Fxn:polygamma(n,";
    "Fxn:test_polygamma" -> "Fxn:x)[()])";
    "Fxn:test_asin" -> "Fxn:self._testMath(torch.asin,";
    "Fxn:test_asin" -> "Fxn:math.asin(x)";
    "Fxn:test_cos" -> "Fxn:self._testMathByName('cos')";
    "Fxn:test_cosh" -> "Fxn:self._testMathByName('cosh')";
    "Fxn:test_acos" -> "Fxn:self._testMath(torch.acos,";
    "Fxn:test_acos" -> "Fxn:math.acos(x)";
    "Fxn:test_tan" -> "Fxn:self._testMathByName('tan')";
    "Fxn:test_tanh" -> "Fxn:self._testMathByName('tanh')";
    "Fxn:test_atan" -> "Fxn:self._testMathByName('atan')";
    "Fxn:test_log" -> "Fxn:self._testMath(torch.log,";
    "Fxn:test_log" -> "Fxn:math.log(x)";
    "Fxn:test_sqrt" -> "Fxn:self._testMath(torch.sqrt,";
    "Fxn:test_sqrt" -> "Fxn:math.sqrt(x)";
    "Fxn:test_erf" -> "Fxn:self._testMathByName('erf')";
    "Fxn:checkType" -> "Fxn:torch.randn(4,";
    "Fxn:checkType" -> "Fxn:out=tensor()).clamp(-2.,";
    "Fxn:checkType" -> "Fxn:self.assertEqual(tensor(inputValues).erf().erfinv(),";
    "Fxn:checkType" -> "Fxn:tensor(inputValues))";
    "Fxn:checkType" -> "Fxn:self.assertTrue(torch.equal(tensor([-1,";
    "Fxn:checkType" -> "Fxn:1]).erfinv(),";
    "Fxn:checkType" -> "Fxn:tensor([float('-inf'),";
    "Fxn:checkType" -> "Fxn:self.assertEqual(tensor([-2,";
    "Fxn:checkType" -> "Fxn:2]).erfinv(),";
    "Fxn:checkType" -> "Fxn:tensor([float('nan'),";
    "Fxn:checkType" -> "Fxn:checkType(torch.FloatTensor)";
    "Fxn:checkType" -> "Fxn:checkType(torch.DoubleTensor)";
    "Fxn:test_exp" -> "Fxn:self._testMathByName('exp')";
    "Fxn:test_expm1" -> "Fxn:self._testMathByName('expm1')";
    "Fxn:test_floor" -> "Fxn:self._testMathByName('floor')";
    "Fxn:test_ceil" -> "Fxn:self._testMathByName('ceil')";
    "Fxn:test_rsqrt" -> "Fxn:self._testMath(torch.rsqrt,";
    "Fxn:test_rsqrt" -> "Fxn:math.sqrt(x)";
    "Fxn:checkType" -> "Fxn:self.assertEqual(tensor(inputValues).sigmoid(),";
    "Fxn:checkType" -> "Fxn:tensor(expectedOutput),";
    "Fxn:checkType" -> "Fxn:checkType(torch.FloatTensor)";
    "Fxn:checkType" -> "Fxn:checkType(torch.DoubleTensor)";
    "Fxn:test_frac" -> "Fxn:self._testMath(torch.frac,";
    "Fxn:test_frac" -> "Fxn:math.fmod(x,";
    "Fxn:test_trunc" -> "Fxn:self._testMath(torch.trunc,";
    "Fxn:test_trunc" -> "Fxn:math.fmod(x,";
    "Fxn:test_round" -> "Fxn:self._testMath(torch.round,";
    "Fxn:test_has_storage" -> "Fxn:self.assertIsNotNone(torch.Tensor().storage())";
    "Fxn:test_has_storage" -> "Fxn:self.assertIsNotNone(torch.Tensor(0).storage())";
    "Fxn:test_has_storage" -> "Fxn:self.assertIsNotNone(torch.Tensor([]).storage())";
    "Fxn:test_has_storage" -> "Fxn:self.assertIsNotNone(torch.Tensor().clone().storage())";
    "Fxn:test_has_storage" -> "Fxn:self.assertIsNotNone(torch.Tensor([0,";
    "Fxn:test_has_storage" -> "Fxn:0]).nonzero().storage())";
    "Fxn:test_has_storage" -> "Fxn:self.assertIsNotNone(torch.Tensor().new().storage())";
    "Fxn:test_has_storage" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_has_storage_numpy" -> "Fxn:np.array([1],";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.FloatTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.DoubleTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.IntTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.LongTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.ByteTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.cuda.FloatTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.cuda.DoubleTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.cuda.IntTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.cuda.LongTensor(arr).storage())";
    "Fxn:test_has_storage_numpy" -> "Fxn:self.assertIsNotNone(torch.cuda.ByteTensor(arr).storage())";
    "Fxn:_testSelection" -> "Fxn:torch.randn(100,";
    "Fxn:_testSelection" -> "Fxn:torchfn(m1)";
    "Fxn:_testSelection" -> "Fxn:iter_indices(m1):";
    "Fxn:_testSelection" -> "Fxn:mathfn(res2,";
    "Fxn:_testSelection" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_testSelection" -> "Fxn:torch.randn(10,";
    "Fxn:_testSelection" -> "Fxn:torchfn(m2)";
    "Fxn:_testSelection" -> "Fxn:iter_indices(m2):";
    "Fxn:_testSelection" -> "Fxn:mathfn(res2,";
    "Fxn:_testSelection" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_testSelection" -> "Fxn:torch.randn(100,";
    "Fxn:_testSelection" -> "Fxn:torchfn(m1,";
    "Fxn:_testSelection" -> "Fxn:0:1].clone().squeeze()";
    "Fxn:_testSelection" -> "Fxn:res1ind.clone().fill_(0)";
    "Fxn:_testSelection" -> "Fxn:iter_indices(m1):";
    "Fxn:_testSelection" -> "Fxn:mathfn(res2val[i],";
    "Fxn:_testSelection" -> "Fxn:self.assertEqual(res1ind[i],";
    "Fxn:_testSelection" -> "Fxn:self.assertLessEqual(abs(maxerr),";
    "Fxn:_testSelection" -> "Fxn:torch.randn(100)";
    "Fxn:_testSelection" -> "Fxn:torch.max(m1,";
    "Fxn:_testSelection" -> "Fxn:self.assertTrue(math.isnan(res1val))";
    "Fxn:_testSelection" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:_testSelection" -> "Fxn:torchfn(m1)";
    "Fxn:_testSelection" -> "Fxn:self.assertTrue(math.isnan(res1val))";
    "Fxn:test_max" -> "Fxn:self._testSelection(torch.max,";
    "Fxn:test_min" -> "Fxn:self._testSelection(torch.min,";
    "Fxn:_test_dim_reduction" -> "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.sum().item(),";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.sum(0),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([4,";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.sum(1),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([2,";
    "Fxn:_test_dim_reduction" -> "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.sum(x,";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.sum(0),";
    "Fxn:_test_dim_reduction" -> "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.mean().item(),";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.mean(0),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([2.0,";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.mean(1),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([2.0";
    "Fxn:_test_dim_reduction" -> "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.prod().item(),";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.prod(0),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([-5,";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.prod(1),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([-2,";
    "Fxn:_test_dim_reduction" -> "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.max().item(),";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.max(0),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([1,";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.max(1),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([1,";
    "Fxn:_test_dim_reduction" -> "Fxn:cast(torch.FloatTensor(example).type(tname))";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.min().item(),";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.min(0),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([0,";
    "Fxn:_test_dim_reduction" -> "Fxn:self.assertEqual(x.min(1),";
    "Fxn:_test_dim_reduction" -> "Fxn:torch.FloatTensor([0,";
    "Fxn:normfn_attr" -> "Fxn:attr(t,";
    "Fxn:fn" -> "Fxn:fn_attr(x,";
    "Fxn:fn_tuple" -> "Fxn:fn_attr(x,";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(fn(x,";
    "Fxn:test_multidim" -> "Fxn:dim).unsqueeze(dim),";
    "Fxn:test_multidim" -> "Fxn:fn(x,";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(x.ndimension()";
    "Fxn:test_multidim" -> "Fxn:fn(x,";
    "Fxn:test_multidim" -> "Fxn:dim).ndimension())";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(x.ndimension(),";
    "Fxn:test_multidim" -> "Fxn:fn(x,";
    "Fxn:test_multidim" -> "Fxn:keepdim=True).ndimension())";
    "Fxn:test_multidim" -> "Fxn:cast(torch.randn(3,";
    "Fxn:test_multidim" -> "Fxn:random.randint(0,";
    "Fxn:test_multidim" -> "Fxn:test_multidim(x,";
    "Fxn:test_multidim" -> "Fxn:cast(torch.randn(1))";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(fn(x,";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(fn(x,";
    "Fxn:test_multidim" -> "Fxn:random.randint(0,";
    "Fxn:test_multidim" -> "Fxn:cast(torch.randn(dims))";
    "Fxn:test_multidim" -> "Fxn:test_multidim(x,";
    "Fxn:test_multidim" -> "Fxn:cast(torch.randn(5,";
    "Fxn:test_multidim" -> "Fxn:cast(torch.randn(5,";
    "Fxn:test_multidim" -> "Fxn:cast(torch.zeros(5,";
    "Fxn:test_multidim" -> "Fxn:3).long()";
    "Fxn:test_multidim" -> "Fxn:fn_tuple(y,";
    "Fxn:test_multidim" -> "Fxn:out=(values[:,";
    "Fxn:test_multidim" -> "Fxn:fn_tuple(y,";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(values[:,";
    "Fxn:test_multidim" -> "Fxn:kwarg'.format(fn_name))";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(indices[:,";
    "Fxn:test_multidim" -> "Fxn:kwarg'.format(fn_name))";
    "Fxn:test_multidim" -> "Fxn:cast(torch.randn(5,";
    "Fxn:test_multidim" -> "Fxn:cast(torch.randn(5,";
    "Fxn:test_multidim" -> "Fxn:fn(y,";
    "Fxn:test_multidim" -> "Fxn:fn(y,";
    "Fxn:test_multidim" -> "Fxn:self.assertEqual(x[:,";
    "Fxn:test_multidim" -> "Fxn:kwarg'.format(fn_name))";
    "Fxn:test_dim_reduction" -> "Fxn:self._test_dim_reduction(self,";
    "Fxn:_testCSelection" -> "Fxn:torch.rand(*size)";
    "Fxn:_testCSelection" -> "Fxn:torch.rand(*size)";
    "Fxn:_testCSelection" -> "Fxn:torchfn(a,";
    "Fxn:_testCSelection" -> "Fxn:torch.zeros(*size)";
    "Fxn:_testCSelection" -> "Fxn:expected_c.map2_(a,";
    "Fxn:_testCSelection" -> "Fxn:mathfn(a,";
    "Fxn:_testCSelection" -> "Fxn:self.assertEqual(expected_c,";
    "Fxn:test_max_elementwise" -> "Fxn:self._testCSelection(torch.max,";
    "Fxn:test_min_elementwise" -> "Fxn:self._testCSelection(torch.min,";
    "Fxn:TH_lerp" -> "Fxn:torch.rand(*size)";
    "Fxn:TH_lerp" -> "Fxn:torch.rand(*size)";
    "Fxn:TH_lerp" -> "Fxn:random.random()";
    "Fxn:TH_lerp" -> "Fxn:torch.lerp(a,";
    "Fxn:TH_lerp" -> "Fxn:a.clone()";
    "Fxn:TH_lerp" -> "Fxn:expected.map2_(a,";
    "Fxn:TH_lerp" -> "Fxn:TH_lerp(a,";
    "Fxn:TH_lerp" -> "Fxn:self.assertEqual(result,";
    "Fxn:test" -> "Fxn:torch.ones(*size).byte()";
    "Fxn:test" -> "Fxn:self.assertTrue(x.all())";
    "Fxn:test" -> "Fxn:self.assertTrue(x.any())";
    "Fxn:test" -> "Fxn:self.assertFalse(x.all())";
    "Fxn:test" -> "Fxn:self.assertTrue(x.any())";
    "Fxn:test" -> "Fxn:x.zero_()";
    "Fxn:test" -> "Fxn:self.assertFalse(x.all())";
    "Fxn:test" -> "Fxn:self.assertFalse(x.any())";
    "Fxn:test" -> "Fxn:x.fill_(2)";
    "Fxn:test" -> "Fxn:self.assertTrue(x.all())";
    "Fxn:test" -> "Fxn:self.assertTrue(x.any())";
    "Fxn:test" -> "Fxn:test((10,))";
    "Fxn:test" -> "Fxn:test((5,";
    "Fxn:test_all_any_empty" -> "Fxn:torch.ByteTensor()";
    "Fxn:test_all_any_empty" -> "Fxn:self.assertTrue(x.all())";
    "Fxn:test_all_any_empty" -> "Fxn:self.assertFalse(x.any())";
    "Fxn:test_all_any_empty" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_all_any_empty" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_all_any_empty_cuda" -> "Fxn:torch.cuda.ByteTensor()";
    "Fxn:test_all_any_empty_cuda" -> "Fxn:self.assertTrue(x.all())";
    "Fxn:test_all_any_empty_cuda" -> "Fxn:self.assertFalse(x.any())";
    "Fxn:test_mv" -> "Fxn:torch.randn(100,";
    "Fxn:test_mv" -> "Fxn:torch.randn(100)";
    "Fxn:test_mv" -> "Fxn:torch.mv(m1,";
    "Fxn:test_mv" -> "Fxn:res1.clone().zero_()";
    "Fxn:test_mv" -> "Fxn:iter_indices(m1):";
    "Fxn:test_mv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_add" -> "Fxn:torch.add([res,]";
    "Fxn:test_add" -> "Fxn:torch.randn(100,";
    "Fxn:test_add" -> "Fxn:torch.randn(100)";
    "Fxn:test_add" -> "Fxn:torch.add(m1[4],";
    "Fxn:test_add" -> "Fxn:res1.clone().zero_()";
    "Fxn:test_add" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_add" -> "Fxn:torch.randn(100,";
    "Fxn:test_add" -> "Fxn:torch.randn(100)";
    "Fxn:test_add" -> "Fxn:torch.add(m1[:,";
    "Fxn:test_add" -> "Fxn:res1.clone().zero_()";
    "Fxn:test_add" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_add" -> "Fxn:torch.add([res,]";
    "Fxn:test_add" -> "Fxn:torch.randn(10,";
    "Fxn:test_add" -> "Fxn:m1.clone()";
    "Fxn:test_add" -> "Fxn:res1[3].add_(2)";
    "Fxn:test_add" -> "Fxn:m1.clone()";
    "Fxn:test_add" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_add" -> "Fxn:torch.randn(10,";
    "Fxn:test_add" -> "Fxn:m1.clone()";
    "Fxn:test_add" -> "Fxn:3].add_(2)";
    "Fxn:test_add" -> "Fxn:m1.clone()";
    "Fxn:test_add" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_add" -> "Fxn:torch.add([res,]";
    "Fxn:test_csub" -> "Fxn:torch.randn(100,";
    "Fxn:test_csub" -> "Fxn:a.clone().normal_()";
    "Fxn:test_csub" -> "Fxn:torch.add(a,";
    "Fxn:test_csub" -> "Fxn:a.clone()";
    "Fxn:test_csub" -> "Fxn:res_csub.sub_(b)";
    "Fxn:test_csub" -> "Fxn:self.assertEqual(res_add,";
    "Fxn:test_csub" -> "Fxn:torch.randn(100,";
    "Fxn:test_csub" -> "Fxn:torch.add(a,";
    "Fxn:test_csub" -> "Fxn:a.clone()";
    "Fxn:test_csub" -> "Fxn:res_csub.sub_(scalar)";
    "Fxn:test_csub" -> "Fxn:self.assertEqual(res_add,";
    "Fxn:_test_neg" -> "Fxn:cast(torch.randn(100,";
    "Fxn:_test_neg" -> "Fxn:90).type(t))";
    "Fxn:_test_neg" -> "Fxn:cast(torch.Tensor(100,";
    "Fxn:_test_neg" -> "Fxn:90).type(t).random_())";
    "Fxn:_test_neg" -> "Fxn:cast(torch.Tensor().type(t)).resize_as_(a).zero_()";
    "Fxn:_test_neg" -> "Fxn:torch.add(zeros,";
    "Fxn:_test_neg" -> "Fxn:torch.add(zeros,";
    "Fxn:_test_neg" -> "Fxn:a.clone()";
    "Fxn:_test_neg" -> "Fxn:res_neg.neg_()";
    "Fxn:_test_neg" -> "Fxn:self.assertEqual(res_neg,";
    "Fxn:_test_neg" -> "Fxn:a.clone().neg()";
    "Fxn:_test_neg" -> "Fxn:self.assertEqual(res_neg_out_place,";
    "Fxn:_test_neg" -> "Fxn:-a.clone()";
    "Fxn:_test_neg" -> "Fxn:self.assertEqual(res_neg_op,";
    "Fxn:test_neg" -> "Fxn:self._test_neg(self,";
    "Fxn:test_reciprocal" -> "Fxn:torch.randn(100,";
    "Fxn:test_reciprocal" -> "Fxn:a.clone()";
    "Fxn:test_reciprocal" -> "Fxn:res_reciprocal.reciprocal_()";
    "Fxn:test_reciprocal" -> "Fxn:self.assertEqual(res_reciprocal,";
    "Fxn:test_mul" -> "Fxn:torch.randn(10,";
    "Fxn:test_mul" -> "Fxn:m1.clone()";
    "Fxn:test_mul" -> "Fxn:3].mul_(2)";
    "Fxn:test_mul" -> "Fxn:m1.clone()";
    "Fxn:test_mul" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_div" -> "Fxn:torch.randn(10,";
    "Fxn:test_div" -> "Fxn:m1.clone()";
    "Fxn:test_div" -> "Fxn:3].div_(2)";
    "Fxn:test_div" -> "Fxn:m1.clone()";
    "Fxn:test_div" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_fmod" -> "Fxn:torch.Tensor(10,";
    "Fxn:test_fmod" -> "Fxn:10).uniform_(-10.,";
    "Fxn:test_fmod" -> "Fxn:m1.clone()";
    "Fxn:test_fmod" -> "Fxn:3].fmod_(q)";
    "Fxn:test_fmod" -> "Fxn:m1.clone()";
    "Fxn:test_fmod" -> "Fxn:math.fmod(res2[i,";
    "Fxn:test_fmod" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_remainder" -> "Fxn:torch.Tensor(10,";
    "Fxn:test_remainder" -> "Fxn:10).uniform_(-10.,";
    "Fxn:test_remainder" -> "Fxn:m1.clone()";
    "Fxn:test_remainder" -> "Fxn:m1.clone()";
    "Fxn:test_remainder" -> "Fxn:torch.arange(-5.1,";
    "Fxn:test_remainder" -> "Fxn:col_idx].remainder_(q)";
    "Fxn:test_remainder" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_remainder" -> "Fxn:m1.clone()";
    "Fxn:test_remainder" -> "Fxn:res1.remainder_(qs.unsqueeze(0).expand_as(res1))";
    "Fxn:test_remainder" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_remainder" -> "Fxn:torch.LongTensor(10,";
    "Fxn:test_remainder" -> "Fxn:10).random_(-10,";
    "Fxn:test_remainder" -> "Fxn:long_m1.clone()";
    "Fxn:test_remainder" -> "Fxn:long_m1.clone()";
    "Fxn:test_remainder" -> "Fxn:torch.arange(-5,";
    "Fxn:test_remainder" -> "Fxn:5).long()";
    "Fxn:test_remainder" -> "Fxn:col_idx].remainder_(long_q)";
    "Fxn:test_remainder" -> "Fxn:self.assertEqual(long_res1,";
    "Fxn:test_remainder" -> "Fxn:long_m1.clone()";
    "Fxn:test_remainder" -> "Fxn:long_res1.remainder_(long_qs.unsqueeze(0).expand_as(long_res1))";
    "Fxn:matrixmultiply" -> "Fxn:mat1.size(0)";
    "Fxn:matrixmultiply" -> "Fxn:mat1.size(1)";
    "Fxn:matrixmultiply" -> "Fxn:mat2.size(1)";
    "Fxn:matrixmultiply" -> "Fxn:torch.zeros(n,";
    "Fxn:matrixmultiply" -> "Fxn:iter_indices(res):";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(n,";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(m,";
    "Fxn:matrixmultiply" -> "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:matrixmultiply(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:self.assertEqual(res,";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(n,";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(p,";
    "Fxn:matrixmultiply" -> "Fxn:m).t()";
    "Fxn:matrixmultiply" -> "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:matrixmultiply(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:self.assertEqual(res,";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(m,";
    "Fxn:matrixmultiply" -> "Fxn:n).t()";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(m,";
    "Fxn:matrixmultiply" -> "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:matrixmultiply(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:self.assertEqual(res,";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(m,";
    "Fxn:matrixmultiply" -> "Fxn:n).t()";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(p,";
    "Fxn:matrixmultiply" -> "Fxn:m).t()";
    "Fxn:matrixmultiply" -> "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:matrixmultiply(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:self.assertEqual(res,";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(n,";
    "Fxn:matrixmultiply" -> "Fxn:torch.randn(m,";
    "Fxn:matrixmultiply" -> "Fxn:1).expand(m,";
    "Fxn:matrixmultiply" -> "Fxn:torch.mm(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:matrixmultiply(mat1,";
    "Fxn:matrixmultiply" -> "Fxn:self.assertEqual(res,";
    "Fxn:_test_btrifact" -> "Fxn:torch.FloatTensor((((1.3722,";
    "Fxn:_test_btrifact" -> "Fxn:cast(a)";
    "Fxn:_test_btrifact" -> "Fxn:a.btrifact()";
    "Fxn:_test_btrifact" -> "Fxn:cast(torch.IntTensor())";
    "Fxn:_test_btrifact" -> "Fxn:warnings.catch_warnings(record=True):";
    "Fxn:_test_btrifact" -> "Fxn:a.btrifact(info=info)";
    "Fxn:_test_btrifact" -> "Fxn:self.assertEqual(info.abs().sum(),";
    "Fxn:_test_btrifact" -> "Fxn:a.btrifact_with_info()";
    "Fxn:_test_btrifact" -> "Fxn:self.assertEqual(a_LU,";
    "Fxn:_test_btrifact" -> "Fxn:self.assertEqual(pivots,";
    "Fxn:_test_btrifact" -> "Fxn:self.assertEqual(info,";
    "Fxn:_test_btrifact" -> "Fxn:torch.btriunpack(a_LU,";
    "Fxn:_test_btrifact" -> "Fxn:torch.bmm(P,";
    "Fxn:_test_btrifact" -> "Fxn:torch.bmm(a_L,";
    "Fxn:_test_btrifact" -> "Fxn:self.assertEqual(a_,";
    "Fxn:test_btrifact" -> "Fxn:self._test_btrifact(self,";
    "Fxn:_test_btrisolve" -> "Fxn:torch.FloatTensor((((1.3722,";
    "Fxn:_test_btrisolve" -> "Fxn:torch.FloatTensor(((4.02,";
    "Fxn:_test_btrisolve" -> "Fxn:cast(a),";
    "Fxn:_test_btrisolve" -> "Fxn:cast(b)";
    "Fxn:_test_btrisolve" -> "Fxn:a.btrifact_with_info()";
    "Fxn:_test_btrisolve" -> "Fxn:self.assertEqual(info.abs().sum(),";
    "Fxn:_test_btrisolve" -> "Fxn:torch.btrisolve(b,";
    "Fxn:_test_btrisolve" -> "Fxn:torch.bmm(a,";
    "Fxn:_test_btrisolve" -> "Fxn:x.unsqueeze(2)).squeeze()";
    "Fxn:_test_btrisolve" -> "Fxn:self.assertEqual(b_,";
    "Fxn:test_btrisolve" -> "Fxn:self._test_btrisolve(self,";
    "Fxn:test_bmm" -> "Fxn:torch.randn(num_batches,";
    "Fxn:test_bmm" -> "Fxn:torch.randn(num_batches,";
    "Fxn:test_bmm" -> "Fxn:torch.bmm(b1,";
    "Fxn:test_bmm" -> "Fxn:torch.mm(b1[i],";
    "Fxn:test_bmm" -> "Fxn:self.assertEqual(r,";
    "Fxn:test_addbmm" -> "Fxn:torch.randn(num_batches,";
    "Fxn:test_addbmm" -> "Fxn:torch.randn(num_batches,";
    "Fxn:test_addbmm" -> "Fxn:torch.bmm(b1,";
    "Fxn:test_addbmm" -> "Fxn:torch.Tensor().resize_as_(res[0]).zero_()";
    "Fxn:test_addbmm" -> "Fxn:res2.addbmm_(b1,";
    "Fxn:test_addbmm" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_addbmm" -> "Fxn:res.sum(0,";
    "Fxn:test_addbmm" -> "Fxn:res2.addbmm_(1,";
    "Fxn:test_addbmm" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_addbmm" -> "Fxn:res.sum(0,";
    "Fxn:test_addbmm" -> "Fxn:res2.addbmm_(1.,";
    "Fxn:test_addbmm" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_addbmm" -> "Fxn:res.sum(0,";
    "Fxn:test_addbmm" -> "Fxn:torch.addbmm(1,";
    "Fxn:test_addbmm" -> "Fxn:self.assertEqual(res3,";
    "Fxn:test_addbmm" -> "Fxn:torch.addbmm(1,";
    "Fxn:test_addbmm" -> "Fxn:self.assertEqual(res4,";
    "Fxn:test_addbmm" -> "Fxn:res.sum(0,";
    "Fxn:test_addbmm" -> "Fxn:torch.addbmm(0,";
    "Fxn:test_addbmm" -> "Fxn:self.assertEqual(res5,";
    "Fxn:test_addbmm" -> "Fxn:res.sum(0,";
    "Fxn:test_addbmm" -> "Fxn:torch.addbmm(.1,";
    "Fxn:test_addbmm" -> "Fxn:self.assertEqual(res6,";
    "Fxn:test_baddbmm" -> "Fxn:torch.randn(num_batches,";
    "Fxn:test_baddbmm" -> "Fxn:torch.randn(num_batches,";
    "Fxn:test_baddbmm" -> "Fxn:torch.bmm(b1,";
    "Fxn:test_baddbmm" -> "Fxn:torch.Tensor().resize_as_(res).zero_()";
    "Fxn:test_baddbmm" -> "Fxn:res2.baddbmm_(b1,";
    "Fxn:test_baddbmm" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_baddbmm" -> "Fxn:res2.baddbmm_(1,";
    "Fxn:test_baddbmm" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_baddbmm" -> "Fxn:res2.baddbmm_(1,";
    "Fxn:test_baddbmm" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_baddbmm" -> "Fxn:torch.baddbmm(1,";
    "Fxn:test_baddbmm" -> "Fxn:self.assertEqual(res3,";
    "Fxn:test_baddbmm" -> "Fxn:torch.baddbmm(1,";
    "Fxn:test_baddbmm" -> "Fxn:self.assertEqual(res4,";
    "Fxn:test_baddbmm" -> "Fxn:torch.baddbmm(0,";
    "Fxn:test_baddbmm" -> "Fxn:self.assertEqual(res5,";
    "Fxn:test_baddbmm" -> "Fxn:torch.baddbmm(.1,";
    "Fxn:test_baddbmm" -> "Fxn:self.assertEqual(res6,";
    "Fxn:test_clamp" -> "Fxn:torch.rand(100).mul(5).add(-2.5)";
    "Fxn:test_clamp" -> "Fxn:m1.clone()";
    "Fxn:test_clamp" -> "Fxn:res1.clamp_(min_val,";
    "Fxn:test_clamp" -> "Fxn:m1.clone()";
    "Fxn:test_clamp" -> "Fxn:iter_indices(res2):";
    "Fxn:test_clamp" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_clamp" -> "Fxn:torch.clamp(m1,";
    "Fxn:test_clamp" -> "Fxn:m1.clone()";
    "Fxn:test_clamp" -> "Fxn:iter_indices(res2):";
    "Fxn:test_clamp" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_clamp" -> "Fxn:torch.clamp(m1,";
    "Fxn:test_clamp" -> "Fxn:m1.clone()";
    "Fxn:test_clamp" -> "Fxn:iter_indices(res2):";
    "Fxn:test_clamp" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_pow" -> "Fxn:torch.pow([res,]";
    "Fxn:test_pow" -> "Fxn:torch.rand(100,";
    "Fxn:test_pow" -> "Fxn:torch.pow(m1[4],";
    "Fxn:test_pow" -> "Fxn:res1.clone().zero_()";
    "Fxn:test_pow" -> "Fxn:math.pow(m1[4][i],";
    "Fxn:test_pow" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_pow" -> "Fxn:torch.rand(100,";
    "Fxn:test_pow" -> "Fxn:torch.pow(m1[:,";
    "Fxn:test_pow" -> "Fxn:res1.clone().zero_()";
    "Fxn:test_pow" -> "Fxn:math.pow(m1[i,";
    "Fxn:test_pow" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_pow" -> "Fxn:torch.randn(100,";
    "Fxn:test_pow" -> "Fxn:torch.pow(3,";
    "Fxn:test_pow" -> "Fxn:res1.clone().zero_()";
    "Fxn:test_pow" -> "Fxn:math.pow(3,";
    "Fxn:test_pow" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_pow" -> "Fxn:torch.randn(100,";
    "Fxn:test_pow" -> "Fxn:torch.pow(3,";
    "Fxn:test_pow" -> "Fxn:res1.clone().zero_()";
    "Fxn:test_pow" -> "Fxn:math.pow(3,";
    "Fxn:test_pow" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_rpow" -> "Fxn:torch.randn(10,";
    "Fxn:test_rpow" -> "Fxn:self.assertEqual(torch.pow(2,";
    "Fxn:check_against_np" -> "Fxn:tensor.cpu().numpy()";
    "Fxn:check_against_np" -> "Fxn:exp.cpu().numpy()";
    "Fxn:check_against_np" -> "Fxn:torch.LongTensor(tensor_np";
    "Fxn:check_against_np" -> "Fxn:exp_np).type_as(tensor)";
    "Fxn:check_against_np" -> "Fxn:self.assertEqual(torch.pow(tensor,";
    "Fxn:check_against_np" -> "Fxn:self.assertEqual(tensor.pow(exp),";
    "Fxn:check_against_np" -> "Fxn:torch.pow(tensor,";
    "Fxn:check_against_np" -> "Fxn:x.long(),";
    "Fxn:check_against_np" -> "Fxn:x.short(),";
    "Fxn:check_against_np" -> "Fxn:x.byte(),";
    "Fxn:check_against_np" -> "Fxn:typecasts.append(lambda";
    "Fxn:check_against_np" -> "Fxn:x.int())";
    "Fxn:check_against_np" -> "Fxn:cast(torch.LongTensor(shape).random_(-10,";
    "Fxn:check_against_np" -> "Fxn:cast(torch.LongTensor(shape).random_(0,";
    "Fxn:check_against_np" -> "Fxn:typecast(tensor)";
    "Fxn:check_against_np" -> "Fxn:typecast(exp)";
    "Fxn:check_against_np" -> "Fxn:check_against_np(t,";
    "Fxn:test_int_pow" -> "Fxn:self._test_int_pow(self,";
    "Fxn:reference_implementation" -> "Fxn:iter_indices(sm1):";
    "Fxn:reference_implementation" -> "Fxn:sm1.size(0)";
    "Fxn:reference_implementation" -> "Fxn:mathfn(sm1[i,";
    "Fxn:reference_implementation" -> "Fxn:torch.randn(10,";
    "Fxn:reference_implementation" -> "Fxn:torch.randn(10,";
    "Fxn:reference_implementation" -> "Fxn:torchfn(sm1,";
    "Fxn:reference_implementation" -> "Fxn:sm2.view(10,";
    "Fxn:reference_implementation" -> "Fxn:reference_implementation(res1.clone())";
    "Fxn:reference_implementation" -> "Fxn:self.assertEqual(res1,";
    "Fxn:reference_implementation" -> "Fxn:torch.randn(10,";
    "Fxn:reference_implementation" -> "Fxn:torch.randn(10";
    "Fxn:reference_implementation" -> "Fxn:sm1.size()";
    "Fxn:reference_implementation" -> "Fxn:sm2.set_(sm2.storage(),";
    "Fxn:reference_implementation" -> "Fxn:sm2.storage_offset(),";
    "Fxn:reference_implementation" -> "Fxn:sm1.size(),";
    "Fxn:reference_implementation" -> "Fxn:sm2.stride()[0]))";
    "Fxn:reference_implementation" -> "Fxn:torchfn(sm1,";
    "Fxn:reference_implementation" -> "Fxn:sm2.set_(sm2.storage(),";
    "Fxn:reference_implementation" -> "Fxn:sm2.storage_offset(),";
    "Fxn:reference_implementation" -> "Fxn:4].size(),";
    "Fxn:reference_implementation" -> "Fxn:4].stride())";
    "Fxn:reference_implementation" -> "Fxn:reference_implementation(res1.clone())";
    "Fxn:reference_implementation" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_cdiv" -> "Fxn:self._test_cop(torch.div,";
    "Fxn:test_cfmod" -> "Fxn:self._test_cop(torch.fmod,";
    "Fxn:test_cremainder" -> "Fxn:self._test_cop(torch.remainder,";
    "Fxn:test_cmul" -> "Fxn:self._test_cop(torch.mul,";
    "Fxn:test_cpow" -> "Fxn:self._test_cop(torch.pow,";
    "Fxn:test_cpow" -> "Fxn:math.pow(x,";
    "Fxn:test_sum" -> "Fxn:torch.rand(100,";
    "Fxn:test_sum" -> "Fxn:torch.sum(x,";
    "Fxn:test_sum" -> "Fxn:torch.Tensor()";
    "Fxn:test_sum" -> "Fxn:torch.sum(x,";
    "Fxn:test_sum" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_prod" -> "Fxn:torch.rand(100,";
    "Fxn:test_prod" -> "Fxn:torch.prod(x,";
    "Fxn:test_prod" -> "Fxn:torch.Tensor()";
    "Fxn:test_prod" -> "Fxn:torch.prod(x,";
    "Fxn:test_prod" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_cumsum" -> "Fxn:torch.rand(100,";
    "Fxn:test_cumsum" -> "Fxn:torch.cumsum(x,";
    "Fxn:test_cumsum" -> "Fxn:torch.Tensor()";
    "Fxn:test_cumsum" -> "Fxn:torch.cumsum(x,";
    "Fxn:test_cumsum" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_cumprod" -> "Fxn:torch.rand(100,";
    "Fxn:test_cumprod" -> "Fxn:torch.cumprod(x,";
    "Fxn:test_cumprod" -> "Fxn:torch.Tensor()";
    "Fxn:test_cumprod" -> "Fxn:torch.cumprod(x,";
    "Fxn:test_cumprod" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_cross" -> "Fxn:torch.rand(100,";
    "Fxn:test_cross" -> "Fxn:torch.rand(100,";
    "Fxn:test_cross" -> "Fxn:torch.cross(x,";
    "Fxn:test_cross" -> "Fxn:torch.Tensor()";
    "Fxn:test_cross" -> "Fxn:torch.cross(x,";
    "Fxn:test_cross" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_zeros" -> "Fxn:torch.zeros(100,";
    "Fxn:test_zeros" -> "Fxn:torch.Tensor()";
    "Fxn:test_zeros" -> "Fxn:torch.zeros(100,";
    "Fxn:test_zeros" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_zeros_like" -> "Fxn:torch.zeros(100,";
    "Fxn:test_zeros_like" -> "Fxn:torch.zeros_like(expected)";
    "Fxn:test_zeros_like" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_zeros_like" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_zeros_like" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_zeros_like_cuda" -> "Fxn:torch.zeros(100,";
    "Fxn:test_zeros_like_cuda" -> "Fxn:100).cuda()";
    "Fxn:test_zeros_like_cuda" -> "Fxn:torch.zeros_like(expected)";
    "Fxn:test_zeros_like_cuda" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_zeros_like_cuda" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_zeros_like_multiple_device" -> "Fxn:torch.zeros(100,";
    "Fxn:test_zeros_like_multiple_device" -> "Fxn:100).cuda()";
    "Fxn:test_zeros_like_multiple_device" -> "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:test_zeros_like_multiple_device" -> "Fxn:torch.zeros_like(x)";
    "Fxn:test_zeros_like_multiple_device" -> "Fxn:self.assertEqual(output,";
    "Fxn:test_histc" -> "Fxn:torch.Tensor((2,";
    "Fxn:test_histc" -> "Fxn:torch.histc(x,";
    "Fxn:test_histc" -> "Fxn:torch.Tensor((0,";
    "Fxn:test_histc" -> "Fxn:self.assertEqual(y,";
    "Fxn:test_ones" -> "Fxn:torch.ones(100,";
    "Fxn:test_ones" -> "Fxn:torch.Tensor()";
    "Fxn:test_ones" -> "Fxn:torch.ones(100,";
    "Fxn:test_ones" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ones_like" -> "Fxn:torch.ones(100,";
    "Fxn:test_ones_like" -> "Fxn:torch.ones_like(expected)";
    "Fxn:test_ones_like" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ones_like" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_ones_like" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_ones_like_cuda" -> "Fxn:torch.ones(100,";
    "Fxn:test_ones_like_cuda" -> "Fxn:100).cuda()";
    "Fxn:test_ones_like_cuda" -> "Fxn:torch.ones_like(expected)";
    "Fxn:test_ones_like_cuda" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ones_like_cuda" -> "Fxn:@unittest.skipIf(torch.cuda.device_count()";
    "Fxn:test_ones_like_multiple_device" -> "Fxn:torch.ones(100,";
    "Fxn:test_ones_like_multiple_device" -> "Fxn:100).cuda()";
    "Fxn:test_ones_like_multiple_device" -> "Fxn:torch.cuda.FloatTensor(100,";
    "Fxn:test_ones_like_multiple_device" -> "Fxn:torch.ones_like(x)";
    "Fxn:test_ones_like_multiple_device" -> "Fxn:self.assertEqual(output,";
    "Fxn:_test_dtypes" -> "Fxn:torch.cuda.is_available()";
    "Fxn:_test_dtypes" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_test_dtypes" -> "Fxn:torch.zeros((2,";
    "Fxn:_test_dtypes" -> "Fxn:self.assertIs(dtype,";
    "Fxn:_test_dtypes" -> "Fxn:self.assertEqual(1,";
    "Fxn:_test_dtypes" -> "Fxn:out.get_device())";
    "Fxn:_test_dtypes" -> "Fxn:torch.zeros((2,";
    "Fxn:_test_dtypes" -> "Fxn:self.assertIs(dtype,";
    "Fxn:_test_dtypes" -> "Fxn:self.assertEqual(dtype";
    "Fxn:_test_dtypes" -> "Fxn:self.assertEqual(is_sparse,";
    "Fxn:test_dtypes" -> "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:test_dtypes" -> "Fxn:self._test_dtypes(self,";
    "Fxn:_test_empty_full" -> "Fxn:torch.cuda.is_available()";
    "Fxn:_test_empty_full" -> "Fxn:torch.Size([2,";
    "Fxn:check_value" -> "Fxn:self.assertEqual(shape,";
    "Fxn:check_value" -> "Fxn:self.assertIs(dtype,";
    "Fxn:check_value" -> "Fxn:self.assertEqual(tensor.requires_grad,";
    "Fxn:check_value" -> "Fxn:self.assertEqual(device,";
    "Fxn:check_value" -> "Fxn:tensor.get_device())";
    "Fxn:check_value" -> "Fxn:tensor.new(shape).fill_(value)";
    "Fxn:check_value" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:get_int64_dtype" -> "Fxn:'.'.join(str(dtype).split('.')[1:-1])";
    "Fxn:get_int64_dtype" -> "Fxn:operator.attrgetter(module)(torch).int64";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.empty(shape),";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.full(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:get_int64_dtype(dtype)";
    "Fxn:get_int64_dtype" -> "Fxn:torch.cuda.device_count()";
    "Fxn:get_int64_dtype" -> "Fxn:torch.empty(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(v,";
    "Fxn:get_int64_dtype" -> "Fxn:v.new()";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.empty(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(v.new_empty(shape),";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(v.new_empty(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.empty_like(v),";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.empty_like(v,";
    "Fxn:get_int64_dtype" -> "Fxn:torch.full(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(v,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(v.new_full(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:v.new()";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.full(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(v.new_full(shape,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.full_like(v,";
    "Fxn:get_int64_dtype" -> "Fxn:check_value(torch.full_like(v,";
    "Fxn:test_empty_full" -> "Fxn:torch.testing.get_all_dtypes()";
    "Fxn:test_empty_full" -> "Fxn:self._test_empty_full(self,";
    "Fxn:test_dtype_out_match" -> "Fxn:torch.autograd.Variable(torch.DoubleTensor(2,";
    "Fxn:test_dtype_out_match" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_dtype_out_match" -> "Fxn:torch.zeros((2,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.Tensor().type()";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.Tensor().dtype,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type('torch.FloatTensor')";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.float32,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.float32,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertEqual(torch.FloatStorage,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type(torch.float64)";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.float64,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.float64,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertEqual(torch.DoubleStorage,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type('torch.Tensor')";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.float64,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.float64,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertEqual(torch.DoubleStorage,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type(torch.cuda.float32)";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.cuda.float32,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertIs(torch.cuda.float32,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertEqual(torch.cuda.FloatStorage,";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type('torch.IntTensor'))";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type(torch.int64))";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type(torch.sparse.int64))";
    "Fxn:test_constructor_dtypes" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type(torch.sparse.float64))";
    "Fxn:test_constructor_dtypes" -> "Fxn:torch.set_default_tensor_type(default_type)";
    "Fxn:test_tensor_factory" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_tensor_factory" -> "Fxn:torch.tensor([1,";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_tensor_factory" -> "Fxn:torch.tensor([1,";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertIs(torch.int,";
    "Fxn:test_tensor_factory" -> "Fxn:torch.tensor(expected)";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertEqual(expected,";
    "Fxn:test_tensor_factory" -> "Fxn:torch.ones_like(expected))";
    "Fxn:test_tensor_factory" -> "Fxn:torch.tensor(expected,";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertIs(torch.int,";
    "Fxn:test_tensor_factory" -> "Fxn:np.array([5.])";
    "Fxn:test_tensor_factory" -> "Fxn:torch.tensor(a)";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertEqual(5.,";
    "Fxn:test_tensor_factory" -> "Fxn:res1[0].item())";
    "Fxn:test_tensor_factory" -> "Fxn:self.assertEqual(5.,";
    "Fxn:test_tensor_factory" -> "Fxn:res1[0].item())";
    "Fxn:test_new_tensor" -> "Fxn:torch.autograd.Variable(torch.ByteTensor([1,";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor([1,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor([1,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertIs(torch.int,";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor(expected)";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(expected,";
    "Fxn:test_new_tensor" -> "Fxn:torch.ones_like(expected))";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor(expected,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res2,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertIs(torch.int,";
    "Fxn:test_new_tensor" -> "Fxn:np.array([5.])";
    "Fxn:test_new_tensor" -> "Fxn:torch.tensor(a)";
    "Fxn:test_new_tensor" -> "Fxn:res1.new_tensor(a)";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(5.,";
    "Fxn:test_new_tensor" -> "Fxn:res1[0].item())";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(5.,";
    "Fxn:test_new_tensor" -> "Fxn:res1[0].item())";
    "Fxn:test_new_tensor" -> "Fxn:torch.cuda.device_count()";
    "Fxn:test_new_tensor" -> "Fxn:expected.cuda(1)";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor([1,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:test_new_tensor" -> "Fxn:expected.get_device())";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor([1,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:test_new_tensor" -> "Fxn:expected.get_device())";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor(expected)";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res2.get_device(),";
    "Fxn:test_new_tensor" -> "Fxn:expected.get_device())";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor(expected,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res2.get_device(),";
    "Fxn:test_new_tensor" -> "Fxn:expected.get_device())";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor(expected,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res2.get_device(),";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor(1)";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:test_new_tensor" -> "Fxn:expected.get_device())";
    "Fxn:test_new_tensor" -> "Fxn:expected.new_tensor(1,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertIs(torch.cuda.int,";
    "Fxn:test_new_tensor" -> "Fxn:self.assertEqual(res1.get_device(),";
    "Fxn:test_new_tensor" -> "Fxn:expected.get_device())";
    "Fxn:test_diag" -> "Fxn:torch.rand(100,";
    "Fxn:test_diag" -> "Fxn:torch.diag(x)";
    "Fxn:test_diag" -> "Fxn:torch.Tensor()";
    "Fxn:test_diag" -> "Fxn:torch.diag(x,";
    "Fxn:test_diag" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_diagonal" -> "Fxn:torch.randn((100,";
    "Fxn:_test_diagonal" -> "Fxn:torch.diagonal(x)";
    "Fxn:_test_diagonal" -> "Fxn:torch.diag(x)";
    "Fxn:_test_diagonal" -> "Fxn:self.assertEqual(result,";
    "Fxn:_test_diagonal" -> "Fxn:torch.randn((100,";
    "Fxn:_test_diagonal" -> "Fxn:torch.diagonal(x,";
    "Fxn:_test_diagonal" -> "Fxn:torch.diag(x,";
    "Fxn:_test_diagonal" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_diagonal" -> "Fxn:self._test_diagonal(self,";
    "Fxn:_test_diagflat" -> "Fxn:torch.randn((100,),";
    "Fxn:_test_diagflat" -> "Fxn:torch.diagflat(x)";
    "Fxn:_test_diagflat" -> "Fxn:torch.diag(x)";
    "Fxn:_test_diagflat" -> "Fxn:self.assertEqual(result,";
    "Fxn:_test_diagflat" -> "Fxn:torch.randn((100,),";
    "Fxn:_test_diagflat" -> "Fxn:torch.diagflat(x,";
    "Fxn:_test_diagflat" -> "Fxn:torch.diag(x,";
    "Fxn:_test_diagflat" -> "Fxn:self.assertEqual(result,";
    "Fxn:_test_diagflat" -> "Fxn:torch.randn((2,";
    "Fxn:_test_diagflat" -> "Fxn:torch.diagflat(x)";
    "Fxn:_test_diagflat" -> "Fxn:torch.diag(x.contiguous().view(-1))";
    "Fxn:_test_diagflat" -> "Fxn:self.assertEqual(result,";
    "Fxn:_test_diagflat" -> "Fxn:torch.randn((2,";
    "Fxn:_test_diagflat" -> "Fxn:dtype=dtype).transpose(2,";
    "Fxn:_test_diagflat" -> "Fxn:self.assertFalse(x.is_contiguous())";
    "Fxn:_test_diagflat" -> "Fxn:torch.diagflat(x)";
    "Fxn:_test_diagflat" -> "Fxn:torch.diag(x.contiguous().view(-1))";
    "Fxn:_test_diagflat" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_diagflat" -> "Fxn:self._test_diagflat(self,";
    "Fxn:test_eye" -> "Fxn:torch.eye(100,";
    "Fxn:test_eye" -> "Fxn:torch.Tensor()";
    "Fxn:test_eye" -> "Fxn:torch.eye(100,";
    "Fxn:test_eye" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_renorm" -> "Fxn:torch.randn(10,";
    "Fxn:test_renorm" -> "Fxn:torch.Tensor()";
    "Fxn:renorm" -> "Fxn:matrix.transpose(dim,";
    "Fxn:renorm" -> "Fxn:0).contiguous()";
    "Fxn:renorm" -> "Fxn:m1.clone().resize_(m1.size(0),";
    "Fxn:renorm" -> "Fxn:m1.size(0))))";
    "Fxn:renorm" -> "Fxn:m2.norm(value,";
    "Fxn:renorm" -> "Fxn:norms.clone()";
    "Fxn:renorm" -> "Fxn:new_norms[torch.gt(norms,";
    "Fxn:renorm" -> "Fxn:new_norms.div_(norms.add_(1e-7))";
    "Fxn:renorm" -> "Fxn:m1.mul_(new_norms.expand_as(m1))";
    "Fxn:renorm" -> "Fxn:m1.transpose(dim,";
    "Fxn:renorm" -> "Fxn:m1.norm(2,";
    "Fxn:renorm" -> "Fxn:1).mean()";
    "Fxn:renorm" -> "Fxn:renorm(m1,";
    "Fxn:renorm" -> "Fxn:m1.renorm_(2,";
    "Fxn:renorm" -> "Fxn:self.assertEqual(m1,";
    "Fxn:renorm" -> "Fxn:self.assertEqual(m1.norm(2,";
    "Fxn:renorm" -> "Fxn:m2.norm(2,";
    "Fxn:renorm" -> "Fxn:torch.randn(3,";
    "Fxn:renorm" -> "Fxn:m1.transpose(1,";
    "Fxn:renorm" -> "Fxn:2).contiguous().clone().resize_(15,";
    "Fxn:renorm" -> "Fxn:m2.norm(2,";
    "Fxn:renorm" -> "Fxn:0).mean()";
    "Fxn:renorm" -> "Fxn:renorm(m2,";
    "Fxn:renorm" -> "Fxn:m1.renorm_(2,";
    "Fxn:renorm" -> "Fxn:m1.transpose(1,";
    "Fxn:renorm" -> "Fxn:2).contiguous().clone().resize_(15,";
    "Fxn:renorm" -> "Fxn:self.assertEqual(m3,";
    "Fxn:renorm" -> "Fxn:self.assertEqual(m3.norm(2,";
    "Fxn:renorm" -> "Fxn:m2.norm(2,";
    "Fxn:make_prob_dist" -> "Fxn:[5])).uniform_()[:,";
    "Fxn:make_prob_dist" -> "Fxn:prob_dist.transpose(1,";
    "Fxn:make_prob_dist" -> "Fxn:prob_dist.is_contiguous()";
    "Fxn:make_prob_dist" -> "Fxn:make_prob_dist([n_row,";
    "Fxn:make_prob_dist" -> "Fxn:torch.LongTensor(n_row).random_(-2,";
    "Fxn:make_prob_dist" -> "Fxn:n_col).tolist()";
    "Fxn:make_prob_dist" -> "Fxn:torch.multinomial(prob_dist,";
    "Fxn:make_prob_dist" -> "Fxn:self.assertEqual(prob_dist.dim(),";
    "Fxn:make_prob_dist" -> "Fxn:self.assertEqual(sample_indices.size(1),";
    "Fxn:make_prob_dist" -> "Fxn:self.assertNotEqual(sample_indices[i,";
    "Fxn:make_prob_dist" -> "Fxn:make_prob_dist([n_row,";
    "Fxn:make_prob_dist" -> "Fxn:torch.LongTensor(n_row).random_(-1,";
    "Fxn:make_prob_dist" -> "Fxn:n_col).tolist()";
    "Fxn:make_prob_dist" -> "Fxn:torch.multinomial(prob_dist,";
    "Fxn:make_prob_dist" -> "Fxn:self.assertEqual(prob_dist.dim(),";
    "Fxn:make_prob_dist" -> "Fxn:self.assertEqual(sample_indices.size(1),";
    "Fxn:make_prob_dist" -> "Fxn:self.assertNotEqual(sample_idx,";
    "Fxn:make_prob_dist" -> "Fxn:self.assertNotIn(sample_idx,";
    "Fxn:make_prob_dist" -> "Fxn:make_prob_dist([n_col],";
    "Fxn:make_prob_dist" -> "Fxn:is_contiguous).fill_(1)";
    "Fxn:make_prob_dist" -> "Fxn:torch.multinomial(prob_dist,";
    "Fxn:make_prob_dist" -> "Fxn:self.assertNotEqual(sample_index,";
    "Fxn:make_prob_dist" -> "Fxn:sample_indices.dim()";
    "Fxn:make_prob_dist" -> "Fxn:self.assertEqual(sample_indices.dim(),";
    "Fxn:make_prob_dist" -> "Fxn:self.assertEqual(prob_dist.dim(),";
    "Fxn:make_prob_dist" -> "Fxn:self.assertEqual(sample_indices.size(0),";
    "Fxn:test_multinomial" -> "Fxn:self._test_multinomial(self,";
    "Fxn:test_range" -> "Fxn:torch.range(0,";
    "Fxn:test_range" -> "Fxn:torch.Tensor()";
    "Fxn:test_range" -> "Fxn:torch.range(0,";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_range" -> "Fxn:torch.zeros(2,";
    "Fxn:test_range" -> "Fxn:torch.range(0,";
    "Fxn:test_range" -> "Fxn:out=x.narrow(1,";
    "Fxn:test_range" -> "Fxn:torch.Tensor(((0,";
    "Fxn:test_range" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_range" -> "Fxn:torch.Tensor((1,";
    "Fxn:test_range" -> "Fxn:torch.Tensor()";
    "Fxn:test_range" -> "Fxn:torch.range(1,";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_range" -> "Fxn:torch.ones(1)";
    "Fxn:test_range" -> "Fxn:torch.Tensor()";
    "Fxn:test_range" -> "Fxn:torch.range(1,";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_range" -> "Fxn:torch.range(1,";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_range" -> "Fxn:torch.range(0.6,";
    "Fxn:test_range" -> "Fxn:out=torch.FloatTensor())";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:test_range" -> "Fxn:torch.range(1,";
    "Fxn:test_range" -> "Fxn:out=torch.FloatTensor())";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:test_range" -> "Fxn:torch.range(0.6,";
    "Fxn:test_range" -> "Fxn:out=torch.DoubleTensor())";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:test_range" -> "Fxn:torch.range(1,";
    "Fxn:test_range" -> "Fxn:out=torch.DoubleTensor())";
    "Fxn:test_range" -> "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:torch.Tensor()";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_arange" -> "Fxn:torch.arange(10)";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_arange" -> "Fxn:torch.zeros(2,";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:out=x.narrow(1,";
    "Fxn:test_arange" -> "Fxn:torch.Tensor(((0,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_arange" -> "Fxn:torch.Tensor((1,";
    "Fxn:test_arange" -> "Fxn:torch.Tensor()";
    "Fxn:test_arange" -> "Fxn:torch.arange(1,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_arange" -> "Fxn:torch.ones(1)";
    "Fxn:test_arange" -> "Fxn:torch.Tensor()";
    "Fxn:test_arange" -> "Fxn:torch.arange(1,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_arange" -> "Fxn:torch.arange(1,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_arange" -> "Fxn:torch.arange(0.6,";
    "Fxn:test_arange" -> "Fxn:out=torch.FloatTensor())";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_arange" -> "Fxn:torch.arange(1,";
    "Fxn:test_arange" -> "Fxn:out=torch.FloatTensor())";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1[0],";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1[29],";
    "Fxn:test_arange" -> "Fxn:torch.arange(0.6,";
    "Fxn:test_arange" -> "Fxn:out=torch.DoubleTensor())";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_arange" -> "Fxn:torch.arange(1,";
    "Fxn:test_arange" -> "Fxn:out=torch.DoubleTensor())";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1.size(0),";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1[0],";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(res1[29],";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r.min(),";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r.max(),";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r.numel(),";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r.min(),";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r.max(),";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r.numel(),";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:torch.arange(0,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r1[:-1],";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r2,";
    "Fxn:test_arange" -> "Fxn:torch.arange(10,";
    "Fxn:test_arange" -> "Fxn:torch.arange(10,";
    "Fxn:test_arange" -> "Fxn:torch.arange(10,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r1,";
    "Fxn:test_arange" -> "Fxn:self.assertEqual(r2,";
    "Fxn:_select_broadcastable_dims" -> "Fxn:random.randint(1,";
    "Fxn:_select_broadcastable_dims" -> "Fxn:[random.randint(1,";
    "Fxn:_select_broadcastable_dims" -> "Fxn:random.randint(1,";
    "Fxn:_select_broadcastable_dims" -> "Fxn:random.randint(1,";
    "Fxn:_test_broadcast" -> "Fxn:self._select_broadcastable_dims()";
    "Fxn:_test_broadcast" -> "Fxn:cast(torch.randn(*dims_small).float())";
    "Fxn:_test_broadcast" -> "Fxn:cast(torch.randn(*dims_large).float())";
    "Fxn:_test_broadcast" -> "Fxn:small.expand(*dims_full)";
    "Fxn:_test_broadcast" -> "Fxn:large.expand(*dims_full)";
    "Fxn:_test_broadcast" -> "Fxn:self._select_broadcastable_dims(dims_full)";
    "Fxn:_test_broadcast" -> "Fxn:cast(torch.randn(*dims_small2).float())";
    "Fxn:_test_broadcast" -> "Fxn:small2.expand(*dims_full)";
    "Fxn:tensorfn" -> "Fxn:myfn(t1,";
    "Fxn:tensorfn" -> "Fxn:myfn(t1";
    "Fxn:tensorfn" -> "Fxn:myfn(1,";
    "Fxn:tensorfn" -> "Fxn:myfn(t1)";
    "Fxn:tensorfn" -> "Fxn:[(large,";
    "Fxn:tensorfn" -> "Fxn:tensorfn(method_expanded,";
    "Fxn:tensorfn" -> "Fxn:tensorfn(method,";
    "Fxn:tensorfn" -> "Fxn:self.assertEqual(r1,";
    "Fxn:torchfn" -> "Fxn:fntorch(t1,";
    "Fxn:torchfn" -> "Fxn:fntorch(t1,";
    "Fxn:torchfn" -> "Fxn:fntorch(t1,";
    "Fxn:torchfn" -> "Fxn:cast(torch.arange(1,";
    "Fxn:torchfn" -> "Fxn:t1.nelement()";
    "Fxn:torchfn" -> "Fxn:1).float()))";
    "Fxn:torchfn" -> "Fxn:fntorch(t1,";
    "Fxn:torchfn" -> "Fxn:fntorch(t1,";
    "Fxn:torchfn" -> "Fxn:fntorch(t1,";
    "Fxn:torchfn" -> "Fxn:[(large,";
    "Fxn:torchfn" -> "Fxn:torchfn(expanded[first],";
    "Fxn:torchfn" -> "Fxn:torchfn(first,";
    "Fxn:torchfn" -> "Fxn:self.assertEqual(r1,";
    "Fxn:torchfn" -> "Fxn:argument(s)";
    "Fxn:torchfn" -> "Fxn:large_expanded.clone()";
    "Fxn:tensorfn_inplace" -> "Fxn:t0_fn(t1,";
    "Fxn:tensorfn_inplace" -> "Fxn:t0_fn(t1";
    "Fxn:tensorfn_inplace" -> "Fxn:cast(torch.arange(1,";
    "Fxn:tensorfn_inplace" -> "Fxn:t0.nelement()";
    "Fxn:tensorfn_inplace" -> "Fxn:1).float()))";
    "Fxn:tensorfn_inplace" -> "Fxn:t0_fn(t1";
    "Fxn:tensorfn_inplace" -> "Fxn:t0_fn(t1,";
    "Fxn:tensorfn_inplace" -> "Fxn:t0_fn(t1,";
    "Fxn:tensorfn_inplace" -> "Fxn:t0_fn(1.0,";
    "Fxn:tensorfn_inplace" -> "Fxn:t0_fn(t1)";
    "Fxn:tensorfn_inplace" -> "Fxn:tensorfn_inplace(large_expanded,";
    "Fxn:tensorfn_inplace" -> "Fxn:tensorfn_inplace(large_expanded_clone,";
    "Fxn:tensorfn_inplace" -> "Fxn:large_expanded.stride()";
    "Fxn:tensorfn_inplace" -> "Fxn:large_expanded_clone.stride()):";
    "Fxn:tensorfn_inplace" -> "Fxn:self.assertEqual(r1,";
    "Fxn:broadcastable" -> "Fxn:t1.expand_as(t0)";
    "Fxn:broadcastable" -> "Fxn:t2.expand_as(t0)";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:broadcastable(t0,";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:t0.numel()";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:t1.numel()";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:t2.numel()";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:tensorfn_inplace(t0,";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:tensorfn_inplace(t0,";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:_test_in_place_broadcastable(small,";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:_test_in_place_broadcastable(small,";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:_test_in_place_broadcastable(small2,";
    "Fxn:_test_in_place_broadcastable" -> "Fxn:_test_in_place_broadcastable(small2,";
    "Fxn:test_broadcast" -> "Fxn:self._test_broadcast(self,";
    "Fxn:_test_contiguous" -> "Fxn:cast(torch.randn(1,";
    "Fxn:_test_contiguous" -> "Fxn:self.assertTrue(x.is_contiguous())";
    "Fxn:_test_contiguous" -> "Fxn:x.set_(x.storage(),";
    "Fxn:_test_contiguous" -> "Fxn:x.size(),";
    "Fxn:_test_contiguous" -> "Fxn:self.assertTrue(x.is_contiguous())";
    "Fxn:test_contiguous" -> "Fxn:self._test_contiguous(self,";
    "Fxn:test_scalars_as_floats" -> "Fxn:torch.tensor(2)";
    "Fxn:test_scalars_as_floats" -> "Fxn:torch.tensor(3)";
    "Fxn:test_scalars_as_floats" -> "Fxn:self.assertEqual(y.addcmul(y,";
    "Fxn:test_scalars_as_floats" -> "Fxn:torch.tensor(2,";
    "Fxn:test_scalars_as_floats" -> "Fxn:self.assertRaises(Exception,";
    "Fxn:test_scalars_as_floats" -> "Fxn:y.addcmul(y,";
    "Fxn:_test_broadcast_fused_matmul" -> "Fxn:random.randint(1,";
    "Fxn:_test_broadcast_fused_matmul" -> "Fxn:random.randint(1,";
    "Fxn:_test_broadcast_fused_matmul" -> "Fxn:random.randint(1,";
    "Fxn:_test_broadcast_fused_matmul" -> "Fxn:random.randint(1,";
    "Fxn:dims_full_for_fn" -> "Fxn:AssertionError("unknown";
    "Fxn:dims_full_for_fn" -> "Fxn:dims_full_for_fn()";
    "Fxn:dims_full_for_fn" -> "Fxn:self._select_broadcastable_dims(t0_dims_full)";
    "Fxn:dims_full_for_fn" -> "Fxn:cast(torch.randn(*t0_dims_small).float())";
    "Fxn:dims_full_for_fn" -> "Fxn:cast(torch.randn(*t1_dims).float())";
    "Fxn:dims_full_for_fn" -> "Fxn:cast(torch.randn(*t2_dims).float())";
    "Fxn:dims_full_for_fn" -> "Fxn:cast(t0_small.expand(*t0_dims_full))";
    "Fxn:dims_full_for_fn" -> "Fxn:fntorch(t0_small,";
    "Fxn:dims_full_for_fn" -> "Fxn:fntorch(t0_full,";
    "Fxn:dims_full_for_fn" -> "Fxn:self.assertEqual(r0,";
    "Fxn:test_broadcast_fused_matmul" -> "Fxn:self._test_broadcast_fused_matmul(self,";
    "Fxn:_test_broadcast_batched_matmul" -> "Fxn:random.randint(1,";
    "Fxn:_test_broadcast_batched_matmul" -> "Fxn:random.randint(1,";
    "Fxn:_test_broadcast_batched_matmul" -> "Fxn:random.randint(1,";
    "Fxn:_test_broadcast_batched_matmul" -> "Fxn:[random.randint(1,";
    "Fxn:_test_broadcast_batched_matmul" -> "Fxn:self._select_broadcastable_dims(full_batch_dims)";
    "Fxn:verify_batched_matmul" -> "Fxn:cast(torch.randn(*(small_dims)).float())";
    "Fxn:verify_batched_matmul" -> "Fxn:cast(torch.randn(*(dim0_dims)).float())";
    "Fxn:verify_batched_matmul" -> "Fxn:cast(torch.randn(*(full_batch_dims";
    "Fxn:verify_batched_matmul" -> "Fxn:full_mat_dims)).float())";
    "Fxn:maybe_squeeze_result" -> "Fxn:l.dim()";
    "Fxn:maybe_squeeze_result" -> "Fxn:result.squeeze(-2)";
    "Fxn:maybe_squeeze_result" -> "Fxn:r.dim()";
    "Fxn:maybe_squeeze_result" -> "Fxn:result.squeeze(-1)";
    "Fxn:maybe_squeeze_result" -> "Fxn:lhs.expand(*(torch.Size(full_batch_dims)";
    "Fxn:maybe_squeeze_result" -> "Fxn:torch.Size(lhs_mat_dims)))";
    "Fxn:maybe_squeeze_result" -> "Fxn:rhs.unsqueeze(-1)).";
    "Fxn:maybe_squeeze_result" -> "Fxn:expand(*(torch.Size(full_batch_dims)";
    "Fxn:maybe_squeeze_result" -> "Fxn:torch.Size(rhs_mat_dims))))";
    "Fxn:maybe_squeeze_result" -> "Fxn:maybe_squeeze_result(lhs_expanded,";
    "Fxn:maybe_squeeze_result" -> "Fxn:lhs_expanded_matmul_fn(rhs_expanded))";
    "Fxn:maybe_squeeze_result" -> "Fxn:maybe_squeeze_result(l,";
    "Fxn:maybe_squeeze_result" -> "Fxn:l_matmul_fn(r))";
    "Fxn:maybe_squeeze_result" -> "Fxn:self.assertEqual(truth,";
    "Fxn:maybe_squeeze_result" -> "Fxn:maybe_squeeze_result(l,";
    "Fxn:maybe_squeeze_result" -> "Fxn:torch.matmul(l,";
    "Fxn:maybe_squeeze_result" -> "Fxn:self.assertEqual(truth,";
    "Fxn:maybe_squeeze_result" -> "Fxn:rhs_expanded.contiguous().view(-1,";
    "Fxn:maybe_squeeze_result" -> "Fxn:self.assertEqual(truth.view(-1,";
    "Fxn:maybe_squeeze_result" -> "Fxn:bmm_result.view(-1,";
    "Fxn:maybe_squeeze_result" -> "Fxn:product((True,";
    "Fxn:maybe_squeeze_result" -> "Fxn:verify_batched_matmul(*indices)";
    "Fxn:test_broadcast_batched_matmul" -> "Fxn:self._test_broadcast_batched_matmul(self,";
    "Fxn:test_copy_broadcast" -> "Fxn:torch.zeros(5,";
    "Fxn:test_copy_broadcast" -> "Fxn:6).copy_(torch.zeros(6))";
    "Fxn:test_copy_broadcast" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_copy_broadcast" -> "Fxn:torch.zeros(5,";
    "Fxn:test_copy_broadcast" -> "Fxn:6).copy_(torch.zeros(30)))";
    "Fxn:test_randperm" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_randperm" -> "Fxn:torch.randperm(100)";
    "Fxn:test_randperm" -> "Fxn:torch.LongTensor()";
    "Fxn:test_randperm" -> "Fxn:torch.set_rng_state(_RNGState)";
    "Fxn:test_randperm" -> "Fxn:torch.randperm(100,";
    "Fxn:test_randperm" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_random" -> "Fxn:p<=(2/(ub-lb))^200=6e-36";
    "Fxn:test_random" -> "Fxn:torch.FloatTensor(200)";
    "Fxn:test_random" -> "Fxn:t.fill_(-1)";
    "Fxn:test_random" -> "Fxn:t.random_(lb,";
    "Fxn:test_random" -> "Fxn:self.assertEqual(t.min(),";
    "Fxn:test_random" -> "Fxn:self.assertEqual(t.max(),";
    "Fxn:test_random" -> "Fxn:t.fill_(-1)";
    "Fxn:test_random" -> "Fxn:t.random_(ub)";
    "Fxn:test_random" -> "Fxn:self.assertEqual(t.min(),";
    "Fxn:test_random" -> "Fxn:self.assertEqual(t.max(),";
    "Fxn:check_order" -> "Fxn:error('unknown";
    "Fxn:check_order" -> "Fxn:"descending"'.format(order))";
    "Fxn:check_order" -> "Fxn:product(range(SIZE),";
    "Fxn:check_order" -> "Fxn:self.assertTrue(check_order(mxx[j][k";
    "Fxn:check_order" -> "Fxn:{}'.format(order,";
    "Fxn:check_order" -> "Fxn:x.size(x.dim()";
    "Fxn:check_order" -> "Fxn:seen.clear()";
    "Fxn:check_order" -> "Fxn:self.assertEqual(x[k][ixx[k][j]],";
    "Fxn:check_order" -> "Fxn:{}'.format(order,";
    "Fxn:check_order" -> "Fxn:seen.add(ixx[k][j])";
    "Fxn:check_order" -> "Fxn:self.assertEqual(len(seen),";
    "Fxn:test_sort" -> "Fxn:torch.rand(SIZE,";
    "Fxn:test_sort" -> "Fxn:torch.sort(x)";
    "Fxn:test_sort" -> "Fxn:torch.Tensor()";
    "Fxn:test_sort" -> "Fxn:torch.LongTensor()";
    "Fxn:test_sort" -> "Fxn:torch.sort(x,";
    "Fxn:test_sort" -> "Fxn:out=(res2val,";
    "Fxn:test_sort" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_sort" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_sort" -> "Fxn:self.assertIsOrdered('ascending',";
    "Fxn:test_sort" -> "Fxn:self.assertEqual(";
    "Fxn:test_sort" -> "Fxn:torch.sort(torch.Tensor((50,";
    "Fxn:test_sort" -> "Fxn:torch.Tensor((10,";
    "Fxn:test_sort" -> "Fxn:torch.floor(torch.rand(SIZE,";
    "Fxn:test_sort" -> "Fxn:torch.sort(x,";
    "Fxn:test_sort" -> "Fxn:out=(res2val,";
    "Fxn:test_sort" -> "Fxn:self.assertIsOrdered('ascending',";
    "Fxn:test_sort" -> "Fxn:torch.rand(SIZE,";
    "Fxn:test_sort" -> "Fxn:torch.sort(x,";
    "Fxn:test_sort" -> "Fxn:x.dim()";
    "Fxn:test_sort" -> "Fxn:torch.Tensor()";
    "Fxn:test_sort" -> "Fxn:torch.LongTensor()";
    "Fxn:test_sort" -> "Fxn:torch.sort(x,";
    "Fxn:test_sort" -> "Fxn:x.dim()";
    "Fxn:test_sort" -> "Fxn:out=(res2val,";
    "Fxn:test_sort" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_sort" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_sort" -> "Fxn:self.assertIsOrdered('descending',";
    "Fxn:test_sort" -> "Fxn:self.assertEqual(";
    "Fxn:test_sort" -> "Fxn:torch.sort(torch.Tensor((10,";
    "Fxn:test_sort" -> "Fxn:torch.Tensor((50,";
    "Fxn:test_sort" -> "Fxn:self.assertIsOrdered('descending',";
    "Fxn:topKViaSort" -> "Fxn:t.sort(dim,";
    "Fxn:topKViaSort" -> "Fxn:sorted.narrow(dim,";
    "Fxn:topKViaSort" -> "Fxn:indices.narrow(dim,";
    "Fxn:compareTensors" -> "Fxn:self.assertEqual(res1,";
    "Fxn:compareTensors" -> "Fxn:ind1.eq(ind2).all():";
    "Fxn:compareTensors" -> "Fxn:t.gather(dim,";
    "Fxn:compareTensors" -> "Fxn:self.assertEqual(res1,";
    "Fxn:compare" -> "Fxn:t.topk(k,";
    "Fxn:compare" -> "Fxn:topKViaSort(t,";
    "Fxn:compare" -> "Fxn:compareTensors(t,";
    "Fxn:compare" -> "Fxn:torch.rand(random.randint(1,";
    "Fxn:compare" -> "Fxn:random.randint(1,";
    "Fxn:compare" -> "Fxn:random.randint(1,";
    "Fxn:compare" -> "Fxn:random.randrange(t.ndimension())";
    "Fxn:compare" -> "Fxn:random.randrange(t.ndimension())";
    "Fxn:compare" -> "Fxn:t.transpose(dim1,";
    "Fxn:compare" -> "Fxn:random.randrange(testTensor.ndimension())";
    "Fxn:compare" -> "Fxn:random.randint(1,";
    "Fxn:compare" -> "Fxn:testTensor.size(dim))";
    "Fxn:compare" -> "Fxn:compare(testTensor,";
    "Fxn:test_topk_arguments" -> "Fxn:torch.randn(10,";
    "Fxn:test_topk_arguments" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_topk_arguments" -> "Fxn:q.topk(4,";
    "Fxn:test_kthvalue" -> "Fxn:torch.rand(SIZE,";
    "Fxn:test_kthvalue" -> "Fxn:x.clone()";
    "Fxn:test_kthvalue" -> "Fxn:random.randint(1,";
    "Fxn:test_kthvalue" -> "Fxn:torch.kthvalue(x,";
    "Fxn:test_kthvalue" -> "Fxn:torch.sort(x)";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1val[:,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1ind[:,";
    "Fxn:test_kthvalue" -> "Fxn:random.randint(1,";
    "Fxn:test_kthvalue" -> "Fxn:torch.Tensor()";
    "Fxn:test_kthvalue" -> "Fxn:torch.LongTensor()";
    "Fxn:test_kthvalue" -> "Fxn:torch.kthvalue(x,";
    "Fxn:test_kthvalue" -> "Fxn:out=(res1val,";
    "Fxn:test_kthvalue" -> "Fxn:torch.sort(x)";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1val[:,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1ind[:,";
    "Fxn:test_kthvalue" -> "Fxn:random.randint(1,";
    "Fxn:test_kthvalue" -> "Fxn:torch.kthvalue(x,";
    "Fxn:test_kthvalue" -> "Fxn:torch.sort(x,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_kthvalue" -> "Fxn:x.narrow(1,";
    "Fxn:test_kthvalue" -> "Fxn:y.contiguous()";
    "Fxn:test_kthvalue" -> "Fxn:random.randint(1,";
    "Fxn:test_kthvalue" -> "Fxn:torch.kthvalue(y,";
    "Fxn:test_kthvalue" -> "Fxn:torch.kthvalue(y0,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_kthvalue" -> "Fxn:torch.Tensor((3,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(torch.kthvalue(y,";
    "Fxn:test_kthvalue" -> "Fxn:self.assertEqual(torch.kthvalue(y,";
    "Fxn:test_median" -> "Fxn:torch.rand(size,";
    "Fxn:test_median" -> "Fxn:x.clone()";
    "Fxn:test_median" -> "Fxn:x.nelement()";
    "Fxn:test_median" -> "Fxn:torch.median(x)";
    "Fxn:test_median" -> "Fxn:torch.sort(x.view(nelem))";
    "Fxn:test_median" -> "Fxn:self.assertEqual(res2val[ind],";
    "Fxn:test_median" -> "Fxn:torch.median(x,";
    "Fxn:test_median" -> "Fxn:torch.sort(x)";
    "Fxn:test_median" -> "Fxn:self.assertEqual(res2val.select(1,";
    "Fxn:test_median" -> "Fxn:self.assertEqual(res2val.select(1,";
    "Fxn:test_median" -> "Fxn:torch.Tensor()";
    "Fxn:test_median" -> "Fxn:torch.LongTensor()";
    "Fxn:test_median" -> "Fxn:torch.median(x,";
    "Fxn:test_median" -> "Fxn:out=(res2val,";
    "Fxn:test_median" -> "Fxn:self.assertEqual(res2val,";
    "Fxn:test_median" -> "Fxn:self.assertEqual(res2ind,";
    "Fxn:test_median" -> "Fxn:torch.median(x,";
    "Fxn:test_median" -> "Fxn:torch.sort(x,";
    "Fxn:test_median" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_median" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_median" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_mode" -> "Fxn:torch.arange(1,";
    "Fxn:test_mode" -> "Fxn:1).clone().resize_(SIZE,";
    "Fxn:test_mode" -> "Fxn:x.clone()";
    "Fxn:test_mode" -> "Fxn:torch.Tensor(SIZE).fill_(1)";
    "Fxn:test_mode" -> "Fxn:torch.LongTensor(SIZE).fill_(1)";
    "Fxn:test_mode" -> "Fxn:torch.mode(x,";
    "Fxn:test_mode" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_mode" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_mode" -> "Fxn:torch.Tensor()";
    "Fxn:test_mode" -> "Fxn:torch.LongTensor()";
    "Fxn:test_mode" -> "Fxn:torch.mode(x,";
    "Fxn:test_mode" -> "Fxn:out=(res2val,";
    "Fxn:test_mode" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_mode" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_mode" -> "Fxn:torch.mode(x,";
    "Fxn:test_mode" -> "Fxn:self.assertEqual(res1val,";
    "Fxn:test_mode" -> "Fxn:self.assertEqual(res1ind,";
    "Fxn:test_mode" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_tril" -> "Fxn:torch.rand(SIZE,";
    "Fxn:test_tril" -> "Fxn:torch.tril(x)";
    "Fxn:test_tril" -> "Fxn:torch.Tensor()";
    "Fxn:test_tril" -> "Fxn:torch.tril(x,";
    "Fxn:test_tril" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_triu" -> "Fxn:torch.rand(SIZE,";
    "Fxn:test_triu" -> "Fxn:torch.triu(x)";
    "Fxn:test_triu" -> "Fxn:torch.Tensor()";
    "Fxn:test_triu" -> "Fxn:torch.triu(x,";
    "Fxn:test_triu" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_cat" -> "Fxn:torch.rand(13,";
    "Fxn:test_cat" -> "Fxn:SIZE).transpose(0,";
    "Fxn:test_cat" -> "Fxn:torch.rand(17,";
    "Fxn:test_cat" -> "Fxn:SIZE).transpose(0,";
    "Fxn:test_cat" -> "Fxn:torch.rand(19,";
    "Fxn:test_cat" -> "Fxn:SIZE).transpose(0,";
    "Fxn:test_cat" -> "Fxn:torch.cat((x,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(res1.narrow(pos_dim,";
    "Fxn:test_cat" -> "Fxn:torch.randn(20,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(torch.cat(torch.split(x,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(torch.cat(torch.chunk(x,";
    "Fxn:test_cat" -> "Fxn:torch.randn(1,";
    "Fxn:test_cat" -> "Fxn:torch.cat([x,";
    "Fxn:test_cat" -> "Fxn:self.assertEqual(z.size(),";
    "Fxn:test_cat" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_cat" -> "Fxn:torch.cat([]))";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.cat([x,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.randn(2,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_cat_bad_input_sizes" -> "Fxn:torch.cat([x,";
    "Fxn:test_cat_scalars" -> "Fxn:torch.tensor(0)";
    "Fxn:test_cat_scalars" -> "Fxn:torch.tensor(1)";
    "Fxn:test_cat_scalars" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_cat_scalars" -> "Fxn:torch.cat([x,";
    "Fxn:test_stack" -> "Fxn:torch.rand(2,";
    "Fxn:test_stack" -> "Fxn:torch.rand(2,";
    "Fxn:test_stack" -> "Fxn:torch.rand(2,";
    "Fxn:test_stack" -> "Fxn:torch.stack((x,";
    "Fxn:test_stack" -> "Fxn:torch.stack((x,";
    "Fxn:test_stack" -> "Fxn:x.size()[:dim]";
    "Fxn:test_stack" -> "Fxn:x.size()[dim:]";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(res.size(),";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(res.select(dim,";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(res.select(dim,";
    "Fxn:test_stack" -> "Fxn:self.assertEqual(res.select(dim,";
    "Fxn:test_stack_out" -> "Fxn:torch.rand(2,";
    "Fxn:test_stack_out" -> "Fxn:torch.rand(2,";
    "Fxn:test_stack_out" -> "Fxn:torch.rand(2,";
    "Fxn:test_stack_out" -> "Fxn:x.size()[:dim]";
    "Fxn:test_stack_out" -> "Fxn:x.size()[dim:]";
    "Fxn:test_stack_out" -> "Fxn:x.new(expected_size)";
    "Fxn:test_stack_out" -> "Fxn:x.new(expected_size)";
    "Fxn:test_stack_out" -> "Fxn:res_out.data_ptr()";
    "Fxn:test_stack_out" -> "Fxn:res_neg_out.data_ptr()";
    "Fxn:test_stack_out" -> "Fxn:torch.stack((x,";
    "Fxn:test_stack_out" -> "Fxn:torch.stack((x,";
    "Fxn:test_stack_out" -> "Fxn:self.assertEqual(res_out,";
    "Fxn:test_stack_out" -> "Fxn:self.assertEqual(res_out.size(),";
    "Fxn:test_stack_out" -> "Fxn:self.assertEqual(res_out_dp,";
    "Fxn:test_stack_out" -> "Fxn:res_out.data_ptr())";
    "Fxn:test_stack_out" -> "Fxn:self.assertEqual(res_out_neg_dp,";
    "Fxn:test_stack_out" -> "Fxn:res_neg_out.data_ptr())";
    "Fxn:test_stack_out" -> "Fxn:self.assertEqual(res_out.select(dim,";
    "Fxn:test_stack_out" -> "Fxn:self.assertEqual(res_out.select(dim,";
    "Fxn:test_stack_out" -> "Fxn:self.assertEqual(res_out.select(dim,";
    "Fxn:test_unbind" -> "Fxn:torch.rand(2,";
    "Fxn:test_unbind" -> "Fxn:torch.unbind(x,";
    "Fxn:test_unbind" -> "Fxn:self.assertEqual(x.size(dim),";
    "Fxn:test_unbind" -> "Fxn:self.assertEqual(x.select(dim,";
    "Fxn:test_linspace" -> "Fxn:random.random()";
    "Fxn:test_linspace" -> "Fxn:random.random()";
    "Fxn:test_linspace" -> "Fxn:torch.linspace(_from,";
    "Fxn:test_linspace" -> "Fxn:torch.Tensor()";
    "Fxn:test_linspace" -> "Fxn:torch.linspace(_from,";
    "Fxn:test_linspace" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_linspace" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_linspace" -> "Fxn:torch.linspace(0,";
    "Fxn:test_linspace" -> "Fxn:self.assertEqual(torch.linspace(0,";
    "Fxn:test_linspace" -> "Fxn:torch.zeros(1),";
    "Fxn:test_linspace" -> "Fxn:self.assertEqual(torch.linspace(2,";
    "Fxn:test_linspace" -> "Fxn:torch.Tensor((2,";
    "Fxn:test_linspace" -> "Fxn:torch.zeros(2,";
    "Fxn:test_linspace" -> "Fxn:torch.linspace(0,";
    "Fxn:test_linspace" -> "Fxn:out=x.narrow(1,";
    "Fxn:test_linspace" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_linspace" -> "Fxn:torch.Tensor(((0,";
    "Fxn:test_logspace" -> "Fxn:random.random()";
    "Fxn:test_logspace" -> "Fxn:random.random()";
    "Fxn:test_logspace" -> "Fxn:torch.logspace(_from,";
    "Fxn:test_logspace" -> "Fxn:torch.Tensor()";
    "Fxn:test_logspace" -> "Fxn:torch.logspace(_from,";
    "Fxn:test_logspace" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_logspace" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_logspace" -> "Fxn:torch.logspace(0,";
    "Fxn:test_logspace" -> "Fxn:self.assertEqual(torch.logspace(0,";
    "Fxn:test_logspace" -> "Fxn:torch.ones(1),";
    "Fxn:test_logspace" -> "Fxn:self.assertEqual(torch.logspace(1,";
    "Fxn:test_logspace" -> "Fxn:torch.Tensor((10,";
    "Fxn:test_logspace" -> "Fxn:torch.zeros(2,";
    "Fxn:test_logspace" -> "Fxn:torch.logspace(0,";
    "Fxn:test_logspace" -> "Fxn:out=x.narrow(1,";
    "Fxn:test_logspace" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_logspace" -> "Fxn:torch.Tensor(((0,";
    "Fxn:test_rand" -> "Fxn:torch.manual_seed(123456)";
    "Fxn:test_rand" -> "Fxn:torch.rand(SIZE,";
    "Fxn:test_rand" -> "Fxn:torch.Tensor()";
    "Fxn:test_rand" -> "Fxn:torch.manual_seed(123456)";
    "Fxn:test_rand" -> "Fxn:torch.rand(SIZE,";
    "Fxn:test_rand" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_randn" -> "Fxn:torch.manual_seed(123456)";
    "Fxn:test_randn" -> "Fxn:torch.randn(SIZE,";
    "Fxn:test_randn" -> "Fxn:torch.Tensor()";
    "Fxn:test_randn" -> "Fxn:torch.manual_seed(123456)";
    "Fxn:test_randn" -> "Fxn:torch.randn(SIZE,";
    "Fxn:test_randn" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_slice" -> "Fxn:torch.Tensor()";
    "Fxn:test_slice" -> "Fxn:torch.arange(0,";
    "Fxn:test_slice" -> "Fxn:16).view(4,";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(),";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:1).data.tolist(),";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:-3).data.tolist(),";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(start=-2,";
    "Fxn:test_slice" -> "Fxn:dim=1).data.tolist(),";
    "Fxn:test_slice" -> "Fxn:self.assertEqual(x.slice(0,";
    "Fxn:test_slice" -> "Fxn:2).data.tolist(),";
    "Fxn:test_is_signed" -> "Fxn:self.assertEqual(torch.IntTensor(5).is_signed(),";
    "Fxn:test_is_signed" -> "Fxn:self.assertEqual(torch.ByteTensor(5).is_signed(),";
    "Fxn:test_is_signed" -> "Fxn:self.assertEqual(torch.CharTensor(5).is_signed(),";
    "Fxn:test_is_signed" -> "Fxn:self.assertEqual(torch.FloatTensor(5).is_signed(),";
    "Fxn:test_is_signed" -> "Fxn:self.assertEqual(torch.HalfTensor(10).is_signed(),";
    "Fxn:test_is_signed" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_is_signed" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_is_signed_cuda" -> "Fxn:self.assertEqual(torch.cuda.IntTensor(5).is_signed(),";
    "Fxn:test_is_signed_cuda" -> "Fxn:self.assertEqual(torch.cuda.ByteTensor(5).is_signed(),";
    "Fxn:test_is_signed_cuda" -> "Fxn:self.assertEqual(torch.cuda.CharTensor(5).is_signed(),";
    "Fxn:test_is_signed_cuda" -> "Fxn:self.assertEqual(torch.cuda.FloatTensor(5).is_signed(),";
    "Fxn:test_is_signed_cuda" -> "Fxn:self.assertEqual(torch.cuda.HalfTensor(10).is_signed(),";
    "Fxn:test_gesv" -> "Fxn:torch.Tensor(((6.80,";
    "Fxn:test_gesv" -> "Fxn:-6.87))).t()";
    "Fxn:test_gesv" -> "Fxn:torch.Tensor(((4.02,";
    "Fxn:test_gesv" -> "Fxn:8.99))).t()";
    "Fxn:test_gesv" -> "Fxn:torch.gesv(b,";
    "Fxn:test_gesv" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(a,";
    "Fxn:test_gesv" -> "Fxn:torch.Tensor()";
    "Fxn:test_gesv" -> "Fxn:torch.Tensor()";
    "Fxn:test_gesv" -> "Fxn:torch.gesv(b,";
    "Fxn:test_gesv" -> "Fxn:out=(tb,";
    "Fxn:test_gesv" -> "Fxn:torch.gesv(b,";
    "Fxn:test_gesv" -> "Fxn:out=(b,";
    "Fxn:test_gesv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_gesv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_gesv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_gesv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_gesv" -> "Fxn:torch.gesv(b,";
    "Fxn:test_gesv" -> "Fxn:torch.Tensor()";
    "Fxn:test_gesv" -> "Fxn:torch.Tensor()";
    "Fxn:test_gesv" -> "Fxn:torch.gesv(b,";
    "Fxn:test_gesv" -> "Fxn:out=(tb,";
    "Fxn:test_gesv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_gesv" -> "Fxn:torch.gesv(b,";
    "Fxn:test_gesv" -> "Fxn:out=(tb,";
    "Fxn:test_gesv" -> "Fxn:self.assertEqual(res1,";
    "Fxn:canonicalize" -> "Fxn:r.diag().sign().diag()";
    "Fxn:canonicalize" -> "Fxn:torch.mm(q,";
    "Fxn:canonicalize" -> "Fxn:torch.mm(d,";
    "Fxn:canon_and_check" -> "Fxn:canonicalize(q,";
    "Fxn:canon_and_check" -> "Fxn:canonicalize(expected_q,";
    "Fxn:canon_and_check" -> "Fxn:self.assertEqual(q_canon,";
    "Fxn:canon_and_check" -> "Fxn:self.assertEqual(r_canon,";
    "Fxn:check_qr" -> "Fxn:torch.qr(a)";
    "Fxn:check_qr" -> "Fxn:canon_and_check(q,";
    "Fxn:check_qr" -> "Fxn:torch.Tensor(),";
    "Fxn:check_qr" -> "Fxn:torch.Tensor()";
    "Fxn:check_qr" -> "Fxn:torch.qr(a,";
    "Fxn:check_qr" -> "Fxn:out=(q,";
    "Fxn:check_qr" -> "Fxn:canon_and_check(q,";
    "Fxn:check_qr" -> "Fxn:a.size(0)";
    "Fxn:check_qr" -> "Fxn:a.size(1)";
    "Fxn:check_qr" -> "Fxn:torch.geqrf(a)";
    "Fxn:check_qr" -> "Fxn:self.assertEqual(result.size(0),";
    "Fxn:check_qr" -> "Fxn:self.assertEqual(result.size(1),";
    "Fxn:check_qr" -> "Fxn:self.assertEqual(tau.size(0),";
    "Fxn:check_qr" -> "Fxn:torch.triu(result.narrow(0,";
    "Fxn:check_qr" -> "Fxn:torch.orgqr(result,";
    "Fxn:check_qr" -> "Fxn:q.narrow(1,";
    "Fxn:check_qr" -> "Fxn:canon_and_check(q,";
    "Fxn:check_qr" -> "Fxn:torch.Tensor(((1,";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:check_qr(a,";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:check_qr(a,";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:torch.Tensor((";
    "Fxn:check_qr" -> "Fxn:check_qr(a,";
    "Fxn:check_qr" -> "Fxn:torch.randn(1000,";
    "Fxn:check_qr" -> "Fxn:torch.qr(a)";
    "Fxn:check_qr" -> "Fxn:torch.mm(q,";
    "Fxn:check_qr" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_ormqr" -> "Fxn:torch.randn(10,";
    "Fxn:test_ormqr" -> "Fxn:torch.randn(10,";
    "Fxn:test_ormqr" -> "Fxn:torch.qr(mat1)";
    "Fxn:test_ormqr" -> "Fxn:torch.geqrf(mat1)";
    "Fxn:test_ormqr" -> "Fxn:torch.mm(q,";
    "Fxn:test_ormqr" -> "Fxn:torch.ormqr(m,";
    "Fxn:test_ormqr" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ormqr" -> "Fxn:torch.mm(mat2,";
    "Fxn:test_ormqr" -> "Fxn:torch.ormqr(m,";
    "Fxn:test_ormqr" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ormqr" -> "Fxn:torch.mm(q.t(),";
    "Fxn:test_ormqr" -> "Fxn:torch.ormqr(m,";
    "Fxn:test_ormqr" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_ormqr" -> "Fxn:torch.mm(mat2,";
    "Fxn:test_ormqr" -> "Fxn:q.t())";
    "Fxn:test_ormqr" -> "Fxn:torch.ormqr(m,";
    "Fxn:test_ormqr" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_trtrs" -> "Fxn:torch.Tensor(((6.80,";
    "Fxn:test_trtrs" -> "Fxn:-6.87))).t()";
    "Fxn:test_trtrs" -> "Fxn:torch.Tensor(((4.02,";
    "Fxn:test_trtrs" -> "Fxn:8.99))).t()";
    "Fxn:test_trtrs" -> "Fxn:torch.triu(a)";
    "Fxn:test_trtrs" -> "Fxn:torch.tril(a)";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(U,";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(U,";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(L,";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(L,";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(U.t(),";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(U.t(),";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:U.t(),";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(x.dist(y),";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(L.t(),";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(L.t(),";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:L.t(),";
    "Fxn:test_trtrs" -> "Fxn:self.assertLessEqual(x.dist(y),";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:torch.Tensor()";
    "Fxn:test_trtrs" -> "Fxn:torch.Tensor()";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:out=(tb,";
    "Fxn:test_trtrs" -> "Fxn:self.assertEqual(res1,";
    "Fxn:test_trtrs" -> "Fxn:tb.zero_()";
    "Fxn:test_trtrs" -> "Fxn:torch.trtrs(b,";
    "Fxn:test_trtrs" -> "Fxn:out=(tb,";
    "Fxn:test_trtrs" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_underdetermined" -> "Fxn:a.size()[0]";
    "Fxn:_test_underdetermined" -> "Fxn:a.size()[1]";
    "Fxn:_test_underdetermined" -> "Fxn:assert(m";
    "Fxn:_test_underdetermined" -> "Fxn:a.clone()";
    "Fxn:_test_underdetermined" -> "Fxn:b.clone()";
    "Fxn:_test_underdetermined" -> "Fxn:torch.gels(b,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(a,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(b,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:_test_underdetermined" -> "Fxn:b).norm(),";
    "Fxn:_test_underdetermined" -> "Fxn:torch.Tensor()";
    "Fxn:_test_underdetermined" -> "Fxn:torch.Tensor()";
    "Fxn:_test_underdetermined" -> "Fxn:torch.gels(b,";
    "Fxn:_test_underdetermined" -> "Fxn:out=(tb,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(a,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(b,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:_test_underdetermined" -> "Fxn:b).norm(),";
    "Fxn:_test_underdetermined" -> "Fxn:torch.gels(b,";
    "Fxn:_test_underdetermined" -> "Fxn:out=(b,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual((torch.mm(a_copy,";
    "Fxn:_test_underdetermined" -> "Fxn:b_copy).norm(),";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_underdetermined" -> "Fxn:self.assertEqual(res1,";
    "Fxn:_test_overdetermined" -> "Fxn:a.size()[0]";
    "Fxn:_test_overdetermined" -> "Fxn:a.size()[1]";
    "Fxn:_test_overdetermined" -> "Fxn:assert(m";
    "Fxn:check_norm" -> "Fxn:a.size()[1]";
    "Fxn:check_norm" -> "Fxn:b).norm()";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(resid_norm,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(resid_info.norm(),";
    "Fxn:check_norm" -> "Fxn:a.clone()";
    "Fxn:check_norm" -> "Fxn:b.clone()";
    "Fxn:check_norm" -> "Fxn:torch.gels(b,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(a,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(b,";
    "Fxn:check_norm" -> "Fxn:check_norm(a,";
    "Fxn:check_norm" -> "Fxn:torch.Tensor()";
    "Fxn:check_norm" -> "Fxn:torch.Tensor()";
    "Fxn:check_norm" -> "Fxn:torch.gels(b,";
    "Fxn:check_norm" -> "Fxn:out=(tb,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(a,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(b,";
    "Fxn:check_norm" -> "Fxn:check_norm(a,";
    "Fxn:check_norm" -> "Fxn:torch.gels(b,";
    "Fxn:check_norm" -> "Fxn:out=(b,";
    "Fxn:check_norm" -> "Fxn:check_norm(a_copy,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(res1,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(res1,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(res1,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual(res1,";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((1.44,";
    "Fxn:check_norm" -> "Fxn:2.06))).t()";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((8.58,";
    "Fxn:check_norm" -> "Fxn:-0.26))).t()";
    "Fxn:check_norm" -> "Fxn:_test_underdetermined(a,";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((1.44,";
    "Fxn:check_norm" -> "Fxn:4.70))).t()";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((8.58,";
    "Fxn:check_norm" -> "Fxn:-2.52))).t()";
    "Fxn:check_norm" -> "Fxn:_test_overdetermined(a,";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((1.44,";
    "Fxn:check_norm" -> "Fxn:-6.64))).t()";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((8.58,";
    "Fxn:check_norm" -> "Fxn:-0.70))).t()";
    "Fxn:check_norm" -> "Fxn:_test_underdetermined(a,";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((1.44,";
    "Fxn:check_norm" -> "Fxn:2.06))).t()";
    "Fxn:check_norm" -> "Fxn:torch.Tensor(((8.58,";
    "Fxn:check_norm" -> "Fxn:-0.26))).t()";
    "Fxn:check_norm" -> "Fxn:torch.Tensor()";
    "Fxn:check_norm" -> "Fxn:torch.Tensor()";
    "Fxn:check_norm" -> "Fxn:torch.gels(b,";
    "Fxn:check_norm" -> "Fxn:out=(tb,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:check_norm" -> "Fxn:b).norm(),";
    "Fxn:check_norm" -> "Fxn:torch.gels(b,";
    "Fxn:check_norm" -> "Fxn:out=(tb,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:check_norm" -> "Fxn:b).norm(),";
    "Fxn:check_norm" -> "Fxn:torch.gels(b,";
    "Fxn:check_norm" -> "Fxn:out=(tb,";
    "Fxn:check_norm" -> "Fxn:self.assertEqual((torch.mm(a,";
    "Fxn:check_norm" -> "Fxn:b).norm(),";
    "Fxn:test_eig" -> "Fxn:torch.Tensor(((1.96,";
    "Fxn:test_eig" -> "Fxn:-7.10))).t().contiguous()";
    "Fxn:test_eig" -> "Fxn:torch.eig(a)[0]";
    "Fxn:test_eig" -> "Fxn:torch.eig(a,";
    "Fxn:test_eig" -> "Fxn:torch.Tensor()";
    "Fxn:test_eig" -> "Fxn:torch.Tensor()";
    "Fxn:test_eig" -> "Fxn:torch.eig(a,";
    "Fxn:test_eig" -> "Fxn:out=(te,";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(e,";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(ee,";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(ee,";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(vv,";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(vv,";
    "Fxn:test_eig" -> "Fxn:torch.randn(4,";
    "Fxn:test_eig" -> "Fxn:torch.mm(X.t(),";
    "Fxn:test_eig" -> "Fxn:torch.zeros(4,";
    "Fxn:test_eig" -> "Fxn:torch.zeros(4,";
    "Fxn:test_eig" -> "Fxn:torch.eig(X,";
    "Fxn:test_eig" -> "Fxn:out=(e,";
    "Fxn:test_eig" -> "Fxn:torch.mm(torch.mm(v,";
    "Fxn:test_eig" -> "Fxn:torch.diag(e.select(1,";
    "Fxn:test_eig" -> "Fxn:v.t())";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(X,";
    "Fxn:test_eig" -> "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:test_eig" -> "Fxn:torch.eig(X,";
    "Fxn:test_eig" -> "Fxn:out=(e,";
    "Fxn:test_eig" -> "Fxn:torch.mm(v,";
    "Fxn:test_eig" -> "Fxn:torch.mm(e.select(1,";
    "Fxn:test_eig" -> "Fxn:0).diag(),";
    "Fxn:test_eig" -> "Fxn:v.t()))";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(X,";
    "Fxn:test_eig" -> "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:test_eig" -> "Fxn:torch.randn(4,";
    "Fxn:test_eig" -> "Fxn:torch.mm(X.t(),";
    "Fxn:test_eig" -> "Fxn:torch.zeros(4,";
    "Fxn:test_eig" -> "Fxn:torch.zeros(4,";
    "Fxn:test_eig" -> "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:test_eig" -> "Fxn:self.assertFalse(e.is_contiguous(),";
    "Fxn:test_eig" -> "Fxn:torch.eig(X,";
    "Fxn:test_eig" -> "Fxn:out=(e,";
    "Fxn:test_eig" -> "Fxn:torch.mm(torch.mm(v,";
    "Fxn:test_eig" -> "Fxn:torch.diag(e.select(1,";
    "Fxn:test_eig" -> "Fxn:v.t())";
    "Fxn:test_eig" -> "Fxn:self.assertEqual(X,";
    "Fxn:test_symeig" -> "Fxn:torch.rand(100,";
    "Fxn:test_symeig" -> "Fxn:torch.mm(xval.t(),";
    "Fxn:test_symeig" -> "Fxn:torch.zeros(3)";
    "Fxn:test_symeig" -> "Fxn:torch.zeros(3,";
    "Fxn:test_symeig" -> "Fxn:self.assertTrue(resv.is_contiguous(),";
    "Fxn:test_symeig" -> "Fxn:torch.symeig(cov.clone(),";
    "Fxn:test_symeig" -> "Fxn:out=(rese,";
    "Fxn:test_symeig" -> "Fxn:torch.mm(torch.mm(resv,";
    "Fxn:test_symeig" -> "Fxn:torch.diag(rese)),";
    "Fxn:test_symeig" -> "Fxn:resv.t())";
    "Fxn:test_symeig" -> "Fxn:self.assertEqual(cov,";
    "Fxn:test_symeig" -> "Fxn:self.assertFalse(resv.is_contiguous(),";
    "Fxn:test_symeig" -> "Fxn:torch.symeig(cov.clone(),";
    "Fxn:test_symeig" -> "Fxn:out=(rese,";
    "Fxn:test_symeig" -> "Fxn:torch.mm(torch.mm(resv,";
    "Fxn:test_symeig" -> "Fxn:torch.diag(rese)),";
    "Fxn:test_symeig" -> "Fxn:resv.t())";
    "Fxn:test_symeig" -> "Fxn:self.assertEqual(cov,";
    "Fxn:test_symeig" -> "Fxn:torch.rand(5,";
    "Fxn:test_symeig" -> "Fxn:X.t()";
    "Fxn:test_symeig" -> "Fxn:torch.zeros(4,";
    "Fxn:test_symeig" -> "Fxn:2).select(1,";
    "Fxn:test_symeig" -> "Fxn:torch.zeros(4,";
    "Fxn:test_symeig" -> "Fxn:self.assertFalse(v.is_contiguous(),";
    "Fxn:test_symeig" -> "Fxn:self.assertFalse(e.is_contiguous(),";
    "Fxn:test_symeig" -> "Fxn:torch.symeig(X,";
    "Fxn:test_symeig" -> "Fxn:out=(e,";
    "Fxn:test_symeig" -> "Fxn:torch.mm(torch.mm(v,";
    "Fxn:test_symeig" -> "Fxn:torch.diag(e)),";
    "Fxn:test_symeig" -> "Fxn:v.t())";
    "Fxn:test_symeig" -> "Fxn:self.assertEqual(X,";
    "Fxn:test_svd" -> "Fxn:torch.Tensor(((8.79,";
    "Fxn:test_svd" -> "Fxn:-5.31))).t().clone()";
    "Fxn:test_svd" -> "Fxn:torch.svd(a)";
    "Fxn:test_svd" -> "Fxn:torch.Tensor()";
    "Fxn:test_svd" -> "Fxn:torch.Tensor()";
    "Fxn:test_svd" -> "Fxn:torch.Tensor()";
    "Fxn:test_svd" -> "Fxn:torch.svd(a,";
    "Fxn:test_svd" -> "Fxn:out=(uu,";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(u,";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(u,";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(s,";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(s,";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(v,";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(v,";
    "Fxn:test_svd" -> "Fxn:torch.randn(4,";
    "Fxn:test_svd" -> "Fxn:torch.svd(X)";
    "Fxn:test_svd" -> "Fxn:torch.mm(U,";
    "Fxn:test_svd" -> "Fxn:torch.mm(S.diag(),";
    "Fxn:test_svd" -> "Fxn:V.t()))";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(X,";
    "Fxn:test_svd" -> "Fxn:self.assertFalse(U.is_contiguous(),";
    "Fxn:test_svd" -> "Fxn:torch.svd(X,";
    "Fxn:test_svd" -> "Fxn:out=(U,";
    "Fxn:test_svd" -> "Fxn:torch.mm(U,";
    "Fxn:test_svd" -> "Fxn:torch.mm(S.diag(),";
    "Fxn:test_svd" -> "Fxn:V.t()))";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(X,";
    "Fxn:test_svd" -> "Fxn:torch.randn(5,";
    "Fxn:test_svd" -> "Fxn:torch.zeros(5,";
    "Fxn:test_svd" -> "Fxn:torch.zeros(5,";
    "Fxn:test_svd" -> "Fxn:torch.zeros(5,";
    "Fxn:test_svd" -> "Fxn:self.assertFalse(U.is_contiguous(),";
    "Fxn:test_svd" -> "Fxn:self.assertFalse(S.is_contiguous(),";
    "Fxn:test_svd" -> "Fxn:self.assertFalse(V.is_contiguous(),";
    "Fxn:test_svd" -> "Fxn:torch.svd(X,";
    "Fxn:test_svd" -> "Fxn:out=(U,";
    "Fxn:test_svd" -> "Fxn:torch.mm(U,";
    "Fxn:test_svd" -> "Fxn:torch.mm(S.diag(),";
    "Fxn:test_svd" -> "Fxn:V.t()))";
    "Fxn:test_svd" -> "Fxn:self.assertEqual(X,";
    "Fxn:_test_window_function" -> "Fxn:torch.from_numpy(signal.get_window(scipy_name,";
    "Fxn:_test_window_function" -> "Fxn:self.assertEqual(torch_method(size,";
    "Fxn:_test_window_function" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_hann_window" -> "Fxn:self._test_window_function(self,";
    "Fxn:test_hann_window" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_hamming_window" -> "Fxn:self._test_window_function(self,";
    "Fxn:test_hamming_window" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_bartlett_window" -> "Fxn:self._test_window_function(self,";
    "Fxn:test_inverse" -> "Fxn:torch.randn(5,";
    "Fxn:test_inverse" -> "Fxn:torch.inverse(M)";
    "Fxn:test_inverse" -> "Fxn:torch.eye(5)";
    "Fxn:test_inverse" -> "Fxn:self.assertFalse(MI.is_contiguous(),";
    "Fxn:test_inverse" -> "Fxn:self.assertEqual(E,";
    "Fxn:test_inverse" -> "Fxn:torch.mm(M,";
    "Fxn:test_inverse" -> "Fxn:self.assertEqual(E,";
    "Fxn:test_inverse" -> "Fxn:torch.mm(MI,";
    "Fxn:test_inverse" -> "Fxn:torch.Tensor(5,";
    "Fxn:test_inverse" -> "Fxn:torch.inverse(M,";
    "Fxn:test_inverse" -> "Fxn:self.assertFalse(MII.is_contiguous(),";
    "Fxn:test_inverse" -> "Fxn:self.assertEqual(MII,";
    "Fxn:test_inverse" -> "Fxn:torch.inverse(M,";
    "Fxn:test_inverse" -> "Fxn:self.assertFalse(MII.is_contiguous(),";
    "Fxn:test_inverse" -> "Fxn:self.assertEqual(MII,";
    "Fxn:reference_det" -> "Fxn:M.clone()";
    "Fxn:reference_det" -> "Fxn:M.size(0)";
    "Fxn:reference_det" -> "Fxn:M.diag().prod()";
    "Fxn:test_single_det" -> "Fxn:M.det()";
    "Fxn:test_single_det" -> "Fxn:M.logdet()";
    "Fxn:test_single_det" -> "Fxn:M.slogdet()";
    "Fxn:test_single_det" -> "Fxn:self.assertEqual(det,";
    "Fxn:test_single_det" -> "Fxn:det.item()";
    "Fxn:test_single_det" -> "Fxn:self.assertTrue(logdet.item()";
    "Fxn:test_single_det" -> "Fxn:logdet.item(),";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:self.assertTrue(sdet.item()";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:self.assertEqual(logabsdet.exp(),";
    "Fxn:test_single_det" -> "Fxn:det.abs(),";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:det.item()";
    "Fxn:test_single_det" -> "Fxn:self.assertEqual(logdet.exp().item(),";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:self.assertTrue(sdet.item()";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:self.assertEqual(logabsdet.exp().item(),";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:self.assertEqual(logdet.exp(),";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:self.assertTrue(sdet.item()";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:self.assertEqual(logabsdet.exp(),";
    "Fxn:test_single_det" -> "Fxn:case)'.format(desc))";
    "Fxn:test_single_det" -> "Fxn:conv_fn(torch.eye(5))";
    "Fxn:test_single_det" -> "Fxn:test_single_det(eye,";
    "Fxn:test_single_det" -> "Fxn:torch.tensor(1,";
    "Fxn:test" -> "Fxn:M.size(0)";
    "Fxn:test" -> "Fxn:conv_fn(M)";
    "Fxn:test" -> "Fxn:M.det()";
    "Fxn:test" -> "Fxn:reference_det(M)";
    "Fxn:test" -> "Fxn:test_single_det(M,";
    "Fxn:test" -> "Fxn:test_single_det(M,";
    "Fxn:test" -> "Fxn:M.inverse().det().pow_(-1),";
    "Fxn:test" -> "Fxn:test_single_det(M,";
    "Fxn:test" -> "Fxn:M.t().det(),";
    "Fxn:test" -> "Fxn:M.clone()";
    "Fxn:test" -> "Fxn:test_single_det(M_clone,";
    "Fxn:test" -> "Fxn:M.clone()";
    "Fxn:test" -> "Fxn:test_single_det(M_clone,";
    "Fxn:test" -> "Fxn:[(0,";
    "Fxn:test" -> "Fxn:M_det.clone().zero_()";
    "Fxn:test" -> "Fxn:M.clone()";
    "Fxn:test" -> "Fxn:test_single_det(M_clone,";
    "Fxn:test" -> "Fxn:M.clone()";
    "Fxn:test" -> "Fxn:test_single_det(M_clone,";
    "Fxn:test" -> "Fxn:[(0.3,";
    "Fxn:test" -> "Fxn:M.clone()";
    "Fxn:test" -> "Fxn:test_single_det(M_clone,";
    "Fxn:test" -> "Fxn:M.clone()";
    "Fxn:test" -> "Fxn:test_single_det(M_clone,";
    "Fxn:get_random_mat_scale" -> "Fxn:det(A^2)]";
    "Fxn:get_random_mat_scale" -> "Fxn:log((n-1)!)";
    "Fxn:get_random_mat_scale" -> "Fxn:Var[det(A)]";
    "Fxn:get_random_mat_scale" -> "Fxn:E[det(A^2)]";
    "Fxn:get_random_mat_scale" -> "Fxn:det(A^2)]";
    "Fxn:get_random_mat_scale" -> "Fxn:stddev[det(A)]";
    "Fxn:get_random_mat_scale" -> "Fxn:)^(-1/n)";
    "Fxn:get_random_mat_scale" -> "Fxn:)^(-1/(2n))";
    "Fxn:get_random_mat_scale" -> "Fxn:math.factorial(n";
    "Fxn:get_random_mat_scale" -> "Fxn:get_random_mat_scale(n)";
    "Fxn:get_random_mat_scale" -> "Fxn:test(torch.randn(n,";
    "Fxn:get_random_mat_scale" -> "Fxn:torch.randn(n,";
    "Fxn:get_random_mat_scale" -> "Fxn:test(r.mm(r.t()))";
    "Fxn:get_random_mat_scale" -> "Fxn:torch.randn(n,";
    "Fxn:get_random_mat_scale" -> "Fxn:test(r.mm(r.t())";
    "Fxn:get_random_mat_scale" -> "Fxn:torch.eye(n)";
    "Fxn:get_random_mat_scale" -> "Fxn:torch.randn(n,";
    "Fxn:get_random_mat_scale" -> "Fxn:test(r)";
    "Fxn:get_random_mat_scale" -> "Fxn:test((torch.randn(n,";
    "Fxn:get_random_mat_scale" -> "Fxn:torch.randn(n,";
    "Fxn:get_random_mat_scale" -> "Fxn:r.svd()";
    "Fxn:get_random_mat_scale" -> "Fxn:reference_det(u)";
    "Fxn:get_random_mat_scale" -> "Fxn:reference_det(v)";
    "Fxn:get_random_mat_scale" -> "Fxn:test(u.mm(s.diag()).mm(v))";
    "Fxn:test_det_logdet_slogdet" -> "Fxn:self._test_det_logdet_slogdet(self,";
    "Fxn:naive_stft" -> "Fxn:x.clone()";
    "Fxn:naive_stft" -> "Fxn:x.new(frame_length).fill_(1)";
    "Fxn:naive_stft" -> "Fxn:window.clone()";
    "Fxn:naive_stft" -> "Fxn:x.dim()";
    "Fxn:naive_stft" -> "Fxn:x.view(1,";
    "Fxn:naive_stft" -> "Fxn:x.size(0)";
    "Fxn:naive_stft" -> "Fxn:x.new(batch,";
    "Fxn:naive_stft" -> "Fxn:pad_end).fill_(0)";
    "Fxn:naive_stft" -> "Fxn:torch.cat([x,";
    "Fxn:naive_stft" -> "Fxn:x.size(1)";
    "Fxn:naive_stft" -> "Fxn:signal.stft(";
    "Fxn:naive_stft" -> "Fxn:)[2].transpose((0,";
    "Fxn:naive_stft" -> "Fxn:np.abs(window.sum().item())";
    "Fxn:naive_stft" -> "Fxn:torch.Tensor(np.stack([sp_result.real,";
    "Fxn:naive_stft" -> "Fxn:x.new(batch,";
    "Fxn:naive_stft" -> "Fxn:conv_fn(torch.arange(frame_length))";
    "Fxn:naive_stft" -> "Fxn:radians.cos().mul_(window)";
    "Fxn:naive_stft" -> "Fxn:-radians.sin().mul_(window)";
    "Fxn:naive_stft" -> "Fxn:t:(t";
    "Fxn:naive_stft" -> "Fxn:seg.dot(re_kernel)";
    "Fxn:naive_stft" -> "Fxn:seg.dot(im_kernel)";
    "Fxn:naive_stft" -> "Fxn:conv_fn(result)";
    "Fxn:_test" -> "Fxn:Variable(conv_fn(torch.randn(*sizes)))";
    "Fxn:_test" -> "Fxn:Variable(conv_fn(window.clone()))";
    "Fxn:_test" -> "Fxn:x.stft(frame_length,";
    "Fxn:_test" -> "Fxn:naive_stft(x,";
    "Fxn:_test" -> "Fxn:self.assertEqual(result.data,";
    "Fxn:_test" -> "Fxn:self.assertRaises(expected_error,";
    "Fxn:_test" -> "Fxn:x.stft(frame_length,";
    "Fxn:_test" -> "Fxn:_test((2,";
    "Fxn:_test" -> "Fxn:_test((4,";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:_test((10,";
    "Fxn:_test" -> "Fxn:_test((2,";
    "Fxn:_test" -> "Fxn:window=torch.randn(4),";
    "Fxn:_test" -> "Fxn:_test((4,";
    "Fxn:_test" -> "Fxn:window=torch.randn(90),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:window=torch.randn(7),";
    "Fxn:_test" -> "Fxn:_test((10,";
    "Fxn:_test" -> "Fxn:window=torch.randn(1024),";
    "Fxn:_test" -> "Fxn:_test((2,";
    "Fxn:_test" -> "Fxn:window=torch.randn(4),";
    "Fxn:_test" -> "Fxn:_test((4,";
    "Fxn:_test" -> "Fxn:window=torch.randn(90),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:window=torch.randn(7),";
    "Fxn:_test" -> "Fxn:_test((10,";
    "Fxn:_test" -> "Fxn:window=torch.randn(1024),";
    "Fxn:_test" -> "Fxn:_test((2,";
    "Fxn:_test" -> "Fxn:window=torch.randn(4),";
    "Fxn:_test" -> "Fxn:_test((4,";
    "Fxn:_test" -> "Fxn:window=torch.randn(90),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:window=torch.randn(7),";
    "Fxn:_test" -> "Fxn:_test((10,";
    "Fxn:_test" -> "Fxn:window=torch.randn(1024),";
    "Fxn:_test" -> "Fxn:_test((10,";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:window=torch.randn(11),";
    "Fxn:_test" -> "Fxn:_test((10,),";
    "Fxn:_test" -> "Fxn:window=torch.randn(1,";
    "Fxn:test_stft" -> "Fxn:self._test_stft(self,";
    "Fxn:test_stft" -> "Fxn:@unittest.skip("Not";
    "Fxn:test_conv2" -> "Fxn:torch.rand(math.floor(torch.uniform(50,";
    "Fxn:test_conv2" -> "Fxn:math.floor(torch.uniform(50,";
    "Fxn:test_conv2" -> "Fxn:torch.rand(math.floor(torch.uniform(10,";
    "Fxn:test_conv2" -> "Fxn:math.floor(torch.uniform(10,";
    "Fxn:test_conv2" -> "Fxn:torch.conv2(x,";
    "Fxn:test_conv2" -> "Fxn:torch.conv2(x,";
    "Fxn:test_conv2" -> "Fxn:torch.conv2(x,";
    "Fxn:test_conv2" -> "Fxn:k.clone()";
    "Fxn:test_conv2" -> "Fxn:k.storage()";
    "Fxn:test_conv2" -> "Fxn:ki.storage()";
    "Fxn:test_conv2" -> "Fxn:kis[ks.size()";
    "Fxn:test_conv2" -> "Fxn:i=ks.size(),";
    "Fxn:test_conv2" -> "Fxn:kis[ks.size()-i+1]=ks[i]";
    "Fxn:test_conv2" -> "Fxn:torch.xcorr2(x,";
    "Fxn:test_conv2" -> "Fxn:torch.xcorr2(x,";
    "Fxn:test_conv2" -> "Fxn:torch.xcorr2(x,";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(imvc,";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(imvc,";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(imvc,";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(imfc,";
    "Fxn:test_conv2" -> "Fxn:self.assertLessEqual(math.abs(x.dot(x)";
    "Fxn:test_conv2" -> "Fxn:torch.xcorr2(x,";
    "Fxn:test_conv2" -> "Fxn:torch.Tensor(2,";
    "Fxn:test_conv2" -> "Fxn:x.size(1),";
    "Fxn:test_conv2" -> "Fxn:x.size(2))";
    "Fxn:test_conv2" -> "Fxn:xx[1].copy_(x)";
    "Fxn:test_conv2" -> "Fxn:xx[2].copy_(x)";
    "Fxn:test_conv2" -> "Fxn:torch.Tensor(2,";
    "Fxn:test_conv2" -> "Fxn:k.size(1),";
    "Fxn:test_conv2" -> "Fxn:k.size(2))";
    "Fxn:test_conv2" -> "Fxn:kk[1].copy_(k)";
    "Fxn:test_conv2" -> "Fxn:kk[2].copy_(k)";
    "Fxn:test_conv2" -> "Fxn:torch.conv2(xx,";
    "Fxn:test_conv2" -> "Fxn:torch.conv2(xx,";
    "Fxn:test_conv2" -> "Fxn:torch.conv2(xx,";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(immvc[0],";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(immvc[0],";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(immvc2[0],";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(immfc[0],";
    "Fxn:test_conv2" -> "Fxn:self.assertEqual(immfc[0],";
    "Fxn:test_conv2" -> "Fxn:@unittest.skip("Not";
    "Fxn:test_conv3" -> "Fxn:torch.rand(math.floor(torch.uniform(20,";
    "Fxn:test_conv3" -> "Fxn:math.floor(torch.uniform(20,";
    "Fxn:test_conv3" -> "Fxn:math.floor(torch.uniform(20,";
    "Fxn:test_conv3" -> "Fxn:torch.rand(math.floor(torch.uniform(5,";
    "Fxn:test_conv3" -> "Fxn:math.floor(torch.uniform(5,";
    "Fxn:test_conv3" -> "Fxn:math.floor(torch.uniform(5,";
    "Fxn:test_conv3" -> "Fxn:torch.conv3(x,";
    "Fxn:test_conv3" -> "Fxn:torch.conv3(x,";
    "Fxn:test_conv3" -> "Fxn:torch.conv3(x,";
    "Fxn:test_conv3" -> "Fxn:k.clone()";
    "Fxn:test_conv3" -> "Fxn:k.storage()";
    "Fxn:test_conv3" -> "Fxn:ki.storage()";
    "Fxn:test_conv3" -> "Fxn:kis[ks.size()";
    "Fxn:test_conv3" -> "Fxn:torch.xcorr3(x,";
    "Fxn:test_conv3" -> "Fxn:torch.xcorr3(x,";
    "Fxn:test_conv3" -> "Fxn:torch.xcorr3(x,";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(imvc,";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(imvc,";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(imvc,";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(imfc,";
    "Fxn:test_conv3" -> "Fxn:self.assertLessEqual(math.abs(x.dot(x)";
    "Fxn:test_conv3" -> "Fxn:torch.xcorr3(x,";
    "Fxn:test_conv3" -> "Fxn:torch.Tensor(2,";
    "Fxn:test_conv3" -> "Fxn:x.size(1),";
    "Fxn:test_conv3" -> "Fxn:x.size(2),";
    "Fxn:test_conv3" -> "Fxn:x.size(3))";
    "Fxn:test_conv3" -> "Fxn:xx[1].copy_(x)";
    "Fxn:test_conv3" -> "Fxn:xx[2].copy_(x)";
    "Fxn:test_conv3" -> "Fxn:torch.Tensor(2,";
    "Fxn:test_conv3" -> "Fxn:k.size(1),";
    "Fxn:test_conv3" -> "Fxn:k.size(2),";
    "Fxn:test_conv3" -> "Fxn:k.size(3))";
    "Fxn:test_conv3" -> "Fxn:kk[1].copy_(k)";
    "Fxn:test_conv3" -> "Fxn:kk[2].copy_(k)";
    "Fxn:test_conv3" -> "Fxn:torch.conv3(xx,";
    "Fxn:test_conv3" -> "Fxn:torch.conv3(xx,";
    "Fxn:test_conv3" -> "Fxn:torch.conv3(xx,";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(immvc[0],";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(immvc[0],";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(immvc2[0],";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(immfc[0],";
    "Fxn:test_conv3" -> "Fxn:self.assertEqual(immfc[0],";
    "Fxn:test_conv3" -> "Fxn:@unittest.skip("Not";
    "Fxn:_test_conv_corr_eq" -> "Fxn:math.floor(random.randint(20,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:math.floor(random.randint(20,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:math.floor(random.randint(20,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:math.floor(random.randint(5,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:math.floor(random.randint(5,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:math.floor(random.randint(5,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:torch.rand(ix,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:torch.rand(kx,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:fn(x,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:torch.zeros(o3.size())";
    "Fxn:_test_conv_corr_eq" -> "Fxn:fn_2_to_3(x,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:self.assertEqual(o3,";
    "Fxn:_test_conv_corr_eq" -> "Fxn:@unittest.skip("Not";
    "Fxn:reference" -> "Fxn:o32[i].add(torch.xcorr2(x[i";
    "Fxn:reference" -> "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:reference" -> "Fxn:torch.xcorr3(x,";
    "Fxn:reference" -> "Fxn:@unittest.skip("Not";
    "Fxn:reference" -> "Fxn:o32[i].add(torch.xcorr2(x[i],";
    "Fxn:reference" -> "Fxn:k[k.size(1)";
    "Fxn:reference" -> "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:reference" -> "Fxn:torch.xcorr3(x,";
    "Fxn:reference" -> "Fxn:@unittest.skip("Not";
    "Fxn:reference" -> "Fxn:o32[i].add(torch.conv2(x[i";
    "Fxn:reference" -> "Fxn:k[k.size(1)";
    "Fxn:reference" -> "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:reference" -> "Fxn:torch.conv3(x,";
    "Fxn:reference" -> "Fxn:@unittest.skip("Not";
    "Fxn:reference" -> "Fxn:1].add(torch.conv2(x[i],";
    "Fxn:reference" -> "Fxn:self._test_conv_corr_eq(lambda";
    "Fxn:reference" -> "Fxn:torch.conv3(x,";
    "Fxn:test_logical" -> "Fxn:torch.rand(100,";
    "Fxn:test_logical" -> "Fxn:torch.gt(x,";
    "Fxn:test_logical" -> "Fxn:torch.lt(x,";
    "Fxn:test_logical" -> "Fxn:torch.eq(x,";
    "Fxn:test_logical" -> "Fxn:torch.ne(x,";
    "Fxn:test_logical" -> "Fxn:self.assertEqual(neqs.long().sum(),";
    "Fxn:test_logical" -> "Fxn:xne.long().sum(),";
    "Fxn:test_logical" -> "Fxn:self.assertEqual(x.nelement(),";
    "Fxn:test_logical" -> "Fxn:all.long().sum())";
    "Fxn:test_isnan" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_isnan" -> "Fxn:self.assertEqual(torch.isnan(x),";
    "Fxn:test_isnan" -> "Fxn:torch.ByteTensor([0,";
    "Fxn:test_RNGState" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_RNGState" -> "Fxn:state.clone()";
    "Fxn:test_RNGState" -> "Fxn:torch.rand(1000)";
    "Fxn:test_RNGState" -> "Fxn:self.assertEqual(state.ne(stateCloned).long().sum(),";
    "Fxn:test_RNGState" -> "Fxn:torch.set_rng_state(state)";
    "Fxn:test_RNGState" -> "Fxn:torch.rand(1000)";
    "Fxn:test_RNGState" -> "Fxn:self.assertEqual(before,";
    "Fxn:test_RNGStateAliasing" -> "Fxn:torch.Generator()";
    "Fxn:test_RNGStateAliasing" -> "Fxn:gen.set_state(torch.get_rng_state())";
    "Fxn:test_RNGStateAliasing" -> "Fxn:self.assertEqual(gen.get_state(),";
    "Fxn:test_RNGStateAliasing" -> "Fxn:torch.get_rng_state())";
    "Fxn:test_RNGStateAliasing" -> "Fxn:torch.rand(1000)";
    "Fxn:test_RNGStateAliasing" -> "Fxn:torch.rand(100000)";
    "Fxn:test_RNGStateAliasing" -> "Fxn:torch.rand(1000,";
    "Fxn:test_RNGStateAliasing" -> "Fxn:self.assertEqual(target_value,";
    "Fxn:test_boxMullerState" -> "Fxn:torch.manual_seed(123)";
    "Fxn:test_boxMullerState" -> "Fxn:torch.randn(odd_number)";
    "Fxn:test_boxMullerState" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_boxMullerState" -> "Fxn:torch.randn(odd_number)";
    "Fxn:test_boxMullerState" -> "Fxn:torch.set_rng_state(state)";
    "Fxn:test_boxMullerState" -> "Fxn:torch.randn(odd_number)";
    "Fxn:test_boxMullerState" -> "Fxn:torch.manual_seed(123)";
    "Fxn:test_boxMullerState" -> "Fxn:torch.randn(odd_number)";
    "Fxn:test_boxMullerState" -> "Fxn:self.assertEqual(midstream,";
    "Fxn:test_boxMullerState" -> "Fxn:self.assertEqual(seeded,";
    "Fxn:test_manual_seed" -> "Fxn:torch.get_rng_state()";
    "Fxn:test_manual_seed" -> "Fxn:torch.manual_seed(2)";
    "Fxn:test_manual_seed" -> "Fxn:torch.randn(100)";
    "Fxn:test_manual_seed" -> "Fxn:self.assertEqual(torch.initial_seed(),";
    "Fxn:test_manual_seed" -> "Fxn:torch.manual_seed(2)";
    "Fxn:test_manual_seed" -> "Fxn:torch.randn(100)";
    "Fxn:test_manual_seed" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_manual_seed" -> "Fxn:torch.set_rng_state(rng_state)";
    "Fxn:test_cholesky" -> "Fxn:torch.rand(10,";
    "Fxn:test_cholesky" -> "Fxn:torch.mm(x,";
    "Fxn:test_cholesky" -> "Fxn:x.t())";
    "Fxn:test_cholesky" -> "Fxn:torch.potrf(A)";
    "Fxn:test_cholesky" -> "Fxn:torch.mm(C.t(),";
    "Fxn:test_cholesky" -> "Fxn:self.assertEqual(A,";
    "Fxn:test_cholesky" -> "Fxn:torch.potrf(A,";
    "Fxn:test_cholesky" -> "Fxn:torch.mm(U.t(),";
    "Fxn:test_cholesky" -> "Fxn:self.assertEqual(A,";
    "Fxn:test_cholesky" -> "Fxn:torch.potrf(A,";
    "Fxn:test_cholesky" -> "Fxn:torch.mm(L,";
    "Fxn:test_cholesky" -> "Fxn:L.t())";
    "Fxn:test_cholesky" -> "Fxn:self.assertEqual(A,";
    "Fxn:test_potrs" -> "Fxn:torch.Tensor(((6.80,";
    "Fxn:test_potrs" -> "Fxn:-6.87))).t()";
    "Fxn:test_potrs" -> "Fxn:torch.Tensor(((4.02,";
    "Fxn:test_potrs" -> "Fxn:8.99))).t()";
    "Fxn:test_potrs" -> "Fxn:torch.mm(a,";
    "Fxn:test_potrs" -> "Fxn:a.t())";
    "Fxn:test_potrs" -> "Fxn:torch.potrf(a)";
    "Fxn:test_potrs" -> "Fxn:torch.potrs(b,";
    "Fxn:test_potrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(a,";
    "Fxn:test_potrs" -> "Fxn:torch.potrf(a,";
    "Fxn:test_potrs" -> "Fxn:torch.potrs(b,";
    "Fxn:test_potrs" -> "Fxn:self.assertLessEqual(b.dist(torch.mm(a,";
    "Fxn:tset_potri" -> "Fxn:torch.Tensor(((6.80,";
    "Fxn:tset_potri" -> "Fxn:-6.87))).t()";
    "Fxn:tset_potri" -> "Fxn:a.t()";
    "Fxn:tset_potri" -> "Fxn:torch.inverse(a)";
    "Fxn:tset_potri" -> "Fxn:torch.potrf(a)";
    "Fxn:tset_potri" -> "Fxn:torch.potri(chol)";
    "Fxn:tset_potri" -> "Fxn:self.assertLessEqual(inv0.dist(inv1),";
    "Fxn:tset_potri" -> "Fxn:torch.potrf(a,";
    "Fxn:tset_potri" -> "Fxn:torch.potri(chol,";
    "Fxn:tset_potri" -> "Fxn:self.assertLessEqual(inv0.dist(inv1),";
    "Fxn:tset_potri" -> "Fxn:torch.potrf(a,";
    "Fxn:tset_potri" -> "Fxn:torch.potri(chol,";
    "Fxn:tset_potri" -> "Fxn:self.assertLessEqual(inv0.dist(inv1),";
    "Fxn:checkPsdCholesky" -> "Fxn:torch.empty_like(a)";
    "Fxn:checkPsdCholesky" -> "Fxn:a.new(a.size(0)).int()";
    "Fxn:checkPsdCholesky" -> "Fxn:torch.pstrf(*args,";
    "Fxn:checkPsdCholesky" -> "Fxn:torch.mm(u,";
    "Fxn:checkPsdCholesky" -> "Fxn:u.t())";
    "Fxn:checkPsdCholesky" -> "Fxn:torch.mm(u.t(),";
    "Fxn:checkPsdCholesky" -> "Fxn:piv.long()";
    "Fxn:checkPsdCholesky" -> "Fxn:a.index_select(0,";
    "Fxn:checkPsdCholesky" -> "Fxn:piv).index_select(1,";
    "Fxn:checkPsdCholesky" -> "Fxn:self.assertEqual(a_permuted,";
    "Fxn:checkPsdCholesky" -> "Fxn:torch.Tensor(*dim).uniform_()";
    "Fxn:checkPsdCholesky" -> "Fxn:torch.mm(m,";
    "Fxn:checkPsdCholesky" -> "Fxn:m.t())";
    "Fxn:checkPsdCholesky" -> "Fxn:checkPsdCholesky(a,";
    "Fxn:test_numel" -> "Fxn:torch.ByteTensor(3,";
    "Fxn:test_numel" -> "Fxn:self.assertEqual(b.nelement(),";
    "Fxn:test_numel" -> "Fxn:self.assertEqual(b.numel(),";
    "Fxn:_consecutive" -> "Fxn:torch.ones(int(torch.Tensor(size).prod(0))).cumsum(0)";
    "Fxn:_consecutive" -> "Fxn:sequence.add_(start";
    "Fxn:_consecutive" -> "Fxn:sequence.resize_(*size)";
    "Fxn:consec" -> "Fxn:torch.ones(int(torch.Tensor(size).prod(0))).cumsum(0)";
    "Fxn:consec" -> "Fxn:sequence.add_(start";
    "Fxn:consec" -> "Fxn:sequence.view(*size)";
    "Fxn:consec" -> "Fxn:conv_fn(consec((3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[conv_fn(torch.LongTensor())],";
    "Fxn:consec" -> "Fxn:reference.new())";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[0],";
    "Fxn:consec" -> "Fxn:consec((3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[1],";
    "Fxn:consec" -> "Fxn:consec((3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2],";
    "Fxn:consec" -> "Fxn:consec((3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[0,";
    "Fxn:consec" -> "Fxn:consec((3,),";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[0:2],";
    "Fxn:consec" -> "Fxn:consec((2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[:],";
    "Fxn:consec" -> "Fxn:consec((3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[...,";
    "Fxn:consec" -> "Fxn:torch.Tensor([[3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[0,";
    "Fxn:consec" -> "Fxn:torch.Tensor([3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[...,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[0,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[0,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[...,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[...],";
    "Fxn:consec" -> "Fxn:conv_fn(consec((3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference_5d[...,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference_5d[2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference_5d[2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference_5d[...],";
    "Fxn:consec" -> "Fxn:conv_fn(consec((5,";
    "Fxn:consec" -> "Fxn:conv_fn(torch.LongTensor([2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[idx],";
    "Fxn:consec" -> "Fxn:torch.stack([reference[2],";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2,";
    "Fxn:consec" -> "Fxn:torch.stack([reference[2,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[3,";
    "Fxn:consec" -> "Fxn:torch.stack([reference[3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2,";
    "Fxn:consec" -> "Fxn:reference[2].unsqueeze(0))";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2,";
    "Fxn:consec" -> "Fxn:reference[2].unsqueeze(0).unsqueeze(0))";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2:4,";
    "Fxn:consec" -> "Fxn:reference[2:4].unsqueeze(1))";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[None,";
    "Fxn:consec" -> "Fxn:reference.unsqueeze(0)[:,";
    "Fxn:consec" -> "Fxn:2].unsqueeze(0).unsqueeze(0))";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[None,";
    "Fxn:consec" -> "Fxn:reference.unsqueeze(0)[:,";
    "Fxn:consec" -> "Fxn:2:5].unsqueeze(2).unsqueeze(2))";
    "Fxn:consec" -> "Fxn:consec((10,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[1:5:2],";
    "Fxn:consec" -> "Fxn:torch.stack([reference[1],";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[1:6:2],";
    "Fxn:consec" -> "Fxn:torch.stack([reference[1],";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[1:9:4],";
    "Fxn:consec" -> "Fxn:torch.stack([reference[1],";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[2:4,";
    "Fxn:consec" -> "Fxn:torch.stack([reference[2:4,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[3,";
    "Fxn:consec" -> "Fxn:torch.stack([reference[3,";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[None,";
    "Fxn:consec" -> "Fxn:torch.stack([reference[2,";
    "Fxn:consec" -> "Fxn:0).unsqueeze(0))";
    "Fxn:consec" -> "Fxn:self.assertEqual(reference[:,";
    "Fxn:consec" -> "Fxn:torch.stack([reference[:,";
    "Fxn:consec" -> "Fxn:[list(range(i,";
    "Fxn:consec" -> "Fxn:conv_fn(torch.DoubleTensor(lst))";
    "Fxn:consec" -> "Fxn:random.randrange(10)";
    "Fxn:consec" -> "Fxn:random.randrange(1,";
    "Fxn:consec" -> "Fxn:random.randrange(1,";
    "Fxn:consec" -> "Fxn:random.randrange(2)";
    "Fxn:consec" -> "Fxn:random.randrange(10)";
    "Fxn:consec" -> "Fxn:random.randrange(1,";
    "Fxn:consec" -> "Fxn:random.randrange(1,";
    "Fxn:consec" -> "Fxn:self.assertEqual(torch.DoubleTensor(lst_indexed),";
    "Fxn:consec" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:consec" -> "Fxn:self.assertRaises(IndexError,";
    "Fxn:test_index" -> "Fxn:self._test_index(self,";
    "Fxn:consec" -> "Fxn:reduce(lambda";
    "Fxn:consec" -> "Fxn:torch.ones(numel).cumsum(0)";
    "Fxn:consec" -> "Fxn:sequence.add_(start";
    "Fxn:consec" -> "Fxn:sequence.view(*size)";
    "Fxn:ri" -> "Fxn:random.randint(0,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.LongTensor(indices))";
    "Fxn:ri" -> "Fxn:conv_fn(consec((10,)))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[0]],";
    "Fxn:ri" -> "Fxn:consec((1,)))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri" -> "Fxn:consec((1,)))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([3]),";
    "Fxn:ri" -> "Fxn:consec((1,),";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[2,";
    "Fxn:ri" -> "Fxn:consec((3,),";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([2,";
    "Fxn:ri" -> "Fxn:consec((3,),";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[0]],";
    "Fxn:ri" -> "Fxn:torch.Tensor([-2]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri" -> "Fxn:torch.Tensor([-1]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[2,";
    "Fxn:ri" -> "Fxn:torch.Tensor([4,";
    "Fxn:ri" -> "Fxn:reference[ri([2,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([2,";
    "Fxn:ri" -> "Fxn:torch.Tensor([3,";
    "Fxn:ri" -> "Fxn:reference[ri([0,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([5,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([5,";
    "Fxn:ri" -> "Fxn:conv_fn(consec((10,)))";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor())";
    "Fxn:ri" -> "Fxn:strided.set_(reference.storage(),";
    "Fxn:ri" -> "Fxn:size=torch.Size([4]),";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[[0]],";
    "Fxn:ri" -> "Fxn:torch.Tensor([1]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri" -> "Fxn:torch.Tensor([1]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([3]),";
    "Fxn:ri" -> "Fxn:torch.Tensor([7]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[[1,";
    "Fxn:ri" -> "Fxn:torch.Tensor([3,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([1,";
    "Fxn:ri" -> "Fxn:torch.Tensor([3,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([[2,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[5,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor())";
    "Fxn:ri" -> "Fxn:strided.set_(reference.storage(),";
    "Fxn:ri" -> "Fxn:size=torch.Size([2]),";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[[0]],";
    "Fxn:ri" -> "Fxn:torch.Tensor([5]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri" -> "Fxn:torch.Tensor([5]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([1]),";
    "Fxn:ri" -> "Fxn:torch.Tensor([9]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[[0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([5,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([5,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([[0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[5,";
    "Fxn:ri" -> "Fxn:conv_fn(consec((3,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([2,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:consec((1,)))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([2]),";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:consec((1,),";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1])]],";
    "Fxn:ri" -> "Fxn:torch.Tensor([2,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([1,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[1,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:ri([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[2,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[1,";
    "Fxn:ri" -> "Fxn:reference[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([1])]";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([-1]))";
    "Fxn:ri" -> "Fxn:reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0])]";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([-1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([-1,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([[4,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[4,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([[0,";
    "Fxn:ri" -> "Fxn:11]])).t_()";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([4,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([0]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([2]),";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([6]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1])]],";
    "Fxn:ri" -> "Fxn:torch.Tensor([4,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([0,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[0,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:ri([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[4,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[0,";
    "Fxn:ri" -> "Fxn:reference[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([1])]";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([-1]))";
    "Fxn:ri" -> "Fxn:reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0])]";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([-1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([-1,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([[4,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[4,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:ri" -> "Fxn:24).view(3,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor())";
    "Fxn:ri" -> "Fxn:strided.set_(reference.storage(),";
    "Fxn:ri" -> "Fxn:size=torch.Size([2,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([3,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([0])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([1]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([1]),";
    "Fxn:ri" -> "Fxn:ri([3])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([15]))";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[[ri([1]),";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([9,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[[ri([0,";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([1,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[1,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:ri([1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[3,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[1,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:ri" -> "Fxn:24).view(3,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor())";
    "Fxn:ri" -> "Fxn:strided.set_(reference.storage(),";
    "Fxn:ri" -> "Fxn:size=torch.Size([2,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([11]))";
    "Fxn:ri" -> "Fxn:strided[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([1])]";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0]),";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([-1]))";
    "Fxn:ri" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:ri" -> "Fxn:24).view(3,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor())";
    "Fxn:ri" -> "Fxn:strided.set_(reference.storage(),";
    "Fxn:ri" -> "Fxn:size=torch.Size([2,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1,";
    "Fxn:ri" -> "Fxn:torch.Tensor([11,";
    "Fxn:ri" -> "Fxn:strided[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([-1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[ri([0,";
    "Fxn:ri" -> "Fxn:ri([1,";
    "Fxn:ri" -> "Fxn:torch.Tensor([-1,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:ri" -> "Fxn:24).view(3,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor())";
    "Fxn:ri" -> "Fxn:strided.set_(reference.storage(),";
    "Fxn:ri" -> "Fxn:size=torch.Size([2,";
    "Fxn:ri" -> "Fxn:ri([[0],";
    "Fxn:ri" -> "Fxn:ri([[0,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[10,";
    "Fxn:ri" -> "Fxn:conv_fn(torch.Tensor([[4,";
    "Fxn:ri" -> "Fxn:self.assertEqual(strided[rows,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[4,";
    "Fxn:ri" -> "Fxn:conv_fn(consec((3,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([0,";
    "Fxn:ri" -> "Fxn:torch.Tensor([[1,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[ri([1]),";
    "Fxn:ri" -> "Fxn:torch.Tensor([[3,";
    "Fxn:ri" -> "Fxn:self.assertEqual(reference[...,";
    "Fxn:ri" -> "Fxn:ri([1])],";
    "Fxn:ri" -> "Fxn:torch.Tensor([[2],";
    "Fxn:ri" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:ri" -> "Fxn:reference[ri([1]),";
    "Fxn:ri" -> "Fxn:ri([0,";
    "Fxn:ri" -> "Fxn:ri([3])]";
    "Fxn:tensor_indices_to_np" -> "Fxn:tensor.cpu()";
    "Fxn:tensor_indices_to_np" -> "Fxn:tensor.numpy()";
    "Fxn:get_numpy" -> "Fxn:tensor_indices_to_np(tensor,";
    "Fxn:get_numpy" -> "Fxn:torch.Tensor(npt[idxs])";
    "Fxn:set_numpy" -> "Fxn:value.cpu()";
    "Fxn:set_numpy" -> "Fxn:value.numpy()";
    "Fxn:set_numpy" -> "Fxn:tensor_indices_to_np(tensor,";
    "Fxn:assert_get_eq" -> "Fxn:self.assertEqual(reference[indexer],";
    "Fxn:assert_get_eq" -> "Fxn:conv_fn(get_numpy(reference,";
    "Fxn:assert_set_eq" -> "Fxn:tensor.clone()";
    "Fxn:assert_set_eq" -> "Fxn:tensor.clone()";
    "Fxn:assert_set_eq" -> "Fxn:conv_fn(torch.Tensor(set_numpy(numt,";
    "Fxn:assert_set_eq" -> "Fxn:self.assertEqual(pyt,";
    "Fxn:get_set_tensor" -> "Fxn:indexed[indexer].size()";
    "Fxn:get_set_tensor" -> "Fxn:indexed[indexer].numel()";
    "Fxn:get_set_tensor" -> "Fxn:conv_fn(torch.randperm(set_count).view(set_size).double())";
    "Fxn:get_set_tensor" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:get_set_tensor" -> "Fxn:20).view(4,";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:assert_get_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:get_set_tensor(reference,";
    "Fxn:get_set_tensor" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:get_set_tensor" -> "Fxn:160).view(4,";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:assert_get_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:get_set_tensor(reference,";
    "Fxn:get_set_tensor" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:get_set_tensor" -> "Fxn:1296).view(3,";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:assert_get_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:assert_set_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:get_set_tensor(reference,";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:[slice(None),";
    "Fxn:get_set_tensor" -> "Fxn:assert_get_eq(reference,";
    "Fxn:get_set_tensor" -> "Fxn:assert_set_eq(reference,";
    "Fxn:test_advancedindex" -> "Fxn:self._test_advancedindex(self,";
    "Fxn:_test_advancedindex_big" -> "Fxn:conv_fn(torch.arange(0,";
    "Fxn:_test_advancedindex_big" -> "Fxn:123344).int())";
    "Fxn:_test_advancedindex_big" -> "Fxn:self.assertEqual(reference[[0,";
    "Fxn:_test_advancedindex_big" -> "Fxn:torch.LongTensor([0,";
    "Fxn:test_advancedindex_big" -> "Fxn:self._test_advancedindex_big(self,";
    "Fxn:test_advancedindex_big" -> "Fxn:@unittest.skipIf(not";
    "Fxn:run_test" -> "Fxn:tensor.numpy()";
    "Fxn:run_test" -> "Fxn:self.assertEqual(tensor[idx],";
    "Fxn:run_test" -> "Fxn:torch.arange(0,";
    "Fxn:run_test" -> "Fxn:run_test(x,";
    "Fxn:run_test" -> "Fxn:torch.arange(0,";
    "Fxn:run_test" -> "Fxn:12).view(3,";
    "Fxn:run_test" -> "Fxn:run_test(x,";
    "Fxn:test_newindex" -> "Fxn:self._consecutive((3,";
    "Fxn:test_newindex" -> "Fxn:__index__()";
    "Fxn:checkPartialAssign" -> "Fxn:torch.zeros(3,";
    "Fxn:checkPartialAssign" -> "Fxn:self._consecutive((3,";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertEqual(reference[index],";
    "Fxn:checkPartialAssign" -> "Fxn:self._consecutive((3,";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertEqual(reference,";
    "Fxn:checkPartialAssign" -> "Fxn:torch.zeros(3,";
    "Fxn:checkPartialAssign" -> "Fxn:checkPartialAssign(0)";
    "Fxn:checkPartialAssign" -> "Fxn:checkPartialAssign(1)";
    "Fxn:checkPartialAssign" -> "Fxn:checkPartialAssign(2)";
    "Fxn:checkPartialAssign" -> "Fxn:checkPartialAssign((0,";
    "Fxn:checkPartialAssign" -> "Fxn:checkPartialAssign((1,";
    "Fxn:checkPartialAssign" -> "Fxn:checkPartialAssign((0,";
    "Fxn:checkPartialAssign" -> "Fxn:checkPartialAssign(torch.LongTensor((0,";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(TypeError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:checkPartialAssign" -> "Fxn:self.assertRaises(IndexError):";
    "Fxn:test_index_copy" -> "Fxn:torch.randn(num_dest,";
    "Fxn:test_index_copy" -> "Fxn:torch.randn(num_copy,";
    "Fxn:test_index_copy" -> "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:test_index_copy" -> "Fxn:dest.clone()";
    "Fxn:test_index_copy" -> "Fxn:dest.index_copy_(0,";
    "Fxn:test_index_copy" -> "Fxn:self.assertEqual(dest,";
    "Fxn:test_index_copy" -> "Fxn:torch.randn(num_dest)";
    "Fxn:test_index_copy" -> "Fxn:torch.randn(num_copy)";
    "Fxn:test_index_copy" -> "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:test_index_copy" -> "Fxn:dest.clone()";
    "Fxn:test_index_copy" -> "Fxn:dest.index_copy_(0,";
    "Fxn:test_index_copy" -> "Fxn:self.assertEqual(dest,";
    "Fxn:test_index_add" -> "Fxn:torch.randn(num_dest,";
    "Fxn:test_index_add" -> "Fxn:torch.randn(num_copy,";
    "Fxn:test_index_add" -> "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:test_index_add" -> "Fxn:dest.clone()";
    "Fxn:test_index_add" -> "Fxn:dest.index_add_(0,";
    "Fxn:test_index_add" -> "Fxn:self.assertEqual(dest,";
    "Fxn:test_index_add" -> "Fxn:torch.randn(num_dest)";
    "Fxn:test_index_add" -> "Fxn:torch.randn(num_copy)";
    "Fxn:test_index_add" -> "Fxn:torch.randperm(num_dest).narrow(0,";
    "Fxn:test_index_add" -> "Fxn:dest.clone()";
    "Fxn:test_index_add" -> "Fxn:dest.index_add_(0,";
    "Fxn:test_index_add" -> "Fxn:self.assertEqual(dest,";
    "Fxn:test_index_select" -> "Fxn:torch.randn(3,";
    "Fxn:test_index_select" -> "Fxn:torch.LongTensor([2,";
    "Fxn:test_index_select" -> "Fxn:torch.index_select(src,";
    "Fxn:test_index_select" -> "Fxn:self.assertEqual(dest.shape,";
    "Fxn:test_index_select" -> "Fxn:self.assertEqual(dest[i],";
    "Fxn:test_index_select" -> "Fxn:torch.randn(5";
    "Fxn:test_index_select" -> "Fxn:torch.index_select(src,";
    "Fxn:test_index_select" -> "Fxn:out=out.view(5,";
    "Fxn:test_index_select" -> "Fxn:self.assertEqual(dest.shape,";
    "Fxn:test_index_select" -> "Fxn:self.assertEqual(dest[i],";
    "Fxn:test_index_select" -> "Fxn:out.fill_(0.123)";
    "Fxn:test_index_select" -> "Fxn:self.assertEqual(out,";
    "Fxn:test_index_select" -> "Fxn:dest.view(-1))";
    "Fxn:check" -> "Fxn:src.contiguous().view(-1).index_select(";
    "Fxn:check" -> "Fxn:idx.contiguous().view(-1)).view_as(idx)";
    "Fxn:check" -> "Fxn:src.take(idx)";
    "Fxn:check" -> "Fxn:self.assertEqual(actual.size(),";
    "Fxn:check" -> "Fxn:idx.size())";
    "Fxn:check" -> "Fxn:self.assertEqual(expected,";
    "Fxn:check" -> "Fxn:torch.randn(2,";
    "Fxn:check" -> "Fxn:torch.LongTensor([[0,";
    "Fxn:check" -> "Fxn:check(src,";
    "Fxn:check" -> "Fxn:check(src.transpose(1,";
    "Fxn:check" -> "Fxn:dst.clone().view(-1).index_copy_(";
    "Fxn:check" -> "Fxn:idx.contiguous().view(-1),";
    "Fxn:check" -> "Fxn:value.contiguous().view(-1))";
    "Fxn:check" -> "Fxn:expected.view_as(dst)";
    "Fxn:check" -> "Fxn:dst.put_(idx,";
    "Fxn:check" -> "Fxn:self.assertEqual(expected,";
    "Fxn:check" -> "Fxn:torch.randn(2,";
    "Fxn:check" -> "Fxn:torch.LongTensor([[0,";
    "Fxn:check" -> "Fxn:torch.randn(2,";
    "Fxn:check" -> "Fxn:check(dst,";
    "Fxn:check" -> "Fxn:check(dst.transpose(1,";
    "Fxn:test_put_accumulate" -> "Fxn:torch.ones(2,";
    "Fxn:test_put_accumulate" -> "Fxn:torch.LongTensor([[0,";
    "Fxn:test_put_accumulate" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_put_accumulate" -> "Fxn:dst.put_(idx,";
    "Fxn:test_put_accumulate" -> "Fxn:self.assertEqual(dst.tolist(),";
    "Fxn:_fill_indices" -> "Fxn:idx.size(dim)";
    "Fxn:_fill_indices" -> "Fxn:idx[tuple(ii)]";
    "Fxn:_fill_indices" -> "Fxn:torch.randperm(dim_size)[0:elems_per_row]";
    "Fxn:_test_gather" -> "Fxn:random.randint(10,";
    "Fxn:_test_gather" -> "Fxn:random.randint(10,";
    "Fxn:_test_gather" -> "Fxn:random.randint(10,";
    "Fxn:_test_gather" -> "Fxn:random.randint(1,";
    "Fxn:_test_gather" -> "Fxn:random.randrange(3)";
    "Fxn:_test_gather" -> "Fxn:torch.randn(m,";
    "Fxn:_test_gather" -> "Fxn:torch.LongTensor().resize_(*idx_size)";
    "Fxn:_test_gather" -> "Fxn:TestTorch._fill_indices(self,";
    "Fxn:_test_gather" -> "Fxn:src.size(dim),";
    "Fxn:_test_gather" -> "Fxn:cast(src)";
    "Fxn:_test_gather" -> "Fxn:cast(idx)";
    "Fxn:_test_gather" -> "Fxn:torch.gather(src,";
    "Fxn:_test_gather" -> "Fxn:cast(torch.Tensor().resize_(*idx_size))";
    "Fxn:_test_gather" -> "Fxn:src[tuple(ii)]";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(actual,";
    "Fxn:_test_gather" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_gather" -> "Fxn:torch.gather(src,";
    "Fxn:_test_gather" -> "Fxn:cast(torch.randn(3,";
    "Fxn:_test_gather" -> "Fxn:src.max(2,";
    "Fxn:_test_gather" -> "Fxn:cast(expected)";
    "Fxn:_test_gather" -> "Fxn:cast(idx)";
    "Fxn:_test_gather" -> "Fxn:torch.gather(src,";
    "Fxn:_test_gather" -> "Fxn:self.assertEqual(actual,";
    "Fxn:test_gather" -> "Fxn:self._test_gather(self,";
    "Fxn:_test_scatter_base" -> "Fxn:random.randint(10,";
    "Fxn:_test_scatter_base" -> "Fxn:random.randint(10,";
    "Fxn:_test_scatter_base" -> "Fxn:random.randint(10,";
    "Fxn:_test_scatter_base" -> "Fxn:random.randint(1,";
    "Fxn:_test_scatter_base" -> "Fxn:random.randrange(3)";
    "Fxn:_test_scatter_base" -> "Fxn:cast(torch.LongTensor().resize_(*idx_size))";
    "Fxn:_test_scatter_base" -> "Fxn:TestTorch._fill_indices(self,";
    "Fxn:_test_scatter_base" -> "Fxn:random.random()";
    "Fxn:_test_scatter_base" -> "Fxn:cast(torch.Tensor(*idx_size).normal_())";
    "Fxn:_test_scatter_base" -> "Fxn:cast(torch.randn(m,";
    "Fxn:_test_scatter_base" -> "Fxn:method)(dim,";
    "Fxn:_test_scatter_base" -> "Fxn:base.clone()";
    "Fxn:_test_scatter_base" -> "Fxn:expected[tuple(ii)]";
    "Fxn:_test_scatter_base" -> "Fxn:expected[tuple(ii)]";
    "Fxn:_test_scatter_base" -> "Fxn:expected[tuple(ii)]";
    "Fxn:_test_scatter_base" -> "Fxn:self.assertEqual(actual,";
    "Fxn:_test_scatter_base" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:_test_scatter_base" -> "Fxn:method)(dim,";
    "Fxn:test_scatter" -> "Fxn:self._test_scatter_base(self,";
    "Fxn:test_scatterAdd" -> "Fxn:self._test_scatter_base(self,";
    "Fxn:test_scatterFill" -> "Fxn:self._test_scatter_base(self,";
    "Fxn:test_masked_scatter" -> "Fxn:torch.randn(num_dest)";
    "Fxn:test_masked_scatter" -> "Fxn:torch.randn(num_copy)";
    "Fxn:test_masked_scatter" -> "Fxn:torch.ByteTensor((0,";
    "Fxn:test_masked_scatter" -> "Fxn:dest.clone()";
    "Fxn:test_masked_scatter" -> "Fxn:dest.masked_scatter_(mask,";
    "Fxn:test_masked_scatter" -> "Fxn:self.assertEqual(dest,";
    "Fxn:test_masked_scatter" -> "Fxn:torch.randn(num_dest)";
    "Fxn:test_masked_scatter" -> "Fxn:dest.masked_scatter_(mask,";
    "Fxn:test_masked_scatter" -> "Fxn:torch.randn(num_copy";
    "Fxn:test_masked_scatter" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_masked_scatter" -> "Fxn:dest.masked_scatter_(mask,";
    "Fxn:test_masked_select" -> "Fxn:torch.randn(num_src)";
    "Fxn:test_masked_select" -> "Fxn:torch.rand(num_src).clamp(0,";
    "Fxn:test_masked_select" -> "Fxn:1).mul(2).floor().byte()";
    "Fxn:test_masked_select" -> "Fxn:src.masked_select(mask)";
    "Fxn:test_masked_select" -> "Fxn:self.assertEqual(dst,";
    "Fxn:test_masked_select" -> "Fxn:torch.Tensor(dst2),";
    "Fxn:test_masked_fill" -> "Fxn:torch.randn(num_dest)";
    "Fxn:test_masked_fill" -> "Fxn:torch.rand(num_dest).mul(2).floor().byte()";
    "Fxn:test_masked_fill" -> "Fxn:random.random()";
    "Fxn:test_masked_fill" -> "Fxn:dst.clone()";
    "Fxn:test_masked_fill" -> "Fxn:dst.masked_fill_(mask,";
    "Fxn:test_masked_fill" -> "Fxn:self.assertEqual(dst,";
    "Fxn:test_abs" -> "Fxn:torch.rand(size).mul(max_val)";
    "Fxn:test_abs" -> "Fxn:torch.rand(size).mul(2).floor().mul(2).add(-1)";
    "Fxn:test_abs" -> "Fxn:original.type(t)";
    "Fxn:test_abs" -> "Fxn:switch.type(t)";
    "Fxn:test_abs" -> "Fxn:torch.mul(data,";
    "Fxn:test_abs" -> "Fxn:self.assertTensorsSlowEqual(res.abs(),";
    "Fxn:test_abs" -> "Fxn:torch.LongTensor((-bignumber,))";
    "Fxn:test_abs" -> "Fxn:self.assertGreater(res.abs()[0],";
    "Fxn:test_unbiased" -> "Fxn:torch.randn(100)";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.var(0),";
    "Fxn:test_unbiased" -> "Fxn:tensor.var(0,";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:test_unbiased" -> "Fxn:tensor.var(unbiased=True))";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:test_unbiased" -> "Fxn:tensor.var(0,";
    "Fxn:test_unbiased" -> "Fxn:torch.FloatTensor([1.0,";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=True),";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:test_unbiased" -> "Fxn:torch.FloatTensor([1.0,";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=True),";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.var(unbiased=False),";
    "Fxn:test_unbiased" -> "Fxn:torch.randn(100)";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.std(0),";
    "Fxn:test_unbiased" -> "Fxn:tensor.std(0,";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.std(),";
    "Fxn:test_unbiased" -> "Fxn:tensor.std(unbiased=True))";
    "Fxn:test_unbiased" -> "Fxn:self.assertEqual(tensor.std(unbiased=False),";
    "Fxn:test_unbiased" -> "Fxn:tensor.std(0,";
    "Fxn:test_var_stability" -> "Fxn:torch.FloatTensor([2281.5,";
    "Fxn:test_var_stability" -> "Fxn:self.assertEqual(tensor.var(dim=0),";
    "Fxn:test_var_stability" -> "Fxn:self.assertEqual(tensor.var(),";
    "Fxn:_test_view" -> "Fxn:cast(torch.rand(15))";
    "Fxn:_test_view" -> "Fxn:cast(torch.rand(3,";
    "Fxn:_test_view" -> "Fxn:cast(torch.Tensor())";
    "Fxn:_test_view" -> "Fxn:template.size()";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view_as(template).size(),";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(3,";
    "Fxn:_test_view" -> "Fxn:5).size(),";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(torch.Size([3,";
    "Fxn:_test_view" -> "Fxn:5])).size(),";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(-1,";
    "Fxn:_test_view" -> "Fxn:5).size(),";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(3,";
    "Fxn:_test_view" -> "Fxn:-1).size(),";
    "Fxn:_test_view" -> "Fxn:tensor.view(5,";
    "Fxn:_test_view" -> "Fxn:tensor_view.fill_(random.uniform(0,";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(empty.view_as(empty),";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(empty.view(0),";
    "Fxn:_test_view" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_view" -> "Fxn:tensor.view(15,";
    "Fxn:_test_view" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_view" -> "Fxn:tensor.view(7,";
    "Fxn:_test_view" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_view" -> "Fxn:tensor.view(15,";
    "Fxn:_test_view" -> "Fxn:cast(torch.rand(4,";
    "Fxn:_test_view" -> "Fxn:3)).transpose(-1,";
    "Fxn:_test_view" -> "Fxn:2).transpose(-2,";
    "Fxn:_test_view" -> "Fxn:tensor.clone()";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(*view_size),";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(*view_size))";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(*view_size),";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(*view_size))";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(*view_size),";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(*view_size))";
    "Fxn:_test_view" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_view" -> "Fxn:tensor.view(-1))";
    "Fxn:_test_view" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_view" -> "Fxn:tensor.view(24,";
    "Fxn:_test_view" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_view" -> "Fxn:tensor.view(8,";
    "Fxn:_test_view" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:_test_view" -> "Fxn:tensor.view(8,";
    "Fxn:_test_view" -> "Fxn:cast(torch.Tensor(1,";
    "Fxn:_test_view" -> "Fxn:1)).expand(3,";
    "Fxn:_test_view" -> "Fxn:tensor.clone()";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(-1),";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(-1))";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(1,";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(1,";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(-1,";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(-1,";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(6,";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(6,";
    "Fxn:_test_view" -> "Fxn:self.assertEqual(tensor.view(1,";
    "Fxn:_test_view" -> "Fxn:contig_tensor.view(1,";
    "Fxn:test_view" -> "Fxn:TestTorch._test_view(self,";
    "Fxn:test_reshape" -> "Fxn:torch.randn(3,";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(x.data_ptr(),";
    "Fxn:test_reshape" -> "Fxn:x.reshape(-1).data_ptr())";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(x.data_ptr(),";
    "Fxn:test_reshape" -> "Fxn:x.reshape(1,";
    "Fxn:test_reshape" -> "Fxn:1).data_ptr())";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(torch.reshape(x,";
    "Fxn:test_reshape" -> "Fxn:x.reshape(9))";
    "Fxn:test_reshape" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_reshape" -> "Fxn:x.reshape(-1,";
    "Fxn:test_reshape" -> "Fxn:torch.randn(4,";
    "Fxn:test_reshape" -> "Fxn:self.assertNotEqual(y.data_ptr(),";
    "Fxn:test_reshape" -> "Fxn:y.reshape(-1).data_ptr())";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(y.contiguous().view(-1),";
    "Fxn:test_reshape" -> "Fxn:y.reshape(-1))";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(y.reshape(2,";
    "Fxn:test_reshape" -> "Fxn:4).data_ptr(),";
    "Fxn:test_reshape" -> "Fxn:y.data_ptr())";
    "Fxn:test_reshape" -> "Fxn:torch.randn(())";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(s.data_ptr(),";
    "Fxn:test_reshape" -> "Fxn:s.reshape(()).data_ptr())";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(s.reshape(-1).shape,";
    "Fxn:test_reshape" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_reshape" -> "Fxn:s.reshape(2))";
    "Fxn:test_reshape" -> "Fxn:torch.tensor([])";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(empty,";
    "Fxn:test_reshape" -> "Fxn:empty.reshape(-1))";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(empty,";
    "Fxn:test_reshape" -> "Fxn:empty.reshape([0]))";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(empty.reshape([0,";
    "Fxn:test_reshape" -> "Fxn:self.assertEqual(empty.reshape([1,";
    "Fxn:test_reshape" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_reshape" -> "Fxn:empty.reshape(1))";
    "Fxn:test_expand" -> "Fxn:torch.rand(1,";
    "Fxn:test_expand" -> "Fxn:torch.rand(5)";
    "Fxn:test_expand" -> "Fxn:torch.rand(4,";
    "Fxn:test_expand" -> "Fxn:template.size()";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor.expand_as(template).size(),";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor.expand(4,";
    "Fxn:test_expand" -> "Fxn:5).size(),";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor.expand(target).size(),";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor2.expand_as(template).size(),";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor2.expand(4,";
    "Fxn:test_expand" -> "Fxn:5).size(),";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor2.expand(target).size(),";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor2.expand(1,";
    "Fxn:test_expand" -> "Fxn:5).expand(2,";
    "Fxn:test_expand" -> "Fxn:tensor2.repeat(2,";
    "Fxn:test_expand" -> "Fxn:torch.randn(5,";
    "Fxn:test_expand" -> "Fxn:self.assertFalse(noncontig.is_contiguous())";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(noncontig.expand(2,";
    "Fxn:test_expand" -> "Fxn:noncontig.contiguous().repeat(2,";
    "Fxn:test_expand" -> "Fxn:tensor2.expand(1,";
    "Fxn:test_expand" -> "Fxn:tensor2.unsqueeze(0).unsqueeze(1)";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(expanded,";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(expanded.stride(),";
    "Fxn:test_expand" -> "Fxn:unsqueezed.stride())";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(tensor.expand(4,";
    "Fxn:test_expand" -> "Fxn:tensor.expand(4,";
    "Fxn:test_expand" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_expand" -> "Fxn:tensor2.expand(-1,";
    "Fxn:test_expand" -> "Fxn:self.assertEqual(torch.zeros(0).expand((0,)),";
    "Fxn:test_expand" -> "Fxn:torch.zeros(0))";
    "Fxn:test_repeat" -> "Fxn:torch.rand(*initial_shape)";
    "Fxn:test_repeat" -> "Fxn:torch.Size(size)";
    "Fxn:test_repeat" -> "Fxn:self.assertEqual(tensor.repeat(*size).size(),";
    "Fxn:test_repeat" -> "Fxn:self.assertEqual(tensor.repeat(torchSize).size(),";
    "Fxn:test_repeat" -> "Fxn:tensor.repeat(*size)";
    "Fxn:test_repeat" -> "Fxn:self.assertEqual(result.size(),";
    "Fxn:test_repeat" -> "Fxn:tensor.repeat(torchSize)";
    "Fxn:test_repeat" -> "Fxn:self.assertEqual(result.size(),";
    "Fxn:test_repeat" -> "Fxn:self.assertEqual(result.mean(0).view(8,";
    "Fxn:test_repeat" -> "Fxn:@unittest.skipIf(not";
    "Fxn:_generate_noncontiguous_input" -> "Fxn:np.broadcast_to(np.random.random((1,";
    "Fxn:_generate_noncontiguous_input" -> "Fxn:torch.from_numpy(_generate_noncontiguous_input()),):";
    "Fxn:_generate_noncontiguous_input" -> "Fxn:self.assertEqual(tensor.repeat(*repeat).numpy(),";
    "Fxn:_generate_noncontiguous_input" -> "Fxn:np.tile(tensor.numpy(),";
    "Fxn:test_is_same_size" -> "Fxn:torch.Tensor(3,";
    "Fxn:test_is_same_size" -> "Fxn:torch.Tensor(3,";
    "Fxn:test_is_same_size" -> "Fxn:torch.Tensor(1,";
    "Fxn:test_is_same_size" -> "Fxn:torch.Tensor(3,";
    "Fxn:test_is_same_size" -> "Fxn:self.assertFalse(t1.is_same_size(t2))";
    "Fxn:test_is_same_size" -> "Fxn:self.assertFalse(t1.is_same_size(t3))";
    "Fxn:test_is_same_size" -> "Fxn:self.assertTrue(t1.is_same_size(t4))";
    "Fxn:test_is_set_to" -> "Fxn:torch.Tensor(3,";
    "Fxn:test_is_set_to" -> "Fxn:torch.Tensor(3,";
    "Fxn:test_is_set_to" -> "Fxn:torch.Tensor().set_(t1)";
    "Fxn:test_is_set_to" -> "Fxn:t3.clone().resize_(12,";
    "Fxn:test_is_set_to" -> "Fxn:self.assertFalse(t1.is_set_to(t2))";
    "Fxn:test_is_set_to" -> "Fxn:self.assertTrue(t1.is_set_to(t3))";
    "Fxn:test_is_set_to" -> "Fxn:self.assertTrue(t3.is_set_to(t1),";
    "Fxn:test_is_set_to" -> "Fxn:self.assertFalse(t1.is_set_to(t4))";
    "Fxn:test_is_set_to" -> "Fxn:self.assertFalse(torch.Tensor().is_set_to(torch.Tensor()),";
    "Fxn:test_tensor_set" -> "Fxn:torch.Tensor()";
    "Fxn:test_tensor_set" -> "Fxn:torch.Tensor(3,";
    "Fxn:test_tensor_set" -> "Fxn:10).uniform_()";
    "Fxn:test_tensor_set" -> "Fxn:t1.set_(t2)";
    "Fxn:test_tensor_set" -> "Fxn:self.assertEqual(t1.storage()._cdata,";
    "Fxn:test_tensor_set" -> "Fxn:t2.storage()._cdata)";
    "Fxn:test_tensor_set" -> "Fxn:torch.Size([9,";
    "Fxn:test_tensor_set" -> "Fxn:t1.set_(t2.storage(),";
    "Fxn:test_tensor_set" -> "Fxn:self.assertEqual(t1.size(),";
    "Fxn:test_tensor_set" -> "Fxn:t1.set_(t2.storage(),";
    "Fxn:test_tensor_set" -> "Fxn:self.assertEqual(t1.size(),";
    "Fxn:test_tensor_set" -> "Fxn:self.assertEqual(t1.stride(),";
    "Fxn:test_tensor_set" -> "Fxn:t1.set_(t2.storage(),";
    "Fxn:test_tensor_set" -> "Fxn:self.assertEqual(t1.stride(),";
    "Fxn:test_tensor_set" -> "Fxn:t1.set_(t2.storage(),";
    "Fxn:test_tensor_set" -> "Fxn:self.assertEqual(t1.size(),";
    "Fxn:test_tensor_set" -> "Fxn:self.assertEqual(t1.stride(),";
    "Fxn:test_equal" -> "Fxn:torch.Tensor((3,";
    "Fxn:test_equal" -> "Fxn:t1.contiguous()";
    "Fxn:test_equal" -> "Fxn:torch.Tensor((1,";
    "Fxn:test_equal" -> "Fxn:torch.Tensor((3,";
    "Fxn:test_equal" -> "Fxn:torch.Tensor()";
    "Fxn:test_equal" -> "Fxn:self.assertTrue(t1.equal(t2))";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(t1.equal(t3))";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(t1.equal(t4))";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(t1.equal(t5))";
    "Fxn:test_equal" -> "Fxn:self.assertTrue(torch.equal(t1,";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(torch.equal(t1,";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(torch.equal(t1,";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(torch.equal(t1,";
    "Fxn:test_equal" -> "Fxn:torch.Tensor(((1,";
    "Fxn:test_equal" -> "Fxn:s1.clone()";
    "Fxn:test_equal" -> "Fxn:torch.Tensor(((2,";
    "Fxn:test_equal" -> "Fxn:torch.Tensor(((0,";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(s1.is_contiguous())";
    "Fxn:test_equal" -> "Fxn:self.assertTrue(s1.equal(s2))";
    "Fxn:test_equal" -> "Fxn:self.assertTrue(s1.equal(s3))";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(s1.equal(s4))";
    "Fxn:test_equal" -> "Fxn:self.assertTrue(torch.equal(s1,";
    "Fxn:test_equal" -> "Fxn:self.assertTrue(torch.equal(s1,";
    "Fxn:test_equal" -> "Fxn:self.assertFalse(torch.equal(s1,";
    "Fxn:test_element_size" -> "Fxn:torch.ByteStorage().element_size()";
    "Fxn:test_element_size" -> "Fxn:torch.CharStorage().element_size()";
    "Fxn:test_element_size" -> "Fxn:torch.ShortStorage().element_size()";
    "Fxn:test_element_size" -> "Fxn:torch.IntStorage().element_size()";
    "Fxn:test_element_size" -> "Fxn:torch.LongStorage().element_size()";
    "Fxn:test_element_size" -> "Fxn:torch.FloatStorage().element_size()";
    "Fxn:test_element_size" -> "Fxn:torch.DoubleStorage().element_size()";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(byte,";
    "Fxn:test_element_size" -> "Fxn:torch.ByteTensor().element_size())";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(char,";
    "Fxn:test_element_size" -> "Fxn:torch.CharTensor().element_size())";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(short,";
    "Fxn:test_element_size" -> "Fxn:torch.ShortTensor().element_size())";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(int,";
    "Fxn:test_element_size" -> "Fxn:torch.IntTensor().element_size())";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(long,";
    "Fxn:test_element_size" -> "Fxn:torch.LongTensor().element_size())";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(float,";
    "Fxn:test_element_size" -> "Fxn:torch.FloatTensor().element_size())";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(double,";
    "Fxn:test_element_size" -> "Fxn:torch.DoubleTensor().element_size())";
    "Fxn:test_element_size" -> "Fxn:self.assertGreater(byte,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreater(char,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreater(short,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreater(int,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreater(long,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreater(float,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreater(double,";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(byte,";
    "Fxn:test_element_size" -> "Fxn:self.assertEqual(char,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreaterEqual(short,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreaterEqual(int,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreaterEqual(int,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreaterEqual(long,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreaterEqual(long,";
    "Fxn:test_element_size" -> "Fxn:self.assertGreaterEqual(double,";
    "Fxn:test_split" -> "Fxn:torch.rand(7,";
    "Fxn:test_split" -> "Fxn:tensor.split(split_size,";
    "Fxn:test_split" -> "Fxn:self.assertEqual(split.size(),";
    "Fxn:test_split" -> "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:test_split" -> "Fxn:torch.randn(20,";
    "Fxn:test_split" -> "Fxn:tensor.split(split_sizes,";
    "Fxn:test_split" -> "Fxn:self.assertEqual(split.size(),";
    "Fxn:test_split" -> "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:test_split" -> "Fxn:tensor.split(split_sizes,";
    "Fxn:test_split" -> "Fxn:self.assertEqual(split.size(),";
    "Fxn:test_split" -> "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:test_chunk" -> "Fxn:torch.rand(4,";
    "Fxn:test_chunk" -> "Fxn:tensor.chunk(num_chunks,";
    "Fxn:test_chunk" -> "Fxn:self.assertEqual(split.size(),";
    "Fxn:test_chunk" -> "Fxn:self.assertEqual(tensor.narrow(dim,";
    "Fxn:test_tolist" -> "Fxn:torch.Tensor(list0D)";
    "Fxn:test_tolist" -> "Fxn:self.assertEqual(tensor0D.tolist(),";
    "Fxn:test_tolist" -> "Fxn:torch.Tensor(table1D)";
    "Fxn:test_tolist" -> "Fxn:torch.Storage(table1D)";
    "Fxn:test_tolist" -> "Fxn:self.assertEqual(tensor1D.tolist(),";
    "Fxn:test_tolist" -> "Fxn:self.assertEqual(storage.tolist(),";
    "Fxn:test_tolist" -> "Fxn:self.assertEqual(tensor1D.tolist(),";
    "Fxn:test_tolist" -> "Fxn:self.assertEqual(storage.tolist(),";
    "Fxn:test_tolist" -> "Fxn:torch.Tensor(table2D)";
    "Fxn:test_tolist" -> "Fxn:self.assertEqual(tensor2D.tolist(),";
    "Fxn:test_tolist" -> "Fxn:torch.Tensor([[[1,";
    "Fxn:test_tolist" -> "Fxn:tensor3D.select(1,";
    "Fxn:test_tolist" -> "Fxn:self.assertFalse(tensorNonContig.is_contiguous())";
    "Fxn:test_tolist" -> "Fxn:self.assertEqual(tensorNonContig.tolist(),";
    "Fxn:test_permute" -> "Fxn:torch.randperm(7).tolist()";
    "Fxn:test_permute" -> "Fxn:torch.Tensor(*orig).fill_(0)";
    "Fxn:test_permute" -> "Fxn:x.permute(*perm).size()))";
    "Fxn:test_permute" -> "Fxn:self.assertEqual(perm,";
    "Fxn:test_permute" -> "Fxn:self.assertEqual(x.size(),";
    "Fxn:test_storage" -> "Fxn:torch.randn(3,";
    "Fxn:test_storage" -> "Fxn:self.assertEqual(v.storage()[0],";
    "Fxn:test_storage" -> "Fxn:self.assertEqual(v.storage()[14],";
    "Fxn:test_storageview" -> "Fxn:torch.LongStorage((3,";
    "Fxn:test_storageview" -> "Fxn:torch.LongStorage(s1,";
    "Fxn:test_storageview" -> "Fxn:self.assertEqual(s2.size(),";
    "Fxn:test_storageview" -> "Fxn:self.assertEqual(s2[0],";
    "Fxn:test_storageview" -> "Fxn:self.assertEqual(s2[1],";
    "Fxn:test_storageview" -> "Fxn:self.assertEqual(13,";
    "Fxn:test_nonzero" -> "Fxn:torch.Size((12,)),";
    "Fxn:test_nonzero" -> "Fxn:torch.Size((12,";
    "Fxn:test_nonzero" -> "Fxn:torch.Size((1,";
    "Fxn:test_nonzero" -> "Fxn:torch.Size((6,";
    "Fxn:test_nonzero" -> "Fxn:torch.Size((3,";
    "Fxn:test_nonzero" -> "Fxn:torch.rand(num_src).mul(2).floor().type(t)";
    "Fxn:test_nonzero" -> "Fxn:tensor.sum()";
    "Fxn:test_nonzero" -> "Fxn:tensor.clone().resize_(shape)";
    "Fxn:test_nonzero" -> "Fxn:torch.nonzero(tensor)";
    "Fxn:test_nonzero" -> "Fxn:tensor.nonzero()";
    "Fxn:test_nonzero" -> "Fxn:torch.LongTensor()";
    "Fxn:test_nonzero" -> "Fxn:torch.nonzero(tensor,";
    "Fxn:test_nonzero" -> "Fxn:self.assertEqual(dst1.select(1,";
    "Fxn:test_nonzero" -> "Fxn:torch.LongTensor(dst),";
    "Fxn:test_nonzero" -> "Fxn:self.assertEqual(dst2.select(1,";
    "Fxn:test_nonzero" -> "Fxn:torch.LongTensor(dst),";
    "Fxn:test_nonzero" -> "Fxn:self.assertEqual(dst3.select(1,";
    "Fxn:test_nonzero" -> "Fxn:torch.LongTensor(dst),";
    "Fxn:test_nonzero" -> "Fxn:self.assertNotEqual(tensor[dst1[i,";
    "Fxn:test_nonzero" -> "Fxn:1]].item(),";
    "Fxn:test_nonzero" -> "Fxn:self.assertNotEqual(tensor[dst1[i,";
    "Fxn:test_nonzero" -> "Fxn:2]].item(),";
    "Fxn:test_deepcopy" -> "Fxn:torch.randn(5,";
    "Fxn:test_deepcopy" -> "Fxn:torch.randn(5,";
    "Fxn:test_deepcopy" -> "Fxn:a.view(25)";
    "Fxn:test_deepcopy" -> "Fxn:[a.storage(),";
    "Fxn:test_deepcopy" -> "Fxn:b.storage()],";
    "Fxn:test_deepcopy" -> "Fxn:deepcopy(q)";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[0],";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[1][0],";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[1][1],";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[1],";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[2],";
    "Fxn:test_deepcopy" -> "Fxn:w[0].add_(1)";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[1][0][i],";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[3],";
    "Fxn:test_deepcopy" -> "Fxn:w[2].sub_(1)";
    "Fxn:test_deepcopy" -> "Fxn:self.assertEqual(w[1][1][i],";
    "Fxn:test_deepcopy_scalar" -> "Fxn:torch.tensor(5)";
    "Fxn:test_deepcopy_scalar" -> "Fxn:self.assertEqual(a.size(),";
    "Fxn:test_deepcopy_scalar" -> "Fxn:deepcopy(a).size())";
    "Fxn:test_deepcopy_scalar" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_deepcopy_scalar" -> "Fxn:deepcopy(a))";
    "Fxn:test_copy" -> "Fxn:torch.randn(5,";
    "Fxn:test_copy" -> "Fxn:a.clone()";
    "Fxn:test_copy" -> "Fxn:copy(a)";
    "Fxn:test_copy" -> "Fxn:b.fill_(1)";
    "Fxn:test_copy" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_pickle" -> "Fxn:torch.randn(5,";
    "Fxn:test_pickle" -> "Fxn:pickle.dumps(a)";
    "Fxn:test_pickle" -> "Fxn:pickle.loads(serialized)";
    "Fxn:test_pickle" -> "Fxn:self.assertEqual(a,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.randn(3,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.norm(x,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.pow(x.abs().pow(4.5).sum(1),";
    "Fxn:test_norm_fastpaths" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.norm(x,";
    "Fxn:test_norm_fastpaths" -> "Fxn:0).type_as(x).sum(1)";
    "Fxn:test_norm_fastpaths" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.norm(x,";
    "Fxn:test_norm_fastpaths" -> "Fxn:x.abs().sum(1)";
    "Fxn:test_norm_fastpaths" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.norm(x,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.sqrt(x.pow(2).sum(1))";
    "Fxn:test_norm_fastpaths" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.norm(x,";
    "Fxn:test_norm_fastpaths" -> "Fxn:torch.pow(x.pow(3).abs().sum(1),";
    "Fxn:test_norm_fastpaths" -> "Fxn:self.assertEqual(result,";
    "Fxn:test_bernoulli" -> "Fxn:torch.ByteTensor(10,";
    "Fxn:isBinary" -> "Fxn:torch.ne(t,";
    "Fxn:isBinary" -> "Fxn:0).mul_(torch.ne(t,";
    "Fxn:isBinary" -> "Fxn:1)).sum()";
    "Fxn:isBinary" -> "Fxn:t.bernoulli_(p)";
    "Fxn:isBinary" -> "Fxn:self.assertTrue(isBinary(t))";
    "Fxn:isBinary" -> "Fxn:torch.rand(10,";
    "Fxn:isBinary" -> "Fxn:t.bernoulli_(p)";
    "Fxn:isBinary" -> "Fxn:self.assertTrue(isBinary(t))";
    "Fxn:isBinary" -> "Fxn:torch.rand(5,";
    "Fxn:isBinary" -> "Fxn:self.assertTrue(isBinary(q.bernoulli()))";
    "Fxn:test_normal" -> "Fxn:torch.Tensor(100,";
    "Fxn:test_normal" -> "Fxn:q.normal_()";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(q.mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(q.std(),";
    "Fxn:test_normal" -> "Fxn:q.normal_(2,";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(q.mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(q.std(),";
    "Fxn:test_normal" -> "Fxn:torch.Tensor(100,";
    "Fxn:test_normal" -> "Fxn:torch.Tensor(100,";
    "Fxn:test_normal" -> "Fxn:torch.normal(mean)";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[:50].mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[50:].mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r.std(),";
    "Fxn:test_normal" -> "Fxn:torch.normal(mean,";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[:50].mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[50:].mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r.std(),";
    "Fxn:test_normal" -> "Fxn:torch.normal(2,";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r.mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[:,";
    "Fxn:test_normal" -> "Fxn::50].std(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[:,";
    "Fxn:test_normal" -> "Fxn:50:].std(),";
    "Fxn:test_normal" -> "Fxn:torch.normal(mean,";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[:50].mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[50:].mean(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[:,";
    "Fxn:test_normal" -> "Fxn::50].std(),";
    "Fxn:test_normal" -> "Fxn:self.assertEqual(r[:,";
    "Fxn:test_normal" -> "Fxn:50:].std(),";
    "Fxn:_test_serialization" -> "Fxn:[torch.randn(5,";
    "Fxn:_test_serialization" -> "Fxn:5).float()";
    "Fxn:_test_serialization" -> "Fxn:[a[0].storage()]";
    "Fxn:_test_serialization" -> "Fxn:[a[0].storage()[1:4]]";
    "Fxn:_test_serialization" -> "Fxn:[torch.arange(1,";
    "Fxn:_test_serialization" -> "Fxn:11).int()]";
    "Fxn:_test_serialization" -> "Fxn:torch.FloatTensor().set_(a[0].storage()[1:4],";
    "Fxn:_test_serialization" -> "Fxn:torch.FloatTensor().set_(a[0].storage()[1:4],";
    "Fxn:_test_serialization" -> "Fxn:[(t1.storage(),";
    "Fxn:_test_serialization" -> "Fxn:t1.storage(),";
    "Fxn:_test_serialization" -> "Fxn:t2.storage())]";
    "Fxn:_test_serialization" -> "Fxn:[a[0].storage()[0:2]]";
    "Fxn:_test_serialization" -> "Fxn:torch.save(...)";
    "Fxn:_test_serialization" -> "Fxn:filecontext_lambda()";
    "Fxn:_test_serialization" -> "Fxn:torch.save(b,";
    "Fxn:_test_serialization" -> "Fxn:f.seek(0)";
    "Fxn:_test_serialization" -> "Fxn:torch.load(handle)";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(b,";
    "Fxn:_test_serialization" -> "Fxn:self.assertTrue(isinstance(c[0],";
    "Fxn:_test_serialization" -> "Fxn:self.assertTrue(isinstance(c[1],";
    "Fxn:_test_serialization" -> "Fxn:self.assertTrue(isinstance(c[2],";
    "Fxn:_test_serialization" -> "Fxn:self.assertTrue(isinstance(c[3],";
    "Fxn:_test_serialization" -> "Fxn:self.assertTrue(isinstance(c[4],";
    "Fxn:_test_serialization" -> "Fxn:c[0].fill_(10)";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(c[0],";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(c[4],";
    "Fxn:_test_serialization" -> "Fxn:torch.FloatStorage(25).fill_(10),";
    "Fxn:_test_serialization" -> "Fxn:c[1].fill_(20)";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(c[1],";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(c[4][1:4],";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(views[0]._cdata,";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(views[0],";
    "Fxn:_test_serialization" -> "Fxn:self.assertNotEqual(views[0]._cdata,";
    "Fxn:_test_serialization" -> "Fxn:self.assertEqual(rootview.data_ptr(),";
    "Fxn:_test_serialization" -> "Fxn:c[0].data_ptr())";
    "Fxn:test_serialization" -> "Fxn:self._test_serialization(tempfile.NamedTemporaryFile)";
    "Fxn:test_serialization_filelike" -> "Fxn:self._test_serialization(BytesIOContext,";
    "Fxn:_test_serialization_offset" -> "Fxn:torch.randn(5,";
    "Fxn:_test_serialization_offset" -> "Fxn:tempfile.TemporaryFile()";
    "Fxn:_test_serialization_offset" -> "Fxn:pickle.dump(i,";
    "Fxn:_test_serialization_offset" -> "Fxn:torch.save(a,";
    "Fxn:_test_serialization_offset" -> "Fxn:f.seek(0)";
    "Fxn:_test_serialization_offset" -> "Fxn:pickle.load(f)";
    "Fxn:_test_serialization_offset" -> "Fxn:torch.load(f)";
    "Fxn:_test_serialization_offset" -> "Fxn:self.assertTrue(torch.equal(a,";
    "Fxn:_test_serialization_offset" -> "Fxn:self.assertEqual(i,";
    "Fxn:test_serialization_offset" -> "Fxn:self._test_serialization_offset(tempfile.TemporaryFile)";
    "Fxn:test_serialization_offset_filelike" -> "Fxn:self._test_serialization_offset(BytesIOContext)";
    "Fxn:test_half_tensor" -> "Fxn:torch.randn(5,";
    "Fxn:test_half_tensor" -> "Fxn:5).float()";
    "Fxn:test_half_tensor" -> "Fxn:torch.randn(5,";
    "Fxn:test_half_tensor" -> "Fxn:5).float()";
    "Fxn:test_half_tensor" -> "Fxn:x.half(),";
    "Fxn:test_half_tensor" -> "Fxn:y.half()";
    "Fxn:test_half_tensor" -> "Fxn:self.assertEqual(x.half().float(),";
    "Fxn:test_half_tensor" -> "Fxn:torch.Tensor(5,";
    "Fxn:test_half_tensor" -> "Fxn:self.assertEqual(z.copy_(xh),";
    "Fxn:test_half_tensor" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_half_tensor" -> "Fxn:torch.save(xh,";
    "Fxn:test_half_tensor" -> "Fxn:f.seek(0)";
    "Fxn:test_half_tensor" -> "Fxn:torch.load(f)";
    "Fxn:test_half_tensor" -> "Fxn:self.assertEqual(xh.float(),";
    "Fxn:test_half_tensor" -> "Fxn:xh2.float())";
    "Fxn:test_half_tensor" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_half_tensor" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_half_tensor_cuda" -> "Fxn:torch.randn(5,";
    "Fxn:test_half_tensor_cuda" -> "Fxn:5).half()";
    "Fxn:test_half_tensor_cuda" -> "Fxn:self.assertEqual(x.cuda(),";
    "Fxn:test_half_tensor_cuda" -> "Fxn:x.cuda()";
    "Fxn:test_half_tensor_cuda" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_half_tensor_cuda" -> "Fxn:torch.save(xc,";
    "Fxn:test_half_tensor_cuda" -> "Fxn:f.seek(0)";
    "Fxn:test_half_tensor_cuda" -> "Fxn:torch.load(f)";
    "Fxn:test_half_tensor_cuda" -> "Fxn:self.assertIsInstance(xc2,";
    "Fxn:test_half_tensor_cuda" -> "Fxn:self.assertEqual(xc.float(),";
    "Fxn:test_half_tensor_cuda" -> "Fxn:xc2.float())";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.cuda.FloatTensor(5).fill_(1)";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.cuda.set_device(device_count";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.cuda.FloatTensor(3).fill_(2)";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.cuda.set_device(0)";
    "Fxn:_test_serialization_cuda" -> "Fxn:filecontext_lambda()";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.save(b,";
    "Fxn:_test_serialization_cuda" -> "Fxn:f.seek(0)";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.load(f)";
    "Fxn:_test_serialization_cuda" -> "Fxn:self.assertEqual(b,";
    "Fxn:_test_serialization_cuda" -> "Fxn:self.assertEqual(u0.get_device(),";
    "Fxn:_test_serialization_cuda" -> "Fxn:self.assertEqual(un.get_device(),";
    "Fxn:_test_serialization_cuda" -> "Fxn:@unittest.skipIf(not";
    "Fxn:_test_serialization_cuda" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_serialization_cuda" -> "Fxn:self._test_serialization_cuda(tempfile.NamedTemporaryFile)";
    "Fxn:test_serialization_cuda" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_serialization_cuda" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_serialization_cuda_filelike" -> "Fxn:self._test_serialization_cuda(BytesIOContext)";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:[torch.arange(1";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:i).view(5,";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:5).float()";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:[a[0].storage()]";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:[a[0].storage()[1:4]]";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:download_file('https://download.pytorch.org/test_data/legacy_serialized.pt')";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:torch.load(path)";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertEqual(b,";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertTrue(isinstance(c[0],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertTrue(isinstance(c[1],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertTrue(isinstance(c[2],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertTrue(isinstance(c[3],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertTrue(isinstance(c[4],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:c[0].fill_(10)";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertEqual(c[0],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertEqual(c[4],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:torch.FloatStorage(25).fill_(10),";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:c[1].fill_(20)";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertEqual(c[1],";
    "Fxn:test_serialization_backwards_compat" -> "Fxn:self.assertEqual(c[4][1:4],";
    "Fxn:_test_serialization_container" -> "Fxn:'tmpmodule{}'.format(unique_key)";
    "Fxn:import_module" -> "Fxn:importlib.util.spec_from_file_location(name,";
    "Fxn:import_module" -> "Fxn:importlib.util.module_from_spec(spec)";
    "Fxn:import_module" -> "Fxn:spec.loader.exec_module(module)";
    "Fxn:import_module" -> "Fxn:imp.load_source(name,";
    "Fxn:import_module" -> "Fxn:filecontext_lambda()";
    "Fxn:import_module" -> "Fxn:os.path.join(os.path.dirname(__file__),";
    "Fxn:import_module" -> "Fxn:import_module(tmpmodule_name,";
    "Fxn:import_module" -> "Fxn:torch.save(module.Net(),";
    "Fxn:import_module" -> "Fxn:checkpoint.seek(0)";
    "Fxn:import_module" -> "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:import_module" -> "Fxn:torch.load(checkpoint)";
    "Fxn:import_module" -> "Fxn:self.assertTrue(isinstance(loaded,";
    "Fxn:import_module" -> "Fxn:self.assertEquals(len(w),";
    "Fxn:import_module" -> "Fxn:os.path.join(os.path.dirname(__file__),";
    "Fxn:import_module" -> "Fxn:import_module(tmpmodule_name,";
    "Fxn:import_module" -> "Fxn:checkpoint.seek(0)";
    "Fxn:import_module" -> "Fxn:warnings.catch_warnings(record=True)";
    "Fxn:import_module" -> "Fxn:torch.load(checkpoint)";
    "Fxn:import_module" -> "Fxn:self.assertTrue(isinstance(loaded,";
    "Fxn:import_module" -> "Fxn:self.assertEquals(len(w),";
    "Fxn:import_module" -> "Fxn:self.assertTrue(w[0].category,";
    "Fxn:test_serialization_container" -> "Fxn:self._test_serialization_container('file',";
    "Fxn:test_serialization_container_filelike" -> "Fxn:self._test_serialization_container('filelike',";
    "Fxn:test_serialization_map_location" -> "Fxn:download_file('https://download.pytorch.org/test_data/gpu_tensors.pt')";
    "Fxn:load_bytes" -> "Fxn:io.BytesIO(f.read())";
    "Fxn:load_bytes" -> "Fxn:torch.load(fileobject_lambda(),";
    "Fxn:load_bytes" -> "Fxn:self.assertIsInstance(tensor,";
    "Fxn:load_bytes" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:load_bytes" -> "Fxn:torch.FloatTensor([[1.0,";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:FilelikeMock(b'',";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:torch.randn(3,";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:torch.save(tensor,";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:self.assertTrue(expected_superset.issuperset(filemock.calls))";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:filemock.seek(0)";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:filemock.calls.clear()";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:torch.load(filemock)";
    "Fxn:test_serialization_filelike_api_requirements" -> "Fxn:self.assertTrue(expected_superset.issuperset(filemock.calls))";
    "Fxn:_test_serialization_filelike" -> "Fxn:mock(b'')";
    "Fxn:_test_serialization_filelike" -> "Fxn:torch.save(tensor,";
    "Fxn:_test_serialization_filelike" -> "Fxn:f.seek(0)";
    "Fxn:_test_serialization_filelike" -> "Fxn:mock(f.read())";
    "Fxn:_test_serialization_filelike" -> "Fxn:torch.load(data)";
    "Fxn:_test_serialization_filelike" -> "Fxn:self.assertTrue(torch.equal(tensor,";
    "Fxn:_test_serialization_filelike" -> "Fxn:msg.format(desc))";
    "Fxn:test_serialization_filelike_missing_attrs" -> "Fxn:FilelikeMock(x)),";
    "Fxn:test_serialization_filelike_missing_attrs" -> "Fxn:FilelikeMock(x,";
    "Fxn:test_serialization_filelike_missing_attrs" -> "Fxn:FilelikeMock(x,";
    "Fxn:test_serialization_filelike_missing_attrs" -> "Fxn:torch.randn(3,";
    "Fxn:test_serialization_filelike_missing_attrs" -> "Fxn:self._test_serialization_filelike(to_serialize,";
    "Fxn:test_serialization_filelike_stress" -> "Fxn:torch.randn(11";
    "Fxn:test_serialization_filelike_stress" -> "Fxn:self._test_serialization_filelike(a,";
    "Fxn:test_serialization_filelike_stress" -> "Fxn:FilelikeMock(x,";
    "Fxn:test_serialization_filelike_stress" -> "Fxn:'read()";
    "Fxn:test_serialization_filelike_stress" -> "Fxn:self._test_serialization_filelike(a,";
    "Fxn:test_serialization_filelike_stress" -> "Fxn:FilelikeMock(x,";
    "Fxn:test_serialization_filelike_stress" -> "Fxn:'readinto()";
    "Fxn:test_serialization_filelike_uses_readinto" -> "Fxn:torch.randn(5,";
    "Fxn:test_serialization_filelike_uses_readinto" -> "Fxn:io.BytesIO()";
    "Fxn:test_serialization_filelike_uses_readinto" -> "Fxn:torch.save(a,";
    "Fxn:test_serialization_filelike_uses_readinto" -> "Fxn:f.seek(0)";
    "Fxn:test_serialization_filelike_uses_readinto" -> "Fxn:FilelikeMock(f.read(),";
    "Fxn:test_serialization_filelike_uses_readinto" -> "Fxn:torch.load(data)";
    "Fxn:test_serialization_filelike_uses_readinto" -> "Fxn:self.assertTrue(data.was_called('readinto'))";
    "Fxn:test_from_buffer" -> "Fxn:self.assertEqual(torch.ByteStorage.from_buffer(a).tolist(),";
    "Fxn:test_from_buffer" -> "Fxn:torch.ShortStorage.from_buffer(a,";
    "Fxn:test_from_buffer" -> "Fxn:self.assertEqual(shorts.size(),";
    "Fxn:test_from_buffer" -> "Fxn:self.assertEqual(shorts.tolist(),";
    "Fxn:test_from_buffer" -> "Fxn:torch.IntStorage.from_buffer(a,";
    "Fxn:test_from_buffer" -> "Fxn:self.assertEqual(ints.size(),";
    "Fxn:test_from_buffer" -> "Fxn:self.assertEqual(ints[0],";
    "Fxn:test_from_buffer" -> "Fxn:torch.FloatStorage.from_buffer(f,";
    "Fxn:test_from_buffer" -> "Fxn:self.assertEqual(floats.size(),";
    "Fxn:test_from_buffer" -> "Fxn:self.assertEqual(floats[0],";
    "Fxn:test_from_buffer" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_from_file" -> "Fxn:tempfile.NamedTemporaryFile()";
    "Fxn:test_from_file" -> "Fxn:torch.FloatStorage.from_file(f.name,";
    "Fxn:test_from_file" -> "Fxn:torch.FloatTensor(s1).copy_(torch.randn(size))";
    "Fxn:test_from_file" -> "Fxn:torch.FloatStorage.from_file(f.name,";
    "Fxn:test_from_file" -> "Fxn:torch.FloatTensor(s2)";
    "Fxn:test_from_file" -> "Fxn:self.assertEqual(t1,";
    "Fxn:test_from_file" -> "Fxn:random.uniform(-1,";
    "Fxn:test_from_file" -> "Fxn:t1.fill_(rnum)";
    "Fxn:test_from_file" -> "Fxn:self.assertEqual(t1,";
    "Fxn:test_from_file" -> "Fxn:random.uniform(-1,";
    "Fxn:test_from_file" -> "Fxn:t2.fill_(rnum)";
    "Fxn:test_from_file" -> "Fxn:self.assertEqual(t1,";
    "Fxn:test_print" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_print" -> "Fxn:100).fill_(1)";
    "Fxn:test_print" -> "Fxn:obj.__repr__()";
    "Fxn:test_print" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_print" -> "Fxn:obj.__repr__()";
    "Fxn:test_print" -> "Fxn:torch.Tensor([4,";
    "Fxn:test_print" -> "Fxn:x.__repr__()";
    "Fxn:test_print" -> "Fxn:torch.DoubleTensor([1e-324,";
    "Fxn:test_print" -> "Fxn:x.__repr__()";
    "Fxn:test_sizeof" -> "Fxn:torch.randn(0).storage().__sizeof__()";
    "Fxn:test_sizeof" -> "Fxn:torch.randn(10).storage().__sizeof__()";
    "Fxn:test_sizeof" -> "Fxn:torch.randn(100).storage().__sizeof__()";
    "Fxn:test_sizeof" -> "Fxn:self.assertEqual((sizeof_100";
    "Fxn:test_sizeof" -> "Fxn:self.assertEqual((sizeof_100";
    "Fxn:test_sizeof" -> "Fxn:torch.randn(0).type(torch.ByteTensor).storage().__sizeof__()";
    "Fxn:test_sizeof" -> "Fxn:torch.randn(10).type(torch.ByteTensor).storage().__sizeof__()";
    "Fxn:test_sizeof" -> "Fxn:torch.randn(100).type(torch.ByteTensor).storage().__sizeof__()";
    "Fxn:test_sizeof" -> "Fxn:self.assertEqual((sizeof_100";
    "Fxn:test_sizeof" -> "Fxn:self.assertEqual((sizeof_100";
    "Fxn:test_unsqueeze" -> "Fxn:torch.randn(2,";
    "Fxn:test_unsqueeze" -> "Fxn:x.unsqueeze(1)";
    "Fxn:test_unsqueeze" -> "Fxn:self.assertEqual(y,";
    "Fxn:test_unsqueeze" -> "Fxn:x.view(2,";
    "Fxn:test_unsqueeze" -> "Fxn:x.clone().unsqueeze_(2)";
    "Fxn:test_unsqueeze" -> "Fxn:self.assertEqual(y,";
    "Fxn:test_unsqueeze" -> "Fxn:x.view(2,";
    "Fxn:test_unsqueeze" -> "Fxn:self.assertFalse(x.is_contiguous())";
    "Fxn:test_unsqueeze" -> "Fxn:x.unsqueeze(1)";
    "Fxn:test_unsqueeze" -> "Fxn:self.assertEqual(y,";
    "Fxn:test_unsqueeze" -> "Fxn:x.contiguous().view(2,";
    "Fxn:test_unsqueeze" -> "Fxn:x.clone().unsqueeze_(2)";
    "Fxn:test_unsqueeze" -> "Fxn:self.assertEqual(y,";
    "Fxn:test_unsqueeze" -> "Fxn:x.contiguous().view(2,";
    "Fxn:test_unsqueeze" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_unsqueeze" -> "Fxn:torch.Tensor().unsqueeze(0))";
    "Fxn:test_iter" -> "Fxn:torch.randn(5,";
    "Fxn:test_iter" -> "Fxn:self.assertEqual(sub,";
    "Fxn:test_iter" -> "Fxn:torch.Tensor()";
    "Fxn:test_iter" -> "Fxn:self.assertEqual(list(x),";
    "Fxn:test_accreal_type" -> "Fxn:torch.ones(2,";
    "Fxn:test_accreal_type" -> "Fxn:self.assertIsInstance(x.double().sum().item(),";
    "Fxn:test_accreal_type" -> "Fxn:self.assertIsInstance(x.float().sum().item(),";
    "Fxn:test_accreal_type" -> "Fxn:self.assertIsInstance(x.long().sum().item(),";
    "Fxn:test_accreal_type" -> "Fxn:self.assertIsInstance(x.int().sum().item(),";
    "Fxn:test_accreal_type" -> "Fxn:self.assertIsInstance(x.short().sum().item(),";
    "Fxn:test_accreal_type" -> "Fxn:self.assertIsInstance(x.char().sum().item(),";
    "Fxn:test_accreal_type" -> "Fxn:self.assertIsInstance(x.byte().sum().item(),";
    "Fxn:test_assertEqual" -> "Fxn:torch.FloatTensor([0])";
    "Fxn:test_assertEqual" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_assertEqual" -> "Fxn:torch.autograd.Variable(x)";
    "Fxn:test_assertEqual" -> "Fxn:self.assertEqual(xv,";
    "Fxn:test_assertEqual" -> "Fxn:self.assertEqual(x,";
    "Fxn:test_assertEqual" -> "Fxn:self.assertEqual(xv,";
    "Fxn:test_new" -> "Fxn:torch.autograd.Variable(torch.Tensor())";
    "Fxn:test_new" -> "Fxn:torch.autograd.Variable(torch.randn(4,";
    "Fxn:test_new" -> "Fxn:torch.autograd.Variable(torch.IntTensor([1,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new().shape,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.uint8,";
    "Fxn:test_new" -> "Fxn:x.new(dtype=torch.uint8).dtype)";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(1,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(torch.Size([3,";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.uint8,";
    "Fxn:test_new" -> "Fxn:x.new(1,";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.uint8,";
    "Fxn:test_new" -> "Fxn:x.new(torch.Size([3,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([3,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([3,";
    "Fxn:test_new" -> "Fxn:4]).tolist(),";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new((3,";
    "Fxn:test_new" -> "Fxn:4)).tolist(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.uint8,";
    "Fxn:test_new" -> "Fxn:x.new((3,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([np.int32(3),";
    "Fxn:test_new" -> "Fxn:np.float64(4)]).tolist(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.uint8,";
    "Fxn:test_new" -> "Fxn:x.new([np.int32(3),";
    "Fxn:test_new" -> "Fxn:np.float64(4)],";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(np.array((3,";
    "Fxn:test_new" -> "Fxn:4))).tolist(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.int64,";
    "Fxn:test_new" -> "Fxn:x.new(np.array((3,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new([z[2],";
    "Fxn:test_new" -> "Fxn:3]).tolist(),";
    "Fxn:test_new" -> "Fxn:self.assertIs(torch.uint8,";
    "Fxn:test_new" -> "Fxn:x.new([z[2],";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(size=(3,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(tuple()).shape,";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(y.storage()).data_ptr(),";
    "Fxn:test_new" -> "Fxn:y.data_ptr())";
    "Fxn:test_new" -> "Fxn:self.assertEqual(x.new(y).data_ptr(),";
    "Fxn:test_new" -> "Fxn:y.data_ptr())";
    "Fxn:test_new" -> "Fxn:self.assertIsNot(x.new(y),";
    "Fxn:test_new" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_new" -> "Fxn:x.new(z))";
    "Fxn:test_new" -> "Fxn:self.assertRaises(RuntimeError,";
    "Fxn:test_new" -> "Fxn:x.new(z.storage()))";
    "Fxn:test_empty_like" -> "Fxn:torch.autograd.Variable(torch.Tensor())";
    "Fxn:test_empty_like" -> "Fxn:torch.autograd.Variable(torch.randn(4,";
    "Fxn:test_empty_like" -> "Fxn:torch.autograd.Variable(torch.IntTensor([1,";
    "Fxn:test_empty_like" -> "Fxn:self.assertEqual(torch.empty_like(a).shape,";
    "Fxn:test_empty_like" -> "Fxn:self.assertEqual(torch.empty_like(a).type(),";
    "Fxn:test_empty_like" -> "Fxn:a.type())";
    "Fxn:test_empty_like" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_empty_like" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_pin_memory" -> "Fxn:torch.randn(3,";
    "Fxn:test_pin_memory" -> "Fxn:self.assertFalse(x.is_pinned())";
    "Fxn:test_pin_memory" -> "Fxn:x.pin_memory()";
    "Fxn:test_pin_memory" -> "Fxn:self.assertTrue(pinned.is_pinned())";
    "Fxn:test_pin_memory" -> "Fxn:self.assertEqual(pinned,";
    "Fxn:test_pin_memory" -> "Fxn:self.assertNotEqual(pinned.data_ptr(),";
    "Fxn:test_pin_memory" -> "Fxn:x.data_ptr())";
    "Fxn:test_pin_memory" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy_unresizable" -> "Fxn:np.zeros((2,";
    "Fxn:test_numpy_unresizable" -> "Fxn:torch.from_numpy(x)";
    "Fxn:test_numpy_unresizable" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_numpy_unresizable" -> "Fxn:x.resize((5,";
    "Fxn:test_numpy_unresizable" -> "Fxn:torch.randn(5,";
    "Fxn:test_numpy_unresizable" -> "Fxn:z.numpy()";
    "Fxn:test_numpy_unresizable" -> "Fxn:self.assertRaises(RuntimeError):";
    "Fxn:test_numpy_unresizable" -> "Fxn:z.resize_(10,";
    "Fxn:test_numpy_unresizable" -> "Fxn:self.assertRaises(ValueError):";
    "Fxn:test_numpy_unresizable" -> "Fxn:w.resize((10,";
    "Fxn:test_numpy_unresizable" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_toNumpy" -> "Fxn:torch.randn(sz).mul(255).type(tp)";
    "Fxn:test_toNumpy" -> "Fxn:x.numpy()";
    "Fxn:test_toNumpy" -> "Fxn:self.assertEqual(x[i],";
    "Fxn:test_toNumpy" -> "Fxn:torch.randn(sz";
    "Fxn:test_toNumpy" -> "Fxn:2).mul(255).type(tp)";
    "Fxn:test_toNumpy" -> "Fxn:xm.narrow(0,";
    "Fxn:test_toNumpy" -> "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:test_toNumpy" -> "Fxn:x.numpy()";
    "Fxn:test_toNumpy" -> "Fxn:self.assertEqual(x[i],";
    "Fxn:check2d" -> "Fxn:self.assertEqual(x[i][j],";
    "Fxn:check2d" -> "Fxn:torch.Tensor().type(tp)";
    "Fxn:check2d" -> "Fxn:x.numpy()";
    "Fxn:check2d" -> "Fxn:self.assertEqual(y.size,";
    "Fxn:check2d" -> "Fxn:torch.randn(sz1,";
    "Fxn:check2d" -> "Fxn:sz2).mul(255).type(tp)";
    "Fxn:check2d" -> "Fxn:x.numpy()";
    "Fxn:check2d" -> "Fxn:check2d(x,";
    "Fxn:check2d" -> "Fxn:self.assertTrue(y.flags['C_CONTIGUOUS'])";
    "Fxn:check2d" -> "Fxn:torch.randn(sz1";
    "Fxn:check2d" -> "Fxn:sz2).mul(255).type(tp)";
    "Fxn:check2d" -> "Fxn:xm.narrow(0,";
    "Fxn:check2d" -> "Fxn:x.numpy()";
    "Fxn:check2d" -> "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:check2d" -> "Fxn:check2d(x,";
    "Fxn:check2d" -> "Fxn:self.assertTrue(y.flags['C_CONTIGUOUS'])";
    "Fxn:check2d" -> "Fxn:torch.randn(sz2,";
    "Fxn:check2d" -> "Fxn:sz1).mul(255).type(tp).t()";
    "Fxn:check2d" -> "Fxn:x.numpy()";
    "Fxn:check2d" -> "Fxn:check2d(x,";
    "Fxn:check2d" -> "Fxn:self.assertFalse(y.flags['C_CONTIGUOUS'])";
    "Fxn:check2d" -> "Fxn:torch.randn(sz2";
    "Fxn:check2d" -> "Fxn:sz1).mul(255).type(tp)";
    "Fxn:check2d" -> "Fxn:xm.narrow(0,";
    "Fxn:check2d" -> "Fxn:sz2).t()";
    "Fxn:check2d" -> "Fxn:x.numpy()";
    "Fxn:check2d" -> "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:check2d" -> "Fxn:check2d(x,";
    "Fxn:check2d" -> "Fxn:torch.randn(sz2";
    "Fxn:check2d" -> "Fxn:2).mul(255).type(tp)";
    "Fxn:check2d" -> "Fxn:xm.narrow(0,";
    "Fxn:check2d" -> "Fxn:sz2).narrow(1,";
    "Fxn:check2d" -> "Fxn:sz1).t()";
    "Fxn:check2d" -> "Fxn:x.numpy()";
    "Fxn:check2d" -> "Fxn:self.assertTrue(x.storage_offset()";
    "Fxn:check2d" -> "Fxn:check2d(x,";
    "Fxn:check2d" -> "Fxn:torch.randn(3,";
    "Fxn:check2d" -> "Fxn:4).mul(255).type(tp)";
    "Fxn:check2d" -> "Fxn:x.numpy()";
    "Fxn:check2d" -> "Fxn:self.assertTrue(y.flags.writeable)";
    "Fxn:check2d" -> "Fxn:self.assertTrue(x[0][1]";
    "Fxn:check2d" -> "Fxn:x.t().numpy()";
    "Fxn:check2d" -> "Fxn:self.assertTrue(y.flags.writeable)";
    "Fxn:check2d" -> "Fxn:self.assertTrue(x[0][1]";
    "Fxn:test_dlpack_conversion" -> "Fxn:torch.randn(1,";
    "Fxn:test_dlpack_conversion" -> "Fxn:4).type('torch.FloatTensor')";
    "Fxn:test_dlpack_conversion" -> "Fxn:from_dlpack(to_dlpack(x))";
    "Fxn:test_dlpack_conversion" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_dlpack_conversion" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_dlpack_conversion" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_dlpack_cuda" -> "Fxn:torch.randn(1,";
    "Fxn:test_dlpack_cuda" -> "Fxn:4).cuda()";
    "Fxn:test_dlpack_cuda" -> "Fxn:from_dlpack(to_dlpack(x))";
    "Fxn:test_dlpack_cuda" -> "Fxn:self.assertEqual(z,";
    "Fxn:test_dlpack_cuda" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_from_numpy" -> "Fxn:np.array([1,";
    "Fxn:test_from_numpy" -> "Fxn:torch.from_numpy(array)";
    "Fxn:test_from_numpy" -> "Fxn:self.assertEqual(tensor_from_array[i],";
    "Fxn:test_from_numpy" -> "Fxn:np.linspace(1,";
    "Fxn:test_from_numpy" -> "Fxn:torch.arange(1,";
    "Fxn:test_from_numpy" -> "Fxn:126).view(5,";
    "Fxn:test_from_numpy" -> "Fxn:self.assertEqual(torch.from_numpy(x),";
    "Fxn:test_from_numpy" -> "Fxn:np.linspace(1,";
    "Fxn:test_from_numpy" -> "Fxn:torch.arange(1,";
    "Fxn:test_from_numpy" -> "Fxn:26).view(5,";
    "Fxn:test_from_numpy" -> "Fxn:5).t()";
    "Fxn:test_from_numpy" -> "Fxn:self.assertEqual(torch.from_numpy(x.T),";
    "Fxn:test_from_numpy" -> "Fxn:np.linspace(1,";
    "Fxn:test_from_numpy" -> "Fxn:torch.arange(1,";
    "Fxn:test_from_numpy" -> "Fxn:126).view(5,";
    "Fxn:test_from_numpy" -> "Fxn:self.assertEqual(torch.from_numpy(x),";
    "Fxn:test_from_numpy" -> "Fxn:np.zeros((0,";
    "Fxn:test_from_numpy" -> "Fxn:self.assertEqual(torch.from_numpy(x).shape,";
    "Fxn:test_from_numpy" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:np.array([1,";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.DoubleTensor(array)";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:self.assertEqual(tensor[i],";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.cuda.DoubleTensor(array)";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:self.assertEqual(tensor[i],";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.FloatTensor(array)";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:self.assertEqual(tensor[i],";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.HalfTensor(array)";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:self.assertEqual(tensor[i],";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.cuda.is_available():";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.cuda.FloatTensor(array)";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:self.assertEqual(tensor[i],";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:torch.cuda.HalfTensor(array)";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:self.assertEqual(tensor[i],";
    "Fxn:test_ctor_with_numpy_array" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy_index" -> "Fxn:np.int32([0,";
    "Fxn:test_numpy_index" -> "Fxn:torch.randn(5,";
    "Fxn:test_numpy_index" -> "Fxn:self.assertFalse(isinstance(idx,";
    "Fxn:test_numpy_index" -> "Fxn:self.assertEqual(x[idx],";
    "Fxn:test_numpy_index" -> "Fxn:x[int(idx)])";
    "Fxn:test_numpy_index" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.dtype(dtype).kind";
    "Fxn:test_numpy_array_interface" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:4]).type(tp)";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.array([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:-4]).type(tp)";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.array([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.asarray(x)";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertIsInstance(asarray,";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(asarray.dtype,";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(asarray[i],";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.abs(x)";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.abs(array)";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertIsInstance(abs_x,";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(abs_x[i],";
    "Fxn:test_numpy_array_interface" -> "Fxn:torch.IntTensor([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.asarray(x,";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(asarray.dtype,";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.dtype(dtype).kind";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.array([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(asarray[i],";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(asarray[i],";
    "Fxn:test_numpy_array_interface" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:4]).type(tp)";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.array([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:ufunc(x)";
    "Fxn:test_numpy_array_interface" -> "Fxn:ufunc(array)";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertIsInstance(res_x,";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(res_x[i],";
    "Fxn:test_numpy_array_interface" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:4]).type(tp)";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.array([1,";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.greater_equal(x,";
    "Fxn:test_numpy_array_interface" -> "Fxn:np.greater_equal(array,";
    "Fxn:test_numpy_array_interface" -> "Fxn:2).astype('uint8')";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertIsInstance(geq2_x,";
    "Fxn:test_numpy_array_interface" -> "Fxn:self.assertEqual(geq2_x[i],";
    "Fxn:test_error_msg_type_translation" -> "Fxn:self.assertRaisesRegex(";
    "Fxn:test_error_msg_type_translation" -> "Fxn:'(?=.*torch\.DoubleTensor)(?=.*torch\.LongTensor)'):";
    "Fxn:test_error_msg_type_translation" -> "Fxn:torch.autograd.Variable(torch.randn(1,";
    "Fxn:test_error_msg_type_translation" -> "Fxn:6).double())";
    "Fxn:test_error_msg_type_translation" -> "Fxn:torch.zeros(1,";
    "Fxn:test_error_msg_type_translation" -> "Fxn:3).long()";
    "Fxn:test_error_msg_type_translation" -> "Fxn:torch.nn.Conv2d(1,";
    "Fxn:test_error_msg_type_translation" -> "Fxn:model(input)";
    "Fxn:test_comparison_ops" -> "Fxn:torch.randn(5,";
    "Fxn:test_comparison_ops" -> "Fxn:torch.randn(5,";
    "Fxn:test_comparison_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_comparison_ops" -> "Fxn:self.assertEqual(x[idx]";
    "Fxn:test_comparison_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_comparison_ops" -> "Fxn:self.assertEqual(x[idx]";
    "Fxn:test_comparison_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_comparison_ops" -> "Fxn:self.assertEqual(x[idx]";
    "Fxn:test_comparison_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_comparison_ops" -> "Fxn:self.assertEqual(x[idx]";
    "Fxn:test_comparison_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_comparison_ops" -> "Fxn:self.assertEqual(x[idx]";
    "Fxn:test_comparison_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_comparison_ops" -> "Fxn:self.assertEqual(x[idx]";
    "Fxn:test_bitwise_ops" -> "Fxn:torch.randn(5,";
    "Fxn:test_bitwise_ops" -> "Fxn:5).gt(0)";
    "Fxn:test_bitwise_ops" -> "Fxn:torch.randn(5,";
    "Fxn:test_bitwise_ops" -> "Fxn:5).gt(0)";
    "Fxn:test_bitwise_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertTrue(x[idx]";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertFalse(x[idx]";
    "Fxn:test_bitwise_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertTrue(x[idx]";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertFalse(x[idx]";
    "Fxn:test_bitwise_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertTrue(x[idx]";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertFalse(x[idx]";
    "Fxn:test_bitwise_ops" -> "Fxn:iter_indices(x):";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertEqual(1";
    "Fxn:test_bitwise_ops" -> "Fxn:x.clone()";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertEqual(x_clone,";
    "Fxn:test_bitwise_ops" -> "Fxn:x.clone()";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertEqual(x_clone,";
    "Fxn:test_bitwise_ops" -> "Fxn:x.clone()";
    "Fxn:test_bitwise_ops" -> "Fxn:self.assertEqual(x_clone,";
    "Fxn:test_invert" -> "Fxn:torch.ByteTensor([0,";
    "Fxn:test_invert" -> "Fxn:self.assertEqual((~x).tolist(),";
    "Fxn:test_apply" -> "Fxn:torch.arange(1,";
    "Fxn:test_apply" -> "Fxn:x.clone().apply_(lambda";
    "Fxn:test_apply" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_apply" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_apply" -> "Fxn:x.apply_(lambda";
    "Fxn:test_map" -> "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:test_map" -> "Fxn:torch.autograd.Variable(torch.randn(3))";
    "Fxn:test_map" -> "Fxn:x.clone()";
    "Fxn:test_map" -> "Fxn:res.map_(y,";
    "Fxn:test_map" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_map" -> "Fxn:self.assertRaisesRegex(TypeError,";
    "Fxn:test_map" -> "Fxn:res.map_(y,";
    "Fxn:test_map2" -> "Fxn:torch.autograd.Variable(torch.randn(3,";
    "Fxn:test_map2" -> "Fxn:torch.autograd.Variable(torch.randn(3))";
    "Fxn:test_map2" -> "Fxn:torch.autograd.Variable(torch.randn(1,";
    "Fxn:test_map2" -> "Fxn:x.clone()";
    "Fxn:test_map2" -> "Fxn:res.map2_(y,";
    "Fxn:test_map2" -> "Fxn:self.assertEqual(res,";
    "Fxn:test_map2" -> "Fxn:self.assertRaisesRegex(";
    "Fxn:test_map2" -> "Fxn:res.map2_(y,";
    "Fxn:test_Size" -> "Fxn:torch.Size([1,";
    "Fxn:test_Size" -> "Fxn:self.assertIsInstance(x,";
    "Fxn:test_Size" -> "Fxn:self.assertEqual(x[0],";
    "Fxn:test_Size" -> "Fxn:self.assertEqual(x[1],";
    "Fxn:test_Size" -> "Fxn:self.assertEqual(x[2],";
    "Fxn:test_Size" -> "Fxn:self.assertEqual(len(x),";
    "Fxn:test_Size" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_Size" -> "Fxn:torch.Size(torch.ones(3)))";
    "Fxn:test_Size" -> "Fxn:self.assertIsInstance(x";
    "Fxn:test_Size" -> "Fxn:self.assertIsInstance(x[:-1],";
    "Fxn:test_Size" -> "Fxn:self.assertIsInstance(x";
    "Fxn:test_Size" -> "Fxn:THTensor_(copyTranspose)";
    "Fxn:test_Size" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_big_transpose" -> "Fxn:torch.rand(456,";
    "Fxn:test_big_transpose" -> "Fxn:t.t().contiguous()";
    "Fxn:test_big_transpose" -> "Fxn:torch.from_numpy(t.numpy().transpose())";
    "Fxn:test_big_transpose" -> "Fxn:self.assertEqual(t1,";
    "Fxn:test_inplace_division" -> "Fxn:torch.rand(5,";
    "Fxn:test_inplace_division" -> "Fxn:self.assertEqual(id_before,";
    "Fxn:test_simple_scalar_cast" -> "Fxn:[torch.Tensor([1.5]),";
    "Fxn:test_simple_scalar_cast" -> "Fxn:torch.zeros(1,";
    "Fxn:test_simple_scalar_cast" -> "Fxn:self.assertEqual(int(tensor),";
    "Fxn:test_simple_scalar_cast" -> "Fxn:self.assertEqual(float(tensor),";
    "Fxn:test_simple_scalar_cast" -> "Fxn:self.assertEqual(long(tensor),";
    "Fxn:test_simple_scalar_cast" -> "Fxn:long(value))";
    "Fxn:test_simple_scalar_cast" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_simple_scalar_cast" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_simple_scalar_cast" -> "Fxn:self.assertRaises(ValueError,";
    "Fxn:test_simple_scalar_cast" -> "Fxn:long(tensor))";
    "Fxn:test_offset_scalar_cast" -> "Fxn:torch.Tensor([1,";
    "Fxn:test_offset_scalar_cast" -> "Fxn:self.assertEqual(int(y),";
    "Fxn:test_offset_scalar_cast" -> "Fxn:@unittest.skipIf(True,";
    "Fxn:test_set_flush_denormal" -> "Fxn:torch.FloatTensor([1.0,";
    "Fxn:test_set_flush_denormal" -> "Fxn:torch.DoubleTensor([1.0,";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(float_tensor[0],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(float_tensor[1],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(double_tensor[0],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(double_tensor[1],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(double_tensor[2],";
    "Fxn:test_set_flush_denormal" -> "Fxn:torch.set_flush_denormal(True)";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(float_tensor[0],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(float_tensor[1],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(double_tensor[0],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(double_tensor[1],";
    "Fxn:test_set_flush_denormal" -> "Fxn:self.assertEqual(double_tensor[2],";
    "Fxn:test_set_flush_denormal" -> "Fxn:torch.set_flush_denormal(False)";
    "Fxn:test_unique_cpu" -> "Fxn:torch.LongTensor([1,";
    "Fxn:test_unique_cpu" -> "Fxn:torch.LongTensor([1,";
    "Fxn:test_unique_cpu" -> "Fxn:torch.LongTensor([0,";
    "Fxn:test_unique_cpu" -> "Fxn:torch.unique(x)";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(";
    "Fxn:test_unique_cpu" -> "Fxn:expected_unique.tolist(),";
    "Fxn:test_unique_cpu" -> "Fxn:x.unique(return_inverse=True)";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(";
    "Fxn:test_unique_cpu" -> "Fxn:expected_unique.tolist(),";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(expected_inverse.numel(),";
    "Fxn:test_unique_cpu" -> "Fxn:x_inverse.numel())";
    "Fxn:test_unique_cpu" -> "Fxn:x.unique(sorted=True)";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(expected_unique,";
    "Fxn:test_unique_cpu" -> "Fxn:torch.unique(";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(expected_unique,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(expected_inverse,";
    "Fxn:test_unique_cpu" -> "Fxn:x.view(2,";
    "Fxn:test_unique_cpu" -> "Fxn:y.unique(sorted=True,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(expected_unique,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(expected_inverse.view(y.size()),";
    "Fxn:test_unique_cpu" -> "Fxn:torch.unique(";
    "Fxn:test_unique_cpu" -> "Fxn:torch.IntTensor([2,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(torch.IntTensor([1,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(torch.LongTensor([1,";
    "Fxn:test_unique_cpu" -> "Fxn:torch.unique(";
    "Fxn:test_unique_cpu" -> "Fxn:torch.DoubleTensor([2.,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(torch.DoubleTensor([1.5,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(torch.LongTensor([1,";
    "Fxn:test_unique_cpu" -> "Fxn:torch.unique(";
    "Fxn:test_unique_cpu" -> "Fxn:torch.ByteTensor([133,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(torch.ByteTensor([7,";
    "Fxn:test_unique_cpu" -> "Fxn:self.assertEqual(torch.LongTensor([3,";
    "Fxn:test_unique_cpu" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_unique_cpu" -> "Fxn:torch.cuda.is_available(),";
    "Fxn:test_unique_cuda" -> "Fxn:self.assertRaises(";
    "Fxn:test_unique_cuda" -> "Fxn:torch.cuda.LongTensor([0,";
    "Fxn:test_unique_cuda" -> "Fxn:1]).unique())";
    "Fxn:test_unique_cuda" -> "Fxn:self.assertRaises(";
    "Fxn:test_unique_cuda" -> "Fxn:torch.unique(torch.cuda.FloatTensor([0.,";
    "Fxn:neg_dim_test" -> "Fxn:[torch.randn(arg)";
    "Fxn:neg_dim_test" -> "Fxn:torch.randn(*tensor_arg)";
    "Fxn:neg_dim_test" -> "Fxn:arg_constr()))";
    "Fxn:neg_dim_test" -> "Fxn:combinations(range(ndim),";
    "Fxn:neg_dim_test" -> "Fxn:arg_constr()";
    "Fxn:neg_dim_test" -> "Fxn:copy.deepcopy(arg)";
    "Fxn:neg_dim_test" -> "Fxn:name)(*arg)";
    "Fxn:neg_dim_test" -> "Fxn:name)(*arg_neg)";
    "Fxn:neg_dim_test" -> "Fxn:self.assertEqual(a,";
    "Fxn:neg_dim_test" -> "Fxn:x.clone()";
    "Fxn:neg_dim_test" -> "Fxn:'_')(*arg)";
    "Fxn:neg_dim_test" -> "Fxn:x.clone()";
    "Fxn:neg_dim_test" -> "Fxn:'_')(*arg_neg)";
    "Fxn:neg_dim_test" -> "Fxn:self.assertEqual(a,";
    "Fxn:neg_dim_test" -> "Fxn:name)(x,";
    "Fxn:neg_dim_test" -> "Fxn:name)(x,";
    "Fxn:neg_dim_test" -> "Fxn:self.assertEqual(a,";
    "Fxn:idx_tensor" -> "Fxn:torch.LongTensor(*size).random_(0,";
    "Fxn:idx_tensor" -> "Fxn:[(2,";
    "Fxn:idx_tensor" -> "Fxn:idx_tensor((10,";
    "Fxn:idx_tensor" -> "Fxn:idx_tensor((10,),";
    "Fxn:idx_tensor" -> "Fxn:idx_tensor((10,),";
    "Fxn:idx_tensor" -> "Fxn:torch.randn(10,";
    "Fxn:idx_tensor" -> "Fxn:idx_tensor((10,),";
    "Fxn:idx_tensor" -> "Fxn:torch.randn(10,";
    "Fxn:idx_tensor" -> "Fxn:idx_tensor((10,),";
    "Fxn:idx_tensor" -> "Fxn:idx_tensor((10,";
    "Fxn:idx_tensor" -> "Fxn:torch.randn(10,";
    "Fxn:idx_tensor" -> "Fxn:make_neg_dim_test(name,";
    "Fxn:idx_tensor" -> "Fxn:run_tests()";
    "/test/test_utils.py" -> "Import:print_function";
    "/test/test_utils.py" -> "Import:sys";
    "/test/test_utils.py" -> "Import:import";
    "/test/test_utils.py" -> "Import:math";
    "/test/test_utils.py" -> "Import:shutil";
    "/test/test_utils.py" -> "Import:random";
    "/test/test_utils.py" -> "Import:tempfile";
    "/test/test_utils.py" -> "Import:unittest";
    "/test/test_utils.py" -> "Import:traceback";
    "/test/test_utils.py" -> "Import:torch";
    "/test/test_utils.py" -> "Import:torch.utils.data";
    "/test/test_utils.py" -> "Import:torch.cuda";
    "/test/test_utils.py" -> "Import:warnings";
    "/test/test_utils.py" -> "Import:Variable";
    "/test/test_utils.py" -> "Import:Trainer";
    "/test/test_utils.py" -> "Import:torch.utils.trainer.plugins.plugin";
    "/test/test_utils.py" -> "Import:Plugin";
    "/test/test_utils.py" -> "Import:load_lua";
    "/test/test_utils.py" -> "Import:prepare_onnx_paddings";
    "/test/test_utils.py" -> "Import:check_onnx_broadcast";
    "/test/test_utils.py" -> "Import:IS_WINDOWS";
    "/test/test_utils.py" -> "Import:TestCase,";
    "/test/test_utils.py" -> "Import:cffi";
    "/test/test_utils.py" -> "Import:compile_extension";
    "/test/test_utils.py" -> "class:SimplePlugin(Plugin):";
    "/test/test_utils.py" -> "class:ModelMock(object):";
    "/test/test_utils.py" -> "class:CriterionMock(object):";
    "/test/test_utils.py" -> "class:OptimizerMock(object):";
    "/test/test_utils.py" -> "class:DatasetMock(object):";
    "/test/test_utils.py" -> "class:TestDataLoader(TestCase):";
    "/test/test_utils.py" -> "class:TestTrainer(TestCase):";
    "/test/test_utils.py" -> "class:TestFFI(TestCase):";
    "/test/test_utils.py" -> "Import:cpulib";
    "/test/test_utils.py" -> "Import:gpulib";
    "/test/test_utils.py" -> "class:TestLuaReader(TestCase):";
    "/test/test_utils.py" -> "class:TestONNXUtils(TestCase):";
    "class:SimplePlugin(Plugin):" -> "Fxn:__init__";
    "class:SimplePlugin(Plugin):" -> "Fxn:register";
    "class:SimplePlugin(Plugin):" -> "Fxn:iteration";
    "class:SimplePlugin(Plugin):" -> "Fxn:epoch";
    "class:SimplePlugin(Plugin):" -> "Fxn:batch";
    "class:SimplePlugin(Plugin):" -> "Fxn:update";
    "Fxn:__init__" -> "Fxn:self).__init__(interval)";
    "class:ModelMock(object):" -> "Fxn:__init__";
    "class:ModelMock(object):" -> "Fxn:__call__";
    "Fxn:__init__" -> "Fxn:Variable(torch.ones(1,";
    "class:CriterionMock(object):" -> "Fxn:__init__";
    "class:CriterionMock(object):" -> "Fxn:__call__";
    "class:OptimizerMock(object):" -> "Fxn:__init__";
    "class:OptimizerMock(object):" -> "Fxn:step";
    "class:OptimizerMock(object):" -> "Fxn:zero_grad";
    "Fxn:step" -> "Fxn:closure()";
    "class:DatasetMock(object):" -> "Fxn:__iter__";
    "class:DatasetMock(object):" -> "Fxn:__len__";
    "Fxn:__iter__" -> "Fxn:torch.randn(2,";
    "Fxn:__iter__" -> "Fxn:torch.randperm(10)[:2]";
    "class:TestDataLoader(TestCase):" -> "Fxn:setUp";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_single_keep";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_single_drop";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_multi_keep";
    "class:TestDataLoader(TestCase):" -> "Fxn:test_multi_drop";
    "Fxn:setUp" -> "Fxn:torch.randn(5,";
    "Fxn:test_single_keep" -> "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:test_single_keep" -> "Fxn:self.assertEqual(len(list(dataiter)),";
    "Fxn:test_single_drop" -> "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:test_single_drop" -> "Fxn:self.assertEqual(len(list(dataiter)),";
    "Fxn:test_single_drop" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_multi_keep" -> "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:test_multi_keep" -> "Fxn:self.assertEqual(len(list(dataiter)),";
    "Fxn:test_multi_keep" -> "Fxn:@unittest.skipIf(IS_WINDOWS,";
    "Fxn:test_multi_drop" -> "Fxn:torch.utils.data.DataLoader(self.dataset,";
    "Fxn:test_multi_drop" -> "Fxn:self.assertEqual(len(list(dataiter)),";
    "class:TestTrainer(TestCase):" -> "Fxn:setUp";
    "class:TestTrainer(TestCase):" -> "Fxn:test_register_plugin";
    "class:TestTrainer(TestCase):" -> "Fxn:test_optimizer_step";
    "class:TestTrainer(TestCase):" -> "Fxn:test_plugin_interval";
    "class:TestTrainer(TestCase):" -> "Fxn:test_model_called";
    "class:TestTrainer(TestCase):" -> "Fxn:test_model_gradient";
    "Fxn:setUp" -> "Fxn:OptimizerMock()";
    "Fxn:setUp" -> "Fxn:Trainer(ModelMock(),";
    "Fxn:setUp" -> "Fxn:CriterionMock(),";
    "Fxn:setUp" -> "Fxn:DatasetMock())";
    "Fxn:test_register_plugin" -> "Fxn:SimplePlugin(interval)";
    "Fxn:test_register_plugin" -> "Fxn:self.trainer.register_plugin(simple_plugin)";
    "Fxn:test_register_plugin" -> "Fxn:self.assertEqual(simple_plugin.trainer,";
    "Fxn:test_optimizer_step" -> "Fxn:self.trainer.run(epochs=1)";
    "Fxn:test_optimizer_step" -> "Fxn:self.assertEqual(self.trainer.optimizer.num_steps,";
    "Fxn:test_plugin_interval" -> "Fxn:self.setUp()";
    "Fxn:test_plugin_interval" -> "Fxn:SimplePlugin(interval)";
    "Fxn:test_plugin_interval" -> "Fxn:self.trainer.register_plugin(simple_plugin)";
    "Fxn:test_plugin_interval" -> "Fxn:self.trainer.run(epochs=self.num_epochs)";
    "Fxn:test_plugin_interval" -> "Fxn:math.floor(num_triggers";
    "Fxn:test_plugin_interval" -> "Fxn:self.assertEqual(num_calls,";
    "Fxn:test_model_called" -> "Fxn:self.trainer.run(epochs=self.num_epochs)";
    "Fxn:test_model_called" -> "Fxn:self.assertEqual(num_model_calls,";
    "Fxn:test_model_called" -> "Fxn:self.assertEqual(num_calls,";
    "Fxn:test_model_called" -> "Fxn:self.assertLessEqual(lower_bound,";
    "Fxn:test_model_called" -> "Fxn:self.assertLessEqual(num_calls,";
    "Fxn:test_model_gradient" -> "Fxn:self.trainer.run(epochs=self.num_epochs)";
    "Fxn:test_model_gradient" -> "Fxn:torch.ones(1,";
    "Fxn:test_model_gradient" -> "Fxn:self.assertEqual(output_var.grad.data,";
    "Fxn:test_model_gradient" -> "Fxn:os.path.abspath(os.path.dirname(str(__file__)))";
    "class:TestFFI(TestCase):" -> "Fxn:setUp";
    "class:TestFFI(TestCase):" -> "Fxn:tearDown";
    "class:TestFFI(TestCase):" -> "Fxn:test_cpu";
    "class:TestFFI(TestCase):" -> "Fxn:test_gpu";
    "Fxn:setUp" -> "Fxn:tempfile.mkdtemp()";
    "Fxn:setUp" -> "Fxn:os.chdir(self.tmpdir)";
    "Fxn:setUp" -> "Fxn:sys.path.append(self.tmpdir)";
    "Fxn:tearDown" -> "Fxn:shutil.rmtree(self.tmpdir)";
    "Fxn:tearDown" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_cpu" -> "Fxn:compile_extension(";
    "Fxn:test_cpu" -> "Fxn:torch.ones(2,";
    "Fxn:test_cpu" -> "Fxn:2).float()";
    "Fxn:test_cpu" -> "Fxn:cpulib.good_func(tensor,";
    "Fxn:test_cpu" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_cpu" -> "Fxn:torch.ones(2,";
    "Fxn:test_cpu" -> "Fxn:cpulib.new_tensor(4)";
    "Fxn:test_cpu" -> "Fxn:self.assertEqual(new_tensor,";
    "Fxn:test_cpu" -> "Fxn:torch.ones(4,";
    "Fxn:test_cpu" -> "Fxn:cpulib.int_to_float(5)";
    "Fxn:test_cpu" -> "Fxn:self.assertIs(type(f),";
    "Fxn:test_cpu" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_cpu" -> "Fxn:cpulib.good_func(tensor.double(),";
    "Fxn:test_cpu" -> "Fxn:self.assertRaises(torch.FatalError,";
    "Fxn:test_cpu" -> "Fxn:cpulib.bad_func(tensor,";
    "Fxn:test_cpu" -> "Fxn:@unittest.skipIf(not";
    "Fxn:test_gpu" -> "Fxn:compile_extension(";
    "Fxn:test_gpu" -> "Fxn:torch.ones(2,";
    "Fxn:test_gpu" -> "Fxn:2).float()";
    "Fxn:test_gpu" -> "Fxn:gpulib.good_func(tensor,";
    "Fxn:test_gpu" -> "Fxn:self.assertEqual(tensor,";
    "Fxn:test_gpu" -> "Fxn:torch.ones(2,";
    "Fxn:test_gpu" -> "Fxn:tensor.cuda().fill_(1)";
    "Fxn:test_gpu" -> "Fxn:gpulib.cuda_func(ctensor,";
    "Fxn:test_gpu" -> "Fxn:self.assertEqual(ctensor,";
    "Fxn:test_gpu" -> "Fxn:torch.ones(2,";
    "Fxn:test_gpu" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_gpu" -> "Fxn:gpulib.cuda_func(tensor,";
    "Fxn:test_gpu" -> "Fxn:self.assertRaises(TypeError,";
    "Fxn:test_gpu" -> "Fxn:gpulib.cuda_func(ctensor.storage(),";
    "class:TestLuaReader(TestCase):" -> "Fxn:_module_test";
    "class:TestLuaReader(TestCase):" -> "Fxn:do_test";
    "class:TestLuaReader(TestCase):" -> "Fxn:_criterion_test";
    "class:TestLuaReader(TestCase):" -> "Fxn:do_test";
    "class:TestLuaReader(TestCase):" -> "Fxn:init";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_Index";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_LookupTable";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_MultiLabelMarginCriterion";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_ClassNLLCriterion";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_SpatialClassNLLCriterion";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_ClassSimplexCriterion";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_CrossEntropyCriterion";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_ParallelCriterion";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_MultiCriterion";
    "class:TestLuaReader(TestCase):" -> "Fxn:_transform_MultiMarginCriterion";
    "Fxn:do_test" -> "Fxn:name)(input)";
    "Fxn:do_test" -> "Fxn:module.forward(input)";
    "Fxn:do_test" -> "Fxn:module.zeroGradParameters()";
    "Fxn:do_test" -> "Fxn:module.backward(input,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(output,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(grad_input,";
    "Fxn:do_test" -> "Fxn:module.parameters()";
    "Fxn:do_test" -> "Fxn:module.parameters()";
    "Fxn:do_test" -> "Fxn:self.assertEqual(params,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(d_params,";
    "Fxn:do_test" -> "Fxn:self.assertFalse('params'";
    "Fxn:do_test" -> "Fxn:self.assertFalse('params'";
    "Fxn:do_test" -> "Fxn:name)(input,";
    "Fxn:do_test" -> "Fxn:module.forward(input,";
    "Fxn:do_test" -> "Fxn:module.backward(input,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(output,";
    "Fxn:do_test" -> "Fxn:self.assertEqual(grad_input,";
    "Fxn:init" -> "Fxn:download_file('https://download.pytorch.org/test_data/legacy_modules.t7')";
    "Fxn:init" -> "Fxn:load_lua(path,";
    "Fxn:init" -> "Fxn:tests['modules'].items():";
    "Fxn:init" -> "Fxn:name.replace('nn.',";
    "Fxn:init" -> "Fxn:cls._module_test(name,";
    "Fxn:init" -> "Fxn:tests['criterions'].items():";
    "Fxn:init" -> "Fxn:name.replace('nn.',";
    "Fxn:init" -> "Fxn:cls._criterion_test(name,";
    "Fxn:_transform_Index" -> "Fxn:input[1].sub(1)]";
    "Fxn:_transform_LookupTable" -> "Fxn:input.sub(1)";
    "Fxn:_transform_MultiLabelMarginCriterion" -> "Fxn:target.sub(1)";
    "Fxn:_transform_ClassNLLCriterion" -> "Fxn:target.sub(1)";
    "Fxn:_transform_SpatialClassNLLCriterion" -> "Fxn:target.sub(1)";
    "Fxn:_transform_ClassSimplexCriterion" -> "Fxn:target.sub(1)";
    "Fxn:_transform_CrossEntropyCriterion" -> "Fxn:target.sub(1)";
    "Fxn:_transform_ParallelCriterion" -> "Fxn:[target[0].sub(1),";
    "Fxn:_transform_MultiCriterion" -> "Fxn:target.sub(1)";
    "Fxn:_transform_MultiMarginCriterion" -> "Fxn:target.sub(1)";
    "class:TestONNXUtils(TestCase):" -> "Fxn:test_prepare_onnx_paddings";
    "class:TestONNXUtils(TestCase):" -> "Fxn:test_check_onnx_broadcast";
    "class:TestONNXUtils(TestCase):" -> "Fxn:try_check_onnx_broadcast";
    "Fxn:test_prepare_onnx_paddings" -> "Fxn:prepare_onnx_paddings(len(sizes),";
    "Fxn:test_prepare_onnx_paddings" -> "Fxn:self.assertEqual(paddings,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:self.assertEqual(broadcast,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:self.assertEqual(fail,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:numel(dims2)";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:numel(dims2)";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:numel(dims2)";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:numel(s2)";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:try_check_onnx_broadcast(dims1,";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:TestLuaReader.init()";
    "Fxn:try_check_onnx_broadcast" -> "Fxn:run_tests()";
    "/test/cpp_extensions/setup.py" -> "Import:torch.cuda";
    "/test/cpp_extensions/setup.py" -> "Import:setup";
    "/test/cpp_extensions/setup.py" -> "Import:CppExtension,";
    "/test/data/network1.py" -> "Import:torch.nn";
    "/test/data/network1.py" -> "class:Net(nn.Module):";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "/test/data/network2.py" -> "Import:torch.nn";
    "/test/data/network2.py" -> "class:Net(nn.Module):";
    "class:Net(nn.Module):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Linear(10,";
    "Fxn:__init__" -> "Fxn:nn.ReLU()";
    "/test/error_messages/storage.py" -> "Import:torch";
    "/test/error_messages/storage.py" -> "Fxn:check_error";
    "/test/error_messages/storage.py" -> "Fxn:assign";
    "/test/optim/test.py" -> "Import:json";
    "/test/optim/test.py" -> "Import:torch";
    "/test/optim/test.py" -> "Import:torch.legacy.optim";
    "/test/optim/test.py" -> "Import:pprint";
    "/test/optim/test.py" -> "Fxn:rosenbrock";
    "/test/optim/test.py" -> "Fxn:drosenbrock";
    "/tools/autograd/gen_autograd.py" -> "Import:argparse";
    "/tools/autograd/gen_autograd.py" -> "Import:copy";
    "/tools/autograd/gen_autograd.py" -> "Import:import";
    "/tools/autograd/gen_autograd.py" -> "Import:yaml";
    "/tools/autograd/gen_autograd.py" -> "Import:defaultdict";
    "/tools/autograd/gen_autograd.py" -> "Import:YamlLoader,";
    "/tools/autograd/gen_autograd.py" -> "Fxn:format_return_type";
    "/tools/autograd/gen_autograd.py" -> "Fxn:load_aten_declarations";
    "/tools/autograd/gen_autograd.py" -> "Fxn:load_deprecated_signatures";
    "/tools/autograd/gen_autograd.py" -> "Fxn:group_declarations_by_signature";
    "/tools/autograd/gen_autograd.py" -> "Fxn:get_signature";
    "/tools/autograd/gen_autograd.py" -> "Fxn:gen_autograd";
    "/tools/autograd/gen_autograd.py" -> "Import:load_derivatives";
    "/tools/autograd/gen_autograd.py" -> "Import:gen_variable_type";
    "/tools/autograd/gen_autograd.py" -> "Import:gen_autograd_functions";
    "/tools/autograd/gen_autograd.py" -> "Import:gen_python_functions";
    "/tools/autograd/gen_autograd.py" -> "Fxn:main";
    "/tools/autograd/gen_autograd_functions.py" -> "Import:.utils";
    "/tools/autograd/gen_autograd_functions.py" -> "Import:nested_dict,";
    "/tools/autograd/gen_autograd_functions.py" -> "Import:VIEW_FUNCTIONS,";
    "/tools/autograd/gen_autograd_functions.py" -> "Import:IDENT_REGEX";
    "/tools/autograd/gen_autograd_functions.py" -> "Fxn:gen_autograd_functions";
    "/tools/autograd/gen_autograd_functions.py" -> "Fxn:process_function";
    "/tools/autograd/gen_autograd_functions.py" -> "Fxn:save_arg";
    "/tools/autograd/gen_autograd_functions.py" -> "Fxn:emit_derivative";
    "/tools/autograd/gen_autograd_functions.py" -> "Fxn:uses_ident";
    "/tools/autograd/gen_autograd_functions.py" -> "Fxn:uses_retain_variables";
    "/tools/autograd/gen_autograd_functions.py" -> "Fxn:uses_single_grad";
    "/tools/autograd/gen_python_functions.py" -> "Import:defaultdict";
    "/tools/autograd/gen_python_functions.py" -> "Import:.nested_dict";
    "/tools/autograd/gen_python_functions.py" -> "Import:nested_dict";
    "/tools/autograd/gen_python_functions.py" -> "Import:import_module";
    "/tools/autograd/gen_python_functions.py" -> "Import:template_path";
    "/tools/autograd/gen_python_functions.py" -> "Import:write";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:should_generate_python_binding";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:gen_py_variable_methods";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:should_bind";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:gen_py_nn_functions";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:should_bind";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:gen_py_torch_functions";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:should_bind";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:group_declarations_by_name";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:get_type_default";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:create_python_bindings";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:first_tensor_arg";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:auto_gpu";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:emit_single_dispatch";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:is_output";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:parse_arg";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:append_actuals_formals";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:emit_dispatch";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:get_python_binding_arguments";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:process_function";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:group_declarations";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:get_python_signature";
    "/tools/autograd/gen_python_functions.py" -> "Fxn:get_typed_arg";
    "/tools/autograd/gen_variable_type.py" -> "Import:print_function";
    "/tools/autograd/gen_variable_type.py" -> "Import:import";
    "/tools/autograd/gen_variable_type.py" -> "Import:sys";
    "/tools/autograd/gen_variable_type.py" -> "Import:CodeTemplate,";
    "/tools/autograd/gen_variable_type.py" -> "Import:VIEW_FUNCTIONS,";
    "/tools/autograd/gen_variable_type.py" -> "Import:uses_single_grad";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:gen_variable_type";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_method_definition";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_body";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:is_differentiable";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:setup_derivative";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:error_msg";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:find_args_with_derivatives";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_check_no_requires_grad";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:save_variables";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:reference_args";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:get_trace_outputs";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_record_trace";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:declare_returned_variables";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:wrap_output";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_call";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:tie_return_values";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:get_return_value";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_history";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_save_outputs";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_check_inplace";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:emit_increment_version";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:unpack_args";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:requires_unpack";
    "/tools/autograd/gen_variable_type.py" -> "Fxn:dispatch_strategy";
    "/tools/autograd/load_derivatives.py" -> "Import:defaultdict";
    "/tools/autograd/load_derivatives.py" -> "Import:copy";
    "/tools/autograd/load_derivatives.py" -> "Import:import";
    "/tools/autograd/load_derivatives.py" -> "Import:yaml";
    "/tools/autograd/load_derivatives.py" -> "Import:YamlLoader";
    "/tools/autograd/load_derivatives.py" -> "Import:IDENT_REGEX,";
    "/tools/autograd/load_derivatives.py" -> "Import:HARDCODED_DIFFERENTIABLE_OUTPUTS";
    "/tools/autograd/load_derivatives.py" -> "Fxn:load_derivatives";
    "/tools/autograd/load_derivatives.py" -> "Fxn:create_autograd_function";
    "/tools/autograd/load_derivatives.py" -> "Fxn:create_derivative";
    "/tools/autograd/load_derivatives.py" -> "Fxn:transform_return";
    "/tools/autograd/load_derivatives.py" -> "Fxn:process_definition";
    "/tools/autograd/load_derivatives.py" -> "Fxn:canonical_declaration";
    "/tools/autograd/load_derivatives.py" -> "Fxn:split_names";
    "/tools/autograd/load_derivatives.py" -> "Fxn:lookup_pred";
    "/tools/autograd/load_derivatives.py" -> "Fxn:check_grad_usage";
    "/tools/autograd/load_derivatives.py" -> "Fxn:set_up_derivatives";
    "/tools/autograd/load_derivatives.py" -> "Fxn:unzip";
    "/tools/autograd/load_derivatives.py" -> "Fxn:ensure_unique_names";
    "/tools/autograd/load_derivatives.py" -> "Fxn:get_signature";
    "/tools/autograd/load_derivatives.py" -> "Fxn:used_gradient_indices";
    "/tools/autograd/load_derivatives.py" -> "Fxn:saved_variables";
    "/tools/autograd/load_derivatives.py" -> "Fxn:repl";
    "/tools/autograd/load_derivatives.py" -> "Fxn:all_saved_variables";
    "/tools/autograd/load_derivatives.py" -> "Fxn:to_camel_case";
    "/tools/autograd/load_derivatives.py" -> "Fxn:match_declarations_with_autograd_functions";
    "/tools/autograd/load_derivatives.py" -> "Fxn:find_function";
    "/tools/autograd/nested_dict.py" -> "class:nested_dict(object):";
    "class:nested_dict(object):" -> "Fxn:__init__";
    "class:nested_dict(object):" -> "Fxn:__contains__";
    "class:nested_dict(object):" -> "Fxn:__getitem__";
    "Fxn:__getitem__" -> "Fxn:self.base.get(x)";
    "/tools/autograd/utils.py" -> "Import:import";
    "/tools/autograd/utils.py" -> "Import:tools.shared.module_loader";
    "/tools/autograd/utils.py" -> "Import:import_module";
    "/tools/autograd/utils.py" -> "Import:nested_dict";
    "/tools/autograd/utils.py" -> "Import:CLoader";
    "/tools/autograd/utils.py" -> "Import:Loader";
    "/tools/autograd/utils.py" -> "Fxn:split_name_params";
    "/tools/autograd/utils.py" -> "Fxn:write";
    "/tools/cwrap/cwrap.py" -> "Import:import";
    "/tools/cwrap/cwrap.py" -> "Import:yaml";
    "/tools/cwrap/cwrap.py" -> "Import:Template";
    "/tools/cwrap/cwrap.py" -> "Import:deepcopy";
    "/tools/cwrap/cwrap.py" -> "Import:ArgcountChecker,";
    "/tools/cwrap/cwrap.py" -> "Import:cwrap_common";
    "/tools/cwrap/cwrap.py" -> "class:cwrap(object):";
    "class:cwrap(object):" -> "Fxn:__init__";
    "class:cwrap(object):" -> "Fxn:wrap_declarations";
    "class:cwrap(object):" -> "Fxn:parse_arguments";
    "class:cwrap(object):" -> "Fxn:search_plugins";
    "class:cwrap(object):" -> "Fxn:get_type_check";
    "class:cwrap(object):" -> "Fxn:get_type_unpack";
    "class:cwrap(object):" -> "Fxn:get_return_wrapper";
    "class:cwrap(object):" -> "Fxn:get_wrapper_template";
    "class:cwrap(object):" -> "Fxn:get_assign_args";
    "class:cwrap(object):" -> "Fxn:get_arg_accessor";
    "class:cwrap(object):" -> "Fxn:wrap_accessor";
    "class:cwrap(object):" -> "Fxn:generate_wrapper";
    "class:cwrap(object):" -> "Fxn:map_selected_arguments";
    "class:cwrap(object):" -> "Fxn:build_option_args";
    "class:cwrap(object):" -> "Fxn:indent_code";
    "class:cwrap(object):" -> "Fxn:generate_option";
    "Fxn:__init__" -> "Fxn:source.replace('.cwrap',";
    "Fxn:__init__" -> "Fxn:[cls()";
    "Fxn:__init__" -> "Fxn:plugin.initialize(self)";
    "Fxn:__init__" -> "Fxn:os.path.dirname(os.path.abspath(source))";
    "Fxn:__init__" -> "Fxn:f.read()";
    "Fxn:__init__" -> "Fxn:self.wrap_declarations(declarations)";
    "Fxn:__init__" -> "Fxn:plugin.process_full_file(wrapper)";
    "Fxn:__init__" -> "Fxn:f.read()";
    "Fxn:__init__" -> "Fxn:{}".format(destination))";
    "Fxn:__init__" -> "Fxn:f.write(wrapper)";
    "Fxn:__init__" -> "Fxn:{}".format(destination))";
    "Fxn:wrap_declarations" -> "Fxn:declarations.split('\n')";
    "Fxn:wrap_declarations" -> "Fxn:yaml.load('\n'.join(declaration_lines))";
    "Fxn:wrap_declarations" -> "Fxn:cwrap_common.set_declaration_defaults(declaration)";
    "Fxn:wrap_declarations" -> "Fxn:plugin.process_declarations(declarations)";
    "Fxn:wrap_declarations" -> "Fxn:self.generate_wrapper(declaration)";
    "Fxn:wrap_declarations" -> "Fxn:plugin.process_wrapper(wrapper,";
    "Fxn:wrap_declarations" -> "Fxn:output.append(wrapper)";
    "Fxn:wrap_declarations" -> "Fxn:declaration_lines.append(line)";
    "Fxn:wrap_declarations" -> "Fxn:os.path.join(self.base_path,";
    "Fxn:wrap_declarations" -> "Fxn:line[6:].strip())";
    "Fxn:wrap_declarations" -> "Fxn:f.read().split('\n')";
    "Fxn:wrap_declarations" -> "Fxn:output.append(line)";
    "Fxn:wrap_declarations" -> "Fxn:'\n'.join(output)";
    "Fxn:parse_arguments" -> "Fxn:arg.partition('";
    "Fxn:parse_arguments" -> "Fxn:new_args.append({'type':";
    "Fxn:parse_arguments" -> "Fxn:arg['arg'].partition('";
    "Fxn:parse_arguments" -> "Fxn:new_args.append(arg)";
    "Fxn:search_plugins" -> "Fxn:fnname)(*args)";
    "Fxn:search_plugins" -> "Fxn:fallback(*args)";
    "Fxn:get_type_check" -> "Fxn:self.search_plugins('get_type_check',";
    "Fxn:get_type_unpack" -> "Fxn:self.search_plugins('get_type_unpack',";
    "Fxn:get_return_wrapper" -> "Fxn:self.search_plugins('get_return_wrapper',";
    "Fxn:get_wrapper_template" -> "Fxn:self.search_plugins('get_wrapper_template',";
    "Fxn:get_assign_args" -> "Fxn:self.search_plugins('get_assign_args',";
    "Fxn:wrap_accessor" -> "Fxn:arg.get('idx')";
    "Fxn:wrap_accessor" -> "Fxn:RuntimeError("Missing";
    "Fxn:wrap_accessor" -> "Fxn:{}'".format(";
    "Fxn:wrap_accessor" -> "Fxn:'PyTuple_GET_ITEM(args,";
    "Fxn:wrap_accessor" -> "Fxn:{})'.format(arg['idx'])";
    "Fxn:wrap_accessor" -> "Fxn:self.search_plugins('get_arg_accessor',";
    "Fxn:generate_wrapper" -> "Fxn:self.generate_option(option,";
    "Fxn:generate_wrapper" -> "Fxn:is_first=(i";
    "Fxn:generate_wrapper" -> "Fxn:plugin.process_option_code(option_wrapper,";
    "Fxn:generate_wrapper" -> "Fxn:self.get_wrapper_template(declaration).substitute(name=declaration['name'],";
    "Fxn:map_selected_arguments" -> "Fxn:self.get_arg_accessor(arg,";
    "Fxn:map_selected_arguments" -> "Fxn:base_fn_name)(arg,";
    "Fxn:map_selected_arguments" -> "Fxn:RuntimeError("Missing";
    "Fxn:map_selected_arguments" -> "Fxn:{}'".format(";
    "Fxn:map_selected_arguments" -> "Fxn:tmpl.substitute(arg=accessor,";
    "Fxn:map_selected_arguments" -> "Fxn:idx=arg.get('idx'))";
    "Fxn:map_selected_arguments" -> "Fxn:plugin_fn_name)(res,";
    "Fxn:map_selected_arguments" -> "Fxn:result.append(res)";
    "Fxn:build_option_args" -> "Fxn:self.get_assign_args(arguments)";
    "Fxn:build_option_args" -> "Fxn:call_arg.append(unpack)";
    "Fxn:build_option_args" -> "Fxn:self.ARG_ASSIGN_TEMPLATE.substitute(";
    "Fxn:build_option_args" -> "Fxn:assignement.append(res)";
    "Fxn:build_option_args" -> "Fxn:call_arg.append(var_name)";
    "Fxn:indent_code" -> "Fxn:s.strip(),";
    "Fxn:indent_code" -> "Fxn:code.split('\n'))";
    "Fxn:indent_code" -> "Fxn:line.count('}')";
    "Fxn:indent_code" -> "Fxn:line.count('{')";
    "Fxn:indent_code" -> "Fxn:line.count('(')";
    "Fxn:indent_code" -> "Fxn:line.count(')')";
    "Fxn:generate_option" -> "Fxn:arg.get('ignore_check')";
    "Fxn:generate_option" -> "Fxn:arg.get('no_idx'),";
    "Fxn:generate_option" -> "Fxn:self.map_selected_arguments('get_type_check',";
    "Fxn:generate_option" -> "Fxn:'.join(arg_checks)";
    "Fxn:generate_option" -> "Fxn:plugin.process_all_checks(arg_checks,";
    "Fxn:generate_option" -> "Fxn:plugin.process_pre_arg_assign(pre_arg_assign,";
    "Fxn:generate_option" -> "Fxn:self.map_selected_arguments('get_type_unpack',";
    "Fxn:generate_option" -> "Fxn:self.build_option_args(option['arguments'],";
    "Fxn:generate_option" -> "Fxn:'.join(call_arg)";
    "Fxn:generate_option" -> "Fxn:plugin.process_all_call_arg(call_arg,";
    "Fxn:generate_option" -> "Fxn:self.get_return_wrapper(option).substitute()";
    "Fxn:generate_option" -> "Fxn:self.FUNCTION_CALL_TEMPLATE.substitute(capture_result='',";
    "Fxn:generate_option" -> "Fxn:self.get_return_wrapper(option).substitute(result='__result')";
    "Fxn:generate_option" -> "Fxn:self.FUNCTION_CALL_TEMPLATE.substitute(capture_result=(option['return']";
    "Fxn:generate_option" -> "Fxn:deepcopy(self.OPTION_CODE_TEMPLATE)";
    "Fxn:generate_option" -> "Fxn:plugin.process_option_code_template(code_template,";
    "Fxn:generate_option" -> "Fxn:Template('\n'.join(code_template))";
    "Fxn:generate_option" -> "Fxn:code_template.substitute(call=call,";
    "Fxn:generate_option" -> "Fxn:self.indent_code(code)";
    "Fxn:generate_option" -> "Fxn:self.indent_code('\n'.join(pre_arg_assign))";
    "Fxn:generate_option" -> "Fxn:self.indent_code('\n'.join(arg_assign))";
    "Fxn:generate_option" -> "Fxn:self.OPTION_TEMPLATE.substitute(";
    "Fxn:generate_option" -> "Fxn:els=('}";
    "/tools/cwrap/__init__.py" -> "Import:cwrap";
    "/tools/cwrap/plugins/ArgcountChecker.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/ArgcountChecker.py" -> "class:ArgcountChecker(CWrapPlugin):";
    "class:ArgcountChecker(CWrapPlugin):" -> "Fxn:process_all_checks";
    "Fxn:process_all_checks" -> "Fxn:option.get('argcount_offset',";
    "Fxn:process_all_checks" -> "Fxn:&&'.format(str(argcount))";
    "/tools/cwrap/plugins/ArgcountSortPlugin.py" -> "Import:import";
    "/tools/cwrap/plugins/ArgcountSortPlugin.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/ArgcountSortPlugin.py" -> "Import:cwrap_common";
    "/tools/cwrap/plugins/ArgcountSortPlugin.py" -> "class:ArgcountSortPlugin(CWrapPlugin):";
    "class:ArgcountSortPlugin(CWrapPlugin):" -> "Fxn:__init__";
    "class:ArgcountSortPlugin(CWrapPlugin):" -> "Fxn:process_declarations";
    "Fxn:process_declarations" -> "Fxn:cwrap_common.sort_by_number_of_options(declaration,";
    "/tools/cwrap/plugins/ArgumentReferences.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/ArgumentReferences.py" -> "Import:Template";
    "/tools/cwrap/plugins/ArgumentReferences.py" -> "class:ArgumentReferences(CWrapPlugin):";
    "class:ArgumentReferences(CWrapPlugin):" -> "Fxn:initialize";
    "class:ArgumentReferences(CWrapPlugin):" -> "Fxn:process_declarations";
    "class:ArgumentReferences(CWrapPlugin):" -> "Fxn:_get_true_idx";
    "class:ArgumentReferences(CWrapPlugin):" -> "Fxn:get_arg_accessor";
    "Fxn:_get_true_idx" -> "Fxn:arg.get('ignore_check',";
    "Fxn:get_arg_accessor" -> "Fxn:arg.get('is_reference',";
    "Fxn:get_arg_accessor" -> "Fxn:self.cwrap.get_arg_accessor(referenced,";
    "/tools/cwrap/plugins/AssertNDim.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/AssertNDim.py" -> "Import:Template";
    "/tools/cwrap/plugins/AssertNDim.py" -> "class:AssertNDim(CWrapPlugin):";
    "class:AssertNDim(CWrapPlugin):" -> "Fxn:process_option_code_template";
    "Fxn:process_option_code_template" -> "Fxn:arg.get('assert_ndim')";
    "Fxn:process_option_code_template" -> "Fxn:arg.get('assign_name',";
    "Fxn:process_option_code_template" -> "Fxn:new_code_pre.append(self.PRE_CODE_TEMPLATE.substitute(op=op,";
    "/tools/cwrap/plugins/AutoGPU.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/AutoGPU.py" -> "class:AutoGPU(CWrapPlugin):";
    "class:AutoGPU(CWrapPlugin):" -> "Fxn:__init__";
    "class:AutoGPU(CWrapPlugin):" -> "Fxn:process_pre_arg_assign";
    "Fxn:process_pre_arg_assign" -> "Fxn:option.get('auto_gpu',";
    "Fxn:process_pre_arg_assign" -> "Fxn:auto_gpu(get_device(args));'";
    "/tools/cwrap/plugins/BeforeAfterCall.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/BeforeAfterCall.py" -> "Import:Template";
    "/tools/cwrap/plugins/BeforeAfterCall.py" -> "class:BeforeAfterCall(CWrapPlugin):";
    "class:BeforeAfterCall(CWrapPlugin):" -> "Fxn:initialize";
    "class:BeforeAfterCall(CWrapPlugin):" -> "Fxn:insert_snippet";
    "class:BeforeAfterCall(CWrapPlugin):" -> "Fxn:process_pre_arg_assign";
    "class:BeforeAfterCall(CWrapPlugin):" -> "Fxn:process_option_code_template";
    "Fxn:insert_snippet" -> "Fxn:option.get(name)";
    "Fxn:insert_snippet" -> "Fxn:prepend_str.get(backend,";
    "Fxn:insert_snippet" -> "Fxn:Template(prepend_str)";
    "Fxn:insert_snippet" -> "Fxn:self.cwrap.get_arg_accessor(arg,";
    "Fxn:insert_snippet" -> "Fxn:before_call_template.substitute(args)";
    "Fxn:insert_snippet" -> "Fxn:template.insert(offset,";
    "Fxn:process_pre_arg_assign" -> "Fxn:option.get('before_arg_assign'):";
    "Fxn:process_pre_arg_assign" -> "Fxn:self.insert_snippet(template,";
    "Fxn:process_option_code_template" -> "Fxn:option.get('before_call')";
    "Fxn:process_option_code_template" -> "Fxn:option.get('after_call'):";
    "Fxn:process_option_code_template" -> "Fxn:template.index('$call')";
    "Fxn:process_option_code_template" -> "Fxn:self.insert_snippet(template,";
    "Fxn:process_option_code_template" -> "Fxn:template.index('$call')";
    "Fxn:process_option_code_template" -> "Fxn:self.insert_snippet(template,";
    "/tools/cwrap/plugins/BoolOption.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/BoolOption.py" -> "Import:Template";
    "/tools/cwrap/plugins/BoolOption.py" -> "Import:sys";
    "/tools/cwrap/plugins/BoolOption.py" -> "class:BoolOption(CWrapPlugin):";
    "class:BoolOption(CWrapPlugin):" -> "Fxn:is_bool_option";
    "class:BoolOption(CWrapPlugin):" -> "Fxn:process_declarations";
    "class:BoolOption(CWrapPlugin):" -> "Fxn:get_type_check";
    "class:BoolOption(CWrapPlugin):" -> "Fxn:get_type_unpack";
    "Fxn:process_declarations" -> "Fxn:self.is_bool_option(arg):";
    "Fxn:get_type_check" -> "Fxn:arg.get('is_bool_option',";
    "Fxn:get_type_check" -> "Fxn:Template('PyBool_Check($arg)')";
    "Fxn:get_type_unpack" -> "Fxn:arg.get('is_bool_option',";
    "Fxn:get_type_unpack" -> "Fxn:Template(self.UNPACK_TEMPLATE.safe_substitute(";
    "/tools/cwrap/plugins/Broadcast.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/Broadcast.py" -> "Import:Template";
    "/tools/cwrap/plugins/Broadcast.py" -> "class:Broadcast(CWrapPlugin):";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getPreArgStringTemplate";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getNewForExpand";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getExpandTemplate";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getOutPlacePreExpand2Template";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getOutPlacePreExpand3Template";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getOutPlacePreExpandPostDimTemplate";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getInPlacePreExpand1Template";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:getInPlacePreExpand2Template";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:initialize";
    "class:Broadcast(CWrapPlugin):" -> "Fxn:process_option_code_template";
    "Fxn:getPreArgStringTemplate" -> "Fxn:${arg_op_other}_guard(nullptr);\n"""";
    "Fxn:getPreArgStringTemplate" -> "Fxn:${arg_op_other}_guard(nullptr);\n"";
    "Fxn:getPreArgStringTemplate" -> "Fxn:${arg_op_other}_guard(nullptr);\n"";
    "Fxn:getPreArgStringTemplate" -> "Fxn:Template(ret)";
    "Fxn:getNewForExpand" -> "Fxn:"""THTensor_(new)(LIBRARY_STATE_NOARGS);\n"""";
    "Fxn:getNewForExpand" -> "Fxn:"_new(LIBRARY_STATE_NOARGS);\n"";
    "Fxn:getNewForExpand" -> "Fxn:"_new(LIBRARY_STATE_NOARGS);\n"";
    "Fxn:getExpandTemplate" -> "Fxn:Template(";
    "Fxn:getExpandTemplate" -> "Fxn:"if(expand_success)";
    "Fxn:getExpandTemplate" -> "Fxn:Template(";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:"""THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:self.getNewForExpand(type_op_a)";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:self.getNewForExpand(type_op_other)";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:"""expand_outplace2(LIBRARY_STATE";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:${arg_op_a}_guard.get(),";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:${arg_op_other}_guard.get(),";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:${arg_op_a}_guard.get();";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:${arg_op_other}_guard.get();"""";
    "Fxn:getOutPlacePreExpand2Template" -> "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:"""(THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:self.getNewForExpand(type_op_a)";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:self.getNewForExpand(type_op_other1)";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:self.getNewForExpand(type_op_other2)";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:"""expand_outplace3(LIBRARY_STATE";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_a}_guard.get(),";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_other1}_guard.get(),";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_other2}_guard.get(),";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_a}_guard.get();";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_other1}_guard.get();";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_other2}_guard.get();"""";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:Template(";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:"""if(THTensor_(nDimension)(LIBRARY_STATE";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:THError("Argument";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:THTensor_(nDimension)(LIBRARY_STATE";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:THTensor_(size)(LIBRARY_STATE";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:Template(";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_a}_storage(THLongStorage_newWithSize1(${arg_op_a}_dim0_size));\n""")";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:Template(";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_a}_storage(";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:THLongStorage_newWithSize2(${arg_op_a}_dim0_size,";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:Template(";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:${arg_op_a}_storage(";
    "Fxn:getOutPlacePreExpand3Template" -> "Fxn:THLongStorage_newWithSize3(${arg_op_a}_dim0_size,";
    "Fxn:getOutPlacePreExpandPostDimTemplate" -> "Fxn:"""THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:getOutPlacePreExpandPostDimTemplate" -> "Fxn:self.getNewForExpand(type_op_a)";
    "Fxn:getOutPlacePreExpandPostDimTemplate" -> "Fxn:"""expand(LIBRARY_STATE";
    "Fxn:getOutPlacePreExpandPostDimTemplate" -> "Fxn:${arg_op_a}_guard.get(),";
    "Fxn:getOutPlacePreExpandPostDimTemplate" -> "Fxn:${arg_op_a}_guard.get();"""";
    "Fxn:getOutPlacePreExpandPostDimTemplate" -> "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:getOutPlacePreExpandPostDimTemplate" -> "Fxn:Template(";
    "Fxn:getInPlacePreExpand1Template" -> "Fxn:"""THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:getInPlacePreExpand1Template" -> "Fxn:self.getNewForExpand(type_op_other)";
    "Fxn:getInPlacePreExpand1Template" -> "Fxn:"""expand_inplace1(LIBRARY_STATE";
    "Fxn:getInPlacePreExpand1Template" -> "Fxn:${arg_op_other}_guard.get(),";
    "Fxn:getInPlacePreExpand1Template" -> "Fxn:${arg_op_other}_guard.get();"""";
    "Fxn:getInPlacePreExpand1Template" -> "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:"""(THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:THSize_isSameSizeAs(${arg_op_a}->size,";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:self.getNewForExpand(type_op_other1)";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:self.getNewForExpand(type_op_other2)";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:"""expand_inplace2(LIBRARY_STATE";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:${arg_op_other1}_guard.get(),";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:${arg_op_other2}_guard.get(),";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:${arg_op_other1}_guard.get();";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:${arg_op_other2}_guard.get();"""";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:self.getExpandTemplate(size_check,";
    "Fxn:getInPlacePreExpand2Template" -> "Fxn:Template(";
    "Fxn:process_option_code_template" -> "Fxn:arg.get('broadcast').split("";
    "Fxn:process_option_code_template" -> "Fxn:arg.get('assign_name',";
    "Fxn:process_option_code_template" -> "Fxn:params[0].split(",")";
    "Fxn:process_option_code_template" -> "Fxn:ValueError('Broadcast";
    "Fxn:process_option_code_template" -> "Fxn:p.startswith("dims:"):";
    "Fxn:process_option_code_template" -> "Fxn:assert(raise_errors";
    "Fxn:process_option_code_template" -> "Fxn:ValueError("multiple";
    "Fxn:process_option_code_template" -> "Fxn:p[len("dims:"):].split(",")";
    "Fxn:process_option_code_template" -> "Fxn:dim.split(".")";
    "Fxn:process_option_code_template" -> "Fxn:batchdim[1].startswith("dim")";
    "Fxn:process_option_code_template" -> "Fxn:batchdim[1][len("dim"):]";
    "Fxn:process_option_code_template" -> "Fxn:dims_kvs.append({"op":";
    "Fxn:process_option_code_template" -> "Fxn:p.startswith("dims:")";
    "Fxn:process_option_code_template" -> "Fxn:p.startswith("types:"):";
    "Fxn:process_option_code_template" -> "Fxn:ValueError("invalid";
    "Fxn:process_option_code_template" -> "Fxn:{}".format(p))";
    "Fxn:process_option_code_template" -> "Fxn:p.startswith("types:"):";
    "Fxn:process_option_code_template" -> "Fxn:ValueError("type";
    "Fxn:process_option_code_template" -> "Fxn:p[len("types:"):].split(",")";
    "Fxn:process_option_code_template" -> "Fxn:assert(len(types)";
    "Fxn:process_option_code_template" -> "Fxn:self.getPreArgStringTemplate(type=type_op_b).substitute(op_b_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:self.getPreArgStringTemplate(type=type_op_c).substitute(op_c_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:self.getInPlacePreExpand2Template(type_op_b,";
    "Fxn:process_option_code_template" -> "Fxn:raise_errors_s).substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.getInPlacePreExpand1Template(type_op_b,";
    "Fxn:process_option_code_template" -> "Fxn:raise_errors_s).substitute(op_b_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:new_code_pre.append(self.IN_PLACE_PRE_TEMPLATE.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:new_code_pre.append("")";
    "Fxn:process_option_code_template" -> "Fxn:self.POST_TEMPLATE.substitute(op_b_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:self.POST_TEMPLATE.substitute(op_c_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:new_code_post.append(post_code)";
    "Fxn:process_option_code_template" -> "Fxn:new_code_post.append("")";
    "Fxn:process_option_code_template" -> "Fxn:self.getPreArgStringTemplate().substitute(arg_op_other=arg_op_a)";
    "Fxn:process_option_code_template" -> "Fxn:self.OUT_PLACE_PRE_EXPAND_PRE_DIM_TEMPLATE.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.OUT_PLACE_PRE_EXPAND1_DIM_TEMPLATE.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.OUT_PLACE_PRE_EXPAND2_DIM_TEMPLATE.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.OUT_PLACE_PRE_EXPAND3_DIM_TEMPLATE.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.getOutPlacePreExpandPostDimTemplate(None,";
    "Fxn:process_option_code_template" -> "Fxn:raise_errors_s).substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.POST_TEMPLATE.substitute(arg_op_other=arg_op_a)";
    "Fxn:process_option_code_template" -> "Fxn:self.getPreArgStringTemplate().substitute(arg_op_other=arg_op_a)";
    "Fxn:process_option_code_template" -> "Fxn:self.getPreArgStringTemplate(type=type_op_b).substitute(op_b_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:self.getOutPlacePreExpand3Template(None,";
    "Fxn:process_option_code_template" -> "Fxn:expand_template.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.getOutPlacePreExpand2Template(None,";
    "Fxn:process_option_code_template" -> "Fxn:raise_errors_s).substitute(";
    "Fxn:process_option_code_template" -> "Fxn:self.POST_TEMPLATE.substitute(arg_op_other=arg_op_a)";
    "Fxn:process_option_code_template" -> "Fxn:self.POST_TEMPLATE.substitute(op_b_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:self.POST_TEMPLATE.substitute(op_c_mapping)";
    "Fxn:process_option_code_template" -> "Fxn:new_code_pre.append(self.OUT_PLACE_PRE_TEMPLATE.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:new_code_pre.append("")";
    "Fxn:process_option_code_template" -> "Fxn:new_code_post.append(post_code)";
    "Fxn:process_option_code_template" -> "Fxn:new_code_post.append("")";
    "/tools/cwrap/plugins/ConstantArguments.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/ConstantArguments.py" -> "Import:Template";
    "/tools/cwrap/plugins/ConstantArguments.py" -> "class:ConstantArguments(CWrapPlugin):";
    "class:ConstantArguments(CWrapPlugin):" -> "Fxn:process_declarations";
    "class:ConstantArguments(CWrapPlugin):" -> "Fxn:get_type_unpack";
    "class:ConstantArguments(CWrapPlugin):" -> "Fxn:get_arg_accessor";
    "Fxn:get_type_unpack" -> "Fxn:Template('$arg')";
    "Fxn:get_arg_accessor" -> "Fxn:arg.get('default',";
    "/tools/cwrap/plugins/CuDNNPlugin.py" -> "Import:Template";
    "/tools/cwrap/plugins/CuDNNPlugin.py" -> "Import:copy";
    "/tools/cwrap/plugins/CuDNNPlugin.py" -> "Import:deepcopy";
    "/tools/cwrap/plugins/CuDNNPlugin.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/CuDNNPlugin.py" -> "Import:product";
    "/tools/cwrap/plugins/CuDNNPlugin.py" -> "class:CuDNNPlugin(CWrapPlugin):";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:__init__";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:get_type_unpack";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:get_type_check";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:get_assign_args";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:get_wrapper_template";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:get_return_wrapper";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:get_arg_accessor";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:process_declarations";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:filter_unique_options";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:signature";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:preprocessor_guard";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:process_wrapper";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:process_all_call_arg";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:declare_methods";
    "class:CuDNNPlugin(CWrapPlugin):" -> "Fxn:process_full_file";
    "Fxn:get_type_unpack" -> "Fxn:self.TYPE_UNPACK.get(arg['type'],";
    "Fxn:get_type_check" -> "Fxn:self.TYPE_CHECK.get(arg['type'],";
    "Fxn:get_assign_args" -> "Fxn:copy.copy(arg)";
    "Fxn:get_assign_args" -> "Fxn:self.INPUT_ARGUMENT_MAP.get(arg['type'])";
    "Fxn:get_assign_args" -> "Fxn:assign_args.append(arg)";
    "Fxn:get_wrapper_template" -> "Fxn:[self.TYPE_NAMES.get(arg['type'],";
    "Fxn:get_wrapper_template" -> "Fxn:arg.get('ignore_check',";
    "Fxn:get_wrapper_template" -> "Fxn:arg_desc.append('({})'.format(',";
    "Fxn:get_wrapper_template" -> "Fxn:'.join(option_desc)))";
    "Fxn:get_wrapper_template" -> "Fxn:arg_desc.append('no";
    "Fxn:get_wrapper_template" -> "Fxn:arg_desc.sort(key=len)";
    "Fxn:get_wrapper_template" -> "Fxn:'.join(arg_desc)";
    "Fxn:get_wrapper_template" -> "Fxn:Template(self.WRAPPER_TEMPLATE.safe_substitute(";
    "Fxn:get_wrapper_template" -> "Fxn:num_options=len(arg_desc),";
    "Fxn:get_return_wrapper" -> "Fxn:self.RETURN_WRAPPER.get(option['return'],";
    "Fxn:get_arg_accessor" -> "Fxn:'getCudnnDataType(tensorClass)'";
    "Fxn:get_arg_accessor" -> "Fxn:'getCudnnHandle()'";
    "Fxn:process_declarations" -> "Fxn:declaration.setdefault('python_name',";
    "Fxn:process_declarations" -> "Fxn:'_{}'.format(declaration['name']))";
    "Fxn:process_declarations" -> "Fxn:'THCUDNN_{}'.format(declaration['name'])";
    "Fxn:process_declarations" -> "Fxn:self.declarations.append(declaration)";
    "Fxn:process_declarations" -> "Fxn:self.filter_unique_options(declaration['options'])";
    "Fxn:process_declarations" -> "Fxn:d.get('only_register',";
    "Fxn:signature" -> "Fxn:'#'.join(arg['type']";
    "Fxn:signature" -> "Fxn:signature(option)";
    "Fxn:signature" -> "Fxn:unique.append(option)";
    "Fxn:signature" -> "Fxn:seen_signatures.add(sig)";
    "Fxn:process_wrapper" -> "Fxn:self.preprocessor_guard(code,";
    "Fxn:declare_methods" -> "Fxn:declaration.get('method_flags')";
    "Fxn:declare_methods" -> "Fxn:declaration.get('only_register'):";
    "Fxn:declare_methods" -> "Fxn:Template('";
    "Fxn:declare_methods" -> "Fxn:NULL},\n').substitute(";
    "Fxn:declare_methods" -> "Fxn:self.preprocessor_guard(entry,";
    "Fxn:declare_methods" -> "Fxn:self.METHODS_DECLARATION.substitute(methods=methods)";
    "Fxn:process_full_file" -> "Fxn:self.declare_methods()";
    "/tools/cwrap/plugins/GILRelease.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/GILRelease.py" -> "Import:Template";
    "/tools/cwrap/plugins/GILRelease.py" -> "class:GILRelease(CWrapPlugin):";
    "class:GILRelease(CWrapPlugin):" -> "Fxn:process_option_code_template";
    "Fxn:process_option_code_template" -> "Fxn:option.get('with_gil',";
    "Fxn:process_option_code_template" -> "Fxn:template.index('$call')";
    "Fxn:process_option_code_template" -> "Fxn:template.insert(call_idx,";
    "Fxn:process_option_code_template" -> "Fxn:template.insert(call_idx";
    "/tools/cwrap/plugins/KwargsPlugin.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/KwargsPlugin.py" -> "Import:Template";
    "/tools/cwrap/plugins/KwargsPlugin.py" -> "class:KwargsPlugin(CWrapPlugin):";
    "class:KwargsPlugin(CWrapPlugin):" -> "Fxn:process_declarations";
    "class:KwargsPlugin(CWrapPlugin):" -> "Fxn:get_arg_accessor";
    "class:KwargsPlugin(CWrapPlugin):" -> "Fxn:process_single_check";
    "class:KwargsPlugin(CWrapPlugin):" -> "Fxn:process_wrapper";
    "Fxn:process_declarations" -> "Fxn:declaration.get('no_kwargs'):";
    "Fxn:process_declarations" -> "Fxn:arg.get('kwarg_only'):";
    "Fxn:get_arg_accessor" -> "Fxn:arg.get('no_kwargs'):";
    "Fxn:get_arg_accessor" -> "Fxn:arg.get('kwarg_only'):";
    "Fxn:get_arg_accessor" -> "Fxn:self.KWARG_ONLY_ACCESSOR_TEMPLATE.substitute(name=arg['name'])";
    "Fxn:get_arg_accessor" -> "Fxn:self.ACCESSOR_TEMPLATE.substitute(idx=arg['idx'],";
    "Fxn:process_single_check" -> "Fxn:arg.get('no_kwargs'):";
    "Fxn:process_single_check" -> "Fxn:arg.get('kwarg_only'):";
    "Fxn:process_single_check" -> "Fxn:self.KWARG_ONLY_CHECK_TEMPLATE.substitute(name=arg['name'],";
    "Fxn:process_single_check" -> "Fxn:self.CHECK_TEMPLATE.substitute(idx=arg['idx'],";
    "Fxn:process_wrapper" -> "Fxn:declaration.get('no_kwargs'):";
    "Fxn:process_wrapper" -> "Fxn:arg.get('ignore_check')";
    "Fxn:process_wrapper" -> "Fxn:arg.get('no_kwargs')";
    "Fxn:process_wrapper" -> "Fxn:seen_args.add(name)";
    "Fxn:process_wrapper" -> "Fxn:args.append(name)";
    "Fxn:process_wrapper" -> "Fxn:'.join(['PyObject";
    "Fxn:process_wrapper" -> "Fxn:NULL;'.format(a)";
    "Fxn:process_wrapper" -> "Fxn:'.join(";
    "Fxn:process_wrapper" -> "Fxn:PyDict_GetItemString(kwargs,";
    "Fxn:process_wrapper" -> "Fxn:"{name}");'.format(name=a)";
    "Fxn:process_wrapper" -> "Fxn:code.find('{')";
    "Fxn:process_wrapper" -> "Fxn:self.WRAPPER_TEMPLATE.substitute(declarations=declarations,";
    "/tools/cwrap/plugins/NNExtension.py" -> "Import:string";
    "/tools/cwrap/plugins/NNExtension.py" -> "Import:Template";
    "/tools/cwrap/plugins/NNExtension.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/NNExtension.py" -> "class:NNExtension(CWrapPlugin):";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:__init__";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:process_full_file";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:process_wrapper";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:declare_module_methods";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:get_type_unpack";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:get_type_check";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:get_wrapper_template";
    "class:NNExtension(CWrapPlugin):" -> "Fxn:describe_arg";
    "Fxn:process_full_file" -> "Fxn:self.module_name.split('.')[-1]";
    "Fxn:process_full_file" -> "Fxn:self.declare_module_methods()";
    "Fxn:process_full_file" -> "Fxn:MODULE_TAIL.substitute(full_name=self.module_name,";
    "Fxn:process_wrapper" -> "Fxn:self.declarations.append(declaration)";
    "Fxn:declare_module_methods" -> "Fxn:REGISTER_METHOD_TEMPLATE.substitute(name=declaration['name'])";
    "Fxn:declare_module_methods" -> "Fxn:MODULE_METHODS_TEMPLATE.substitute(METHODS=module_methods)";
    "Fxn:get_type_unpack" -> "Fxn:self.TYPE_UNPACK.get(arg['type'],";
    "Fxn:get_type_check" -> "Fxn:self.TYPE_CHECK.get(arg['type'],";
    "Fxn:describe_arg" -> "Fxn:arg.get('nullable'):";
    "Fxn:describe_arg" -> "Fxn:None]'.format(desc)";
    "Fxn:describe_arg" -> "Fxn:[describe_arg(arg)";
    "Fxn:describe_arg" -> "Fxn:arg.get('ignore_check',";
    "Fxn:describe_arg" -> "Fxn:arg_desc.append('({})'.format(',";
    "Fxn:describe_arg" -> "Fxn:'.join(option_desc)))";
    "Fxn:describe_arg" -> "Fxn:arg_desc.append('no";
    "Fxn:describe_arg" -> "Fxn:arg_desc.sort(key=len)";
    "Fxn:describe_arg" -> "Fxn:'.join(arg_desc)";
    "Fxn:describe_arg" -> "Fxn:Template(self.WRAPPER_TEMPLATE.safe_substitute(expected_args=arg_str))";
    "/tools/cwrap/plugins/NullableArguments.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/NullableArguments.py" -> "class:NullableArguments(CWrapPlugin):";
    "/tools/cwrap/plugins/NullableArguments.py" -> "class:UndefinedArguments(CWrapPlugin):";
    "class:NullableArguments(CWrapPlugin):" -> "Fxn:process_single_check";
    "class:NullableArguments(CWrapPlugin):" -> "Fxn:process_single_unpack";
    "Fxn:process_single_check" -> "Fxn:'({}";
    "Fxn:process_single_check" -> "Fxn:Py_None)'.format(code,";
    "Fxn:process_single_unpack" -> "Fxn:'({}";
    "Fxn:process_single_unpack" -> "Fxn:{})'.format(arg_accessor,";
    "class:UndefinedArguments(CWrapPlugin):" -> "Fxn:process_single_check";
    "class:UndefinedArguments(CWrapPlugin):" -> "Fxn:process_single_unpack";
    "Fxn:process_single_check" -> "Fxn:'({}";
    "Fxn:process_single_check" -> "Fxn:Py_None)'.format(code,";
    "Fxn:process_single_unpack" -> "Fxn:'({}";
    "Fxn:process_single_unpack" -> "Fxn:at::Tensor()";
    "Fxn:process_single_unpack" -> "Fxn:{})'.format(arg_accessor,";
    "/tools/cwrap/plugins/OptionalArguments.py" -> "Import:copy";
    "/tools/cwrap/plugins/OptionalArguments.py" -> "Import:deepcopy";
    "/tools/cwrap/plugins/OptionalArguments.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/OptionalArguments.py" -> "Import:product";
    "/tools/cwrap/plugins/OptionalArguments.py" -> "Import:cwrap_common";
    "/tools/cwrap/plugins/OptionalArguments.py" -> "class:OptionalArguments(CWrapPlugin):";
    "class:OptionalArguments(CWrapPlugin):" -> "Fxn:process_declarations";
    "Fxn:process_declarations" -> "Fxn:cwrap_common.enumerate_options_due_to_default(";
    "/tools/cwrap/plugins/ProcessorSpecificPlugin.py" -> "Import:deepcopy";
    "/tools/cwrap/plugins/ProcessorSpecificPlugin.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/ProcessorSpecificPlugin.py" -> "Import:yaml";
    "/tools/cwrap/plugins/ProcessorSpecificPlugin.py" -> "class:ProcessorSpecificPlugin(CWrapPlugin):";
    "class:ProcessorSpecificPlugin(CWrapPlugin):" -> "Fxn:process_declarations";
    "class:ProcessorSpecificPlugin(CWrapPlugin):" -> "Fxn:arg_contains_generator";
    "class:ProcessorSpecificPlugin(CWrapPlugin):" -> "Fxn:split_candidate";
    "class:ProcessorSpecificPlugin(CWrapPlugin):" -> "Fxn:can_we_handle_the_split";
    "class:ProcessorSpecificPlugin(CWrapPlugin):" -> "Fxn:generator_split";
    "Fxn:split_candidate" -> "Fxn:arg_contains_generator(argument):";
    "Fxn:generator_split" -> "Fxn:deepcopy(declaration)";
    "Fxn:generator_split" -> "Fxn:dec_cpu['backends'].remove('CUDA')";
    "Fxn:generator_split" -> "Fxn:dec_cpu.get('backend_type_pairs',";
    "Fxn:generator_split" -> "Fxn:option['backends'].remove('CUDA')";
    "Fxn:generator_split" -> "Fxn:dec_gpu['backends'].remove('CPU')";
    "Fxn:generator_split" -> "Fxn:dec_gpu.get('backend_type_pairs',";
    "Fxn:generator_split" -> "Fxn:option['backends'].remove('CPU')";
    "Fxn:generator_split" -> "Fxn:arg_contains_generator(arg)])";
    "Fxn:generator_split" -> "Fxn:split_candidate(declaration):";
    "Fxn:generator_split" -> "Fxn:assert(can_we_handle_the_split(declaration))";
    "Fxn:generator_split" -> "Fxn:generator_split(declaration)";
    "Fxn:generator_split" -> "Fxn:decs.extend(newdecs)";
    "Fxn:generator_split" -> "Fxn:decs.append(declaration)";
    "/tools/cwrap/plugins/ReturnArguments.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/ReturnArguments.py" -> "Import:Template";
    "/tools/cwrap/plugins/ReturnArguments.py" -> "class:ReturnArguments(CWrapPlugin):";
    "class:ReturnArguments(CWrapPlugin):" -> "Fxn:initialize";
    "class:ReturnArguments(CWrapPlugin):" -> "Fxn:get_return_wrapper";
    "Fxn:get_return_wrapper" -> "Fxn:option['return'].startswith('argument";
    "Fxn:get_return_wrapper" -> "Fxn:option['return'][len('argument";
    "Fxn:get_return_wrapper" -> "Fxn:'):].split(',')))";
    "Fxn:get_return_wrapper" -> "Fxn:[self.cwrap.get_arg_accessor(arg,";
    "Fxn:get_return_wrapper" -> "Fxn:Template(self.ARGUMENT_RETURN_TEMPLATE.safe_substitute(arg=accessors[0]))";
    "Fxn:get_return_wrapper" -> "Fxn:Template(self.TUPLE_RETURN_TEMPLATE.safe_substitute(num_args=len(args),";
    "Fxn:get_return_wrapper" -> "Fxn:'.join(accessors)))";
    "/tools/cwrap/plugins/THPPlugin.py" -> "Import:Template";
    "/tools/cwrap/plugins/THPPlugin.py" -> "Import:deepcopy";
    "/tools/cwrap/plugins/THPPlugin.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/THPPlugin.py" -> "Import:product,";
    "/tools/cwrap/plugins/THPPlugin.py" -> "Import:OrderedDict";
    "/tools/cwrap/plugins/THPPlugin.py" -> "class:THPPlugin(CWrapPlugin):";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:_allocate";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:__init__";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:substitute_tensor_backend";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:get_type_unpack";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:get_type_check";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:get_wrapper_template";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:format_arg";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:format_args";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:get_return_wrapper";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:get_arg_accessor";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_docstrings";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:generate_out_options";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_declarations";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:has_arg_type";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:has_long_args";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:has_output_args";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:backends_types_to_defined_if_string";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:get_defined_string";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:expand_composite_type";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:make_stateless";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:declare_methods";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_full_file";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:preprocessor_guard";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_wrapper";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_all_call_arg";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_all_checks";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_option_code";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:process_pre_arg_assign";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:generate_docstrings_cpp";
    "class:THPPlugin(CWrapPlugin):" -> "Fxn:generate_docstrings_h";
    "Fxn:_allocate" -> "Fxn:tmpl.safe_substitute(type=typename)";
    "Fxn:_allocate" -> "Fxn:code.replace('NewEmpty',";
    "Fxn:_allocate" -> "Fxn:'(NewEmpty)')";
    "Fxn:_allocate" -> "Fxn:code.replace('THP',";
    "Fxn:_allocate" -> "Fxn:cuda_tmpl.substitute(cuda=cuda_code,";
    "Fxn:_allocate" -> "Fxn:code.replace('THP',";
    "Fxn:_allocate" -> "Fxn:code.replace('THCP',";
    "Fxn:_allocate" -> "Fxn:Template(code)";
    "Fxn:_allocate" -> "Fxn:_allocate('',";
    "Fxn:_allocate" -> "Fxn:_allocate('Long',";
    "Fxn:_allocate" -> "Fxn:_allocate('Int',";
    "Fxn:_allocate" -> "Fxn:_allocate('Byte',";
    "Fxn:_allocate" -> "Fxn:_allocate('Long',";
    "Fxn:_allocate" -> "Fxn:_allocate('Int',";
    "Fxn:_allocate" -> "Fxn:_allocate('',";
    "Fxn:_allocate" -> "Fxn:PyDict_GetItemString(kwargs,";
    "Fxn:substitute_tensor_backend" -> "Fxn:arg['type'].replace('Backend',";
    "Fxn:substitute_tensor_backend" -> "Fxn:self.BACKEND_SUBSTITUTIONS.get(option['backends'][0]))";
    "Fxn:substitute_tensor_backend" -> "Fxn:arg['type'].replace('Float',";
    "Fxn:get_type_unpack" -> "Fxn:self.substitute_tensor_backend(arg,";
    "Fxn:get_type_unpack" -> "Fxn:self.TYPE_UNPACK.get(arg['type'],";
    "Fxn:get_type_check" -> "Fxn:arg.get('long_args',";
    "Fxn:get_type_check" -> "Fxn:self.substitute_tensor_backend(arg,";
    "Fxn:get_type_check" -> "Fxn:self.TYPE_CHECK.get(arg['type'],";
    "Fxn:get_wrapper_template" -> "Fxn:OrderedDict()";
    "Fxn:format_arg" -> "Fxn:arg.get('long_args',";
    "Fxn:format_args" -> "Fxn:[format_arg(arg,";
    "Fxn:format_args" -> "Fxn:arg.get('ignore_check',";
    "Fxn:format_args" -> "Fxn:arg.get('output')]";
    "Fxn:format_args" -> "Fxn:a.get('output'),";
    "Fxn:format_args" -> "Fxn:'.join(";
    "Fxn:format_args" -> "Fxn:'({})'.format(',";
    "Fxn:format_args" -> "Fxn:'.join(option_desc))";
    "Fxn:format_args" -> "Fxn:arg_desc[format_args(option['arguments'],";
    "Fxn:format_args" -> "Fxn:arg_desc[format_args(option['arguments'],";
    "Fxn:format_args" -> "Fxn:'.join(arg_desc)";
    "Fxn:format_args" -> "Fxn:'\n'.join(declaration.get('variables',";
    "Fxn:format_args" -> "Fxn:'\n'.join(declaration.get('init',";
    "Fxn:format_args" -> "Fxn:Template(self.WRAPPER_TEMPLATE.safe_substitute(";
    "Fxn:format_args" -> "Fxn:num_options=len(arg_desc),";
    "Fxn:get_return_wrapper" -> "Fxn:self.RETURN_WRAPPER.get(option['return'],";
    "Fxn:get_arg_accessor" -> "Fxn:arg.get('output'):";
    "Fxn:get_arg_accessor" -> "Fxn:'PyTuple_GET_ITEM(___out,";
    "Fxn:get_arg_accessor" -> "Fxn:{})'.format(arg['output_idx'])";
    "Fxn:process_docstrings" -> "Fxn:declaration.get('docstring_method')";
    "Fxn:process_docstrings" -> "Fxn:docstr.replace('\n',";
    "Fxn:process_docstrings" -> "Fxn:declaration.get('docstring_stateless')";
    "Fxn:process_docstrings" -> "Fxn:docstr.replace('\n',";
    "Fxn:generate_out_options" -> "Fxn:declaration.setdefault('init',";
    "Fxn:generate_out_options" -> "Fxn:arg.get('output'):";
    "Fxn:generate_out_options" -> "Fxn:out_idx.append(i)";
    "Fxn:generate_out_options" -> "Fxn:new_options.append(option)";
    "Fxn:generate_out_options" -> "Fxn:deepcopy(option)";
    "Fxn:generate_out_options" -> "Fxn:-len(out_idx)";
    "Fxn:generate_out_options" -> "Fxn:new_options.append(option_copy)";
    "Fxn:backends_types_to_defined_if_string" -> "Fxn:declaration.get('types',";
    "Fxn:get_defined_string" -> "Fxn:'CUDA_{0}'.format(real.upper())";
    "Fxn:get_defined_string" -> "Fxn:'defined(TH_REAL_IS_{0})'.format(real.upper())";
    "Fxn:expand_composite_type" -> "Fxn:result.append('half')";
    "Fxn:expand_composite_type" -> "Fxn:declaration.get('backend_type_pairs',";
    "Fxn:expand_composite_type" -> "Fxn:defineds.extend([get_defined_string(p,";
    "Fxn:expand_composite_type" -> "Fxn:expand_composite_type(p,";
    "Fxn:expand_composite_type" -> "Fxn:".join(defineds)";
    "Fxn:expand_composite_type" -> "Fxn:defineds.append('IS_CUDA'";
    "Fxn:expand_composite_type" -> "Fxn:".join(defineds)";
    "Fxn:expand_composite_type" -> "Fxn:defineds.extend([get_defined_string(p,";
    "Fxn:expand_composite_type" -> "Fxn:expand_composite_type(p,";
    "Fxn:expand_composite_type" -> "Fxn:".join(defineds)";
    "Fxn:expand_composite_type" -> "Fxn:backends_types_to_defined_if_string(declaration)";
    "Fxn:expand_composite_type" -> "Fxn:declaration.get('cpu_half',";
    "Fxn:expand_composite_type" -> "Fxn:'!defined(TH_REAL_IS_HALF)'";
    "Fxn:expand_composite_type" -> "Fxn:declaration.get('only_register',";
    "Fxn:expand_composite_type" -> "Fxn:declaration.setdefault('python_name',";
    "Fxn:expand_composite_type" -> "Fxn:declaration.setdefault('variables',";
    "Fxn:expand_composite_type" -> "Fxn:has_arg_type(declaration,";
    "Fxn:expand_composite_type" -> "Fxn:has_arg_type(declaration,";
    "Fxn:expand_composite_type" -> "Fxn:has_output_args(declaration):";
    "Fxn:expand_composite_type" -> "Fxn:self.generate_out_options(declaration)";
    "Fxn:expand_composite_type" -> "Fxn:has_long_args(declaration):";
    "Fxn:expand_composite_type" -> "Fxn:arg.get('long_args',";
    "Fxn:expand_composite_type" -> "Fxn:'TH{}Tensor_({})'.format(";
    "Fxn:expand_composite_type" -> "Fxn:option.get('sparse',";
    "Fxn:expand_composite_type" -> "Fxn:option.get('sparse',";
    "Fxn:expand_composite_type" -> "Fxn:option.get('defined_if',";
    "Fxn:expand_composite_type" -> "Fxn:declaration.get('variants',";
    "Fxn:expand_composite_type" -> "Fxn:self.make_stateless(declaration)";
    "Fxn:expand_composite_type" -> "Fxn:new_declarations.append(stateless_declaration)";
    "Fxn:expand_composite_type" -> "Fxn:self.stateless_declarations.append(stateless_declaration)";
    "Fxn:expand_composite_type" -> "Fxn:self.declarations.append(declaration)";
    "Fxn:expand_composite_type" -> "Fxn:'TH{}PTensor_({})'.format(";
    "Fxn:expand_composite_type" -> "Fxn:declaration.get('sparse',";
    "Fxn:expand_composite_type" -> "Fxn:d.get('only_register',";
    "Fxn:expand_composite_type" -> "Fxn:d.get('variants',";
    "Fxn:expand_composite_type" -> "Fxn:d.get('only_register',";
    "Fxn:expand_composite_type" -> "Fxn:self.declarations.extend(filter(lambda";
    "Fxn:expand_composite_type" -> "Fxn:x.get('variants',";
    "Fxn:expand_composite_type" -> "Fxn:self.stateless_declarations.extend(filter(lambda";
    "Fxn:expand_composite_type" -> "Fxn:x.get('variants',";
    "Fxn:expand_composite_type" -> "Fxn:self.process_docstrings()";
    "Fxn:make_stateless" -> "Fxn:deepcopy(declaration)";
    "Fxn:make_stateless" -> "Fxn:'TH{}PTensor_stateless_({})'.format(";
    "Fxn:make_stateless" -> "Fxn:declaration.get('sparse',";
    "Fxn:declare_methods" -> "Fxn:declaration.get('sparse',";
    "Fxn:declare_methods" -> "Fxn:declaration.get('method_flags')";
    "Fxn:declare_methods" -> "Fxn:declaration.get('only_register'):";
    "Fxn:declare_methods" -> "Fxn:declaration.get('override_method_flags'):";
    "Fxn:declare_methods" -> "Fxn:Template('";
    "Fxn:declare_methods" -> "Fxn:$docstring},\n').substitute(";
    "Fxn:declare_methods" -> "Fxn:docstring=declaration.get('docstring_var',";
    "Fxn:declare_methods" -> "Fxn:self.preprocessor_guard(entry,";
    "Fxn:declare_methods" -> "Fxn:self.TENSOR_METHODS_DECLARATION.substitute(";
    "Fxn:declare_methods" -> "Fxn:stateless=(''";
    "Fxn:declare_methods" -> "Fxn:sparse=(''";
    "Fxn:declare_methods" -> "Fxn:!defined(TH_REAL_IS_HALF)";
    "Fxn:process_full_file" -> "Fxn:code.find('//";
    "Fxn:process_full_file" -> "Fxn:self.declare_methods(False,";
    "Fxn:process_full_file" -> "Fxn:self.declare_methods(True,";
    "Fxn:process_full_file" -> "Fxn:self.declare_methods(False,";
    "Fxn:process_full_file" -> "Fxn:self.declare_methods(True,";
    "Fxn:process_wrapper" -> "Fxn:self.preprocessor_guard(code,";
    "Fxn:process_all_checks" -> "Fxn:option.get('has_output'):";
    "Fxn:process_all_checks" -> "Fxn:"PyTuple_Check(___out)";
    "Fxn:process_all_checks" -> "Fxn:"PyTuple_GET_SIZE(___out)";
    "Fxn:process_all_checks" -> "Fxn:&&\n".format(";
    "Fxn:process_all_checks" -> "Fxn:code.replace('__argcount";
    "Fxn:process_all_checks" -> "Fxn:arg.get('no_kwargs',";
    "Fxn:process_all_checks" -> "Fxn:arg.get('ignore_check',";
    "Fxn:process_option_code" -> "Fxn:option.get('defined_if',";
    "Fxn:process_pre_arg_assign" -> "Fxn:option.get('output_provided',";
    "Fxn:process_pre_arg_assign" -> "Fxn:arg.get('output'):";
    "Fxn:process_pre_arg_assign" -> "Fxn:new_args.append(self.ALLOCATE_TYPE[arg['type']].substitute(name=arg['name']))";
    "Fxn:generate_docstrings_cpp" -> "Fxn:Template('char*";
    "Fxn:generate_docstrings_cpp" -> "Fxn:'\n\n'.join(";
    "Fxn:generate_docstrings_cpp" -> "Fxn:template.substitute(name=decl['docstring_var'],";
    "Fxn:generate_docstrings_cpp" -> "Fxn:chain(self.declarations,";
    "Fxn:generate_docstrings_h" -> "Fxn:Template('extern";
    "Fxn:generate_docstrings_h" -> "Fxn:'\n\n'.join(";
    "Fxn:generate_docstrings_h" -> "Fxn:template.substitute(name=decl['docstring_var'])";
    "Fxn:generate_docstrings_h" -> "Fxn:chain(self.declarations,";
    "/tools/cwrap/plugins/WrapDim.py" -> "Import:CWrapPlugin";
    "/tools/cwrap/plugins/WrapDim.py" -> "Import:Template";
    "/tools/cwrap/plugins/WrapDim.py" -> "class:WrapDim(CWrapPlugin):";
    "class:WrapDim(CWrapPlugin):" -> "Fxn:initialize";
    "class:WrapDim(CWrapPlugin):" -> "Fxn:process_option_code_template";
    "Fxn:process_option_code_template" -> "Fxn:arg.get('wrap_dim').split("+")";
    "Fxn:process_option_code_template" -> "Fxn:arg.get('assign_name',";
    "Fxn:process_option_code_template" -> "Fxn:self.NDIM_TEMPLATE.substitute(arg_tensor=arg_tensor)";
    "Fxn:process_option_code_template" -> "Fxn:"+".join(params)";
    "Fxn:process_option_code_template" -> "Fxn:new_code.append(self.CODE_TEMPLATE.substitute(";
    "Fxn:process_option_code_template" -> "Fxn:new_code.append("")";
    "/tools/cwrap/plugins/__init__.py" -> "class:CWrapPlugin(object):";
    "/tools/cwrap/plugins/__init__.py" -> "Import:NNExtension";
    "/tools/cwrap/plugins/__init__.py" -> "Import:NullableArguments";
    "/tools/cwrap/plugins/__init__.py" -> "Import:OptionalArguments";
    "/tools/cwrap/plugins/__init__.py" -> "Import:ArgcountChecker";
    "/tools/cwrap/plugins/__init__.py" -> "Import:ArgumentReferences";
    "/tools/cwrap/plugins/__init__.py" -> "Import:BeforeAfterCall";
    "/tools/cwrap/plugins/__init__.py" -> "Import:ConstantArguments";
    "/tools/cwrap/plugins/__init__.py" -> "Import:ReturnArguments";
    "/tools/cwrap/plugins/__init__.py" -> "Import:GILRelease";
    "/tools/cwrap/plugins/__init__.py" -> "Import:AutoGPU";
    "/tools/cwrap/plugins/__init__.py" -> "Import:CuDNNPlugin";
    "/tools/cwrap/plugins/__init__.py" -> "Import:WrapDim";
    "/tools/cwrap/plugins/__init__.py" -> "Import:Broadcast";
    "class:CWrapPlugin(object):" -> "Fxn:initialize";
    "class:CWrapPlugin(object):" -> "Fxn:get_type_check";
    "class:CWrapPlugin(object):" -> "Fxn:get_type_unpack";
    "class:CWrapPlugin(object):" -> "Fxn:get_return_wrapper";
    "class:CWrapPlugin(object):" -> "Fxn:get_wrapper_template";
    "class:CWrapPlugin(object):" -> "Fxn:get_assign_args";
    "class:CWrapPlugin(object):" -> "Fxn:get_arg_accessor";
    "class:CWrapPlugin(object):" -> "Fxn:process_full_file";
    "class:CWrapPlugin(object):" -> "Fxn:process_single_check";
    "class:CWrapPlugin(object):" -> "Fxn:process_all_checks";
    "class:CWrapPlugin(object):" -> "Fxn:process_single_unpack";
    "class:CWrapPlugin(object):" -> "Fxn:process_all_call_arg";
    "class:CWrapPlugin(object):" -> "Fxn:process_option_code";
    "class:CWrapPlugin(object):" -> "Fxn:process_wrapper";
    "class:CWrapPlugin(object):" -> "Fxn:process_declarations";
    "class:CWrapPlugin(object):" -> "Fxn:process_option_code_template";
    "class:CWrapPlugin(object):" -> "Fxn:process_pre_arg_assign";
    "Fxn:get_type_check" -> "Fxn:Template('(PyObject*)Py_TYPE($arg)";
    "Fxn:get_type_check" -> "Fxn:Template('PyBool_Check($arg)')";
    "Fxn:get_type_unpack" -> "Fxn:Template('((THPTensor*)$arg)->cdata')";
    "Fxn:get_type_unpack" -> "Fxn:Template('PyLong_AsLong($arg)')";
    "Fxn:get_return_wrapper" -> "Fxn:Template('return";
    "Fxn:get_return_wrapper" -> "Fxn:THPTensor_(New)($result);')";
    "Fxn:get_return_wrapper" -> "Fxn:Template('return";
    "Fxn:get_return_wrapper" -> "Fxn:PyBool_FromLong($result);').";
    "Fxn:process_single_check" -> "Fxn:'(PyObject*)Py_TYPE(PyTuple_GET_ITEM(args,";
    "Fxn:process_all_checks" -> "Fxn:CHECK_TYPE(GET_ARG(0))";
    "Fxn:process_all_checks" -> "Fxn:CHECK_TYPE(GET_ARG(1))";
    "Fxn:process_single_unpack" -> "Fxn:PyLong_FromLong(PyTuple_GET_ITEM(args,";
    "Fxn:process_declarations" -> "Fxn:function(s)";
    "/tools/jit/gen_jit_dispatch.py" -> "Import:import";
    "/tools/jit/gen_jit_dispatch.py" -> "Import:argparse";
    "/tools/jit/gen_jit_dispatch.py" -> "Import:count";
    "/tools/jit/gen_jit_dispatch.py" -> "Import:CodeTemplate,";
    "/tools/jit/gen_jit_dispatch.py" -> "Import:load_aten_declarations";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:is_magic_method";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:is_jit_op";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:gen_jit_dispatch";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:is_tensor_arg";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:get_invocation";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:emit_decl_variant";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:emit_decl";
    "/tools/jit/gen_jit_dispatch.py" -> "Fxn:main";
    "/tools/nnwrap/generate_wrappers.py" -> "Import:import";
    "/tools/nnwrap/generate_wrappers.py" -> "Import:sys";
    "/tools/nnwrap/generate_wrappers.py" -> "Import:Template,";
    "/tools/nnwrap/generate_wrappers.py" -> "Import:cwrap";
    "/tools/nnwrap/generate_wrappers.py" -> "Import:NNExtension,";
    "/tools/nnwrap/generate_wrappers.py" -> "Import:import_module";
    "/tools/nnwrap/generate_wrappers.py" -> "Fxn:wrap_function";
    "/tools/nnwrap/generate_wrappers.py" -> "Fxn:generate_wrappers";
    "/tools/nnwrap/generate_wrappers.py" -> "Fxn:wrap_nn";
    "/tools/nnwrap/generate_wrappers.py" -> "Fxn:wrap_cunn";
    "/tools/nnwrap/__init__.py" -> "Import:generate_wrappers,";
    "/tools/setup_helpers/cuda.py" -> "Import:import";
    "/tools/setup_helpers/cuda.py" -> "Import:glob";
    "/tools/setup_helpers/cuda.py" -> "Import:import";
    "/tools/setup_helpers/cuda.py" -> "Import:ctypes.util";
    "/tools/setup_helpers/cuda.py" -> "Import:Popen,";
    "/tools/setup_helpers/cuda.py" -> "Import:IS_WINDOWS,";
    "/tools/setup_helpers/cuda.py" -> "Fxn:find_nvcc";
    "/tools/setup_helpers/cuda.py" -> "Fxn:find_cuda_version";
    "/tools/setup_helpers/cudnn.py" -> "Import:import";
    "/tools/setup_helpers/cudnn.py" -> "Import:glob";
    "/tools/setup_helpers/cudnn.py" -> "Import:IS_WINDOWS,";
    "/tools/setup_helpers/cudnn.py" -> "Import:WITH_CUDA,";
    "/tools/setup_helpers/dist_check.py" -> "Import:import";
    "/tools/setup_helpers/dist_check.py" -> "Import:subprocess";
    "/tools/setup_helpers/dist_check.py" -> "Import:glob";
    "/tools/setup_helpers/dist_check.py" -> "Import:IS_CONDA,";
    "/tools/setup_helpers/dist_check.py" -> "Fxn:get_command_path";
    "/tools/setup_helpers/dist_check.py" -> "Fxn:excutable";
    "/tools/setup_helpers/dist_check.py" -> "Fxn:should_build_ib";
    "/tools/setup_helpers/env.py" -> "Import:import";
    "/tools/setup_helpers/env.py" -> "Import:platform";
    "/tools/setup_helpers/env.py" -> "Import:sys";
    "/tools/setup_helpers/env.py" -> "Import:chain";
    "/tools/setup_helpers/env.py" -> "Fxn:check_env_flag";
    "/tools/setup_helpers/env.py" -> "Fxn:gather_paths";
    "/tools/setup_helpers/generate_code.py" -> "Import:import";
    "/tools/setup_helpers/generate_code.py" -> "Import:sys";
    "/tools/setup_helpers/generate_code.py" -> "Fxn:all_generator_source";
    "/tools/setup_helpers/generate_code.py" -> "Fxn:generate_code_ninja";
    "/tools/setup_helpers/generate_code.py" -> "Fxn:generate_code";
    "/tools/setup_helpers/generate_code.py" -> "Import:earlier";
    "/tools/setup_helpers/generate_code.py" -> "Import:gen_autograd";
    "/tools/setup_helpers/generate_code.py" -> "Import:gen_jit_dispatch";
    "/tools/setup_helpers/generate_code.py" -> "Import:generate_wrappers";
    "/tools/setup_helpers/nccl.py" -> "Import:import";
    "/tools/setup_helpers/nccl.py" -> "Import:glob";
    "/tools/setup_helpers/nccl.py" -> "Import:warnings";
    "/tools/setup_helpers/nccl.py" -> "Import:chain";
    "/tools/setup_helpers/nccl.py" -> "Import:IS_WINDOWS,";
    "/tools/setup_helpers/nccl.py" -> "Import:WITH_CUDA,";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:import";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:import";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:sys";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:setuptools";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:distutils";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:contextmanager";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:subprocess";
    "/tools/setup_helpers/ninja_builder.py" -> "class:NinjaBuilder(object):";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:ninja";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:ninja";
    "/tools/setup_helpers/ninja_builder.py" -> "class:ninja_build_ext(setuptools.command.build_ext.build_ext):";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:distutils.msvccompiler";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:distutils.msvc9compiler";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:distutils.unixccompiler";
    "/tools/setup_helpers/ninja_builder.py" -> "Import:_nt_quote_args";
    "class:NinjaBuilder(object):" -> "Fxn:__init__";
    "class:NinjaBuilder(object):" -> "Fxn:run";
    "Fxn:__init__" -> "Fxn:os.path.exists(BUILD_DIR):";
    "Fxn:__init__" -> "Fxn:os.mkdir(BUILD_DIR)";
    "Fxn:__init__" -> "Fxn:os.path.join(ninja.BIN_DIR,";
    "Fxn:__init__" -> "Fxn:os.path.join(BUILD_DIR,";
    "Fxn:__init__" -> "Fxn:'build.{}.ninja'.format(name))";
    "Fxn:__init__" -> "Fxn:ninja.Writer(open(self.filename,";
    "Fxn:__init__" -> "Fxn:self.writer.rule('do_cmd',";
    "Fxn:__init__" -> "Fxn:self.writer.rule('compile',";
    "Fxn:run" -> "Fxn:self.writer.close()";
    "Fxn:run" -> "Fxn:subprocess.check_call([self.ninja_program,";
    "Fxn:run" -> "Fxn:sys.stderr.write(str(err)";
    "Fxn:run" -> "Fxn:sys.exit(1)";
    "Fxn:run" -> "Fxn:os.path.join(BUILD_DIR,";
    "Fxn:run" -> "Fxn:'{}_compile_commands.json'.format(self.name))";
    "Fxn:run" -> "Fxn:subprocess.check_call([self.ninja_program,";
    "Fxn:run" -> "Fxn:self.__init__(self.name";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:_build_default";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:build_extension";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:patch";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:win_compile";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:spawn";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:unix_compile";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:spawn";
    "class:ninja_build_ext(setuptools.command.build_ext.build_ext):" -> "Fxn:link";
    "Fxn:_build_default" -> "Fxn:setuptools.command.build_ext.build_ext.build_extension(self,";
    "Fxn:build_extension" -> "Fxn:NinjaBuilder(ext.name)";
    "Fxn:spawn" -> "Fxn:re.compile('/T(p|c)(.*)')";
    "Fxn:spawn" -> "Fxn:[m.group(2)";
    "Fxn:spawn" -> "Fxn:src_regex.match(elem)";
    "Fxn:spawn" -> "Fxn:re.compile('/Fo(.*)')";
    "Fxn:spawn" -> "Fxn:[m.group(1)";
    "Fxn:spawn" -> "Fxn:obj_regex.match(elem)";
    "Fxn:spawn" -> "Fxn:orig_spawn(cmd)";
    "Fxn:spawn" -> "Fxn:_nt_quote_args(cmd)";
    "Fxn:spawn" -> "Fxn:builder.writer.build(";
    "Fxn:spawn" -> "Fxn:patch(self,";
    "Fxn:spawn" -> "Fxn:orig_compile(self,";
    "Fxn:unix_compile" -> "Fxn:os.path.splitext(obj)[0]";
    "Fxn:spawn" -> "Fxn:builder.writer.build(";
    "Fxn:spawn" -> "Fxn:patch(self,";
    "Fxn:spawn" -> "Fxn:orig_compile(self,";
    "Fxn:link" -> "Fxn:builder.run()";
    "Fxn:link" -> "Fxn:orig_link(self,";
    "Fxn:link" -> "Fxn:patch(orig_compiler,";
    "Fxn:link" -> "Fxn:patch(orig_compiler,";
    "Fxn:link" -> "Fxn:patch(self,";
    "Fxn:link" -> "Fxn:self._build_default(ext)";
    "/tools/setup_helpers/nnpack.py" -> "Import:check_env_flag";
    "/tools/setup_helpers/nvtoolext.py" -> "Import:import";
    "/tools/setup_helpers/nvtoolext.py" -> "Import:platform";
    "/tools/setup_helpers/nvtoolext.py" -> "Import:ctypes.util";
    "/tools/setup_helpers/nvtoolext.py" -> "Import:Popen,";
    "/tools/setup_helpers/nvtoolext.py" -> "Import:WITH_CUDA";
    "/tools/setup_helpers/split_types.py" -> "Import:import";
    "/tools/setup_helpers/split_types.py" -> "Import:sys";
    "/tools/setup_helpers/split_types.py" -> "Fxn:get_gen_path_prefix";
    "/tools/setup_helpers/split_types.py" -> "Fxn:split_types_ninja";
    "/tools/setup_helpers/split_types.py" -> "Fxn:split_types";
    "/tools/shared/module_loader.py" -> "Import:sys";
    "/tools/shared/module_loader.py" -> "Fxn:import_module";
    "/tools/shared/module_loader.py" -> "Import:importlib.util";
    "/tools/shared/module_loader.py" -> "Import:SourceFileLoader";
    "/tools/shared/module_loader.py" -> "Import:imp";
    "/tools/shared/__init__.py" -> "Import:import_module";
    "/tools/shared/__init__.py" -> "Import:set_declaration_defaults,";
    "/torch/functional.py" -> "Import:torch";
    "/torch/functional.py" -> "Import:mul";
    "/torch/functional.py" -> "Import:reduce";
    "/torch/functional.py" -> "Import:math";
    "/torch/functional.py" -> "Fxn:split";
    "/torch/functional.py" -> "Fxn:btrifact";
    "/torch/functional.py" -> "Fxn:unbind";
    "/torch/functional.py" -> "Fxn:btriunpack";
    "/torch/functional.py" -> "Fxn:hann_window";
    "/torch/functional.py" -> "Fxn:hamming_window";
    "/torch/functional.py" -> "Fxn:bartlett_window";
    "/torch/functional.py" -> "Fxn:isnan";
    "/torch/functional.py" -> "Fxn:unique";
    "/torch/random.py" -> "Import:torch";
    "/torch/random.py" -> "Import:contextlib";
    "/torch/random.py" -> "Import:warnings";
    "/torch/random.py" -> "Import:default_generator";
    "/torch/random.py" -> "Fxn:set_rng_state";
    "/torch/random.py" -> "Fxn:get_rng_state";
    "/torch/random.py" -> "Fxn:manual_seed";
    "/torch/random.py" -> "Import:torch.cuda";
    "/torch/random.py" -> "Fxn:initial_seed";
    "/torch/random.py" -> "Fxn:fork_rng";
    "/torch/random.py" -> "Import:torch.cuda";
    "/torch/serialization.py" -> "Import:difflib";
    "/torch/serialization.py" -> "Import:inspect";
    "/torch/serialization.py" -> "Import:import";
    "/torch/serialization.py" -> "Import:import";
    "/torch/serialization.py" -> "Import:shutil";
    "/torch/serialization.py" -> "Import:struct";
    "/torch/serialization.py" -> "Import:sys";
    "/torch/serialization.py" -> "Import:torch";
    "/torch/serialization.py" -> "Import:tarfile";
    "/torch/serialization.py" -> "Import:tempfile";
    "/torch/serialization.py" -> "Import:warnings";
    "/torch/serialization.py" -> "Import:closing,";
    "/torch/serialization.py" -> "Import:_import_dotted_name";
    "/torch/serialization.py" -> "Import:string_classes";
    "/torch/serialization.py" -> "Import:cPickle";
    "/torch/serialization.py" -> "Import:pickle";
    "/torch/serialization.py" -> "Import:pathlib";
    "/torch/serialization.py" -> "class:SourceChangeWarning(Warning):";
    "/torch/serialization.py" -> "Import:StringIO";
    "/torch/serialization.py" -> "Import:torch.nn";
    "class:SourceChangeWarning(Warning):" -> "Fxn:mkdtemp";
    "class:SourceChangeWarning(Warning):" -> "Fxn:register_package";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_cpu_tag";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_cuda_tag";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_cpu_deserialize";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_cuda_deserialize";
    "class:SourceChangeWarning(Warning):" -> "Fxn:location_tag";
    "class:SourceChangeWarning(Warning):" -> "Fxn:default_restore_location";
    "class:SourceChangeWarning(Warning):" -> "Fxn:normalize_storage_type";
    "class:SourceChangeWarning(Warning):" -> "Fxn:storage_to_tensor_type";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_with_file_like";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_is_real_file";
    "class:SourceChangeWarning(Warning):" -> "Fxn:save";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_save";
    "class:SourceChangeWarning(Warning):" -> "Fxn:persistent_id";
    "class:SourceChangeWarning(Warning):" -> "Fxn:load";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_load";
    "class:SourceChangeWarning(Warning):" -> "Fxn:restore_location";
    "class:SourceChangeWarning(Warning):" -> "Fxn:restore_location";
    "class:SourceChangeWarning(Warning):" -> "Fxn:restore_location";
    "class:SourceChangeWarning(Warning):" -> "Fxn:_check_container_source";
    "class:SourceChangeWarning(Warning):" -> "Fxn:legacy_load";
    "class:SourceChangeWarning(Warning):" -> "Fxn:persistent_load";
    "class:SourceChangeWarning(Warning):" -> "Fxn:persistent_load";
    "Fxn:mkdtemp" -> "Fxn:tempfile.mkdtemp()";
    "Fxn:mkdtemp" -> "Fxn:shutil.rmtree(path)";
    "Fxn:register_package" -> "Fxn:_package_registry.append(queue_elem)";
    "Fxn:register_package" -> "Fxn:_package_registry.sort()";
    "Fxn:_cuda_deserialize" -> "Fxn:location.startswith('cuda'):";
    "Fxn:_cuda_deserialize" -> "Fxn:obj.cuda(device)";
    "Fxn:_cuda_deserialize" -> "Fxn:register_package(10,";
    "Fxn:_cuda_deserialize" -> "Fxn:register_package(20,";
    "Fxn:location_tag" -> "Fxn:tagger(storage)";
    "Fxn:location_tag" -> "Fxn:RuntimeError("don't";
    "Fxn:location_tag" -> "Fxn:torch.typename(storage))";
    "Fxn:default_restore_location" -> "Fxn:fn(storage,";
    "Fxn:default_restore_location" -> "Fxn:RuntimeError("don't";
    "Fxn:default_restore_location" -> "Fxn:torch.typename(storage)";
    "Fxn:storage_to_tensor_type" -> "Fxn:_import_dotted_name(storage_type.__module__)";
    "Fxn:storage_to_tensor_type" -> "Fxn:storage_type.__name__.replace('Storage',";
    "Fxn:_with_file_like" -> "Fxn:body(f)";
    "Fxn:_with_file_like" -> "Fxn:f.close()";
    "Fxn:_is_real_file" -> "Fxn:f.fileno()";
    "Fxn:save" -> "Fxn:StringIO.write()";
    "Fxn:save" -> "Fxn:torch.Tensor([0,";
    "Fxn:save" -> "Fxn:torch.save(x,";
    "Fxn:save" -> "Fxn:io.BytesIO()";
    "Fxn:save" -> "Fxn:torch.save(x,";
    "Fxn:save" -> "Fxn:_with_file_like(f,";
    "Fxn:save" -> "Fxn:_save(obj,";
    "Fxn:_save" -> "Fxn:RuntimeError(msg)";
    "Fxn:persistent_id" -> "Fxn:inspect.getsourcefile(obj)";
    "Fxn:persistent_id" -> "Fxn:inspect.getsource(obj)";
    "Fxn:persistent_id" -> "Fxn:warnings.warn("Couldn't";
    "Fxn:persistent_id" -> "Fxn:torch.is_storage(obj):";
    "Fxn:persistent_id" -> "Fxn:normalize_storage_type(type(obj))";
    "Fxn:persistent_id" -> "Fxn:obj._root_storage()";
    "Fxn:persistent_id" -> "Fxn:location_tag(obj)";
    "Fxn:persistent_id" -> "Fxn:obj.size())";
    "Fxn:persistent_id" -> "Fxn:root.size(),";
    "Fxn:persistent_id" -> "Fxn:type_sizes=dict(";
    "Fxn:persistent_id" -> "Fxn:pickle_module.dump(MAGIC_NUMBER,";
    "Fxn:persistent_id" -> "Fxn:pickle_module.dump(PROTOCOL_VERSION,";
    "Fxn:persistent_id" -> "Fxn:pickle_module.dump(sys_info,";
    "Fxn:persistent_id" -> "Fxn:pickle_module.Pickler(f,";
    "Fxn:persistent_id" -> "Fxn:pickler.dump(obj)";
    "Fxn:persistent_id" -> "Fxn:pickle_module.dump(serialized_storage_keys,";
    "Fxn:persistent_id" -> "Fxn:f.flush()";
    "Fxn:persistent_id" -> "Fxn:serialized_storages[key]._write_file(f,";
    "Fxn:persistent_id" -> "Fxn:_is_real_file(f))";
    "Fxn:load" -> "Fxn:torch.load('tensors.pt')";
    "Fxn:load" -> "Fxn:torch.load('tensors.pt',";
    "Fxn:load" -> "Fxn:torch.load('tensors.pt',";
    "Fxn:load" -> "Fxn:torch.load('tensors.pt',";
    "Fxn:load" -> "Fxn:storage.cuda(1))";
    "Fxn:load" -> "Fxn:torch.load('tensors.pt',";
    "Fxn:load" -> "Fxn:io.BytesIO(f.read())";
    "Fxn:load" -> "Fxn:torch.load(buffer)";
    "Fxn:load" -> "Fxn:_load(f,";
    "Fxn:load" -> "Fxn:f.close()";
    "Fxn:restore_location" -> "Fxn:map_location.get(location,";
    "Fxn:restore_location" -> "Fxn:default_restore_location(storage,";
    "Fxn:restore_location" -> "Fxn:default_restore_location(storage,";
    "Fxn:restore_location" -> "Fxn:map_location(storage,";
    "Fxn:restore_location" -> "Fxn:default_restore_location(storage,";
    "Fxn:_check_container_source" -> "Fxn:inspect.getsource(container_type)";
    "Fxn:_check_container_source" -> "Fxn:warnings.warn("Couldn't";
    "Fxn:_check_container_source" -> "Fxn:difflib.unified_diff(current_source.split('\n'),";
    "Fxn:_check_container_source" -> "Fxn:original_source.split('\n'),";
    "Fxn:_check_container_source" -> "Fxn:'\n'.join(diff)";
    "Fxn:_check_container_source" -> "Fxn:f.seek(0,";
    "Fxn:_check_container_source" -> "Fxn:f.seek(0)";
    "Fxn:_check_container_source" -> "Fxn:f.write(lines)";
    "Fxn:_check_container_source" -> "Fxn:f.read()";
    "Fxn:persistent_load" -> "Fxn:_check_container_source(*saved_id)";
    "Fxn:persistent_load" -> "Fxn:deserialized_objects[int(saved_id)]";
    "Fxn:persistent_load" -> "Fxn:closing(tarfile.open(fileobj=f,";
    "Fxn:persistent_load" -> "Fxn:mkdtemp()";
    "Fxn:persistent_load" -> "Fxn:tar.extract('storages',";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:storage_type._new_with_file(f)";
    "Fxn:persistent_load" -> "Fxn:restore_location(obj,";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:tar.extract('tensors',";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:storage_to_tensor_type(storage)";
    "Fxn:persistent_load" -> "Fxn:struct.unpack('<i',";
    "Fxn:persistent_load" -> "Fxn:f.read(4))";
    "Fxn:persistent_load" -> "Fxn:f.read(4)";
    "Fxn:persistent_load" -> "Fxn:struct.unpack('<{}q'.format(ndim),";
    "Fxn:persistent_load" -> "Fxn:f.read(8";
    "Fxn:persistent_load" -> "Fxn:struct.unpack('<{}q'.format(ndim),";
    "Fxn:persistent_load" -> "Fxn:f.read(8";
    "Fxn:persistent_load" -> "Fxn:struct.unpack('<q',";
    "Fxn:persistent_load" -> "Fxn:f.read(8))";
    "Fxn:persistent_load" -> "Fxn:tensor_type().set_(storage,";
    "Fxn:persistent_load" -> "Fxn:tar.extractfile('pickle')";
    "Fxn:persistent_load" -> "Fxn:pickle_module.Unpickler(pickle_file)";
    "Fxn:persistent_load" -> "Fxn:unpickler.load()";
    "Fxn:persistent_load" -> "Fxn:_check_container_source(*data)";
    "Fxn:persistent_load" -> "Fxn:restore_location(";
    "Fxn:persistent_load" -> "Fxn:data_type(size),";
    "Fxn:persistent_load" -> "Fxn:RuntimeError("Unknown";
    "Fxn:persistent_load" -> "Fxn:_is_real_file(f)";
    "Fxn:persistent_load" -> "Fxn:f.tell()";
    "Fxn:persistent_load" -> "Fxn:fileno()";
    "Fxn:persistent_load" -> "Fxn:legacy_load(f)";
    "Fxn:persistent_load" -> "Fxn:f.seek(0)";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:RuntimeError("Invalid";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:RuntimeError("Invalid";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:pickle_module.Unpickler(f)";
    "Fxn:persistent_load" -> "Fxn:unpickler.load()";
    "Fxn:persistent_load" -> "Fxn:pickle_module.load(f)";
    "Fxn:persistent_load" -> "Fxn:f.tell()";
    "Fxn:persistent_load" -> "Fxn:deserialized_objects[key]._set_from_file(f,";
    "/torch/storage.py" -> "Import:torch";
    "/torch/storage.py" -> "Import:_type,";
    "/torch/storage.py" -> "class:_StorageBase(object):";
    "/torch/storage.py" -> "Import:torch.cuda";
    "/torch/storage.py" -> "Import:get_sharing_strategy";
    "/torch/storage.py" -> "Import:get_sharing_strategy";
    "class:_StorageBase(object):" -> "Fxn:__str__";
    "class:_StorageBase(object):" -> "Fxn:__repr__";
    "class:_StorageBase(object):" -> "Fxn:__iter__";
    "class:_StorageBase(object):" -> "Fxn:__copy__";
    "class:_StorageBase(object):" -> "Fxn:__deepcopy__";
    "class:_StorageBase(object):" -> "Fxn:__reduce__";
    "class:_StorageBase(object):" -> "Fxn:__sizeof__";
    "class:_StorageBase(object):" -> "Fxn:clone";
    "class:_StorageBase(object):" -> "Fxn:tolist";
    "class:_StorageBase(object):" -> "Fxn:cpu";
    "class:_StorageBase(object):" -> "Fxn:double";
    "class:_StorageBase(object):" -> "Fxn:float";
    "class:_StorageBase(object):" -> "Fxn:half";
    "class:_StorageBase(object):" -> "Fxn:long";
    "class:_StorageBase(object):" -> "Fxn:int";
    "class:_StorageBase(object):" -> "Fxn:short";
    "class:_StorageBase(object):" -> "Fxn:char";
    "class:_StorageBase(object):" -> "Fxn:byte";
    "class:_StorageBase(object):" -> "Fxn:pin_memory";
    "class:_StorageBase(object):" -> "Fxn:share_memory_";
    "class:_StorageBase(object):" -> "Fxn:_new_shared";
    "Fxn:__str__" -> "Fxn:'.join(str(self[i])";
    "Fxn:__str__" -> "Fxn:{}]'.format(torch.typename(self),";
    "Fxn:__copy__" -> "Fxn:self.clone()";
    "Fxn:__deepcopy__" -> "Fxn:memo.setdefault('torch',";
    "Fxn:__deepcopy__" -> "Fxn:self.clone()";
    "Fxn:__sizeof__" -> "Fxn:self).__sizeof__()";
    "Fxn:__sizeof__" -> "Fxn:self.element_size()";
    "Fxn:__sizeof__" -> "Fxn:self.size()";
    "Fxn:cpu" -> "Fxn:self.type(getattr(torch,";
    "Fxn:double" -> "Fxn:self.type(type(self).__module__";
    "Fxn:float" -> "Fxn:self.type(type(self).__module__";
    "Fxn:half" -> "Fxn:self.type(type(self).__module__";
    "Fxn:long" -> "Fxn:self.type(type(self).__module__";
    "Fxn:int" -> "Fxn:self.type(type(self).__module__";
    "Fxn:short" -> "Fxn:self.type(type(self).__module__";
    "Fxn:char" -> "Fxn:self.type(type(self).__module__";
    "Fxn:byte" -> "Fxn:self.type(type(self).__module__";
    "Fxn:pin_memory" -> "Fxn:TypeError("cannot";
    "Fxn:pin_memory" -> "Fxn:.format(self.type()))";
    "Fxn:pin_memory" -> "Fxn:torch.cuda._host_allocator()";
    "Fxn:pin_memory" -> "Fxn:allocator=allocator).copy_(self)";
    "Fxn:share_memory_" -> "Fxn:get_sharing_strategy()";
    "Fxn:share_memory_" -> "Fxn:self._share_filename_()";
    "Fxn:share_memory_" -> "Fxn:self._share_fd_()";
    "Fxn:_new_shared" -> "Fxn:cls(size)";
    "Fxn:_new_shared" -> "Fxn:get_sharing_strategy()";
    "Fxn:_new_shared" -> "Fxn:cls._new_using_filename(size)";
    "Fxn:_new_shared" -> "Fxn:cls._new_using_fd(size)";
    "/torch/_six.py" -> "Import:itertools";
    "/torch/_six.py" -> "Import:sys";
    "/torch/_six.py" -> "Fxn:with_metaclass";
    "/torch/_six.py" -> "class:metaclass(meta):";
    "/torch/_six.py" -> "Import:builtins";
    "class:metaclass(meta):" -> "Fxn:__new__";
    "class:metaclass(meta):" -> "Fxn:exec_";
    "class:metaclass(meta):" -> "Fxn:raise_from";
    "Fxn:__new__" -> "Fxn:meta(name,";
    "Fxn:__new__" -> "Fxn:type.__new__(metaclass,";
    "Fxn:exec_" -> "Fxn:sys._getframe(1)";
    "Fxn:exec_" -> "Fxn:exec_("""def";
    "Fxn:exec_" -> "Fxn:raise_from(value,";
    "Fxn:exec_" -> "Fxn:exec_("""def";
    "Fxn:exec_" -> "Fxn:raise_from(value,";
    "/torch/_storage_docs.py" -> "Import:torch._C";
    "/torch/_storage_docs.py" -> "Import:_add_docstr";
    "/torch/_storage_docs.py" -> "Fxn:add_docstr_all";
    "/torch/_tensor_docs.py" -> "Import:torch._C";
    "/torch/_tensor_docs.py" -> "Import:_add_docstr";
    "/torch/_tensor_docs.py" -> "Fxn:add_docstr_all";
    "/torch/_tensor_docs.py" -> "Fxn:callable";
    "/torch/_tensor_str.py" -> "Import:math";
    "/torch/_tensor_str.py" -> "Import:torch";
    "/torch/_tensor_str.py" -> "Import:reduce";
    "/torch/_tensor_str.py" -> "Import:float_info";
    "/torch/_tensor_str.py" -> "class:__PrinterOptions(object):";
    "class:__PrinterOptions(object):" -> "Fxn:set_printoptions";
    "class:__PrinterOptions(object):" -> "Fxn:_get_min_log_scale";
    "class:__PrinterOptions(object):" -> "Fxn:_number_format";
    "class:__PrinterOptions(object):" -> "Fxn:_tensor_str";
    "class:__PrinterOptions(object):" -> "Fxn:__repr_row";
    "class:__PrinterOptions(object):" -> "Fxn:_matrix_str";
    "class:__PrinterOptions(object):" -> "Fxn:_vector_str";
    "class:__PrinterOptions(object):" -> "Fxn:_str";
    "Fxn:_get_min_log_scale" -> "Fxn:math.ceil(math.log(min_positive,";
    "Fxn:_number_format" -> "Fxn:_get_min_log_scale()";
    "Fxn:_number_format" -> "Fxn:torch.DoubleTensor(tensor.size()).copy_(tensor).abs_().view(tensor.nelement())";
    "Fxn:_number_format" -> "Fxn:tensor.eq(float('inf'))";
    "Fxn:_number_format" -> "Fxn:tensor.eq(float('-inf'))";
    "Fxn:_number_format" -> "Fxn:tensor.ne(tensor)";
    "Fxn:_number_format" -> "Fxn:invalid_value_mask.all():";
    "Fxn:_number_format" -> "Fxn:tensor[invalid_value_mask.eq(0)][0]";
    "Fxn:_number_format" -> "Fxn:invalid_value_mask.any():";
    "Fxn:_number_format" -> "Fxn:math.ceil(value.item()):";
    "Fxn:_number_format" -> "Fxn:tensor.min()";
    "Fxn:_number_format" -> "Fxn:math.floor(math.log10(exp_min))";
    "Fxn:_number_format" -> "Fxn:tensor.max()";
    "Fxn:_number_format" -> "Fxn:math.floor(math.log10(exp_max))";
    "Fxn:_number_format" -> "Fxn:'{{:11.{}e}}'.format(prec)";
    "Fxn:_number_format" -> "Fxn:'{{:{}.{}e}}'.format(sz,";
    "Fxn:_number_format" -> "Fxn:math.pow(10,";
    "Fxn:_number_format" -> "Fxn:'{{:{}.{}f}}'.format(sz,";
    "Fxn:_tensor_str" -> "Fxn:self.size()[-1]";
    "Fxn:_tensor_str" -> "Fxn:self.size()[-2]";
    "Fxn:_tensor_str" -> "Fxn:_number_format(self,";
    "Fxn:_tensor_str" -> "Fxn:self.numel()";
    "Fxn:_tensor_str" -> "Fxn:self.size()))";
    "Fxn:_tensor_str" -> "Fxn:self.ndimension()";
    "Fxn:_tensor_str" -> "Fxn:torch.LongStorage(counter_dim).fill_(0)";
    "Fxn:_tensor_str" -> "Fxn:counter[counter.size()";
    "Fxn:_tensor_str" -> "Fxn:self.size(i)";
    "Fxn:_tensor_str" -> "Fxn:self.size(i)";
    "Fxn:_tensor_str" -> "Fxn:self.size(i):";
    "Fxn:_tensor_str" -> "Fxn:dot_fmt.format('...')";
    "Fxn:_tensor_str" -> "Fxn:dot_fmt.format('')";
    "Fxn:_tensor_str" -> "Fxn:dot_fmt.format(u'\u22EE'";
    "Fxn:_tensor_str" -> "Fxn:'({},.,.)";
    "Fxn:_tensor_str" -> "Fxn:\n'.format(";
    "Fxn:_tensor_str" -> "Fxn:','.join(dim_fmt.format(i)";
    "Fxn:_tensor_str" -> "Fxn:reduce(lambda";
    "Fxn:_tensor_str" -> "Fxn:t.select(0,";
    "Fxn:_tensor_str" -> "Fxn:_matrix_str(submatrix,";
    "Fxn:__repr_row" -> "Fxn:'.join(fmt.format(val.item()";
    "Fxn:__repr_row" -> "Fxn:dotfmt.format('...')";
    "Fxn:__repr_row" -> "Fxn:'.join(fmt.format(val.item()";
    "Fxn:__repr_row" -> "Fxn:'.join(fmt.format(val.item()";
    "Fxn:_matrix_str" -> "Fxn:self.size(1)";
    "Fxn:_matrix_str" -> "Fxn:self.size(0)";
    "Fxn:_matrix_str" -> "Fxn:_number_format(self,";
    "Fxn:_matrix_str" -> "Fxn:self.size(1):";
    "Fxn:_matrix_str" -> "Fxn:self.size(1)";
    "Fxn:_matrix_str" -> "Fxn:self.size(1):";
    "Fxn:_matrix_str" -> "Fxn:\n{}'.format(";
    "Fxn:_matrix_str" -> "Fxn:SCALE_FORMAT.format(scale)";
    "Fxn:_matrix_str" -> "Fxn:'.join(fmt.format(val.item()";
    "Fxn:_matrix_str" -> "Fxn:SCALE_FORMAT.format(scale)";
    "Fxn:_matrix_str" -> "Fxn:__repr_row(row,";
    "Fxn:_matrix_str" -> "Fxn:'.join([vdotfmt.format('...'),";
    "Fxn:_matrix_str" -> "Fxn:ddotfmt.format(u'\u22F1'),";
    "Fxn:_matrix_str" -> "Fxn:vdotfmt.format('...')])";
    "Fxn:_matrix_str" -> "Fxn:__repr_row(row,";
    "Fxn:_matrix_str" -> "Fxn:__repr_row(row,";
    "Fxn:_matrix_str" -> "Fxn:__repr_row(row,";
    "Fxn:_matrix_str" -> "Fxn:vdotfmt.format(u'\u22EE')";
    "Fxn:_matrix_str" -> "Fxn:__repr_row(row,";
    "Fxn:_matrix_str" -> "Fxn:__repr_row(row,";
    "Fxn:_vector_str" -> "Fxn:_number_format(self)";
    "Fxn:_vector_str" -> "Fxn:SCALE_FORMAT.format(scale)";
    "Fxn:_vector_str" -> "Fxn:self.numel()";
    "Fxn:_vector_str" -> "Fxn:'\n'.join(ident";
    "Fxn:_vector_str" -> "Fxn:fmt.format(val.item()";
    "Fxn:_vector_str" -> "Fxn:'\n'.join(ident";
    "Fxn:_vector_str" -> "Fxn:fmt.format(val.item()";
    "Fxn:_vector_str" -> "Fxn:dotfmt.format(u"\u22EE"))";
    "Fxn:_vector_str" -> "Fxn:'\n'.join(ident";
    "Fxn:_vector_str" -> "Fxn:fmt.format(val.item()";
    "Fxn:_str" -> "Fxn:values:\n{}'.format(";
    "Fxn:_str" -> "Fxn:self.type(),";
    "Fxn:_str" -> "Fxn:self._indices(),";
    "Fxn:_str" -> "Fxn:self._values())";
    "Fxn:_str" -> "Fxn:self.numel()";
    "Fxn:_str" -> "Fxn:self.dim()";
    "Fxn:_str" -> "Fxn:_vector_str(self.unsqueeze(0))";
    "Fxn:_str" -> "Fxn:_vector_str(self)";
    "Fxn:_str" -> "Fxn:_matrix_str(self)";
    "Fxn:_str" -> "Fxn:_tensor_str(self)";
    "Fxn:_str" -> "Fxn:{})'.format(self.get_device())";
    "Fxn:_str" -> "Fxn:{}{}]\n'.format(self.type(),";
    "/torch/_torch_docs.py" -> "Import:torch._C";
    "/torch/_torch_docs.py" -> "Import:_add_docstr";
    "/torch/_torch_docs.py" -> "Import:torch";
    "/torch/_utils.py" -> "Import:torch";
    "/torch/_utils.py" -> "Import:importlib";
    "/torch/_utils.py" -> "Import:warnings";
    "/torch/_utils.py" -> "Import:defaultdict";
    "/torch/_utils.py" -> "Fxn:_type";
    "/torch/_utils.py" -> "Fxn:_cuda";
    "/torch/_utils.py" -> "Fxn:_get_async_or_non_blocking";
    "/torch/_utils.py" -> "Fxn:_rebuild_tensor";
    "/torch/_utils.py" -> "Fxn:_rebuild_tensor_v2";
    "/torch/_utils.py" -> "Fxn:_import_dotted_name";
    "/torch/_utils.py" -> "Fxn:_accumulate";
    "/torch/_utils.py" -> "Fxn:_flatten_dense_tensors";
    "/torch/_utils.py" -> "Fxn:_flatten_sparse_tensors";
    "/torch/_utils.py" -> "Fxn:_unflatten_dense_tensors";
    "/torch/_utils.py" -> "Fxn:_unflatten_sparse_tensors";
    "/torch/_utils.py" -> "Fxn:_reorder_tensors_as";
    "/torch/_utils.py" -> "Fxn:_take_tensors";
    "/torch/__init__.py" -> "Import:sys";
    "/torch/__init__.py" -> "Import:platform";
    "/torch/__init__.py" -> "Import:_import_dotted_name";
    "/torch/__init__.py" -> "Import:__version__";
    "/torch/__init__.py" -> "Import:string_classes";
    "/torch/__init__.py" -> "Import:_dl_flags";
    "/torch/__init__.py" -> "Import:numpy";
    "/torch/__init__.py" -> "Fxn:get_nvToolsExt_path";
    "/torch/__init__.py" -> "Import:DLFCN";
    "/torch/__init__.py" -> "Import:torch._dl";
    "/torch/__init__.py" -> "Import:torch._nvrtc";
    "/torch/__init__.py" -> "Import:__all__";
    "/torch/__init__.py" -> "Fxn:typename";
    "/torch/__init__.py" -> "Fxn:is_tensor";
    "/torch/__init__.py" -> "Fxn:is_storage";
    "/torch/__init__.py" -> "Fxn:set_default_tensor_type";
    "/torch/__init__.py" -> "Import:set_rng_state,";
    "/torch/__init__.py" -> "Import:save,";
    "/torch/__init__.py" -> "Import:set_printoptions";
    "/torch/__init__.py" -> "Import:_StorageBase";
    "/torch/__init__.py" -> "class:DoubleStorage(_C.DoubleStorageBase,";
    "/torch/__init__.py" -> "class:FloatStorage(_C.FloatStorageBase,";
    "/torch/__init__.py" -> "class:HalfStorage(_C.HalfStorageBase,";
    "/torch/__init__.py" -> "class:LongStorage(_C.LongStorageBase,";
    "/torch/__init__.py" -> "class:IntStorage(_C.IntStorageBase,";
    "/torch/__init__.py" -> "class:ShortStorage(_C.ShortStorageBase,";
    "/torch/__init__.py" -> "class:CharStorage(_C.CharStorageBase,";
    "/torch/__init__.py" -> "class:ByteStorage(_C.ByteStorageBase,";
    "/torch/__init__.py" -> "Import:path";
    "/torch/__init__.py" -> "Import:################################################################################";
    "/torch/__init__.py" -> "Import:torch.cuda";
    "/torch/__init__.py" -> "Import:torch.autograd";
    "/torch/__init__.py" -> "Import:torch.nn";
    "/torch/__init__.py" -> "Import:torch.optim";
    "/torch/__init__.py" -> "Import:torch.multiprocessing";
    "/torch/__init__.py" -> "Import:torch.sparse";
    "/torch/__init__.py" -> "Import:torch.utils.backcompat";
    "/torch/__init__.py" -> "Import:torch.onnx";
    "/torch/__init__.py" -> "Import:torch.jit";
    "/torch/__init__.py" -> "Import:torch.random";
    "/torch/__init__.py" -> "Import:torch.distributions";
    "/torch/__init__.py" -> "Import:torch.testing";
    "/torch/__init__.py" -> "Import:no_grad,";
    "/torch/__init__.py" -> "Import:_torch_docs,";
    "class:ByteStorage(_C.ByteStorageBase," -> "Fxn:manager_path";
    "Fxn:manager_path" -> "Fxn:platform.system()";
    "Fxn:manager_path" -> "Fxn:os.path.join(os.path.abspath(os.path.dirname(__file__)),";
    "Fxn:manager_path" -> "Fxn:os.path.exists(path):";
    "Fxn:manager_path" -> "Fxn:RuntimeError("Unable";
    "Fxn:manager_path" -> "Fxn:path.encode('utf-8')";
    "Fxn:manager_path" -> "Fxn:_C._initExtension(manager_path())";
    "Fxn:manager_path" -> "Fxn:_C._init_names(list(torch._storage_classes))";
    "/torch/autograd/function.py" -> "Import:torch";
    "/torch/autograd/function.py" -> "Import:torch._C";
    "/torch/autograd/function.py" -> "Import:torch.utils.hooks";
    "/torch/autograd/function.py" -> "Import:with_metaclass";
    "/torch/autograd/function.py" -> "Import:functools";
    "/torch/autograd/function.py" -> "Import:warnings";
    "/torch/autograd/function.py" -> "Import:OrderedDict";
    "/torch/autograd/function.py" -> "class:_ContextMethodMixin(object):";
    "/torch/autograd/function.py" -> "class:_HookMixin(object):";
    "/torch/autograd/function.py" -> "class:BackwardCFunction(_C._FunctionBase,";
    "/torch/autograd/function.py" -> "class:FunctionMeta(type):";
    "/torch/autograd/function.py" -> "class:Function(with_metaclass(FunctionMeta,";
    "/torch/autograd/function.py" -> "class:Exp(Function):";
    "/torch/autograd/function.py" -> "Import:Variable";
    "/torch/autograd/function.py" -> "class:InplaceFunction(Function):";
    "/torch/autograd/function.py" -> "class:NestedIOFunction(Function):";
    "class:_ContextMethodMixin(object):" -> "Fxn:save_for_backward";
    "class:_ContextMethodMixin(object):" -> "Fxn:mark_dirty";
    "class:_ContextMethodMixin(object):" -> "Fxn:mark_shared_storage";
    "class:_ContextMethodMixin(object):" -> "Fxn:mark_non_differentiable";
    "Fxn:mark_shared_storage" -> "Fxn:warnings.warn(";
    "Fxn:mark_shared_storage" -> "Fxn:`set_()`";
    "class:_HookMixin(object):" -> "Fxn:_register_hook";
    "Fxn:_register_hook" -> "Fxn:OrderedDict()";
    "Fxn:_register_hook" -> "Fxn:hooks.RemovableHandle(backward_hooks)";
    "class:BackwardCFunction(_C._FunctionBase," -> "Fxn:apply";
    "Fxn:apply" -> "Fxn:self._forward_cls.backward(self,";
    "class:FunctionMeta(type):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:cls.mro():";
    "Fxn:__init__" -> "Fxn:super_cls.__dict__.get('forward')";
    "Fxn:__init__" -> "Fxn:cls).__init__(name,";
    "Fxn:__init__" -> "Fxn:cls).__init__(name,";
    "class:Exp(Function):" -> "Fxn:forward";
    "class:Exp(Function):" -> "Fxn:backward";
    "class:Exp(Function):" -> "Fxn:forward";
    "class:Exp(Function):" -> "Fxn:backward";
    "class:Exp(Function):" -> "Fxn:once_differentiable";
    "class:Exp(Function):" -> "Fxn:wrapper";
    "class:Exp(Function):" -> "Fxn:fake_requires_grad";
    "class:Exp(Function):" -> "Fxn:traceable";
    "Fxn:forward" -> "Fxn:i.exp()";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(result)";
    "Fxn:once_differentiable" -> "Fxn:@functools.wraps(fn)";
    "Fxn:wrapper" -> "Fxn:torch.no_grad():";
    "Fxn:wrapper" -> "Fxn:fn(ctx,";
    "Fxn:wrapper" -> "Fxn:torch.is_grad_enabled():";
    "Fxn:wrapper" -> "Fxn:torch._C._functions.DelayedError(";
    "Fxn:fake_requires_grad" -> "Fxn:var.detach()";
    "Fxn:fake_requires_grad" -> "Fxn:err_fn(*[fake_requires_grad(v)";
    "class:InplaceFunction(Function):" -> "Fxn:__init__";
    "class:InplaceFunction(Function):" -> "Fxn:_nested_map";
    "class:InplaceFunction(Function):" -> "Fxn:_map";
    "class:InplaceFunction(Function):" -> "Fxn:_iter_filter";
    "class:InplaceFunction(Function):" -> "Fxn:_iter";
    "class:InplaceFunction(Function):" -> "Fxn:_unflatten";
    "class:InplaceFunction(Function):" -> "Fxn:unflatten_helper";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_map" -> "Fxn:condition(obj):";
    "Fxn:_map" -> "Fxn:fn(obj)";
    "Fxn:_map" -> "Fxn:ValueError("Auto";
    "Fxn:_map" -> "Fxn:torch.typename(obj)";
    "Fxn:_iter" -> "Fxn:condition(obj):";
    "Fxn:_iter" -> "Fxn:_iter(o):";
    "Fxn:_iter" -> "Fxn:ValueError("Auto";
    "Fxn:_iter" -> "Fxn:torch.typename(obj)";
    "Fxn:unflatten_helper" -> "Fxn:res.append(e)";
    "Fxn:unflatten_helper" -> "Fxn:unflatten_helper(input,";
    "Fxn:unflatten_helper" -> "Fxn:res.append(res_e)";
    "Fxn:unflatten_helper" -> "Fxn:unflatten_helper(input,";
    "Fxn:unflatten_helper" -> "Fxn:_iter_filter(lambda";
    "Fxn:unflatten_helper" -> "Fxn:_iter_filter(lambda";
    "Fxn:unflatten_helper" -> "Fxn:_iter_filter(lambda";
    "Fxn:unflatten_helper" -> "Fxn:_iter_filter(torch.is_tensor,";
    "Fxn:unflatten_helper" -> "Fxn:_iter_filter(";
    "Fxn:unflatten_helper" -> "Fxn:torch.is_tensor(o)";
    "Fxn:unflatten_helper" -> "Fxn:_nested_map(lambda";
    "class:NestedIOFunction(Function):" -> "Fxn:_do_forward";
    "class:NestedIOFunction(Function):" -> "Fxn:_do_backward";
    "class:NestedIOFunction(Function):" -> "Fxn:backward";
    "class:NestedIOFunction(Function):" -> "Fxn:forward";
    "class:NestedIOFunction(Function):" -> "Fxn:save_for_backward";
    "class:NestedIOFunction(Function):" -> "Fxn:saved_tensors";
    "class:NestedIOFunction(Function):" -> "Fxn:mark_dirty";
    "class:NestedIOFunction(Function):" -> "Fxn:mark_non_differentiable";
    "class:NestedIOFunction(Function):" -> "Fxn:forward_extended";
    "class:NestedIOFunction(Function):" -> "Fxn:backward_extended";
    "Fxn:_do_forward" -> "Fxn:self)._do_forward(*flat_input)";
    "Fxn:_do_forward" -> "Fxn:_unflatten(flat_output,";
    "Fxn:_do_backward" -> "Fxn:self)._do_backward(gradients,";
    "Fxn:backward" -> "Fxn:_unflatten(gradients,";
    "Fxn:backward" -> "Fxn:self.backward_extended(*nested_gradients)";
    "Fxn:forward" -> "Fxn:_map_variable_tensor(self._nested_input)";
    "Fxn:forward" -> "Fxn:self.forward_extended(*nested_tensors)";
    "Fxn:saved_tensors" -> "Fxn:_unflatten(flat_tensors,";
    "/torch/autograd/gradcheck.py" -> "Import:torch";
    "/torch/autograd/gradcheck.py" -> "Import:Variable";
    "/torch/autograd/gradcheck.py" -> "Import:Iterable";
    "/torch/autograd/gradcheck.py" -> "Import:torch.testing";
    "/torch/autograd/gradcheck.py" -> "Import:sys";
    "/torch/autograd/gradcheck.py" -> "Fxn:iter_variables";
    "/torch/autograd/gradcheck.py" -> "Fxn:zero_gradients";
    "/torch/autograd/gradcheck.py" -> "Fxn:make_jacobian";
    "/torch/autograd/gradcheck.py" -> "Fxn:iter_tensors";
    "/torch/autograd/gradcheck.py" -> "Fxn:contiguous";
    "/torch/autograd/gradcheck.py" -> "Fxn:get_numerical_jacobian";
    "/torch/autograd/gradcheck.py" -> "Fxn:get_analytical_jacobian";
    "/torch/autograd/gradcheck.py" -> "Fxn:_as_tuple";
    "/torch/autograd/gradcheck.py" -> "Fxn:_differentiable_outputs";
    "/torch/autograd/gradcheck.py" -> "Fxn:gradcheck";
    "/torch/autograd/gradcheck.py" -> "Fxn:fail_test";
    "/torch/autograd/gradcheck.py" -> "Fxn:fn";
    "/torch/autograd/gradcheck.py" -> "Fxn:gradgradcheck";
    "/torch/autograd/gradcheck.py" -> "Fxn:randn_like";
    "/torch/autograd/gradcheck.py" -> "Fxn:new_func";
    "/torch/autograd/grad_mode.py" -> "Import:torch";
    "/torch/autograd/grad_mode.py" -> "class:no_grad(object):";
    "/torch/autograd/grad_mode.py" -> "class:enable_grad(object):";
    "/torch/autograd/grad_mode.py" -> "class:set_grad_enabled(object):";
    "class:no_grad(object):" -> "Fxn:__init__";
    "class:no_grad(object):" -> "Fxn:__enter__";
    "class:no_grad(object):" -> "Fxn:__exit__";
    "Fxn:__init__" -> "Fxn:torch.is_grad_enabled()";
    "Fxn:__enter__" -> "Fxn:torch._C.set_grad_enabled(False)";
    "Fxn:__exit__" -> "Fxn:torch.set_grad_enabled(self.prev)";
    "class:enable_grad(object):" -> "Fxn:__init__";
    "class:enable_grad(object):" -> "Fxn:__enter__";
    "class:enable_grad(object):" -> "Fxn:__exit__";
    "Fxn:__init__" -> "Fxn:torch.is_grad_enabled()";
    "Fxn:__enter__" -> "Fxn:torch._C.set_grad_enabled(True)";
    "Fxn:__exit__" -> "Fxn:torch.set_grad_enabled(self.prev)";
    "class:set_grad_enabled(object):" -> "Fxn:__init__";
    "class:set_grad_enabled(object):" -> "Fxn:__enter__";
    "class:set_grad_enabled(object):" -> "Fxn:__exit__";
    "Fxn:__init__" -> "Fxn:torch.is_grad_enabled()";
    "Fxn:__init__" -> "Fxn:torch._C.set_grad_enabled(mode)";
    "Fxn:__exit__" -> "Fxn:torch.set_grad_enabled(self.prev)";
    "/torch/autograd/profiler.py" -> "Import:subprocess";
    "/torch/autograd/profiler.py" -> "Import:import";
    "/torch/autograd/profiler.py" -> "Import:import";
    "/torch/autograd/profiler.py" -> "Import:sys";
    "/torch/autograd/profiler.py" -> "Import:itertools";
    "/torch/autograd/profiler.py" -> "Import:defaultdict";
    "/torch/autograd/profiler.py" -> "Import:torch";
    "/torch/autograd/profiler.py" -> "class:range(object):";
    "/torch/autograd/profiler.py" -> "class:EventList(list):";
    "/torch/autograd/profiler.py" -> "Import:json";
    "/torch/autograd/profiler.py" -> "class:profile(object):";
    "/torch/autograd/profiler.py" -> "class:emit_nvtx(object):";
    "/torch/autograd/profiler.py" -> "class:FormattedTimesMixin(object):";
    "/torch/autograd/profiler.py" -> "class:Interval(object):";
    "/torch/autograd/profiler.py" -> "class:Kernel(object):";
    "/torch/autograd/profiler.py" -> "class:FunctionEvent(FormattedTimesMixin):";
    "/torch/autograd/profiler.py" -> "class:FunctionEventAvg(FormattedTimesMixin):";
    "/torch/autograd/profiler.py" -> "class:StringTable(defaultdict):";
    "/torch/autograd/profiler.py" -> "class:EnforceUnique(object):";
    "/torch/autograd/profiler.py" -> "Import:sqlite3";
    "class:range(object):" -> "Fxn:__init__";
    "class:range(object):" -> "Fxn:__enter__";
    "class:range(object):" -> "Fxn:__exit__";
    "Fxn:__enter__" -> "Fxn:torch.autograd._push_range(self.name)";
    "Fxn:__exit__" -> "Fxn:torch.autograd._pop_range()";
    "class:EventList(list):" -> "Fxn:__init__";
    "class:EventList(list):" -> "Fxn:__str__";
    "class:EventList(list):" -> "Fxn:table";
    "class:EventList(list):" -> "Fxn:export_chrome_trace";
    "class:EventList(list):" -> "Fxn:key_averages";
    "class:EventList(list):" -> "Fxn:total_average";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__str__" -> "Fxn:self.table()";
    "Fxn:table" -> "Fxn:build_table(self,";
    "Fxn:export_chrome_trace" -> "Fxn:chrome_events.append(dict(";
    "Fxn:export_chrome_trace" -> "Fxn:dur=evt.cpu_interval.elapsed_us(),";
    "Fxn:export_chrome_trace" -> "Fxn:chrome_events.append(dict(";
    "Fxn:export_chrome_trace" -> "Fxn:chrome_events.append(dict(";
    "Fxn:export_chrome_trace" -> "Fxn:chrome_events.append(dict(";
    "Fxn:export_chrome_trace" -> "Fxn:dur=k.interval.elapsed_us(),";
    "Fxn:export_chrome_trace" -> "Fxn:json.dump(chrome_events,";
    "Fxn:key_averages" -> "Fxn:defaultdict(FunctionEventAvg)";
    "Fxn:key_averages" -> "Fxn:EventList(stats.values())";
    "Fxn:total_average" -> "Fxn:FunctionEventAvg()";
    "class:profile(object):" -> "Fxn:__init__";
    "class:profile(object):" -> "Fxn:__enter__";
    "class:profile(object):" -> "Fxn:__exit__";
    "class:profile(object):" -> "Fxn:__repr__";
    "class:profile(object):" -> "Fxn:__str__";
    "class:profile(object):" -> "Fxn:_check_finish";
    "class:profile(object):" -> "Fxn:table";
    "class:profile(object):" -> "Fxn:export_chrome_trace";
    "class:profile(object):" -> "Fxn:key_averages";
    "class:profile(object):" -> "Fxn:total_average";
    "Fxn:__enter__" -> "Fxn:RuntimeError("autograd";
    "Fxn:__enter__" -> "Fxn:torch.autograd._enable_profiler(profiler_kind)";
    "Fxn:__exit__" -> "Fxn:torch.autograd._disable_profiler()";
    "Fxn:__exit__" -> "Fxn:EventList(parse_cpu_trace(records))";
    "Fxn:_check_finish" -> "Fxn:RuntimeError("can't";
    "Fxn:table" -> "Fxn:self._check_finish()";
    "Fxn:table" -> "Fxn:self.function_events.table(sort_by)";
    "Fxn:export_chrome_trace" -> "Fxn:self._check_finish()";
    "Fxn:export_chrome_trace" -> "Fxn:self.function_events.export_chrome_trace(path)";
    "Fxn:key_averages" -> "Fxn:self._check_finish()";
    "Fxn:key_averages" -> "Fxn:self.function_events.key_averages()";
    "Fxn:total_average" -> "Fxn:self._check_finish()";
    "Fxn:total_average" -> "Fxn:self.function_events.total_average()";
    "class:emit_nvtx(object):" -> "Fxn:__init__";
    "class:emit_nvtx(object):" -> "Fxn:__enter__";
    "class:emit_nvtx(object):" -> "Fxn:__exit__";
    "class:emit_nvtx(object):" -> "Fxn:load_nvprof";
    "class:emit_nvtx(object):" -> "Fxn:format_time";
    "class:emit_nvtx(object):" -> "Fxn:attr_formatter";
    "Fxn:__enter__" -> "Fxn:RuntimeError("NVTX";
    "Fxn:__enter__" -> "Fxn:torch.cuda.synchronize()";
    "Fxn:__enter__" -> "Fxn:torch.autograd._enable_profiler(torch.autograd.ProfilerState.NVTX)";
    "Fxn:__exit__" -> "Fxn:torch.cuda.synchronize()";
    "Fxn:__exit__" -> "Fxn:torch.autograd._disable_profiler()";
    "Fxn:load_nvprof" -> "Fxn:EventList(parse_nvprof_trace(path))";
    "Fxn:format_time" -> "Fxn:'{:.3f}us'.format(time_us)";
    "Fxn:attr_formatter" -> "Fxn:format_time(getattr(self,";
    "class:FormattedTimesMixin(object):" -> "Fxn:cpu_time";
    "class:FormattedTimesMixin(object):" -> "Fxn:cuda_time";
    "class:Interval(object):" -> "Fxn:__init__";
    "class:Interval(object):" -> "Fxn:elapsed_us";
    "class:Kernel(object):" -> "Fxn:__init__";
    "class:FunctionEvent(FormattedTimesMixin):" -> "Fxn:__init__";
    "class:FunctionEvent(FormattedTimesMixin):" -> "Fxn:append_kernel";
    "class:FunctionEvent(FormattedTimesMixin):" -> "Fxn:cuda_time_total";
    "class:FunctionEvent(FormattedTimesMixin):" -> "Fxn:cpu_time_total";
    "class:FunctionEvent(FormattedTimesMixin):" -> "Fxn:key";
    "class:FunctionEvent(FormattedTimesMixin):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:Interval(cpu_start,";
    "Fxn:append_kernel" -> "Fxn:self.kernels.append(Kernel(name,";
    "Fxn:append_kernel" -> "Fxn:Interval(start,";
    "Fxn:cpu_time_total" -> "Fxn:self.cpu_interval.elapsed_us()";
    "Fxn:__repr__" -> "Fxn:thread={}>'.format(";
    "class:FunctionEventAvg(FormattedTimesMixin):" -> "Fxn:__init__";
    "class:FunctionEventAvg(FormattedTimesMixin):" -> "Fxn:__iadd__";
    "class:FunctionEventAvg(FormattedTimesMixin):" -> "Fxn:__repr__";
    "class:FunctionEventAvg(FormattedTimesMixin):" -> "Fxn:demangle";
    "Fxn:__repr__" -> "Fxn:key={}>'.format(";
    "Fxn:demangle" -> "Fxn:subprocess.check_output(filt_cmd,";
    "Fxn:demangle" -> "Fxn:stderr=devnull).rstrip().decode("ascii")";
    "Fxn:demangle" -> "Fxn:re.search('is";
    "Fxn:demangle" -> "Fxn:\"(.*)"',";
    "Fxn:demangle" -> "Fxn:orig_name).group(1)";
    "class:StringTable(defaultdict):" -> "Fxn:__missing__";
    "class:StringTable(defaultdict):" -> "Fxn:parse_cpu_trace";
    "class:StringTable(defaultdict):" -> "Fxn:adjusted_time";
    "Fxn:__missing__" -> "Fxn:demangle(key)";
    "Fxn:parse_cpu_trace" -> "Fxn:StringTable()";
    "Fxn:adjusted_time" -> "Fxn:cuda_record.device()";
    "Fxn:adjusted_time" -> "Fxn:cuda_records[cuda_record.device()]";
    "Fxn:adjusted_time" -> "Fxn:cuda_time_0.cuda_elapsed_us(cuda_record)";
    "Fxn:adjusted_time" -> "Fxn:start_record.cpu_elapsed_us(cuda_time_0)";
    "Fxn:adjusted_time" -> "Fxn:itertools.chain(*thread_records):";
    "Fxn:adjusted_time" -> "Fxn:record.name()";
    "Fxn:adjusted_time" -> "Fxn:record.name()";
    "Fxn:adjusted_time" -> "Fxn:record.device()";
    "Fxn:adjusted_time" -> "Fxn:cuda_records[record.device()]";
    "Fxn:adjusted_time" -> "Fxn:itertools.chain(*thread_records):";
    "Fxn:adjusted_time" -> "Fxn:record.kind()";
    "Fxn:adjusted_time" -> "Fxn:record.kind()";
    "Fxn:adjusted_time" -> "Fxn:record_stack.append((next_id,";
    "Fxn:adjusted_time" -> "Fxn:record.kind()";
    "Fxn:adjusted_time" -> "Fxn:record_stack.pop()";
    "Fxn:adjusted_time" -> "Fxn:FunctionEvent(";
    "Fxn:adjusted_time" -> "Fxn:name=string_table[start.name()],";
    "Fxn:adjusted_time" -> "Fxn:thread=start.thread_id(),";
    "Fxn:adjusted_time" -> "Fxn:cpu_start=start_record.cpu_elapsed_us(start),";
    "Fxn:adjusted_time" -> "Fxn:cpu_end=start_record.cpu_elapsed_us(record))";
    "Fxn:adjusted_time" -> "Fxn:start.has_cuda():";
    "Fxn:adjusted_time" -> "Fxn:adjusted_time(start)";
    "Fxn:adjusted_time" -> "Fxn:adjusted_time(record)";
    "Fxn:adjusted_time" -> "Fxn:fe.append_kernel(start.name(),";
    "Fxn:adjusted_time" -> "Fxn:start.device(),";
    "Fxn:adjusted_time" -> "Fxn:functions.append(fe)";
    "Fxn:adjusted_time" -> "Fxn:functions.sort(key=lambda";
    "class:EnforceUnique(object):" -> "Fxn:__init__";
    "class:EnforceUnique(object):" -> "Fxn:see";
    "class:EnforceUnique(object):" -> "Fxn:parse_nvprof_trace";
    "class:EnforceUnique(object):" -> "Fxn:build_table";
    "class:EnforceUnique(object):" -> "Fxn:append";
    "Fxn:see" -> "Fxn:RuntimeError('duplicate";
    "Fxn:see" -> "Fxn:self.seen.add(key)";
    "Fxn:parse_nvprof_trace" -> "Fxn:sqlite3.connect(path)";
    "Fxn:parse_nvprof_trace" -> "Fxn:conn.execute("SELECT";
    "Fxn:parse_nvprof_trace" -> "Fxn:demangle(r["value"])";
    "Fxn:parse_nvprof_trace" -> "Fxn:EnforceUnique()";
    "Fxn:parse_nvprof_trace" -> "Fxn:conn.execute(marker_query):";
    "Fxn:parse_nvprof_trace" -> "Fxn:unique.see(row['marker_id'])";
    "Fxn:parse_nvprof_trace" -> "Fxn:FunctionEvent(id=row['marker_id'],";
    "Fxn:parse_nvprof_trace" -> "Fxn:functions.append(evt)";
    "Fxn:parse_nvprof_trace" -> "Fxn:EnforceUnique()";
    "Fxn:parse_nvprof_trace" -> "Fxn:conn.execute(kernel_query):";
    "Fxn:parse_nvprof_trace" -> "Fxn:unique.see(row['marker_id'],";
    "Fxn:parse_nvprof_trace" -> "Fxn:evt.append_kernel(row['kernel_name'],";
    "Fxn:parse_nvprof_trace" -> "Fxn:functions.sort(key=lambda";
    "Fxn:append" -> "Fxn:append('='";
    "Fxn:append" -> "Fxn:append(header)";
    "Fxn:append" -> "Fxn:append(header_sep)";
    "Fxn:append" -> "Fxn:append(row_format.format('Name',";
    "Fxn:append" -> "Fxn:append(header_sep)";
    "Fxn:append" -> "Fxn:append(row_format.format(evt.key,";
    "/torch/autograd/variable.py" -> "Import:sys";
    "/torch/autograd/variable.py" -> "Import:torch";
    "/torch/autograd/variable.py" -> "Import:torch._C";
    "/torch/autograd/variable.py" -> "Import:OrderedDict";
    "/torch/autograd/variable.py" -> "Import:torch.sparse";
    "/torch/autograd/variable.py" -> "Import:torch.utils.hooks";
    "/torch/autograd/variable.py" -> "Import:warnings";
    "/torch/autograd/variable.py" -> "Import:weakref";
    "/torch/autograd/variable.py" -> "Import:imap";
    "/torch/autograd/variable.py" -> "Import:_add_docstr";
    "/torch/autograd/variable.py" -> "class:Variable(_C._VariableBase):";
    "/torch/autograd/variable.py" -> "Import:Resize";
    "/torch/autograd/variable.py" -> "Import:Resize";
    "/torch/autograd/variable.py" -> "Import:_ImperativeEngine";
    "class:Variable(_C._VariableBase):" -> "Fxn:__deepcopy__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__reduce_ex__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__setstate__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__repr__";
    "class:Variable(_C._VariableBase):" -> "Fxn:backward";
    "class:Variable(_C._VariableBase):" -> "Fxn:register_hook";
    "class:Variable(_C._VariableBase):" -> "Fxn:reinforce";
    "class:Variable(_C._VariableBase):" -> "Fxn:trim";
    "class:Variable(_C._VariableBase):" -> "Fxn:retain_grad";
    "class:Variable(_C._VariableBase):" -> "Fxn:retain_grad_hook";
    "class:Variable(_C._VariableBase):" -> "Fxn:is_pinned";
    "class:Variable(_C._VariableBase):" -> "Fxn:is_shared";
    "class:Variable(_C._VariableBase):" -> "Fxn:share_memory_";
    "class:Variable(_C._VariableBase):" -> "Fxn:view_as";
    "class:Variable(_C._VariableBase):" -> "Fxn:btrifact";
    "class:Variable(_C._VariableBase):" -> "Fxn:resize";
    "class:Variable(_C._VariableBase):" -> "Fxn:resize_as";
    "class:Variable(_C._VariableBase):" -> "Fxn:split";
    "class:Variable(_C._VariableBase):" -> "Fxn:index_add";
    "class:Variable(_C._VariableBase):" -> "Fxn:index_copy";
    "class:Variable(_C._VariableBase):" -> "Fxn:index_fill";
    "class:Variable(_C._VariableBase):" -> "Fxn:scatter";
    "class:Variable(_C._VariableBase):" -> "Fxn:scatter_add";
    "class:Variable(_C._VariableBase):" -> "Fxn:masked_copy";
    "class:Variable(_C._VariableBase):" -> "Fxn:masked_copy_";
    "class:Variable(_C._VariableBase):" -> "Fxn:masked_scatter";
    "class:Variable(_C._VariableBase):" -> "Fxn:masked_fill";
    "class:Variable(_C._VariableBase):" -> "Fxn:expand_as";
    "class:Variable(_C._VariableBase):" -> "Fxn:unique";
    "class:Variable(_C._VariableBase):" -> "Fxn:__rsub__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__rdiv__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__format__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__ipow__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__rpow__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__len__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__iter__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__hash__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__dir__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__array__";
    "class:Variable(_C._VariableBase):" -> "Fxn:__array_wrap__";
    "Fxn:__deepcopy__" -> "Fxn:RuntimeError("Only";
    "Fxn:__deepcopy__" -> "Fxn:"(graph";
    "Fxn:__deepcopy__" -> "Fxn:memo[id(self)]";
    "Fxn:__deepcopy__" -> "Fxn:torch.no_grad():";
    "Fxn:__deepcopy__" -> "Fxn:self.clone()";
    "Fxn:__deepcopy__" -> "Fxn:self.storage().__deepcopy__(memo)";
    "Fxn:__deepcopy__" -> "Fxn:self.new()";
    "Fxn:__deepcopy__" -> "Fxn:new_tensor.set_(new_storage,";
    "Fxn:__deepcopy__" -> "Fxn:self.storage_offset(),";
    "Fxn:__deepcopy__" -> "Fxn:self.size(),";
    "Fxn:__deepcopy__" -> "Fxn:self.stride())";
    "Fxn:__deepcopy__" -> "Fxn:memo[id(self)]";
    "Fxn:__reduce_ex__" -> "Fxn:self.storage_offset(),";
    "Fxn:__reduce_ex__" -> "Fxn:self.stride(),";
    "Fxn:__setstate__" -> "Fxn:RuntimeError('__setstate__";
    "Fxn:__repr__" -> "Fxn:torch._tensor_str._str(self)";
    "Fxn:__repr__" -> "Fxn:torch._tensor_str._str(self).encode(";
    "Fxn:__repr__" -> "Fxn:torch._tensor_str._str(self).encode('UTF-8',";
    "Fxn:backward" -> "Fxn:torch.autograd.backward(self,";
    "Fxn:register_hook" -> "Fxn:hook(grad)";
    "Fxn:register_hook" -> "Fxn:``handle.remove()``";
    "Fxn:register_hook" -> "Fxn:Variable(torch.Tensor([0,";
    "Fxn:register_hook" -> "Fxn:v.register_hook(lambda";
    "Fxn:register_hook" -> "Fxn:v.backward(torch.Tensor([1,";
    "Fxn:register_hook" -> "Fxn:h.remove()";
    "Fxn:register_hook" -> "Fxn:RuntimeError("cannot";
    "Fxn:register_hook" -> "Fxn:OrderedDict()";
    "Fxn:register_hook" -> "Fxn:self.grad_fn._register_hook_dict(self)";
    "Fxn:register_hook" -> "Fxn:hooks.RemovableHandle(self._backward_hooks)";
    "Fxn:trim" -> "Fxn:'\n'.join([line.strip()";
    "Fxn:trim" -> "Fxn:str.split('\n')])";
    "Fxn:trim" -> "Fxn:RuntimeError(trim(r"""reinforce()";
    "Fxn:trim" -> "Fxn:policy_network(state)";
    "Fxn:trim" -> "Fxn:probs.multinomial()";
    "Fxn:trim" -> "Fxn:env.step(action)";
    "Fxn:trim" -> "Fxn:action.reinforce(reward)";
    "Fxn:trim" -> "Fxn:action.backward()";
    "Fxn:trim" -> "Fxn:policy_network(state)";
    "Fxn:trim" -> "Fxn:torch.distributions.Categorical(probs)";
    "Fxn:trim" -> "Fxn:m.sample()";
    "Fxn:trim" -> "Fxn:env.step(action)";
    "Fxn:trim" -> "Fxn:-m.log_prob(action)";
    "Fxn:trim" -> "Fxn:loss.backward()";
    "Fxn:trim" -> "Fxn:_add_docstr(_C._VariableBase.detach,";
    "Fxn:trim" -> "Fxn:_add_docstr(_C._VariableBase.detach_,";
    "Fxn:retain_grad" -> "Fxn:RuntimeError("can't";
    "Fxn:retain_grad" -> "Fxn:weakref.ref(self)";
    "Fxn:retain_grad_hook" -> "Fxn:weak_self()";
    "Fxn:retain_grad_hook" -> "Fxn:grad.clone()";
    "Fxn:retain_grad_hook" -> "Fxn:self.register_hook(retain_grad_hook)";
    "Fxn:is_pinned" -> "Fxn:self.storage()";
    "Fxn:is_pinned" -> "Fxn:storage.is_pinned()";
    "Fxn:is_shared" -> "Fxn:self.storage().is_shared()";
    "Fxn:share_memory_" -> "Fxn:self.storage().share_memory_()";
    "Fxn:view_as" -> "Fxn:self.view(tensor.size())";
    "Fxn:btrifact" -> "Fxn:warnings.warn("info";
    "Fxn:btrifact" -> "Fxn:self).btrifact_with_info(pivot=pivot)";
    "Fxn:btrifact" -> "Fxn:info.type()";
    "Fxn:btrifact" -> "Fxn:_info.type():";
    "Fxn:btrifact" -> "Fxn:ValueError('btrifact";
    "Fxn:btrifact" -> "Fxn:info.resize_as_(_info).copy_(_info)";
    "Fxn:btrifact" -> "Fxn:self).btrifact(pivot=pivot)";
    "Fxn:resize" -> "Fxn:warnings.warn("non-inplace";
    "Fxn:resize" -> "Fxn:Resize.apply(self,";
    "Fxn:resize_as" -> "Fxn:warnings.warn("non-inplace";
    "Fxn:resize_as" -> "Fxn:Resize.apply(self,";
    "Fxn:resize_as" -> "Fxn:variable.size())";
    "Fxn:split" -> "Fxn:self).split(split_size,";
    "Fxn:split" -> "Fxn:self).split_with_sizes(split_size,";
    "Fxn:index_add" -> "Fxn:self.clone().index_add_(dim,";
    "Fxn:index_copy" -> "Fxn:self.clone().index_copy_(dim,";
    "Fxn:index_fill" -> "Fxn:self.clone().index_fill_(dim,";
    "Fxn:scatter" -> "Fxn:self.clone().scatter_(dim,";
    "Fxn:scatter_add" -> "Fxn:self.clone().scatter_add_(dim,";
    "Fxn:masked_copy" -> "Fxn:warnings.warn("masked_copy";
    "Fxn:masked_copy" -> "Fxn:self.masked_scatter(mask,";
    "Fxn:masked_copy_" -> "Fxn:warnings.warn("masked_copy_";
    "Fxn:masked_copy_" -> "Fxn:self.masked_scatter_(mask,";
    "Fxn:masked_scatter" -> "Fxn:self.clone().masked_scatter_(mask,";
    "Fxn:masked_fill" -> "Fxn:self.clone().masked_fill_(mask,";
    "Fxn:expand_as" -> "Fxn:self.expand(tensor.size())";
    "Fxn:unique" -> "Fxn:self._unique(";
    "Fxn:__rdiv__" -> "Fxn:self.reciprocal()";
    "Fxn:__format__" -> "Fxn:self.dim()";
    "Fxn:__format__" -> "Fxn:self.item().__format__(format_spec)";
    "Fxn:__format__" -> "Fxn:object.__format__(self,";
    "Fxn:__ipow__" -> "Fxn:NotImplementedError("in-place";
    "Fxn:__rpow__" -> "Fxn:self.new([other])";
    "Fxn:__len__" -> "Fxn:self.dim()";
    "Fxn:__len__" -> "Fxn:TypeError("len()";
    "Fxn:__iter__" -> "Fxn:self.dim()";
    "Fxn:__iter__" -> "Fxn:TypeError('iteration";
    "Fxn:__dir__" -> "Fxn:variable_methods.remove('volatile')";
    "Fxn:__dir__" -> "Fxn:`numpy.asarray(tensor)";
    "Fxn:__array__" -> "Fxn:self.cpu().numpy()";
    "Fxn:__array__" -> "Fxn:self.cpu().numpy().astype(dtype,";
    "Fxn:__array__" -> "Fxn:`numpy.sin(tensor)";
    "Fxn:__array__" -> "Fxn:`numpy.greater(tensor,";
    "Fxn:__array_wrap__" -> "Fxn:array.astype('uint8')";
    "Fxn:__array_wrap__" -> "Fxn:torch.from_numpy(array)";
    "Fxn:__array_wrap__" -> "Fxn:ImperativeEngine()";
    "/torch/autograd/__init__.py" -> "Import:torch";
    "/torch/autograd/__init__.py" -> "Import:warnings";
    "/torch/autograd/__init__.py" -> "Import:Variable";
    "/torch/autograd/__init__.py" -> "Import:Function,";
    "/torch/autograd/__init__.py" -> "Import:gradcheck";
    "/torch/autograd/__init__.py" -> "Import:no_grad,";
    "/torch/autograd/__init__.py" -> "Import:profiler";
    "/torch/autograd/__init__.py" -> "Fxn:_make_grads";
    "/torch/autograd/__init__.py" -> "Fxn:backward";
    "/torch/autograd/__init__.py" -> "Fxn:grad";
    "/torch/autograd/__init__.py" -> "Fxn:variable";
    "/torch/autograd/_functions/tensor.py" -> "Import:reduce";
    "/torch/autograd/_functions/tensor.py" -> "Import:torch";
    "/torch/autograd/_functions/tensor.py" -> "Import:torch._utils";
    "/torch/autograd/_functions/tensor.py" -> "Import:Function";
    "/torch/autograd/_functions/tensor.py" -> "class:Type(Function):";
    "/torch/autograd/_functions/tensor.py" -> "class:Resize(Function):";
    "class:Type(Function):" -> "Fxn:forward";
    "class:Type(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:i.get_device()";
    "Fxn:forward" -> "Fxn:i.type(dest_type)";
    "Fxn:backward" -> "Fxn:grad_output.type(ctx.input_type),";
    "Fxn:backward" -> "Fxn:torch.cuda.device(ctx.input_device):";
    "Fxn:backward" -> "Fxn:grad_output.type(ctx.input_type),";
    "class:Resize(Function):" -> "Fxn:forward";
    "class:Resize(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:reduce(lambda";
    "Fxn:forward" -> "Fxn:tensor.numel()";
    "Fxn:forward" -> "Fxn:RuntimeError(("requested";
    "Fxn:forward" -> "Fxn:").format(";
    "Fxn:forward" -> "Fxn:'x'.join(map(str,";
    "Fxn:forward" -> "Fxn:'x'.join(map(str,";
    "Fxn:forward" -> "Fxn:tensor.size())),";
    "Fxn:forward" -> "Fxn:tensor.numel()))";
    "Fxn:forward" -> "Fxn:tensor.size()";
    "Fxn:forward" -> "Fxn:tensor.is_contiguous():";
    "Fxn:forward" -> "Fxn:tensor.new(tensor).contiguous().view(*sizes)";
    "Fxn:forward" -> "Fxn:tensor.contiguous().view(*sizes)";
    "Fxn:backward" -> "Fxn:grad_output.numel()";
    "Fxn:backward" -> "Fxn:grad_output.contiguous().view(ctx.input_sizes),";
    "/torch/autograd/_functions/utils.py" -> "Import:torch";
    "/torch/autograd/_functions/utils.py" -> "Import:reduce";
    "/torch/autograd/_functions/utils.py" -> "Fxn:maybe_view";
    "/torch/autograd/_functions/utils.py" -> "Fxn:maybe_unexpand";
    "/torch/autograd/_functions/utils.py" -> "Fxn:prepare_onnx_paddings";
    "/torch/autograd/_functions/utils.py" -> "Fxn:check_onnx_broadcast";
    "/torch/backends/cudnn/rnn.py" -> "Import:torch.cuda";
    "/torch/backends/cudnn/rnn.py" -> "Import:torch.backends.cudnn";
    "/torch/backends/cudnn/rnn.py" -> "Fxn:get_cudnn_mode";
    "/torch/backends/cudnn/rnn.py" -> "class:Unserializable(object):";
    "class:Unserializable(object):" -> "Fxn:__init__";
    "class:Unserializable(object):" -> "Fxn:get";
    "class:Unserializable(object):" -> "Fxn:__getstate__";
    "class:Unserializable(object):" -> "Fxn:__setstate__";
    "class:Unserializable(object):" -> "Fxn:init_dropout_state";
    "Fxn:init_dropout_state" -> "Fxn:Unserializable(";
    "Fxn:init_dropout_state" -> "Fxn:torch._C._VariableFunctions._cudnn_init_dropout_state(dropout_p,";
    "Fxn:init_dropout_state" -> "Fxn:dropout_state[dropout_desc_name].get()";
    "/torch/backends/cudnn/__init__.py" -> "Import:import";
    "/torch/backends/cudnn/__init__.py" -> "Import:ctypes";
    "/torch/backends/cudnn/__init__.py" -> "Import:sys";
    "/torch/backends/cudnn/__init__.py" -> "Import:torch";
    "/torch/backends/cudnn/__init__.py" -> "Import:warnings";
    "/torch/backends/cudnn/__init__.py" -> "Import:cuda";
    "/torch/backends/cudnn/__init__.py" -> "Import:contextmanager";
    "/torch/backends/cudnn/__init__.py" -> "Import:Popen,";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:find_cudnn_windows_lib";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:_libcudnn";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:version";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:is_acceptable";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:set_flags";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:disable_global_flags";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:flags_frozen";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:__allow_nonbracketed_mutation";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:flags";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:__init__";
    "/torch/backends/cudnn/__init__.py" -> "Fxn:__del__";
    "/torch/backends/cudnn/__init__.py" -> "class:CuDNNError(RuntimeError):";
    "/torch/backends/cudnn/__init__.py" -> "class:TensorDescriptor(object):";
    "/torch/backends/cudnn/__init__.py" -> "class:TensorDescriptorArray(object):";
    "/torch/backends/cudnn/__init__.py" -> "class:FilterDescriptor(object):";
    "/torch/backends/cudnn/__init__.py" -> "class:DropoutDescriptor(object):";
    "/torch/backends/cudnn/__init__.py" -> "class:RNNDescriptor(object):";
    "/torch/backends/cudnn/__init__.py" -> "class:ContextProp(object):";
    "/torch/backends/cudnn/__init__.py" -> "class:CudnnModule(object):";
    "class:CuDNNError(RuntimeError):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:{}'.format(status,";
    "Fxn:__init__" -> "Fxn:get_error_string(status))";
    "Fxn:__init__" -> "Fxn:self).__init__(msg)";
    "class:TensorDescriptor(object):" -> "Fxn:__init__";
    "class:TensorDescriptor(object):" -> "Fxn:__del__";
    "class:TensorDescriptor(object):" -> "Fxn:set";
    "class:TensorDescriptor(object):" -> "Fxn:as_tuple";
    "Fxn:__init__" -> "Fxn:ctypes.c_void_p()";
    "Fxn:__init__" -> "Fxn:check_error(lib.cudnnCreateTensorDescriptor(ctypes.byref(ptr)))";
    "Fxn:__del__" -> "Fxn:check_error(lib.cudnnDestroyTensorDescriptor(self._as_parameter_))";
    "Fxn:set" -> "Fxn:tensor.type()";
    "Fxn:set" -> "Fxn:tensor.size()";
    "Fxn:set" -> "Fxn:tensor.stride()";
    "Fxn:set" -> "Fxn:check_error(lib.cudnnSetTensorNdDescriptor(";
    "Fxn:set" -> "Fxn:_typemap[tensor.type()],";
    "Fxn:set" -> "Fxn:tensor.dim(),";
    "Fxn:set" -> "Fxn:int_array(tensor.size()),";
    "Fxn:set" -> "Fxn:int_array(tensor.stride())))";
    "class:TensorDescriptorArray(object):" -> "Fxn:__init__";
    "class:TensorDescriptorArray(object):" -> "Fxn:__del__";
    "class:TensorDescriptorArray(object):" -> "Fxn:__getitem__";
    "class:TensorDescriptorArray(object):" -> "Fxn:set_all";
    "class:TensorDescriptorArray(object):" -> "Fxn:set_raw";
    "Fxn:__init__" -> "Fxn:N)()";
    "Fxn:__init__" -> "Fxn:ctypes.byref(self.ptrs,";
    "Fxn:__init__" -> "Fxn:ctypes.sizeof(ctypes.c_void_p))";
    "Fxn:__init__" -> "Fxn:check_error(lib.cudnnCreateTensorDescriptor(ptr))";
    "Fxn:__del__" -> "Fxn:check_error(lib.cudnnDestroyTensorDescriptor(ctypes.c_void_p(ptr)))";
    "Fxn:__getitem__" -> "Fxn:ctypes.c_void_p(self.ptrs[key])";
    "Fxn:set_all" -> "Fxn:_typemap[tensor.type()]";
    "Fxn:set_all" -> "Fxn:tensor.dim()";
    "Fxn:set_all" -> "Fxn:int_array(tensor.size())";
    "Fxn:set_all" -> "Fxn:int_array(tensor.stride())";
    "Fxn:set_all" -> "Fxn:check_error(lib.cudnnSetTensorNdDescriptor(";
    "Fxn:set_all" -> "Fxn:ctypes.c_void_p(ptr),";
    "Fxn:set_raw" -> "Fxn:check_error(lib.cudnnSetTensorNdDescriptor(";
    "Fxn:set_raw" -> "Fxn:ctypes.c_void_p(ptr),";
    "class:FilterDescriptor(object):" -> "Fxn:__init__";
    "class:FilterDescriptor(object):" -> "Fxn:__del__";
    "class:FilterDescriptor(object):" -> "Fxn:set";
    "class:FilterDescriptor(object):" -> "Fxn:as_tuple";
    "Fxn:__init__" -> "Fxn:ctypes.c_void_p()";
    "Fxn:__init__" -> "Fxn:check_error(lib.cudnnCreateFilterDescriptor(ctypes.byref(ptr)))";
    "Fxn:__del__" -> "Fxn:check_error(lib.cudnnDestroyFilterDescriptor(self._as_parameter_))";
    "Fxn:set" -> "Fxn:weight.size()";
    "Fxn:set" -> "Fxn:_typemap[weight.type()]";
    "Fxn:set" -> "Fxn:check_error(lib.cudnnSetFilterNdDescriptor(";
    "Fxn:set" -> "Fxn:weight.ndimension(),";
    "Fxn:set" -> "Fxn:int_array(weight.size())))";
    "class:DropoutDescriptor(object):" -> "Fxn:__init__";
    "class:DropoutDescriptor(object):" -> "Fxn:set_dropout";
    "class:DropoutDescriptor(object):" -> "Fxn:_set";
    "class:DropoutDescriptor(object):" -> "Fxn:__del__";
    "Fxn:__init__" -> "Fxn:ctypes.c_void_p()";
    "Fxn:__init__" -> "Fxn:check_error(lib.cudnnCreateDropoutDescriptor(ctypes.byref(ptr)))";
    "Fxn:__init__" -> "Fxn:self._set(dropout,";
    "Fxn:set_dropout" -> "Fxn:self._set(dropout,";
    "Fxn:_set" -> "Fxn:ctypes.c_long()";
    "Fxn:_set" -> "Fxn:check_error(lib.cudnnDropoutGetStatesSize(";
    "Fxn:_set" -> "Fxn:ctypes.byref(dropout_states_size)))";
    "Fxn:_set" -> "Fxn:torch.cuda.ByteTensor(dropout_states_size.value)";
    "Fxn:_set" -> "Fxn:self.state.data_ptr()";
    "Fxn:_set" -> "Fxn:self.state.size(0)";
    "Fxn:_set" -> "Fxn:check_error(lib.cudnnSetDropoutDescriptor(";
    "Fxn:_set" -> "Fxn:ctypes.c_float(dropout),";
    "Fxn:_set" -> "Fxn:ctypes.c_void_p(state_ptr),";
    "Fxn:_set" -> "Fxn:ctypes.c_size_t(state_size),";
    "Fxn:_set" -> "Fxn:ctypes.c_ulonglong(seed),";
    "Fxn:__del__" -> "Fxn:check_error(lib.cudnnDestroyDropoutDescriptor(self))";
    "class:RNNDescriptor(object):" -> "Fxn:__init__";
    "class:RNNDescriptor(object):" -> "Fxn:__del__";
    "class:RNNDescriptor(object):" -> "Fxn:check_error";
    "class:RNNDescriptor(object):" -> "Fxn:get_error_string";
    "class:RNNDescriptor(object):" -> "Fxn:get_handle";
    "class:RNNDescriptor(object):" -> "Fxn:c_type";
    "class:RNNDescriptor(object):" -> "Fxn:int_array";
    "class:RNNDescriptor(object):" -> "Fxn:descriptor";
    "class:RNNDescriptor(object):" -> "Fxn:descriptor_sequence";
    "class:RNNDescriptor(object):" -> "Fxn:add_tensor";
    "Fxn:__init__" -> "Fxn:ctypes.c_void_p()";
    "Fxn:__init__" -> "Fxn:check_error(lib.cudnnCreateRNNDescriptor(ctypes.byref(ptr)))";
    "Fxn:__init__" -> "Fxn:version()";
    "Fxn:__init__" -> "Fxn:check_error(lib.cudnnSetRNNDescriptor_v6(";
    "Fxn:__init__" -> "Fxn:version()";
    "Fxn:__init__" -> "Fxn:torch.cuda.get_device_capability(torch.cuda.current_device())[0]";
    "Fxn:__init__" -> "Fxn:lib.cudnnSetRNNMatrixMathType(self,";
    "Fxn:__init__" -> "Fxn:lib.cudnnSetRNNMatrixMathType(self,";
    "Fxn:__init__" -> "Fxn:check_error(lib.cudnnSetRNNDescriptor(";
    "Fxn:__del__" -> "Fxn:check_error(lib.cudnnDestroyRNNDescriptor(self))";
    "Fxn:check_error" -> "Fxn:CuDNNError(status)";
    "Fxn:get_error_string" -> "Fxn:lib.cudnnGetErrorString(status)";
    "Fxn:get_handle" -> "Fxn:_libcudnn()";
    "Fxn:get_handle" -> "Fxn:RuntimeError('cuDNN";
    "Fxn:get_handle" -> "Fxn:torch.cuda.current_device()";
    "Fxn:get_handle" -> "Fxn:_handles.get(current_device,";
    "Fxn:get_handle" -> "Fxn:CuDNNHandle()";
    "Fxn:c_type" -> "Fxn:ValueError("unknown";
    "Fxn:c_type" -> "Fxn:'{}'".format(type(tensor)))";
    "Fxn:int_array" -> "Fxn:array_type(*itr)";
    "Fxn:descriptor" -> "Fxn:tensor.size()";
    "Fxn:descriptor" -> "Fxn:tensor.dim()))";
    "Fxn:descriptor" -> "Fxn:tensor.view(padded_size)";
    "Fxn:descriptor" -> "Fxn:TensorDescriptorArray(N)";
    "Fxn:descriptor" -> "Fxn:descriptor.set_all(tensor)";
    "Fxn:descriptor" -> "Fxn:TensorDescriptor()";
    "Fxn:descriptor" -> "Fxn:descriptor.set(tensor)";
    "Fxn:descriptor_sequence" -> "Fxn:TensorDescriptorArray(len(batch_sizes))";
    "Fxn:descriptor_sequence" -> "Fxn:_typemap[tensor.type()]";
    "Fxn:descriptor_sequence" -> "Fxn:tensor.dim())";
    "Fxn:descriptor_sequence" -> "Fxn:int_array(tensor.size()";
    "Fxn:descriptor_sequence" -> "Fxn:int_array(tensor.stride()";
    "Fxn:descriptor_sequence" -> "Fxn:descriptors.set_raw(i,";
    "Fxn:add_tensor" -> "Fxn:check_error(lib.cudnnAddTensor(*args))";
    "class:ContextProp(object):" -> "Fxn:__init__";
    "class:ContextProp(object):" -> "Fxn:__get__";
    "class:ContextProp(object):" -> "Fxn:__set__";
    "Fxn:__get__" -> "Fxn:self.getter()";
    "Fxn:__set__" -> "Fxn:flags_frozen():";
    "Fxn:__set__" -> "Fxn:self.setter(val)";
    "Fxn:__set__" -> "Fxn:RuntimeError("not";
    "Fxn:__set__" -> "Fxn:flags()";
    "class:CudnnModule(object):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:ContextProp(torch._C._get_cudnn_enabled,";
    "Fxn:__init__" -> "Fxn:ContextProp(torch._C._get_cudnn_deterministic,";
    "Fxn:__init__" -> "Fxn:ContextProp(torch._C._get_cudnn_benchmark,";
    "Fxn:__init__" -> "Fxn:CudnnModule(sys.modules[__name__])";
    "/torch/contrib/_graph_vis.py" -> "Import:string";
    "/torch/contrib/_graph_vis.py" -> "Import:json";
    "/torch/contrib/_graph_vis.py" -> "Fxn:write";
    "/torch/contrib/_graph_vis.py" -> "Fxn:add_edge";
    "/torch/cuda/comm.py" -> "Import:torch";
    "/torch/cuda/comm.py" -> "Import:nccl";
    "/torch/cuda/comm.py" -> "Import:_accumulate,";
    "/torch/cuda/comm.py" -> "Fxn:broadcast";
    "/torch/cuda/comm.py" -> "Fxn:broadcast_coalesced";
    "/torch/cuda/comm.py" -> "Fxn:reduce_add";
    "/torch/cuda/comm.py" -> "Fxn:reduce_add_coalesced";
    "/torch/cuda/comm.py" -> "Fxn:scatter";
    "/torch/cuda/comm.py" -> "Fxn:gather";
    "/torch/cuda/nccl.py" -> "Import:warnings";
    "/torch/cuda/nccl.py" -> "Import:torch.cuda";
    "/torch/cuda/nccl.py" -> "Fxn:is_available";
    "/torch/cuda/nccl.py" -> "Fxn:version";
    "/torch/cuda/nccl.py" -> "Fxn:unique_id";
    "/torch/cuda/nccl.py" -> "Fxn:init_rank";
    "/torch/cuda/nccl.py" -> "Fxn:all_reduce";
    "/torch/cuda/nccl.py" -> "Fxn:reduce";
    "/torch/cuda/nccl.py" -> "Fxn:broadcast";
    "/torch/cuda/nccl.py" -> "Fxn:all_gather";
    "/torch/cuda/nccl.py" -> "Fxn:reduce_scatter";
    "/torch/cuda/nvtx.py" -> "Import:import";
    "/torch/cuda/nvtx.py" -> "Import:glob";
    "/torch/cuda/nvtx.py" -> "Import:ctypes";
    "/torch/cuda/nvtx.py" -> "Import:platform";
    "/torch/cuda/nvtx.py" -> "Fxn:windows_nvToolsExt_lib";
    "/torch/cuda/nvtx.py" -> "Fxn:windows_nvToolsExt_path";
    "/torch/cuda/nvtx.py" -> "Fxn:_libnvToolsExt";
    "/torch/cuda/nvtx.py" -> "Fxn:range_push";
    "/torch/cuda/nvtx.py" -> "Fxn:range_pop";
    "/torch/cuda/nvtx.py" -> "Fxn:mark";
    "/torch/cuda/profiler.py" -> "Import:ctypes";
    "/torch/cuda/profiler.py" -> "Import:tempfile";
    "/torch/cuda/profiler.py" -> "Import:contextlib";
    "/torch/cuda/profiler.py" -> "Import:cudart,";
    "/torch/cuda/profiler.py" -> "class:cudaOutputMode(object):";
    "class:cudaOutputMode(object):" -> "Fxn:for_key";
    "class:cudaOutputMode(object):" -> "Fxn:init";
    "class:cudaOutputMode(object):" -> "Fxn:start";
    "class:cudaOutputMode(object):" -> "Fxn:stop";
    "class:cudaOutputMode(object):" -> "Fxn:profile";
    "Fxn:for_key" -> "Fxn:RuntimeError("supported";
    "Fxn:init" -> "Fxn:cudaOutputMode.for_key(output_mode)";
    "Fxn:init" -> "Fxn:tempfile.NamedTemporaryFile(delete=True)";
    "Fxn:init" -> "Fxn:f.write(b'\n'.join(map(lambda";
    "Fxn:init" -> "Fxn:f.encode('ascii'),";
    "Fxn:init" -> "Fxn:f.flush()";
    "Fxn:init" -> "Fxn:check_error(cudart().cudaProfilerInitialize(";
    "Fxn:init" -> "Fxn:ctypes.c_char_p(f.name.encode('ascii')),";
    "Fxn:init" -> "Fxn:ctypes.c_char_p(output_file.encode('ascii')),";
    "Fxn:start" -> "Fxn:check_error(cudart().cudaProfilerStart())";
    "Fxn:stop" -> "Fxn:check_error(cudart().cudaProfilerStop())";
    "Fxn:profile" -> "Fxn:start()";
    "Fxn:profile" -> "Fxn:stop()";
    "/torch/cuda/random.py" -> "Import:import";
    "/torch/cuda/random.py" -> "Import:_lazy_init,";
    "/torch/cuda/random.py" -> "Fxn:get_rng_state";
    "/torch/cuda/random.py" -> "Fxn:get_rng_state_all";
    "/torch/cuda/random.py" -> "Fxn:set_rng_state";
    "/torch/cuda/random.py" -> "Fxn:cb";
    "/torch/cuda/random.py" -> "Fxn:set_rng_state_all";
    "/torch/cuda/random.py" -> "Fxn:manual_seed";
    "/torch/cuda/random.py" -> "Fxn:manual_seed_all";
    "/torch/cuda/random.py" -> "Fxn:seed";
    "/torch/cuda/random.py" -> "Fxn:seed_all";
    "/torch/cuda/random.py" -> "Fxn:initial_seed";
    "/torch/cuda/streams.py" -> "Import:ctypes";
    "/torch/cuda/streams.py" -> "Import:torch";
    "/torch/cuda/streams.py" -> "Import:cudart,";
    "/torch/cuda/streams.py" -> "class:Stream(torch._C._CudaStreamBase):";
    "/torch/cuda/streams.py" -> "class:EventHandle(ctypes.Structure):";
    "/torch/cuda/streams.py" -> "class:Event(object):";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:__new__";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:wait_event";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:wait_stream";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:record_event";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:query";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:synchronize";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:priority_range";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:priority";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:_as_parameter_";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:__eq__";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:__hash__";
    "class:Stream(torch._C._CudaStreamBase):" -> "Fxn:__repr__";
    "Fxn:__new__" -> "Fxn:torch.cuda.device(device):";
    "Fxn:__new__" -> "Fxn:cls).__new__(cls,";
    "Fxn:wait_event" -> "Fxn:``cudaStreamWaitEvent()``:";
    "Fxn:wait_event" -> "Fxn:check_error(cudart().cudaStreamWaitEvent(self,";
    "Fxn:wait_event" -> "Fxn:ctypes.c_int(0)))";
    "Fxn:wait_stream" -> "Fxn:self.wait_event(stream.record_event())";
    "Fxn:record_event" -> "Fxn:Event()";
    "Fxn:record_event" -> "Fxn:check_error(cudart().cudaEventRecord(event,";
    "Fxn:query" -> "Fxn:cudart().cudaStreamQuery(self)";
    "Fxn:query" -> "Fxn:check_error(res)";
    "Fxn:synchronize" -> "Fxn:``cudaStreamSynchronize()``:";
    "Fxn:synchronize" -> "Fxn:check_error(cudart().cudaStreamSynchronize(self))";
    "Fxn:priority_range" -> "Fxn:ctypes.c_int()";
    "Fxn:priority_range" -> "Fxn:ctypes.c_int()";
    "Fxn:priority_range" -> "Fxn:check_error(cudart().cudaDeviceGetStreamPriorityRange(";
    "Fxn:priority_range" -> "Fxn:ctypes.byref(least_priority),";
    "Fxn:priority_range" -> "Fxn:ctypes.byref(greatest_priority)))";
    "Fxn:priority" -> "Fxn:ctypes.c_int()";
    "Fxn:priority" -> "Fxn:check_error(cudart().cudaStreamGetPriority(self,";
    "Fxn:priority" -> "Fxn:ctypes.byref(priority)))";
    "Fxn:_as_parameter_" -> "Fxn:ctypes.c_void_p(self.cuda_stream)";
    "Fxn:__repr__" -> "Fxn:.format(self.device,";
    "class:Event(object):" -> "Fxn:__init__";
    "class:Event(object):" -> "Fxn:__del__";
    "class:Event(object):" -> "Fxn:record";
    "class:Event(object):" -> "Fxn:wait";
    "class:Event(object):" -> "Fxn:query";
    "class:Event(object):" -> "Fxn:elapsed_time";
    "class:Event(object):" -> "Fxn:synchronize";
    "class:Event(object):" -> "Fxn:ipc_handle";
    "class:Event(object):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:ctypes.c_void_p()";
    "Fxn:__init__" -> "Fxn:cudart()";
    "Fxn:__init__" -> "Fxn:check_error(self._cudart.cudaIpcOpenEventHandle(ctypes.byref(ptr),";
    "Fxn:__init__" -> "Fxn:check_error(self._cudart.cudaEventCreateWithFlags(ctypes.byref(ptr),";
    "Fxn:__init__" -> "Fxn:ctypes.c_uint(flags)))";
    "Fxn:__del__" -> "Fxn:check_error(self._cudart.cudaEventDestroy(self._as_parameter_))";
    "Fxn:record" -> "Fxn:torch.cuda.current_stream()";
    "Fxn:record" -> "Fxn:stream.record_event(self)";
    "Fxn:wait" -> "Fxn:torch.cuda.current_stream()";
    "Fxn:wait" -> "Fxn:stream.wait_event(self)";
    "Fxn:query" -> "Fxn:cudart().cudaEventQuery(self)";
    "Fxn:query" -> "Fxn:check_error(res)";
    "Fxn:elapsed_time" -> "Fxn:ctypes.c_float()";
    "Fxn:elapsed_time" -> "Fxn:check_error(cudart().cudaEventElapsedTime(";
    "Fxn:elapsed_time" -> "Fxn:ctypes.byref(time_ms),";
    "Fxn:synchronize" -> "Fxn:check_error(cudart().cudaEventSynchronize(self))";
    "Fxn:ipc_handle" -> "Fxn:EventHandle()";
    "Fxn:ipc_handle" -> "Fxn:check_error(cudart().cudaIpcGetEventHandle(ctypes.byref(handle),";
    "Fxn:__repr__" -> "Fxn:{0:#x}>'.format(self._as_parameter_.value)";
    "/torch/cuda/__init__.py" -> "Import:it,";
    "/torch/cuda/__init__.py" -> "Import:contextlib";
    "/torch/cuda/__init__.py" -> "Import:platform";
    "/torch/cuda/__init__.py" -> "Import:ctypes";
    "/torch/cuda/__init__.py" -> "Import:import";
    "/torch/cuda/__init__.py" -> "Import:torch";
    "/torch/cuda/__init__.py" -> "Import:traceback";
    "/torch/cuda/__init__.py" -> "Import:warnings";
    "/torch/cuda/__init__.py" -> "Import:raise_from";
    "/torch/cuda/__init__.py" -> "Import:Popen,";
    "/torch/cuda/__init__.py" -> "Import:register_after_fork";
    "/torch/cuda/__init__.py" -> "Fxn:find_cuda_windows_lib";
    "/torch/cuda/__init__.py" -> "Fxn:is_available";
    "/torch/cuda/__init__.py" -> "Fxn:_sleep";
    "/torch/cuda/__init__.py" -> "Fxn:_load_cudart";
    "/torch/cuda/__init__.py" -> "Fxn:_check_driver";
    "/torch/cuda/__init__.py" -> "Fxn:_check_capability";
    "/torch/cuda/__init__.py" -> "Fxn:_lazy_call";
    "/torch/cuda/__init__.py" -> "class:DeferredCudaCallError(Exception):";
    "/torch/cuda/__init__.py" -> "Import:version_info";
    "/torch/cuda/__init__.py" -> "class:cudaStatus(object):";
    "/torch/cuda/__init__.py" -> "class:CudaError(RuntimeError):";
    "/torch/cuda/__init__.py" -> "class:device(object):";
    "/torch/cuda/__init__.py" -> "class:device_of(device):";
    "/torch/cuda/__init__.py" -> "Import:################################################################################";
    "/torch/cuda/__init__.py" -> "Import:_StorageBase";
    "/torch/cuda/__init__.py" -> "class:{}".format(class_name))";
    "/torch/cuda/__init__.py" -> "class:_CudaBase(object):";
    "/torch/cuda/__init__.py" -> "class:DoubleStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "class:FloatStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "class:LongStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "class:IntStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "class:ShortStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "class:CharStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "class:ByteStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "class:HalfStorage(_CudaBase,";
    "/torch/cuda/__init__.py" -> "Import:sparse";
    "/torch/cuda/__init__.py" -> "Import:profiler";
    "/torch/cuda/__init__.py" -> "Import:nvtx";
    "/torch/cuda/__init__.py" -> "Import:Stream,";
    "class:DeferredCudaCallError(Exception):" -> "Fxn:init";
    "class:DeferredCudaCallError(Exception):" -> "Fxn:_lazy_init";
    "class:DeferredCudaCallError(Exception):" -> "Fxn:_after_fork";
    "class:DeferredCudaCallError(Exception):" -> "Fxn:cudart";
    "Fxn:init" -> "Fxn:_lazy_init()";
    "Fxn:_lazy_init" -> "Fxn:RuntimeError(";
    "Fxn:_lazy_init" -> "Fxn:_check_driver()";
    "Fxn:_lazy_init" -> "Fxn:torch._C._cuda_init()";
    "Fxn:_lazy_init" -> "Fxn:_load_cudart()";
    "Fxn:_lazy_init" -> "Fxn:os.getpid()";
    "Fxn:_lazy_init" -> "Fxn:_lazy_init()";
    "Fxn:_lazy_init" -> "Fxn:queued_call()";
    "Fxn:_lazy_init" -> "Fxn:at:\n\n{}").format(str(e),";
    "Fxn:_lazy_init" -> "Fxn:raise_from(DeferredCudaCallError(msg),";
    "Fxn:_after_fork" -> "Fxn:os.getpid():";
    "Fxn:_after_fork" -> "Fxn:_register_after_fork(_after_fork,";
    "Fxn:cudart" -> "Fxn:_lazy_init()";
    "class:CudaError(RuntimeError):" -> "Fxn:__init__";
    "class:CudaError(RuntimeError):" -> "Fxn:check_error";
    "Fxn:__init__" -> "Fxn:cudart().cudaGetErrorString(code).decode('utf-8')";
    "Fxn:__init__" -> "Fxn:self).__init__('{0}";
    "Fxn:check_error" -> "Fxn:CudaError(res)";
    "class:device(object):" -> "Fxn:__init__";
    "class:device(object):" -> "Fxn:__enter__";
    "class:device(object):" -> "Fxn:__exit__";
    "Fxn:__enter__" -> "Fxn:torch._C._cuda_getDevice()";
    "Fxn:__enter__" -> "Fxn:torch._C._cuda_setDevice(self.idx)";
    "Fxn:__enter__" -> "Fxn:_lazy_init()";
    "Fxn:__exit__" -> "Fxn:torch._C._cuda_setDevice(self.prev_idx)";
    "class:device_of(device):" -> "Fxn:__init__";
    "class:device_of(device):" -> "Fxn:set_device";
    "class:device_of(device):" -> "Fxn:get_device_name";
    "class:device_of(device):" -> "Fxn:get_device_capability";
    "class:device_of(device):" -> "Fxn:get_device_properties";
    "class:device_of(device):" -> "Fxn:stream";
    "class:device_of(device):" -> "Fxn:device_count";
    "class:device_of(device):" -> "Fxn:current_device";
    "class:device_of(device):" -> "Fxn:synchronize";
    "class:device_of(device):" -> "Fxn:current_stream";
    "class:device_of(device):" -> "Fxn:current_blas_handle";
    "class:device_of(device):" -> "Fxn:empty_cache";
    "class:device_of(device):" -> "Fxn:memory_allocated";
    "class:device_of(device):" -> "Fxn:max_memory_allocated";
    "class:device_of(device):" -> "Fxn:memory_cached";
    "class:device_of(device):" -> "Fxn:max_memory_cached";
    "class:device_of(device):" -> "Fxn:_host_allocator";
    "class:device_of(device):" -> "Fxn:_free_mutex";
    "class:device_of(device):" -> "Fxn:_dummy_type";
    "class:device_of(device):" -> "Fxn:init_err";
    "Fxn:__init__" -> "Fxn:obj.get_device()";
    "Fxn:__init__" -> "Fxn:self).__init__(idx)";
    "Fxn:set_device" -> "Fxn:torch._C._cuda_setDevice(device)";
    "Fxn:get_device_name" -> "Fxn:torch._C._cuda_getDeviceName(device)";
    "Fxn:get_device_capability" -> "Fxn:torch._C._cuda_getDeviceCapability(device)";
    "Fxn:get_device_properties" -> "Fxn:init()";
    "Fxn:get_device_properties" -> "Fxn:device_count():";
    "Fxn:get_device_properties" -> "Fxn:AssertionError("Invalid";
    "Fxn:get_device_properties" -> "Fxn:_get_device_properties(device)";
    "Fxn:stream" -> "Fxn:current_stream()";
    "Fxn:stream" -> "Fxn:torch._C._cuda_setStream(stream._cdata)";
    "Fxn:stream" -> "Fxn:torch._C._cuda_setStream(prev_stream._cdata)";
    "Fxn:device_count" -> "Fxn:is_available():";
    "Fxn:device_count" -> "Fxn:torch._C._cuda_getDeviceCount()";
    "Fxn:current_device" -> "Fxn:_lazy_init()";
    "Fxn:current_device" -> "Fxn:torch._C._cuda_getDevice()";
    "Fxn:synchronize" -> "Fxn:_lazy_init()";
    "Fxn:synchronize" -> "Fxn:torch._C._cuda_synchronize()";
    "Fxn:current_stream" -> "Fxn:_lazy_init()";
    "Fxn:current_stream" -> "Fxn:torch.cuda.Stream(_cdata=torch._C._cuda_getCurrentStream())";
    "Fxn:current_blas_handle" -> "Fxn:_lazy_init()";
    "Fxn:current_blas_handle" -> "Fxn:torch._C._cuda_getCurrentBlasHandle()";
    "Fxn:empty_cache" -> "Fxn:torch._C._cuda_emptyCache()";
    "Fxn:memory_allocated" -> "Fxn:current_device()";
    "Fxn:memory_allocated" -> "Fxn:torch._C._cuda_memoryAllocated(device)";
    "Fxn:max_memory_allocated" -> "Fxn:current_device()";
    "Fxn:max_memory_allocated" -> "Fxn:torch._C._cuda_maxMemoryAllocated(device)";
    "Fxn:memory_cached" -> "Fxn:current_device()";
    "Fxn:memory_cached" -> "Fxn:torch._C._cuda_memoryCached(device)";
    "Fxn:max_memory_cached" -> "Fxn:current_device()";
    "Fxn:max_memory_cached" -> "Fxn:torch._C._cuda_maxMemoryCached(device)";
    "Fxn:_host_allocator" -> "Fxn:_lazy_init()";
    "Fxn:_host_allocator" -> "Fxn:torch._C._cuda_cudaHostAllocator()";
    "Fxn:_free_mutex" -> "Fxn:torch._C._cuda_lock_mutex()";
    "Fxn:_free_mutex" -> "Fxn:torch._C._cuda_unlock_mutex()";
    "Fxn:init_err" -> "Fxn:RuntimeError(";
    "class:{}".format(class_name))" -> "Fxn:_lazy_new";
    "Fxn:_lazy_new" -> "Fxn:_lazy_init()";
    "Fxn:_lazy_new" -> "Fxn:cls).__new__(cls,";
    "class:_CudaBase(object):" -> "Fxn:type";
    "Fxn:type" -> "Fxn:device(self.get_device()):";
    "Fxn:type" -> "Fxn:self).type(*args,";
    "/torch/distributed/launch.py" -> "Import:argparse";
    "/torch/distributed/launch.py" -> "Import:subprocess";
    "/torch/distributed/launch.py" -> "Import:import";
    "/torch/distributed/launch.py" -> "Import:socket";
    "/torch/distributed/launch.py" -> "Import:ArgumentParser,";
    "/torch/distributed/launch.py" -> "Import:torch";
    "/torch/distributed/launch.py" -> "Fxn:parse_args";
    "/torch/distributed/remote_types.py" -> "Import:torch";
    "/torch/distributed/remote_types.py" -> "Import:_StorageBase";
    "/torch/distributed/remote_types.py" -> "class:_DistributedBase(object):";
    "/torch/distributed/remote_types.py" -> "class:DoubleStorage(_DistributedBase,";
    "/torch/distributed/remote_types.py" -> "class:FloatStorage(_DistributedBase,";
    "/torch/distributed/remote_types.py" -> "class:LongStorage(_DistributedBase,";
    "/torch/distributed/remote_types.py" -> "class:IntStorage(_DistributedBase,";
    "/torch/distributed/remote_types.py" -> "class:ShortStorage(_DistributedBase,";
    "/torch/distributed/remote_types.py" -> "class:CharStorage(_DistributedBase,";
    "/torch/distributed/remote_types.py" -> "class:ByteStorage(_DistributedBase,";
    "/torch/distributed/remote_types.py" -> "class:HalfStorage(_DistributedBase,";
    "/torch/distributed/__init__.py" -> "Import:torch";
    "/torch/distributed/__init__.py" -> "Import:atexit";
    "/torch/distributed/__init__.py" -> "Import:warnings";
    "/torch/distributed/__init__.py" -> "Import:_flatten_dense_tensors,";
    "/torch/distributed/__init__.py" -> "Fxn:_extend_scope";
    "/torch/distributed/__init__.py" -> "Fxn:is_available";
    "/torch/distributed/__init__.py" -> "Fxn:destroy_process_group";
    "/torch/distributed/__init__.py" -> "Fxn:is_initialized";
    "/torch/distributed/__init__.py" -> "Fxn:init_process_group";
    "/torch/distributed/__init__.py" -> "Fxn:init_master_worker";
    "/torch/distributed/__init__.py" -> "Import:torch.distributed.collectives";
    "/torch/distributed/__init__.py" -> "Import:torch.distributed.remote_types";
    "/torch/distributed/__init__.py" -> "class:reduce_op(object):";
    "/torch/distributed/__init__.py" -> "class:group(object):";
    "/torch/distributed/__init__.py" -> "class:_DistributedRequest(object):";
    "class:_DistributedRequest(object):" -> "Fxn:__init__";
    "class:_DistributedRequest(object):" -> "Fxn:is_completed";
    "class:_DistributedRequest(object):" -> "Fxn:wait";
    "class:_DistributedRequest(object):" -> "Fxn:get_rank";
    "class:_DistributedRequest(object):" -> "Fxn:get_world_size";
    "class:_DistributedRequest(object):" -> "Fxn:isend";
    "class:_DistributedRequest(object):" -> "Fxn:irecv";
    "class:_DistributedRequest(object):" -> "Fxn:send";
    "class:_DistributedRequest(object):" -> "Fxn:recv";
    "class:_DistributedRequest(object):" -> "Fxn:broadcast_multigpu";
    "class:_DistributedRequest(object):" -> "Fxn:broadcast";
    "class:_DistributedRequest(object):" -> "Fxn:all_reduce_multigpu";
    "class:_DistributedRequest(object):" -> "Fxn:all_reduce";
    "class:_DistributedRequest(object):" -> "Fxn:reduce_multigpu";
    "class:_DistributedRequest(object):" -> "Fxn:reduce";
    "class:_DistributedRequest(object):" -> "Fxn:all_gather_multigpu";
    "class:_DistributedRequest(object):" -> "Fxn:all_gather";
    "class:_DistributedRequest(object):" -> "Fxn:gather";
    "class:_DistributedRequest(object):" -> "Fxn:scatter";
    "class:_DistributedRequest(object):" -> "Fxn:barrier";
    "class:_DistributedRequest(object):" -> "Fxn:new_group";
    "class:_DistributedRequest(object):" -> "Fxn:_clear_group_cache";
    "class:_DistributedRequest(object):" -> "Fxn:_register_stream";
    "Fxn:is_completed" -> "Fxn:torch._C._dist_request_is_completed(self.request)";
    "Fxn:wait" -> "Fxn:torch._C._dist_request_wait(self.request)";
    "Fxn:get_rank" -> "Fxn:torch._C._dist_get_rank()";
    "Fxn:get_world_size" -> "Fxn:torch._C._dist_get_num_processes()";
    "Fxn:isend" -> "Fxn:_DistributedRequest(torch._C._dist_isend(tensor,";
    "Fxn:irecv" -> "Fxn:_DistributedRequest(torch._C._dist_irecv(tensor,";
    "Fxn:send" -> "Fxn:torch._C._dist_send(tensor,";
    "Fxn:recv" -> "Fxn:torch._C._dist_recv_any_source(tensor)";
    "Fxn:recv" -> "Fxn:torch._C._dist_recv(tensor,";
    "Fxn:broadcast_multigpu" -> "Fxn:torch._C._dist_broadcast_multigpu(tensor_list,";
    "Fxn:broadcast" -> "Fxn:torch._C._dist_broadcast(tensor,";
    "Fxn:all_reduce_multigpu" -> "Fxn:torch._C._dist_all_reduce_multigpu(tensor_list,";
    "Fxn:all_reduce" -> "Fxn:torch._C._dist_all_reduce(tensor,";
    "Fxn:reduce_multigpu" -> "Fxn:torch._C._dist_reduce_multigpu(tensor_list,";
    "Fxn:reduce" -> "Fxn:torch._C._dist_reduce(tensor,";
    "Fxn:all_gather_multigpu" -> "Fxn:tensors(on";
    "Fxn:all_gather_multigpu" -> "Fxn:flatten_tensor_list.append(_flatten_dense_tensors(output_tensor_list))";
    "Fxn:all_gather_multigpu" -> "Fxn:torch._C._dist_all_gather_multigpu(flatten_tensor_list,";
    "Fxn:all_gather_multigpu" -> "Fxn:_unflatten_dense_tensors(flatten_tensor,";
    "Fxn:all_gather_multigpu" -> "Fxn:tensor.copy_(value)";
    "Fxn:all_gather" -> "Fxn:torch._C._dist_all_gather(tensor_list,";
    "Fxn:all_gather" -> "Fxn:all_gather_multigpu([tensor_list],";
    "Fxn:gather" -> "Fxn:get_rank()";
    "Fxn:gather" -> "Fxn:kwargs.pop('dst',";
    "Fxn:gather" -> "Fxn:kwargs.pop('gather_list',";
    "Fxn:gather" -> "Fxn:kwargs.pop('group',";
    "Fxn:gather" -> "Fxn:RuntimeError("got";
    "Fxn:gather" -> "Fxn:RuntimeError("gather_list";
    "Fxn:gather" -> "Fxn:torch._C._dist_gather_recv(gather_list,";
    "Fxn:gather" -> "Fxn:RuntimeError("non-empty";
    "Fxn:gather" -> "Fxn:torch._C._dist_gather_send(tensor,";
    "Fxn:scatter" -> "Fxn:get_rank()";
    "Fxn:scatter" -> "Fxn:kwargs.pop('src',";
    "Fxn:scatter" -> "Fxn:kwargs.pop('scatter_list',";
    "Fxn:scatter" -> "Fxn:kwargs.pop('group',";
    "Fxn:scatter" -> "Fxn:RuntimeError("got";
    "Fxn:scatter" -> "Fxn:RuntimeError("scatter_list";
    "Fxn:scatter" -> "Fxn:torch._C._dist_scatter_send(scatter_list,";
    "Fxn:scatter" -> "Fxn:RuntimeError("non-empty";
    "Fxn:scatter" -> "Fxn:torch._C._dist_scatter_recv(tensor,";
    "Fxn:barrier" -> "Fxn:torch._C._dist_barrier(group)";
    "Fxn:new_group" -> "Fxn:torch._C._dist_new_group(ranks)";
    "Fxn:_clear_group_cache" -> "Fxn:torch._C._dist_clear_group_cache(group)";
    "Fxn:_register_stream" -> "Fxn:RuntimeError("torch.distributed";
    "Fxn:_register_stream" -> "Fxn:torch._C._dist_register_stream(stream)";
    "/torch/distributions/bernoulli.py" -> "Import:Number";
    "/torch/distributions/bernoulli.py" -> "Import:torch";
    "/torch/distributions/bernoulli.py" -> "Import:Variable";
    "/torch/distributions/bernoulli.py" -> "Import:constraints";
    "/torch/distributions/bernoulli.py" -> "Import:ExponentialFamily";
    "/torch/distributions/bernoulli.py" -> "Import:broadcast_all,";
    "/torch/distributions/bernoulli.py" -> "Import:binary_cross_entropy_with_logits";
    "/torch/distributions/bernoulli.py" -> "class:Bernoulli(ExponentialFamily):";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:__init__";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:_new";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:mean";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:variance";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:logits";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:probs";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:param_shape";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:sample";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:log_prob";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:entropy";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:enumerate_support";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:_natural_params";
    "class:Bernoulli(ExponentialFamily):" -> "Fxn:_log_normalizer";
    "Fxn:__init__" -> "Fxn:ValueError("Either";
    "Fxn:__init__" -> "Fxn:broadcast_all(probs)";
    "Fxn:__init__" -> "Fxn:broadcast_all(logits)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self._param.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:_new" -> "Fxn:self._param.new(*args,";
    "Fxn:logits" -> "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs" -> "Fxn:logits_to_probs(self.logits,";
    "Fxn:param_shape" -> "Fxn:self._param.size()";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:sample" -> "Fxn:torch.no_grad():";
    "Fxn:sample" -> "Fxn:torch.bernoulli(self.probs.expand(shape))";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:broadcast_all(self.logits,";
    "Fxn:log_prob" -> "Fxn:-binary_cross_entropy_with_logits(logits,";
    "Fxn:entropy" -> "Fxn:binary_cross_entropy_with_logits(self.logits,";
    "Fxn:enumerate_support" -> "Fxn:self._new((2,))";
    "Fxn:enumerate_support" -> "Fxn:torch.arange(2,";
    "Fxn:enumerate_support" -> "Fxn:values.view((-1,)";
    "Fxn:enumerate_support" -> "Fxn:values.expand((-1,)";
    "Fxn:_log_normalizer" -> "Fxn:torch.log(1";
    "Fxn:_log_normalizer" -> "Fxn:torch.exp(x))";
    "/torch/distributions/beta.py" -> "Import:Number";
    "/torch/distributions/beta.py" -> "Import:torch";
    "/torch/distributions/beta.py" -> "Import:constraints";
    "/torch/distributions/beta.py" -> "Import:Dirichlet";
    "/torch/distributions/beta.py" -> "Import:ExponentialFamily";
    "/torch/distributions/beta.py" -> "Import:broadcast_all";
    "/torch/distributions/beta.py" -> "class:Beta(ExponentialFamily):";
    "class:Beta(ExponentialFamily):" -> "Fxn:__init__";
    "class:Beta(ExponentialFamily):" -> "Fxn:mean";
    "class:Beta(ExponentialFamily):" -> "Fxn:variance";
    "class:Beta(ExponentialFamily):" -> "Fxn:rsample";
    "class:Beta(ExponentialFamily):" -> "Fxn:log_prob";
    "class:Beta(ExponentialFamily):" -> "Fxn:entropy";
    "class:Beta(ExponentialFamily):" -> "Fxn:concentration1";
    "class:Beta(ExponentialFamily):" -> "Fxn:concentration0";
    "class:Beta(ExponentialFamily):" -> "Fxn:_natural_params";
    "class:Beta(ExponentialFamily):" -> "Fxn:_log_normalizer";
    "Fxn:__init__" -> "Fxn:torch.tensor([concentration1,";
    "Fxn:__init__" -> "Fxn:broadcast_all(concentration1,";
    "Fxn:__init__" -> "Fxn:torch.stack([concentration1,";
    "Fxn:__init__" -> "Fxn:Dirichlet(concentration1_concentration0)";
    "Fxn:__init__" -> "Fxn:self).__init__(self._dirichlet._batch_shape,";
    "Fxn:rsample" -> "Fxn:sample_shape=()):";
    "Fxn:rsample" -> "Fxn:self._dirichlet.rsample(sample_shape).select(-1,";
    "Fxn:rsample" -> "Fxn:self._dirichlet.concentration.new([value])";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:torch.stack([value,";
    "Fxn:log_prob" -> "Fxn:self._dirichlet.log_prob(heads_tails)";
    "Fxn:entropy" -> "Fxn:self._dirichlet.entropy()";
    "Fxn:concentration1" -> "Fxn:torch.Tensor([result])";
    "Fxn:concentration0" -> "Fxn:torch.Tensor([result])";
    "Fxn:_log_normalizer" -> "Fxn:torch.lgamma(x)";
    "Fxn:_log_normalizer" -> "Fxn:torch.lgamma(y)";
    "Fxn:_log_normalizer" -> "Fxn:torch.lgamma(x";
    "/torch/distributions/binomial.py" -> "Import:Number";
    "/torch/distributions/binomial.py" -> "Import:torch";
    "/torch/distributions/binomial.py" -> "Import:math";
    "/torch/distributions/binomial.py" -> "Import:variable,";
    "/torch/distributions/binomial.py" -> "Import:constraints";
    "/torch/distributions/binomial.py" -> "Import:Distribution";
    "/torch/distributions/binomial.py" -> "Import:broadcast_all,";
    "/torch/distributions/binomial.py" -> "Import:clamp_probs";
    "/torch/distributions/binomial.py" -> "class:Binomial(Distribution):";
    "class:Binomial(Distribution):" -> "Fxn:__init__";
    "class:Binomial(Distribution):" -> "Fxn:_new";
    "class:Binomial(Distribution):" -> "Fxn:support";
    "class:Binomial(Distribution):" -> "Fxn:mean";
    "class:Binomial(Distribution):" -> "Fxn:variance";
    "class:Binomial(Distribution):" -> "Fxn:logits";
    "class:Binomial(Distribution):" -> "Fxn:probs";
    "class:Binomial(Distribution):" -> "Fxn:param_shape";
    "class:Binomial(Distribution):" -> "Fxn:sample";
    "class:Binomial(Distribution):" -> "Fxn:log_prob";
    "class:Binomial(Distribution):" -> "Fxn:enumerate_support";
    "Fxn:__init__" -> "Fxn:NotImplementedError('inhomogeneous";
    "Fxn:__init__" -> "Fxn:ValueError("Either";
    "Fxn:__init__" -> "Fxn:broadcast_all(probs)";
    "Fxn:__init__" -> "Fxn:broadcast_all(logits)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self._param.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:_new" -> "Fxn:self._param.new(*args,";
    "Fxn:support" -> "Fxn:constraints.integer_interval(0,";
    "Fxn:logits" -> "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs" -> "Fxn:logits_to_probs(self.logits,";
    "Fxn:param_shape" -> "Fxn:self._param.size()";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:sample" -> "Fxn:torch.no_grad():";
    "Fxn:sample" -> "Fxn:torch.bernoulli(self.probs.unsqueeze(-1).expand(shape)).sum(dim=-1)";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:math.lgamma(self.total_count";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(value";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(self.total_count";
    "Fxn:log_prob" -> "Fxn:torch.log1p(-self.probs))";
    "Fxn:log_prob" -> "Fxn:torch.log1p((self.logits";
    "Fxn:log_prob" -> "Fxn:max_val).exp()))";
    "Fxn:log_prob" -> "Fxn:torch.log1p((self.logits";
    "Fxn:log_prob" -> "Fxn:max_val).exp()))";
    "Fxn:enumerate_support" -> "Fxn:self._new((self.total_count,))";
    "Fxn:enumerate_support" -> "Fxn:torch.arange(self.total_count,";
    "Fxn:enumerate_support" -> "Fxn:values.view((-1,)";
    "Fxn:enumerate_support" -> "Fxn:values.expand((-1,)";
    "/torch/distributions/categorical.py" -> "Import:torch";
    "/torch/distributions/categorical.py" -> "Import:Variable,";
    "/torch/distributions/categorical.py" -> "Import:constraints";
    "/torch/distributions/categorical.py" -> "Import:Distribution";
    "/torch/distributions/categorical.py" -> "Import:probs_to_logits,";
    "/torch/distributions/categorical.py" -> "class:Categorical(Distribution):";
    "class:Categorical(Distribution):" -> "Fxn:__init__";
    "class:Categorical(Distribution):" -> "Fxn:_new";
    "class:Categorical(Distribution):" -> "Fxn:support";
    "class:Categorical(Distribution):" -> "Fxn:logits";
    "class:Categorical(Distribution):" -> "Fxn:probs";
    "class:Categorical(Distribution):" -> "Fxn:param_shape";
    "class:Categorical(Distribution):" -> "Fxn:mean";
    "class:Categorical(Distribution):" -> "Fxn:variance";
    "class:Categorical(Distribution):" -> "Fxn:sample";
    "class:Categorical(Distribution):" -> "Fxn:log_prob";
    "class:Categorical(Distribution):" -> "Fxn:entropy";
    "class:Categorical(Distribution):" -> "Fxn:enumerate_support";
    "Fxn:__init__" -> "Fxn:ValueError("Either";
    "Fxn:__init__" -> "Fxn:probs.sum(-1,";
    "Fxn:__init__" -> "Fxn:log_sum_exp(logits)";
    "Fxn:__init__" -> "Fxn:self._param.size()[-1]";
    "Fxn:__init__" -> "Fxn:self._param.size()[:-1]";
    "Fxn:__init__" -> "Fxn:self._param.ndimension()";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:_new" -> "Fxn:self._param.new(*args,";
    "Fxn:support" -> "Fxn:constraints.integer_interval(0,";
    "Fxn:logits" -> "Fxn:probs_to_logits(self.probs)";
    "Fxn:probs" -> "Fxn:logits_to_probs(self.logits)";
    "Fxn:param_shape" -> "Fxn:self._param.size()";
    "Fxn:mean" -> "Fxn:self.probs.new_tensor(float('nan')).expand(self._extended_shape())";
    "Fxn:variance" -> "Fxn:self.probs.new_tensor(float('nan')).expand(self._extended_shape())";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:sample" -> "Fxn:torch.Size((self._num_events,))";
    "Fxn:sample" -> "Fxn:self.probs.expand(param_shape)";
    "Fxn:sample" -> "Fxn:self.probs.dim()";
    "Fxn:sample" -> "Fxn:self.probs.size(0)";
    "Fxn:sample" -> "Fxn:probs.view(-1,";
    "Fxn:sample" -> "Fxn:probs.contiguous().view(-1,";
    "Fxn:sample" -> "Fxn:torch.multinomial(probs_2d,";
    "Fxn:sample" -> "Fxn:sample_2d.contiguous().view(sample_shape)";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:torch._C._infer_size(value.size(),";
    "Fxn:log_prob" -> "Fxn:value.size()";
    "Fxn:log_prob" -> "Fxn:value.expand(value_shape)";
    "Fxn:log_prob" -> "Fxn:self.logits.expand(param_shape)";
    "Fxn:log_prob" -> "Fxn:log_pmf.gather(-1,";
    "Fxn:log_prob" -> "Fxn:value.unsqueeze(-1).long()).squeeze(-1)";
    "Fxn:entropy" -> "Fxn:-p_log_p.sum(-1)";
    "Fxn:enumerate_support" -> "Fxn:torch.arange(num_events).long()";
    "Fxn:enumerate_support" -> "Fxn:values.view((-1,)";
    "Fxn:enumerate_support" -> "Fxn:values.expand((-1,)";
    "Fxn:enumerate_support" -> "Fxn:values.cuda(self._param.get_device())";
    "Fxn:enumerate_support" -> "Fxn:Variable(values)";
    "/torch/distributions/cauchy.py" -> "Import:math";
    "/torch/distributions/cauchy.py" -> "Import:Number";
    "/torch/distributions/cauchy.py" -> "Import:torch";
    "/torch/distributions/cauchy.py" -> "Import:constraints";
    "/torch/distributions/cauchy.py" -> "Import:Distribution";
    "/torch/distributions/cauchy.py" -> "Import:broadcast_all";
    "/torch/distributions/cauchy.py" -> "class:Cauchy(Distribution):";
    "class:Cauchy(Distribution):" -> "Fxn:__init__";
    "class:Cauchy(Distribution):" -> "Fxn:mean";
    "class:Cauchy(Distribution):" -> "Fxn:variance";
    "class:Cauchy(Distribution):" -> "Fxn:rsample";
    "class:Cauchy(Distribution):" -> "Fxn:log_prob";
    "class:Cauchy(Distribution):" -> "Fxn:cdf";
    "class:Cauchy(Distribution):" -> "Fxn:icdf";
    "class:Cauchy(Distribution):" -> "Fxn:entropy";
    "Fxn:__init__" -> "Fxn:broadcast_all(loc,";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.loc.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:mean" -> "Fxn:self.loc.new([float('nan')]).expand(self._extended_shape())";
    "Fxn:variance" -> "Fxn:self.loc.new([float('inf')]).expand(self._extended_shape())";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:self.loc.new(shape).cauchy_()";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:-math.log(math.pi)";
    "Fxn:log_prob" -> "Fxn:self.scale.log()";
    "Fxn:log_prob" -> "Fxn:self.scale)**2).log()";
    "Fxn:cdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:cdf" -> "Fxn:torch.atan((value";
    "Fxn:icdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:icdf" -> "Fxn:torch.tan(math.pi";
    "Fxn:entropy" -> "Fxn:math.log(4";
    "Fxn:entropy" -> "Fxn:self.scale.log()";
    "/torch/distributions/chi2.py" -> "Import:constraints";
    "/torch/distributions/chi2.py" -> "Import:Gamma";
    "/torch/distributions/chi2.py" -> "class:Chi2(Gamma):";
    "class:Chi2(Gamma):" -> "Fxn:__init__";
    "class:Chi2(Gamma):" -> "Fxn:df";
    "Fxn:__init__" -> "Fxn:self).__init__(0.5";
    "/torch/distributions/constraints.py" -> "Import:torch";
    "/torch/distributions/constraints.py" -> "class:Constraint(object):";
    "/torch/distributions/constraints.py" -> "class:_Dependent(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_DependentProperty(property,";
    "/torch/distributions/constraints.py" -> "class:Uniform(Distribution):";
    "/torch/distributions/constraints.py" -> "class:_Boolean(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_IntegerInterval(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_IntegerLessThan(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_IntegerGreaterThan(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_Real(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_GreaterThan(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_LessThan(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_Interval(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_Simplex(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_LowerTriangular(Constraint):";
    "/torch/distributions/constraints.py" -> "class:_LowerCholesky(Constraint):";
    "class:Constraint(object):" -> "Fxn:check";
    "class:_Dependent(Constraint):" -> "Fxn:check";
    "class:_Dependent(Constraint):" -> "Fxn:is_dependent";
    "Fxn:check" -> "Fxn:ValueError('Cannot";
    "class:Uniform(Distribution):" -> "Fxn:__init__";
    "class:Uniform(Distribution):" -> "Fxn:support";
    "Fxn:support" -> "Fxn:constraints.interval(self.low,";
    "class:_Boolean(Constraint):" -> "Fxn:check";
    "class:_IntegerInterval(Constraint):" -> "Fxn:__init__";
    "class:_IntegerInterval(Constraint):" -> "Fxn:check";
    "class:_IntegerLessThan(Constraint):" -> "Fxn:__init__";
    "class:_IntegerLessThan(Constraint):" -> "Fxn:check";
    "class:_IntegerGreaterThan(Constraint):" -> "Fxn:__init__";
    "class:_IntegerGreaterThan(Constraint):" -> "Fxn:check";
    "class:_Real(Constraint):" -> "Fxn:check";
    "class:_GreaterThan(Constraint):" -> "Fxn:__init__";
    "class:_GreaterThan(Constraint):" -> "Fxn:check";
    "class:_LessThan(Constraint):" -> "Fxn:__init__";
    "class:_LessThan(Constraint):" -> "Fxn:check";
    "class:_Interval(Constraint):" -> "Fxn:__init__";
    "class:_Interval(Constraint):" -> "Fxn:check";
    "class:_Simplex(Constraint):" -> "Fxn:check";
    "Fxn:check" -> "Fxn:0).all()";
    "Fxn:check" -> "Fxn:1).abs()";
    "Fxn:check" -> "Fxn:1e-6).all()";
    "class:_LowerTriangular(Constraint):" -> "Fxn:check";
    "Fxn:check" -> "Fxn:value).min(-1)[0].min(-1)[0]";
    "class:_LowerCholesky(Constraint):" -> "Fxn:check";
    "Fxn:check" -> "Fxn:value.size(-1)";
    "Fxn:check" -> "Fxn:torch.eye(n,";
    "Fxn:check" -> "Fxn:out=value.new(n,";
    "Fxn:check" -> "Fxn:value).min(-1)[0].min(-1)[0]";
    "Fxn:check" -> "Fxn:1)).min(-1)[0].min(-1)[0]";
    "Fxn:check" -> "Fxn:_Dependent()";
    "Fxn:check" -> "Fxn:_Boolean()";
    "Fxn:check" -> "Fxn:_IntegerGreaterThan(0)";
    "Fxn:check" -> "Fxn:_IntegerGreaterThan(1)";
    "Fxn:check" -> "Fxn:_Real()";
    "Fxn:check" -> "Fxn:_GreaterThan(0)";
    "Fxn:check" -> "Fxn:_Interval(0,";
    "Fxn:check" -> "Fxn:_Simplex()";
    "Fxn:check" -> "Fxn:_LowerTriangular()";
    "Fxn:check" -> "Fxn:_LowerCholesky()";
    "/torch/distributions/constraint_registry.py" -> "Fxn:my_factory";
    "/torch/distributions/constraint_registry.py" -> "Import:constraints,";
    "/torch/distributions/constraint_registry.py" -> "class:ConstraintRegistry(object):";
    "class:ConstraintRegistry(object):" -> "Fxn:__init__";
    "class:ConstraintRegistry(object):" -> "Fxn:register";
    "class:ConstraintRegistry(object):" -> "Fxn:construct_transform";
    "class:ConstraintRegistry(object):" -> "Fxn:__call__";
    "class:ConstraintRegistry(object):" -> "Fxn:_transform_to_greater_than";
    "class:ConstraintRegistry(object):" -> "Fxn:_transform_to_less_than";
    "class:ConstraintRegistry(object):" -> "Fxn:_transform_to_interval";
    "Fxn:register" -> "Fxn:@my_registry.register(MyConstraintClass)";
    "Fxn:construct_transform" -> "Fxn:MyTransform(constraint.params)";
    "Fxn:construct_transform" -> "Fxn:my_registry.register(my_constraint_singleton,";
    "Fxn:construct_transform" -> "Fxn:MyTransform())";
    "Fxn:construct_transform" -> "Fxn:self.register(constraint,";
    "Fxn:construct_transform" -> "Fxn:TypeError('Expected";
    "Fxn:construct_transform" -> "Fxn:{}'.format(constraint))";
    "Fxn:__call__" -> "Fxn:transform_to(constraint)(torch.zeros(1))";
    "Fxn:__call__" -> "Fxn:transform_to(constraint).inv(scale)";
    "Fxn:__call__" -> "Fxn:self._registry[type(constraint)]";
    "Fxn:__call__" -> "Fxn:NotImplementedError(";
    "Fxn:__call__" -> "Fxn:constraints'.format(type(constraint).__name__))";
    "Fxn:__call__" -> "Fxn:factory(constraint)";
    "Fxn:__call__" -> "Fxn:ConstraintRegistry()";
    "Fxn:__call__" -> "Fxn:ConstraintRegistry()";
    "Fxn:__call__" -> "Fxn:biject_to.register(constraints.real,";
    "Fxn:__call__" -> "Fxn:transform_to.register(constraints.real,";
    "Fxn:__call__" -> "Fxn:biject_to.register(constraints.positive,";
    "Fxn:__call__" -> "Fxn:transforms.ExpTransform())";
    "Fxn:__call__" -> "Fxn:transform_to.register(constraints.positive,";
    "Fxn:__call__" -> "Fxn:transforms.ExpTransform())";
    "Fxn:__call__" -> "Fxn:@biject_to.register(constraints.greater_than)";
    "Fxn:__call__" -> "Fxn:@transform_to.register(constraints.greater_than)";
    "Fxn:_transform_to_greater_than" -> "Fxn:loc.new([1]).expand_as(loc)";
    "Fxn:_transform_to_greater_than" -> "Fxn:transforms.ComposeTransform([transforms.ExpTransform(),";
    "Fxn:_transform_to_greater_than" -> "Fxn:transforms.AffineTransform(loc,";
    "Fxn:_transform_to_greater_than" -> "Fxn:@biject_to.register(constraints.less_than)";
    "Fxn:_transform_to_greater_than" -> "Fxn:@transform_to.register(constraints.less_than)";
    "Fxn:_transform_to_less_than" -> "Fxn:loc.new([-1]).expand_as(loc)";
    "Fxn:_transform_to_less_than" -> "Fxn:transforms.ComposeTransform([transforms.ExpTransform(),";
    "Fxn:_transform_to_less_than" -> "Fxn:transforms.AffineTransform(loc,";
    "Fxn:_transform_to_less_than" -> "Fxn:biject_to.register(constraints.unit_interval,";
    "Fxn:_transform_to_less_than" -> "Fxn:transforms.SigmoidTransform())";
    "Fxn:_transform_to_less_than" -> "Fxn:transform_to.register(constraints.unit_interval,";
    "Fxn:_transform_to_less_than" -> "Fxn:transforms.SigmoidTransform())";
    "Fxn:_transform_to_less_than" -> "Fxn:@biject_to.register(constraints.interval)";
    "Fxn:_transform_to_less_than" -> "Fxn:@transform_to.register(constraints.interval)";
    "Fxn:_transform_to_interval" -> "Fxn:transforms.ComposeTransform([transforms.SigmoidTransform(),";
    "Fxn:_transform_to_interval" -> "Fxn:transforms.AffineTransform(loc,";
    "Fxn:_transform_to_interval" -> "Fxn:biject_to.register(constraints.simplex,";
    "Fxn:_transform_to_interval" -> "Fxn:transforms.StickBreakingTransform())";
    "Fxn:_transform_to_interval" -> "Fxn:transform_to.register(constraints.simplex,";
    "Fxn:_transform_to_interval" -> "Fxn:transforms.BoltzmannTransform())";
    "Fxn:_transform_to_interval" -> "Fxn:transform_to.register(constraints.lower_cholesky,";
    "Fxn:_transform_to_interval" -> "Fxn:transforms.LowerCholeskyTransform())";
    "/torch/distributions/dirichlet.py" -> "Import:Number";
    "/torch/distributions/dirichlet.py" -> "Import:torch";
    "/torch/distributions/dirichlet.py" -> "Import:Function,";
    "/torch/distributions/dirichlet.py" -> "Import:once_differentiable";
    "/torch/distributions/dirichlet.py" -> "Import:constraints";
    "/torch/distributions/dirichlet.py" -> "Import:ExponentialFamily";
    "/torch/distributions/dirichlet.py" -> "Import:_finfo,";
    "/torch/distributions/dirichlet.py" -> "Fxn:_dirichlet_sample_nograd";
    "/torch/distributions/dirichlet.py" -> "Fxn:_Dirichlet_backward";
    "/torch/distributions/dirichlet.py" -> "class:_Dirichlet(Function):";
    "/torch/distributions/dirichlet.py" -> "class:Dirichlet(ExponentialFamily):";
    "class:_Dirichlet(Function):" -> "Fxn:forward";
    "class:_Dirichlet(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:_dirichlet_sample_nograd(concentration)";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(x,";
    "Fxn:backward" -> "Fxn:_Dirichlet_backward(x,";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:__init__";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:rsample";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:log_prob";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:mean";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:variance";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:entropy";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:_natural_params";
    "class:Dirichlet(ExponentialFamily):" -> "Fxn:_log_normalizer";
    "Fxn:__init__" -> "Fxn:broadcast_all(concentration)";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample" -> "Fxn:sample_shape=()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:self.concentration.expand(shape)";
    "Fxn:rsample" -> "Fxn:_Dirichlet.apply(concentration)";
    "Fxn:rsample" -> "Fxn:_dirichlet_sample_nograd(concentration)";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:1.0)).sum(-1)";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(self.concentration.sum(-1))";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(self.concentration).sum(-1))";
    "Fxn:mean" -> "Fxn:self.concentration.sum(-1)";
    "Fxn:variance" -> "Fxn:self.concentration.sum(-1)";
    "Fxn:entropy" -> "Fxn:self.concentration.size(-1)";
    "Fxn:entropy" -> "Fxn:self.concentration.sum(-1)";
    "Fxn:entropy" -> "Fxn:torch.lgamma(a0)";
    "Fxn:entropy" -> "Fxn:torch.digamma(a0)";
    "Fxn:entropy" -> "Fxn:torch.digamma(self.concentration)).sum(-1))";
    "Fxn:_log_normalizer" -> "Fxn:x.lgamma().sum(-1)";
    "Fxn:_log_normalizer" -> "Fxn:torch.lgamma(x.sum(-1))";
    "/torch/distributions/distribution.py" -> "Import:torch";
    "/torch/distributions/distribution.py" -> "Import:Variable";
    "/torch/distributions/distribution.py" -> "Import:warnings";
    "/torch/distributions/distribution.py" -> "Import:constraints";
    "/torch/distributions/distribution.py" -> "class:Distribution(object):";
    "class:Distribution(object):" -> "Fxn:set_default_validate_args";
    "class:Distribution(object):" -> "Fxn:__init__";
    "class:Distribution(object):" -> "Fxn:batch_shape";
    "class:Distribution(object):" -> "Fxn:event_shape";
    "class:Distribution(object):" -> "Fxn:params";
    "class:Distribution(object):" -> "Fxn:support";
    "class:Distribution(object):" -> "Fxn:mean";
    "class:Distribution(object):" -> "Fxn:variance";
    "class:Distribution(object):" -> "Fxn:stddev";
    "class:Distribution(object):" -> "Fxn:sample";
    "class:Distribution(object):" -> "Fxn:rsample";
    "class:Distribution(object):" -> "Fxn:sample_n";
    "class:Distribution(object):" -> "Fxn:log_prob";
    "class:Distribution(object):" -> "Fxn:cdf";
    "class:Distribution(object):" -> "Fxn:icdf";
    "class:Distribution(object):" -> "Fxn:enumerate_support";
    "class:Distribution(object):" -> "Fxn:entropy";
    "class:Distribution(object):" -> "Fxn:_extended_shape";
    "class:Distribution(object):" -> "Fxn:_validate_sample";
    "class:Distribution(object):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:batch_shape=torch.Size(),";
    "Fxn:__init__" -> "Fxn:event_shape=torch.Size(),";
    "Fxn:__init__" -> "Fxn:constraints.is_dependent(self.params):";
    "Fxn:__init__" -> "Fxn:self.params.items():";
    "Fxn:__init__" -> "Fxn:constraints.is_dependent(constraint):";
    "Fxn:__init__" -> "Fxn:constraint.check(self.__getattribute__(param)).all():";
    "Fxn:__init__" -> "Fxn:ValueError("The";
    "Fxn:__init__" -> "Fxn:values".format(param))";
    "Fxn:stddev" -> "Fxn:self.variance.sqrt()";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:torch.no_grad():";
    "Fxn:sample" -> "Fxn:self.rsample(sample_shape)";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample_n" -> "Fxn:warnings.warn('sample_n";
    "Fxn:sample_n" -> "Fxn:.sample((n,))";
    "Fxn:sample_n" -> "Fxn:self.sample(torch.Size((n,)))";
    "Fxn:enumerate_support" -> "Fxn:`(cardinality,)";
    "Fxn:enumerate_support" -> "Fxn:`itertools.product(m.enumerate_support())`.";
    "Fxn:_extended_shape" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:_extended_shape" -> "Fxn:torch.Size(sample_shape";
    "Fxn:_validate_sample" -> "Fxn:ValueError('The";
    "Fxn:_validate_sample" -> "Fxn:value.size()[event_dim_start:]";
    "Fxn:_validate_sample" -> "Fxn:ValueError('The";
    "Fxn:_validate_sample" -> "Fxn:value.size()";
    "Fxn:_validate_sample" -> "Fxn:ValueError('Value";
    "Fxn:_validate_sample" -> "Fxn:self.support.check(value).all():";
    "Fxn:_validate_sample" -> "Fxn:ValueError('The";
    "Fxn:__repr__" -> "Fxn:'()'";
    "/torch/distributions/exponential.py" -> "Import:Number";
    "/torch/distributions/exponential.py" -> "Import:torch";
    "/torch/distributions/exponential.py" -> "Import:constraints";
    "/torch/distributions/exponential.py" -> "Import:ExponentialFamily";
    "/torch/distributions/exponential.py" -> "Import:broadcast_all";
    "/torch/distributions/exponential.py" -> "class:Exponential(ExponentialFamily):";
    "class:Exponential(ExponentialFamily):" -> "Fxn:mean";
    "class:Exponential(ExponentialFamily):" -> "Fxn:stddev";
    "class:Exponential(ExponentialFamily):" -> "Fxn:variance";
    "class:Exponential(ExponentialFamily):" -> "Fxn:__init__";
    "class:Exponential(ExponentialFamily):" -> "Fxn:rsample";
    "class:Exponential(ExponentialFamily):" -> "Fxn:log_prob";
    "class:Exponential(ExponentialFamily):" -> "Fxn:cdf";
    "class:Exponential(ExponentialFamily):" -> "Fxn:icdf";
    "class:Exponential(ExponentialFamily):" -> "Fxn:entropy";
    "class:Exponential(ExponentialFamily):" -> "Fxn:_natural_params";
    "class:Exponential(ExponentialFamily):" -> "Fxn:_log_normalizer";
    "Fxn:mean" -> "Fxn:self.rate.reciprocal()";
    "Fxn:stddev" -> "Fxn:self.rate.reciprocal()";
    "Fxn:variance" -> "Fxn:self.rate.pow(-2)";
    "Fxn:__init__" -> "Fxn:broadcast_all(rate)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.rate.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:self.rate.new(shape).exponential_()";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:self.rate.log()";
    "Fxn:cdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:cdf" -> "Fxn:torch.exp(-self.rate";
    "Fxn:icdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:icdf" -> "Fxn:-torch.log(1";
    "Fxn:entropy" -> "Fxn:torch.log(self.rate)";
    "Fxn:_log_normalizer" -> "Fxn:-torch.log(-x)";
    "/torch/distributions/exp_family.py" -> "Import:torch";
    "/torch/distributions/exp_family.py" -> "Import:Distribution";
    "/torch/distributions/exp_family.py" -> "Import:Variable";
    "/torch/distributions/exp_family.py" -> "class:ExponentialFamily(Distribution):";
    "class:ExponentialFamily(Distribution):" -> "Fxn:_natural_params";
    "class:ExponentialFamily(Distribution):" -> "Fxn:_log_normalizer";
    "class:ExponentialFamily(Distribution):" -> "Fxn:_mean_carrier_measure";
    "class:ExponentialFamily(Distribution):" -> "Fxn:entropy";
    "Fxn:entropy" -> "Fxn:[Variable(p.data,";
    "Fxn:entropy" -> "Fxn:self._log_normalizer(*nparams)";
    "Fxn:entropy" -> "Fxn:torch.autograd.grad(lg_normal.sum(),";
    "Fxn:entropy" -> "Fxn:lg_normal.clone()";
    "/torch/distributions/fishersnedecor.py" -> "Import:Number";
    "/torch/distributions/fishersnedecor.py" -> "Import:torch";
    "/torch/distributions/fishersnedecor.py" -> "Import:math";
    "/torch/distributions/fishersnedecor.py" -> "Import:constraints";
    "/torch/distributions/fishersnedecor.py" -> "Import:Distribution";
    "/torch/distributions/fishersnedecor.py" -> "Import:Gamma";
    "/torch/distributions/fishersnedecor.py" -> "Import:broadcast_all,";
    "/torch/distributions/fishersnedecor.py" -> "class:FisherSnedecor(Distribution):";
    "class:FisherSnedecor(Distribution):" -> "Fxn:__init__";
    "class:FisherSnedecor(Distribution):" -> "Fxn:mean";
    "class:FisherSnedecor(Distribution):" -> "Fxn:variance";
    "class:FisherSnedecor(Distribution):" -> "Fxn:rsample";
    "class:FisherSnedecor(Distribution):" -> "Fxn:log_prob";
    "Fxn:__init__" -> "Fxn:broadcast_all(df1,";
    "Fxn:__init__" -> "Fxn:Gamma(self.df1";
    "Fxn:__init__" -> "Fxn:Gamma(self.df2";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.df1.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:mean" -> "Fxn:self.df2.clone()";
    "Fxn:variance" -> "Fxn:self.df2.clone()";
    "Fxn:variance" -> "Fxn:df2.pow(2)";
    "Fxn:variance" -> "Fxn:2).pow(2)";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size(())):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:Gamma(df1";
    "Fxn:rsample" -> "Fxn:Gamma(df2";
    "Fxn:rsample" -> "Fxn:F(df1,";
    "Fxn:rsample" -> "Fxn:self._gamma1.rsample(sample_shape).view(shape)";
    "Fxn:rsample" -> "Fxn:self._gamma2.rsample(sample_shape).view(shape)";
    "Fxn:rsample" -> "Fxn:X2.clamp_(min=_finfo(X2).tiny)";
    "Fxn:rsample" -> "Fxn:Y.clamp_(min=_finfo(X2).tiny)";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:ct2).lgamma()";
    "Fxn:log_prob" -> "Fxn:ct1.lgamma()";
    "Fxn:log_prob" -> "Fxn:ct2.lgamma()";
    "Fxn:log_prob" -> "Fxn:ct3.log()";
    "Fxn:log_prob" -> "Fxn:torch.log(value)";
    "Fxn:log_prob" -> "Fxn:torch.log1p(ct3";
    "/torch/distributions/gamma.py" -> "Import:Number";
    "/torch/distributions/gamma.py" -> "Import:torch";
    "/torch/distributions/gamma.py" -> "Import:Function,";
    "/torch/distributions/gamma.py" -> "Import:once_differentiable";
    "/torch/distributions/gamma.py" -> "Import:constraints";
    "/torch/distributions/gamma.py" -> "Import:ExponentialFamily";
    "/torch/distributions/gamma.py" -> "Import:_finfo,";
    "/torch/distributions/gamma.py" -> "Fxn:_standard_gamma";
    "/torch/distributions/gamma.py" -> "class:Gamma(ExponentialFamily):";
    "class:Gamma(ExponentialFamily):" -> "Fxn:mean";
    "class:Gamma(ExponentialFamily):" -> "Fxn:variance";
    "class:Gamma(ExponentialFamily):" -> "Fxn:__init__";
    "class:Gamma(ExponentialFamily):" -> "Fxn:rsample";
    "class:Gamma(ExponentialFamily):" -> "Fxn:log_prob";
    "class:Gamma(ExponentialFamily):" -> "Fxn:entropy";
    "class:Gamma(ExponentialFamily):" -> "Fxn:_natural_params";
    "class:Gamma(ExponentialFamily):" -> "Fxn:_log_normalizer";
    "Fxn:variance" -> "Fxn:self.rate.pow(2)";
    "Fxn:__init__" -> "Fxn:broadcast_all(concentration,";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.concentration.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:_standard_gamma(self.concentration.expand(shape))";
    "Fxn:rsample" -> "Fxn:self.rate.expand(shape)";
    "Fxn:rsample" -> "Fxn:data.clamp_(min=_finfo(value).tiny)";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:torch.log(self.rate)";
    "Fxn:log_prob" -> "Fxn:torch.log(value)";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(self.concentration))";
    "Fxn:entropy" -> "Fxn:torch.log(self.rate)";
    "Fxn:entropy" -> "Fxn:torch.lgamma(self.concentration)";
    "Fxn:entropy" -> "Fxn:torch.digamma(self.concentration))";
    "Fxn:_log_normalizer" -> "Fxn:torch.lgamma(x";
    "Fxn:_log_normalizer" -> "Fxn:torch.log(-y.reciprocal())";
    "/torch/distributions/geometric.py" -> "Import:Number";
    "/torch/distributions/geometric.py" -> "Import:torch";
    "/torch/distributions/geometric.py" -> "Import:constraints";
    "/torch/distributions/geometric.py" -> "Import:Distribution";
    "/torch/distributions/geometric.py" -> "Import:broadcast_all,";
    "/torch/distributions/geometric.py" -> "Import:binary_cross_entropy_with_logits";
    "/torch/distributions/geometric.py" -> "class:Geometric(Distribution):";
    "class:Geometric(Distribution):" -> "Fxn:__init__";
    "class:Geometric(Distribution):" -> "Fxn:mean";
    "class:Geometric(Distribution):" -> "Fxn:variance";
    "class:Geometric(Distribution):" -> "Fxn:logits";
    "class:Geometric(Distribution):" -> "Fxn:probs";
    "class:Geometric(Distribution):" -> "Fxn:sample";
    "class:Geometric(Distribution):" -> "Fxn:log_prob";
    "class:Geometric(Distribution):" -> "Fxn:entropy";
    "Fxn:__init__" -> "Fxn:ValueError("Either";
    "Fxn:__init__" -> "Fxn:broadcast_all(probs)";
    "Fxn:__init__" -> "Fxn:self.probs.gt(0).all():";
    "Fxn:__init__" -> "Fxn:ValueError('All";
    "Fxn:__init__" -> "Fxn:broadcast_all(logits)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:probs_or_logits.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:logits" -> "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs" -> "Fxn:logits_to_probs(self.logits,";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:sample" -> "Fxn:torch.no_grad():";
    "Fxn:sample" -> "Fxn:self.probs.new(shape).uniform_(_finfo(self.probs).tiny,";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:broadcast_all(value,";
    "Fxn:log_prob" -> "Fxn:self.probs.clone())";
    "Fxn:log_prob" -> "Fxn:probs[(probs";
    "Fxn:log_prob" -> "Fxn:self.probs.log()";
    "Fxn:entropy" -> "Fxn:binary_cross_entropy_with_logits(self.logits,";
    "/torch/distributions/gumbel.py" -> "Import:Number";
    "/torch/distributions/gumbel.py" -> "Import:math";
    "/torch/distributions/gumbel.py" -> "Import:torch";
    "/torch/distributions/gumbel.py" -> "Import:constraints";
    "/torch/distributions/gumbel.py" -> "Import:Uniform";
    "/torch/distributions/gumbel.py" -> "Import:TransformedDistribution";
    "/torch/distributions/gumbel.py" -> "Import:AffineTransform,";
    "/torch/distributions/gumbel.py" -> "Import:_finfo,";
    "/torch/distributions/gumbel.py" -> "class:Gumbel(TransformedDistribution):";
    "class:Gumbel(TransformedDistribution):" -> "Fxn:__init__";
    "class:Gumbel(TransformedDistribution):" -> "Fxn:mean";
    "class:Gumbel(TransformedDistribution):" -> "Fxn:stddev";
    "class:Gumbel(TransformedDistribution):" -> "Fxn:variance";
    "class:Gumbel(TransformedDistribution):" -> "Fxn:entropy";
    "Fxn:__init__" -> "Fxn:broadcast_all(loc,";
    "Fxn:__init__" -> "Fxn:_finfo(self.loc)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:Uniform(finfo.tiny,";
    "Fxn:__init__" -> "Fxn:self.scale.size()";
    "Fxn:__init__" -> "Fxn:Uniform(self.loc.new(self.loc.size()).fill_(finfo.tiny),";
    "Fxn:__init__" -> "Fxn:[ExpTransform().inv,";
    "Fxn:__init__" -> "Fxn:AffineTransform(loc=0,";
    "Fxn:__init__" -> "Fxn:scale=-torch.ones_like(self.scale)),";
    "Fxn:__init__" -> "Fxn:ExpTransform().inv,";
    "Fxn:__init__" -> "Fxn:AffineTransform(loc=loc,";
    "Fxn:__init__" -> "Fxn:self).__init__(base_dist,";
    "Fxn:stddev" -> "Fxn:math.sqrt(6))";
    "Fxn:variance" -> "Fxn:self.stddev.pow(2)";
    "Fxn:entropy" -> "Fxn:self.scale.log()";
    "/torch/distributions/kl.py" -> "Import:math";
    "/torch/distributions/kl.py" -> "Import:warnings";
    "/torch/distributions/kl.py" -> "Import:total_ordering";
    "/torch/distributions/kl.py" -> "Import:torch";
    "/torch/distributions/kl.py" -> "Import:Bernoulli";
    "/torch/distributions/kl.py" -> "Import:Beta";
    "/torch/distributions/kl.py" -> "Import:Binomial";
    "/torch/distributions/kl.py" -> "Import:Categorical";
    "/torch/distributions/kl.py" -> "Import:Dirichlet";
    "/torch/distributions/kl.py" -> "Import:Distribution";
    "/torch/distributions/kl.py" -> "Import:Exponential";
    "/torch/distributions/kl.py" -> "Import:ExponentialFamily";
    "/torch/distributions/kl.py" -> "Import:Gamma";
    "/torch/distributions/kl.py" -> "Import:Geometric";
    "/torch/distributions/kl.py" -> "Import:Gumbel";
    "/torch/distributions/kl.py" -> "Import:Laplace";
    "/torch/distributions/kl.py" -> "Import:LogNormal";
    "/torch/distributions/kl.py" -> "Import:Normal";
    "/torch/distributions/kl.py" -> "Import:OneHotCategorical";
    "/torch/distributions/kl.py" -> "Import:Pareto";
    "/torch/distributions/kl.py" -> "Import:Poisson";
    "/torch/distributions/kl.py" -> "Import:TransformedDistribution";
    "/torch/distributions/kl.py" -> "Import:Uniform";
    "/torch/distributions/kl.py" -> "Import:_sum_rightmost";
    "/torch/distributions/kl.py" -> "Import:Variable,";
    "/torch/distributions/kl.py" -> "Fxn:register_kl";
    "/torch/distributions/kl.py" -> "Fxn:kl_normal_normal";
    "/torch/distributions/kl.py" -> "Fxn:kl_version1";
    "/torch/distributions/kl.py" -> "Fxn:kl_version2";
    "/torch/distributions/kl.py" -> "Fxn:decorator";
    "/torch/distributions/kl.py" -> "class:_Match(object):";
    "class:_Match(object):" -> "Fxn:__init__";
    "class:_Match(object):" -> "Fxn:__eq__";
    "class:_Match(object):" -> "Fxn:__le__";
    "class:_Match(object):" -> "Fxn:_dispatch_kl";
    "class:_Match(object):" -> "Fxn:_infinite_like";
    "class:_Match(object):" -> "Fxn:_x_log_x";
    "class:_Match(object):" -> "Fxn:kl_divergence";
    "class:_Match(object):" -> "Fxn:_kl_bernoulli_bernoulli";
    "class:_Match(object):" -> "Fxn:_kl_beta_beta";
    "class:_Match(object):" -> "Fxn:_kl_binomial_binomial";
    "class:_Match(object):" -> "Fxn:_kl_categorical_categorical";
    "class:_Match(object):" -> "Fxn:_kl_dirichlet_dirichlet";
    "class:_Match(object):" -> "Fxn:_kl_exponential_exponential";
    "class:_Match(object):" -> "Fxn:_kl_expfamily_expfamily";
    "class:_Match(object):" -> "Fxn:_kl_gamma_gamma";
    "class:_Match(object):" -> "Fxn:_kl_gumbel_gumbel";
    "class:_Match(object):" -> "Fxn:_kl_geometric_geometric";
    "class:_Match(object):" -> "Fxn:_kl_laplace_laplace";
    "class:_Match(object):" -> "Fxn:_kl_normal_normal";
    "class:_Match(object):" -> "Fxn:_kl_onehotcategorical_onehotcategorical";
    "class:_Match(object):" -> "Fxn:_kl_pareto_pareto";
    "class:_Match(object):" -> "Fxn:_kl_poisson_poisson";
    "class:_Match(object):" -> "Fxn:_kl_transformed_transformed";
    "class:_Match(object):" -> "Fxn:_kl_uniform_uniform";
    "class:_Match(object):" -> "Fxn:_kl_bernoulli_poisson";
    "class:_Match(object):" -> "Fxn:_kl_beta_infinity";
    "class:_Match(object):" -> "Fxn:_kl_beta_exponential";
    "class:_Match(object):" -> "Fxn:_kl_beta_gamma";
    "class:_Match(object):" -> "Fxn:_kl_beta_normal";
    "class:_Match(object):" -> "Fxn:_kl_beta_uniform";
    "class:_Match(object):" -> "Fxn:_kl_exponential_infinity";
    "class:_Match(object):" -> "Fxn:_kl_exponential_gamma";
    "class:_Match(object):" -> "Fxn:_kl_exponential_gumbel";
    "class:_Match(object):" -> "Fxn:_kl_exponential_normal";
    "class:_Match(object):" -> "Fxn:_kl_gamma_infinity";
    "class:_Match(object):" -> "Fxn:_kl_gamma_exponential";
    "class:_Match(object):" -> "Fxn:_kl_gamma_gumbel";
    "class:_Match(object):" -> "Fxn:_kl_gamma_normal";
    "class:_Match(object):" -> "Fxn:_kl_gumbel_infinity";
    "class:_Match(object):" -> "Fxn:_kl_gumbel_normal";
    "class:_Match(object):" -> "Fxn:_kl_laplace_infinity";
    "class:_Match(object):" -> "Fxn:_kl_laplace_normal";
    "class:_Match(object):" -> "Fxn:_kl_normal_infinity";
    "class:_Match(object):" -> "Fxn:_kl_normal_gumbel";
    "class:_Match(object):" -> "Fxn:_kl_pareto_infinity";
    "class:_Match(object):" -> "Fxn:_kl_pareto_exponential";
    "class:_Match(object):" -> "Fxn:_kl_pareto_gamma";
    "class:_Match(object):" -> "Fxn:_kl_pareto_normal";
    "class:_Match(object):" -> "Fxn:_kl_poisson_infinity";
    "class:_Match(object):" -> "Fxn:_kl_uniform_beta";
    "class:_Match(object):" -> "Fxn:_kl_uniform_exponetial";
    "class:_Match(object):" -> "Fxn:_kl_uniform_gamma";
    "class:_Match(object):" -> "Fxn:_kl_uniform_gumbel";
    "class:_Match(object):" -> "Fxn:_kl_uniform_normal";
    "class:_Match(object):" -> "Fxn:_kl_uniform_pareto";
    "Fxn:_dispatch_kl" -> "Fxn:[(super_p,";
    "Fxn:_dispatch_kl" -> "Fxn:warnings.warn('Ambiguous";
    "Fxn:_dispatch_kl" -> "Fxn:kl_divergence({},";
    "Fxn:_dispatch_kl" -> "Fxn:register_kl({},";
    "Fxn:_dispatch_kl" -> "Fxn:{})'.format(";
    "Fxn:_infinite_like" -> "Fxn:tensor.new_tensor(float('inf')).expand_as(tensor)";
    "Fxn:_infinite_like" -> "Fxn:tensor.new([float('inf')]).expand_as(tensor)";
    "Fxn:_x_log_x" -> "Fxn:tensor.log()";
    "Fxn:kl_divergence" -> "Fxn::math:`KL(p";
    "Fxn:kl_divergence" -> "Fxn:KL(p";
    "Fxn:kl_divergence" -> "Fxn:p(x)";
    "Fxn:kl_divergence" -> "Fxn:{p(x)}";
    "Fxn:kl_divergence" -> "Fxn:{q(x)}";
    "Fxn:kl_divergence" -> "Fxn:_KL_MEMOIZE[type(p),";
    "Fxn:kl_divergence" -> "Fxn:_dispatch_kl(type(p),";
    "Fxn:kl_divergence" -> "Fxn:_KL_MEMOIZE[type(p),";
    "Fxn:kl_divergence" -> "Fxn:fun(p,";
    "Fxn:kl_divergence" -> "Fxn:@register_kl(Bernoulli,";
    "Fxn:_kl_bernoulli_bernoulli" -> "Fxn:q.probs).log()";
    "Fxn:_kl_bernoulli_bernoulli" -> "Fxn:q.probs)).log()";
    "Fxn:_kl_bernoulli_bernoulli" -> "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_beta" -> "Fxn:q.concentration1.lgamma()";
    "Fxn:_kl_beta_beta" -> "Fxn:q.concentration0.lgamma()";
    "Fxn:_kl_beta_beta" -> "Fxn:p.concentration1.lgamma()";
    "Fxn:_kl_beta_beta" -> "Fxn:p.concentration0.lgamma()";
    "Fxn:_kl_beta_beta" -> "Fxn:torch.digamma(p.concentration1)";
    "Fxn:_kl_beta_beta" -> "Fxn:torch.digamma(p.concentration0)";
    "Fxn:_kl_beta_beta" -> "Fxn:torch.digamma(sum_params_p)";
    "Fxn:_kl_beta_beta" -> "Fxn:@register_kl(Binomial,";
    "Fxn:_kl_binomial_binomial" -> "Fxn:_infinite_like(p.probs)";
    "Fxn:_kl_binomial_binomial" -> "Fxn:NotImplementedError('KL";
    "Fxn:_kl_binomial_binomial" -> "Fxn:@register_kl(Categorical,";
    "Fxn:_kl_categorical_categorical" -> "Fxn:t.sum(-1)";
    "Fxn:_kl_categorical_categorical" -> "Fxn:@register_kl(Dirichlet,";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:p.concentration.sum(-1)";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:q.concentration.sum(-1)";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:sum_p_concentration.lgamma()";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:sum_q_concentration.lgamma()";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:q.concentration.lgamma()).sum(-1)";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:p.concentration.digamma()";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:sum_p_concentration.digamma().unsqueeze(-1)";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:t4).sum(-1)";
    "Fxn:_kl_dirichlet_dirichlet" -> "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_exponential" -> "Fxn:-rate_ratio.log()";
    "Fxn:_kl_exponential_exponential" -> "Fxn:@register_kl(ExponentialFamily,";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:NotImplementedError("The";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:[Variable(np.data,";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:p._log_normalizer(*p_nparams)";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:torch.autograd.grad(lg_normal.sum(),";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:q._log_normalizer(*q_nparams)";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:lg_normal.clone()";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:_sum_rightmost(term,";
    "Fxn:_kl_expfamily_expfamily" -> "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_gamma" -> "Fxn:q.rate).log()";
    "Fxn:_kl_gamma_gamma" -> "Fxn:torch.lgamma(q.concentration)";
    "Fxn:_kl_gamma_gamma" -> "Fxn:torch.lgamma(p.concentration)";
    "Fxn:_kl_gamma_gamma" -> "Fxn:torch.digamma(p.concentration)";
    "Fxn:_kl_gamma_gamma" -> "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gumbel_gumbel" -> "Fxn:-ct1.log()";
    "Fxn:_kl_gumbel_gumbel" -> "Fxn:torch.exp(ct2";
    "Fxn:_kl_gumbel_gumbel" -> "Fxn:ct1).lgamma()";
    "Fxn:_kl_gumbel_gumbel" -> "Fxn:@register_kl(Geometric,";
    "Fxn:_kl_geometric_geometric" -> "Fxn:-p.entropy()";
    "Fxn:_kl_geometric_geometric" -> "Fxn:torch.log1p(-q.probs)";
    "Fxn:_kl_geometric_geometric" -> "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_laplace_laplace" -> "Fxn:q.loc).abs()";
    "Fxn:_kl_laplace_laplace" -> "Fxn:-scale_ratio.log()";
    "Fxn:_kl_laplace_laplace" -> "Fxn:torch.exp(-loc_abs_diff";
    "Fxn:_kl_laplace_laplace" -> "Fxn:@register_kl(Normal,";
    "Fxn:_kl_normal_normal" -> "Fxn:q.scale).pow(2)";
    "Fxn:_kl_normal_normal" -> "Fxn:q.scale).pow(2)";
    "Fxn:_kl_normal_normal" -> "Fxn:var_ratio.log())";
    "Fxn:_kl_normal_normal" -> "Fxn:@register_kl(OneHotCategorical,";
    "Fxn:_kl_onehotcategorical_onehotcategorical" -> "Fxn:_kl_categorical_categorical(p._categorical,";
    "Fxn:_kl_onehotcategorical_onehotcategorical" -> "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_pareto" -> "Fxn:scale_ratio.log()";
    "Fxn:_kl_pareto_pareto" -> "Fxn:-alpha_ratio.log()";
    "Fxn:_kl_pareto_pareto" -> "Fxn:@register_kl(Poisson,";
    "Fxn:_kl_poisson_poisson" -> "Fxn:q.rate.log())";
    "Fxn:_kl_poisson_poisson" -> "Fxn:@register_kl(TransformedDistribution,";
    "Fxn:_kl_transformed_transformed" -> "Fxn:kl_divergence(p.base_dist,";
    "Fxn:_kl_transformed_transformed" -> "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_uniform" -> "Fxn:p.low)).log()";
    "Fxn:_kl_uniform_uniform" -> "Fxn:result[(q.low";
    "Fxn:_kl_uniform_uniform" -> "Fxn:@register_kl(Bernoulli,";
    "Fxn:_kl_bernoulli_poisson" -> "Fxn:-p.entropy()";
    "Fxn:_kl_bernoulli_poisson" -> "Fxn:q.rate.log()";
    "Fxn:_kl_bernoulli_poisson" -> "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_infinity" -> "Fxn:_infinite_like(p.concentration1)";
    "Fxn:_kl_beta_infinity" -> "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_exponential" -> "Fxn:-p.entropy()";
    "Fxn:_kl_beta_exponential" -> "Fxn:q.rate.log()";
    "Fxn:_kl_beta_exponential" -> "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_gamma" -> "Fxn:-p.entropy()";
    "Fxn:_kl_beta_gamma" -> "Fxn:q.concentration.lgamma()";
    "Fxn:_kl_beta_gamma" -> "Fxn:q.rate.log()";
    "Fxn:_kl_beta_gamma" -> "Fxn:p.concentration0).digamma())";
    "Fxn:_kl_beta_gamma" -> "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_normal" -> "Fxn:q.scale.pow(2)";
    "Fxn:_kl_beta_normal" -> "Fxn:-p.entropy()";
    "Fxn:_kl_beta_normal" -> "Fxn:math.pi).log()";
    "Fxn:_kl_beta_normal" -> "Fxn:E_beta.pow(2))";
    "Fxn:_kl_beta_normal" -> "Fxn:q.loc.pow(2)";
    "Fxn:_kl_beta_normal" -> "Fxn:@register_kl(Beta,";
    "Fxn:_kl_beta_uniform" -> "Fxn:-p.entropy()";
    "Fxn:_kl_beta_uniform" -> "Fxn:q.low).log()";
    "Fxn:_kl_beta_uniform" -> "Fxn:result[(q.low";
    "Fxn:_kl_beta_uniform" -> "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_beta_uniform" -> "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_beta_uniform" -> "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_infinity" -> "Fxn:_infinite_like(p.rate)";
    "Fxn:_kl_exponential_infinity" -> "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_gamma" -> "Fxn:torch.log(ratio)";
    "Fxn:_kl_exponential_gamma" -> "Fxn:q.concentration.lgamma()";
    "Fxn:_kl_exponential_gamma" -> "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_gumbel" -> "Fxn:scale_rate_prod.log()";
    "Fxn:_kl_exponential_gumbel" -> "Fxn:torch.exp(loc_scale_ratio)";
    "Fxn:_kl_exponential_gumbel" -> "Fxn:scale_rate_prod.reciprocal()";
    "Fxn:_kl_exponential_gumbel" -> "Fxn:@register_kl(Exponential,";
    "Fxn:_kl_exponential_normal" -> "Fxn:q.scale.pow(2)";
    "Fxn:_kl_exponential_normal" -> "Fxn:p.rate.pow(2)";
    "Fxn:_kl_exponential_normal" -> "Fxn:torch.log(rate_sqr";
    "Fxn:_kl_exponential_normal" -> "Fxn:rate_sqr.reciprocal()";
    "Fxn:_kl_exponential_normal" -> "Fxn:q.loc.pow(2)";
    "Fxn:_kl_exponential_normal" -> "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_exponential_normal" -> "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_exponential_normal" -> "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_infinity" -> "Fxn:_infinite_like(p.concentration)";
    "Fxn:_kl_gamma_infinity" -> "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_exponential" -> "Fxn:-p.entropy()";
    "Fxn:_kl_gamma_exponential" -> "Fxn:q.rate.log()";
    "Fxn:_kl_gamma_exponential" -> "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_gumbel" -> "Fxn:p.concentration.digamma()";
    "Fxn:_kl_gamma_gumbel" -> "Fxn:p.concentration.lgamma()";
    "Fxn:_kl_gamma_gumbel" -> "Fxn:beta_scale_prod.log()";
    "Fxn:_kl_gamma_gumbel" -> "Fxn:torch.exp(loc_scale_ratio)";
    "Fxn:_kl_gamma_gumbel" -> "Fxn:beta_scale_prod.reciprocal()).pow(-p.concentration)";
    "Fxn:_kl_gamma_gumbel" -> "Fxn:@register_kl(Gamma,";
    "Fxn:_kl_gamma_normal" -> "Fxn:q.scale.pow(2)";
    "Fxn:_kl_gamma_normal" -> "Fxn:p.rate.pow(2)";
    "Fxn:_kl_gamma_normal" -> "Fxn:torch.log(beta_sqr";
    "Fxn:_kl_gamma_normal" -> "Fxn:p.concentration.lgamma()";
    "Fxn:_kl_gamma_normal" -> "Fxn:q.loc.pow(2)";
    "Fxn:_kl_gamma_normal" -> "Fxn:p.concentration.digamma()";
    "Fxn:_kl_gamma_normal" -> "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gamma_normal" -> "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gamma_normal" -> "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gamma_normal" -> "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gamma_normal" -> "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gumbel_infinity" -> "Fxn:_infinite_like(p.loc)";
    "Fxn:_kl_gumbel_infinity" -> "Fxn:@register_kl(Gumbel,";
    "Fxn:_kl_gumbel_normal" -> "Fxn:math.sqrt(2";
    "Fxn:_kl_gumbel_normal" -> "Fxn:math.pi)).log()";
    "Fxn:_kl_gumbel_normal" -> "Fxn:0.5).pow(2)";
    "Fxn:_kl_gumbel_normal" -> "Fxn:q.scale).pow(2)";
    "Fxn:_kl_gumbel_normal" -> "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_gumbel_normal" -> "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_gumbel_normal" -> "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_gumbel_normal" -> "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_gumbel_normal" -> "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_laplace_infinity" -> "Fxn:_infinite_like(p.loc)";
    "Fxn:_kl_laplace_infinity" -> "Fxn:@register_kl(Laplace,";
    "Fxn:_kl_laplace_normal" -> "Fxn:q.scale.pow(2)";
    "Fxn:_kl_laplace_normal" -> "Fxn:p.scale.pow(2)";
    "Fxn:_kl_laplace_normal" -> "Fxn:torch.log(2";
    "Fxn:_kl_laplace_normal" -> "Fxn:p.loc.pow(2)";
    "Fxn:_kl_laplace_normal" -> "Fxn:q.loc.pow(2)";
    "Fxn:_kl_laplace_normal" -> "Fxn:@register_kl(Normal,";
    "Fxn:_kl_laplace_normal" -> "Fxn:@register_kl(Normal,";
    "Fxn:_kl_laplace_normal" -> "Fxn:@register_kl(Normal,";
    "Fxn:_kl_laplace_normal" -> "Fxn:@register_kl(Normal,";
    "Fxn:_kl_laplace_normal" -> "Fxn:@register_kl(Normal,";
    "Fxn:_kl_normal_infinity" -> "Fxn:_infinite_like(p.loc)";
    "Fxn:_kl_normal_infinity" -> "Fxn:@register_kl(Normal,";
    "Fxn:_kl_normal_gumbel" -> "Fxn:q.scale).pow(2)";
    "Fxn:_kl_normal_gumbel" -> "Fxn:var_scale_sqr_ratio.log()";
    "Fxn:_kl_normal_gumbel" -> "Fxn:torch.exp(-mean_scale_ratio";
    "Fxn:_kl_normal_gumbel" -> "Fxn:math.log(2";
    "Fxn:_kl_normal_gumbel" -> "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_normal_gumbel" -> "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_infinity" -> "Fxn:_infinite_like(p.scale)";
    "Fxn:_kl_pareto_infinity" -> "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_exponential" -> "Fxn:scale_rate_prod).log()";
    "Fxn:_kl_pareto_exponential" -> "Fxn:p.alpha.reciprocal()";
    "Fxn:_kl_pareto_exponential" -> "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_gamma" -> "Fxn:p.scale.log()";
    "Fxn:_kl_pareto_gamma" -> "Fxn:p.alpha.reciprocal()";
    "Fxn:_kl_pareto_gamma" -> "Fxn:p.alpha.log()";
    "Fxn:_kl_pareto_gamma" -> "Fxn:q.concentration.lgamma()";
    "Fxn:_kl_pareto_gamma" -> "Fxn:q.rate.log()";
    "Fxn:_kl_pareto_gamma" -> "Fxn:@register_kl(Pareto,";
    "Fxn:_kl_pareto_normal" -> "Fxn:q.scale.pow(2)";
    "Fxn:_kl_pareto_normal" -> "Fxn:p.scale).log()";
    "Fxn:_kl_pareto_normal" -> "Fxn:p.alpha.reciprocal()";
    "Fxn:_kl_pareto_normal" -> "Fxn:common_term.pow(2)";
    "Fxn:_kl_pareto_normal" -> "Fxn:q.loc).pow(2)";
    "Fxn:_kl_pareto_normal" -> "Fxn:@register_kl(Poisson,";
    "Fxn:_kl_pareto_normal" -> "Fxn:@register_kl(Poisson,";
    "Fxn:_kl_poisson_infinity" -> "Fxn:_infinite_like(p.rate)";
    "Fxn:_kl_poisson_infinity" -> "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_beta" -> "Fxn:torch.log(common_term)";
    "Fxn:_kl_uniform_beta" -> "Fxn:_x_log_x(p.low)";
    "Fxn:_kl_uniform_beta" -> "Fxn:_x_log_x((1";
    "Fxn:_kl_uniform_beta" -> "Fxn:q.concentration1.lgamma()";
    "Fxn:_kl_uniform_beta" -> "Fxn:q.concentration0.lgamma()";
    "Fxn:_kl_uniform_beta" -> "Fxn:q.concentration0).lgamma()";
    "Fxn:_kl_uniform_beta" -> "Fxn:result[(p.high";
    "Fxn:_kl_uniform_beta" -> "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_exponetial" -> "Fxn:q.rate).log()";
    "Fxn:_kl_uniform_exponetial" -> "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_gamma" -> "Fxn:common_term.log()";
    "Fxn:_kl_uniform_gamma" -> "Fxn:q.concentration.lgamma()";
    "Fxn:_kl_uniform_gamma" -> "Fxn:q.rate.log()";
    "Fxn:_kl_uniform_gamma" -> "Fxn:_x_log_x(p.low)";
    "Fxn:_kl_uniform_gamma" -> "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_gumbel" -> "Fxn:common_term.log()";
    "Fxn:_kl_uniform_gumbel" -> "Fxn:torch.exp(-low_loc_diff))";
    "Fxn:_kl_uniform_gumbel" -> "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_normal" -> "Fxn:common_term).log()";
    "Fxn:_kl_uniform_normal" -> "Fxn:2).pow(2)";
    "Fxn:_kl_uniform_normal" -> "Fxn:q.scale.pow(2)";
    "Fxn:_kl_uniform_normal" -> "Fxn:@register_kl(Uniform,";
    "Fxn:_kl_uniform_pareto" -> "Fxn:q.scale.pow(q.alpha)";
    "Fxn:_kl_uniform_pareto" -> "Fxn:_x_log_x(p.low)";
    "/torch/distributions/laplace.py" -> "Import:Number";
    "/torch/distributions/laplace.py" -> "Import:torch";
    "/torch/distributions/laplace.py" -> "Import:constraints";
    "/torch/distributions/laplace.py" -> "Import:Distribution";
    "/torch/distributions/laplace.py" -> "Import:_finfo,";
    "/torch/distributions/laplace.py" -> "class:Laplace(Distribution):";
    "class:Laplace(Distribution):" -> "Fxn:mean";
    "class:Laplace(Distribution):" -> "Fxn:variance";
    "class:Laplace(Distribution):" -> "Fxn:stddev";
    "class:Laplace(Distribution):" -> "Fxn:__init__";
    "class:Laplace(Distribution):" -> "Fxn:rsample";
    "class:Laplace(Distribution):" -> "Fxn:log_prob";
    "class:Laplace(Distribution):" -> "Fxn:cdf";
    "class:Laplace(Distribution):" -> "Fxn:icdf";
    "class:Laplace(Distribution):" -> "Fxn:entropy";
    "Fxn:variance" -> "Fxn:self.scale.pow(2)";
    "Fxn:__init__" -> "Fxn:broadcast_all(loc,";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.loc.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:self.loc.new(shape).uniform_(_finfo(self.loc).eps";
    "Fxn:rsample" -> "Fxn:self.loc.new(shape).uniform_(self.loc.nextafter(-.5,";
    "Fxn:rsample" -> "Fxn:u.sign()";
    "Fxn:rsample" -> "Fxn:torch.log1p(-u.abs())";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:-torch.log(2";
    "Fxn:log_prob" -> "Fxn:torch.abs(value";
    "Fxn:cdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:cdf" -> "Fxn:self.loc).sign()";
    "Fxn:cdf" -> "Fxn:torch.expm1(-(value";
    "Fxn:cdf" -> "Fxn:self.loc).abs()";
    "Fxn:icdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:icdf" -> "Fxn:torch.log1p(-2";
    "Fxn:icdf" -> "Fxn:term.abs())";
    "Fxn:entropy" -> "Fxn:torch.log(2";
    "/torch/distributions/log_normal.py" -> "Import:constraints";
    "/torch/distributions/log_normal.py" -> "Import:ExpTransform";
    "/torch/distributions/log_normal.py" -> "Import:Normal";
    "/torch/distributions/log_normal.py" -> "Import:TransformedDistribution";
    "/torch/distributions/log_normal.py" -> "class:LogNormal(TransformedDistribution):";
    "class:LogNormal(TransformedDistribution):" -> "Fxn:__init__";
    "class:LogNormal(TransformedDistribution):" -> "Fxn:loc";
    "class:LogNormal(TransformedDistribution):" -> "Fxn:scale";
    "class:LogNormal(TransformedDistribution):" -> "Fxn:mean";
    "class:LogNormal(TransformedDistribution):" -> "Fxn:variance";
    "class:LogNormal(TransformedDistribution):" -> "Fxn:entropy";
    "Fxn:__init__" -> "Fxn:self).__init__(Normal(loc,";
    "Fxn:__init__" -> "Fxn:ExpTransform(),";
    "Fxn:mean" -> "Fxn:self.scale.pow(2)";
    "Fxn:mean" -> "Fxn:2).exp()";
    "Fxn:variance" -> "Fxn:self.scale.pow(2)).exp()";
    "Fxn:entropy" -> "Fxn:self.base_dist.entropy()";
    "/torch/distributions/multinomial.py" -> "Import:torch";
    "/torch/distributions/multinomial.py" -> "Import:Distribution";
    "/torch/distributions/multinomial.py" -> "Import:Variable";
    "/torch/distributions/multinomial.py" -> "Import:Categorical";
    "/torch/distributions/multinomial.py" -> "Import:Number";
    "/torch/distributions/multinomial.py" -> "Import:constraints";
    "/torch/distributions/multinomial.py" -> "Import:broadcast_all";
    "/torch/distributions/multinomial.py" -> "class:Multinomial(Distribution):";
    "class:Multinomial(Distribution):" -> "Fxn:mean";
    "class:Multinomial(Distribution):" -> "Fxn:variance";
    "class:Multinomial(Distribution):" -> "Fxn:__init__";
    "class:Multinomial(Distribution):" -> "Fxn:_new";
    "class:Multinomial(Distribution):" -> "Fxn:support";
    "class:Multinomial(Distribution):" -> "Fxn:logits";
    "class:Multinomial(Distribution):" -> "Fxn:probs";
    "class:Multinomial(Distribution):" -> "Fxn:param_shape";
    "class:Multinomial(Distribution):" -> "Fxn:sample";
    "class:Multinomial(Distribution):" -> "Fxn:log_prob";
    "Fxn:__init__" -> "Fxn:NotImplementedError('inhomogeneous";
    "Fxn:__init__" -> "Fxn:Categorical(probs=probs,";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:_new" -> "Fxn:self._categorical._new(*args,";
    "Fxn:support" -> "Fxn:constraints.integer_interval(0,";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:torch.Size(sample_shape)";
    "Fxn:sample" -> "Fxn:self._categorical.sample(torch.Size((self.total_count,))";
    "Fxn:sample" -> "Fxn:shifted_idx.append(shifted_idx.pop(0))";
    "Fxn:sample" -> "Fxn:samples.permute(*shifted_idx)";
    "Fxn:sample" -> "Fxn:samples.new(self._extended_shape(sample_shape)).zero_()";
    "Fxn:sample" -> "Fxn:counts.scatter_add_(-1,";
    "Fxn:sample" -> "Fxn:torch.ones_like(samples))";
    "Fxn:sample" -> "Fxn:counts.type_as(self.probs)";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:broadcast_all(self.logits.clone(),";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(value.sum(-1)";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(value";
    "Fxn:log_prob" -> "Fxn:1).sum(-1)";
    "Fxn:log_prob" -> "Fxn:logits[(value";
    "Fxn:log_prob" -> "Fxn:-float('inf'))]";
    "Fxn:log_prob" -> "Fxn:value).sum(-1)";
    "/torch/distributions/normal.py" -> "Import:math";
    "/torch/distributions/normal.py" -> "Import:Number";
    "/torch/distributions/normal.py" -> "Import:torch";
    "/torch/distributions/normal.py" -> "Import:constraints";
    "/torch/distributions/normal.py" -> "Import:ExponentialFamily";
    "/torch/distributions/normal.py" -> "Import:broadcast_all";
    "/torch/distributions/normal.py" -> "class:Normal(ExponentialFamily):";
    "class:Normal(ExponentialFamily):" -> "Fxn:mean";
    "class:Normal(ExponentialFamily):" -> "Fxn:stddev";
    "class:Normal(ExponentialFamily):" -> "Fxn:variance";
    "class:Normal(ExponentialFamily):" -> "Fxn:__init__";
    "class:Normal(ExponentialFamily):" -> "Fxn:sample";
    "class:Normal(ExponentialFamily):" -> "Fxn:rsample";
    "class:Normal(ExponentialFamily):" -> "Fxn:log_prob";
    "class:Normal(ExponentialFamily):" -> "Fxn:cdf";
    "class:Normal(ExponentialFamily):" -> "Fxn:icdf";
    "class:Normal(ExponentialFamily):" -> "Fxn:entropy";
    "class:Normal(ExponentialFamily):" -> "Fxn:_natural_params";
    "class:Normal(ExponentialFamily):" -> "Fxn:_log_normalizer";
    "Fxn:variance" -> "Fxn:self.stddev.pow(2)";
    "Fxn:__init__" -> "Fxn:broadcast_all(loc,";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.loc.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:sample" -> "Fxn:torch.no_grad():";
    "Fxn:sample" -> "Fxn:torch.normal(self.loc.expand(shape),";
    "Fxn:sample" -> "Fxn:self.scale.expand(shape))";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:self.loc.new(shape).normal_()";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:math.log(self.scale)";
    "Fxn:log_prob" -> "Fxn:self.scale.log()";
    "Fxn:log_prob" -> "Fxn:-((value";
    "Fxn:log_prob" -> "Fxn:math.log(math.sqrt(2";
    "Fxn:cdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:cdf" -> "Fxn:torch.erf((value";
    "Fxn:cdf" -> "Fxn:self.scale.reciprocal()";
    "Fxn:cdf" -> "Fxn:math.sqrt(2)))";
    "Fxn:icdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:icdf" -> "Fxn:torch.erfinv(2";
    "Fxn:icdf" -> "Fxn:math.sqrt(2)";
    "Fxn:entropy" -> "Fxn:math.log(2";
    "Fxn:entropy" -> "Fxn:torch.log(self.scale)";
    "Fxn:_natural_params" -> "Fxn:self.scale.pow(2),";
    "Fxn:_natural_params" -> "Fxn:self.scale.pow(2).reciprocal())";
    "Fxn:_log_normalizer" -> "Fxn:x.pow(2)";
    "Fxn:_log_normalizer" -> "Fxn:torch.log(-math.pi";
    "/torch/distributions/one_hot_categorical.py" -> "Import:torch";
    "/torch/distributions/one_hot_categorical.py" -> "Import:Variable";
    "/torch/distributions/one_hot_categorical.py" -> "Import:constraints";
    "/torch/distributions/one_hot_categorical.py" -> "Import:Categorical";
    "/torch/distributions/one_hot_categorical.py" -> "Import:Distribution";
    "/torch/distributions/one_hot_categorical.py" -> "class:OneHotCategorical(Distribution):";
    "class:OneHotCategorical(Distribution):" -> "Fxn:__init__";
    "class:OneHotCategorical(Distribution):" -> "Fxn:_new";
    "class:OneHotCategorical(Distribution):" -> "Fxn:probs";
    "class:OneHotCategorical(Distribution):" -> "Fxn:logits";
    "class:OneHotCategorical(Distribution):" -> "Fxn:mean";
    "class:OneHotCategorical(Distribution):" -> "Fxn:variance";
    "class:OneHotCategorical(Distribution):" -> "Fxn:param_shape";
    "class:OneHotCategorical(Distribution):" -> "Fxn:sample";
    "class:OneHotCategorical(Distribution):" -> "Fxn:log_prob";
    "class:OneHotCategorical(Distribution):" -> "Fxn:entropy";
    "class:OneHotCategorical(Distribution):" -> "Fxn:enumerate_support";
    "Fxn:__init__" -> "Fxn:Categorical(probs,";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:_new" -> "Fxn:self._categorical._new(*args,";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:torch.Size(sample_shape)";
    "Fxn:sample" -> "Fxn:probs.new(self._extended_shape(sample_shape)).zero_()";
    "Fxn:sample" -> "Fxn:self._categorical.sample(sample_shape)";
    "Fxn:sample" -> "Fxn:indices.dim()";
    "Fxn:sample" -> "Fxn:one_hot.dim():";
    "Fxn:sample" -> "Fxn:indices.unsqueeze(-1)";
    "Fxn:sample" -> "Fxn:one_hot.scatter_(-1,";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:value.max(-1)[1]";
    "Fxn:log_prob" -> "Fxn:self._categorical.log_prob(indices)";
    "Fxn:entropy" -> "Fxn:self._categorical.entropy()";
    "Fxn:enumerate_support" -> "Fxn:self._new((n,";
    "Fxn:enumerate_support" -> "Fxn:torch.eye(n,";
    "Fxn:enumerate_support" -> "Fxn:values.view((n,)";
    "Fxn:enumerate_support" -> "Fxn:values.expand((n,)";
    "/torch/distributions/pareto.py" -> "Import:Number";
    "/torch/distributions/pareto.py" -> "Import:math";
    "/torch/distributions/pareto.py" -> "Import:torch";
    "/torch/distributions/pareto.py" -> "Import:constraints";
    "/torch/distributions/pareto.py" -> "Import:Exponential";
    "/torch/distributions/pareto.py" -> "Import:TransformedDistribution";
    "/torch/distributions/pareto.py" -> "Import:AffineTransform,";
    "/torch/distributions/pareto.py" -> "Import:broadcast_all";
    "/torch/distributions/pareto.py" -> "class:Pareto(TransformedDistribution):";
    "class:Pareto(TransformedDistribution):" -> "Fxn:__init__";
    "class:Pareto(TransformedDistribution):" -> "Fxn:mean";
    "class:Pareto(TransformedDistribution):" -> "Fxn:variance";
    "class:Pareto(TransformedDistribution):" -> "Fxn:support";
    "class:Pareto(TransformedDistribution):" -> "Fxn:entropy";
    "Fxn:__init__" -> "Fxn:broadcast_all(scale,";
    "Fxn:__init__" -> "Fxn:Exponential(self.alpha)";
    "Fxn:__init__" -> "Fxn:[ExpTransform(),";
    "Fxn:__init__" -> "Fxn:AffineTransform(loc=0,";
    "Fxn:__init__" -> "Fxn:self).__init__(base_dist,";
    "Fxn:mean" -> "Fxn:self.alpha.clone().clamp(min=1)";
    "Fxn:variance" -> "Fxn:self.alpha.clone().clamp(min=2)";
    "Fxn:variance" -> "Fxn:self.scale.pow(2)";
    "Fxn:variance" -> "Fxn:1).pow(2)";
    "Fxn:support" -> "Fxn:constraints.greater_than(self.scale)";
    "Fxn:entropy" -> "Fxn:self.alpha).log()";
    "Fxn:entropy" -> "Fxn:self.alpha.reciprocal()))";
    "/torch/distributions/poisson.py" -> "Import:Number";
    "/torch/distributions/poisson.py" -> "Import:torch";
    "/torch/distributions/poisson.py" -> "Import:Variable";
    "/torch/distributions/poisson.py" -> "Import:constraints";
    "/torch/distributions/poisson.py" -> "Import:ExponentialFamily";
    "/torch/distributions/poisson.py" -> "Import:broadcast_all";
    "/torch/distributions/poisson.py" -> "class:Poisson(ExponentialFamily):";
    "class:Poisson(ExponentialFamily):" -> "Fxn:mean";
    "class:Poisson(ExponentialFamily):" -> "Fxn:variance";
    "class:Poisson(ExponentialFamily):" -> "Fxn:__init__";
    "class:Poisson(ExponentialFamily):" -> "Fxn:sample";
    "class:Poisson(ExponentialFamily):" -> "Fxn:log_prob";
    "class:Poisson(ExponentialFamily):" -> "Fxn:_natural_params";
    "class:Poisson(ExponentialFamily):" -> "Fxn:_log_normalizer";
    "Fxn:__init__" -> "Fxn:broadcast_all(rate)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.rate.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:sample" -> "Fxn:torch.no_grad():";
    "Fxn:sample" -> "Fxn:torch.poisson(self.rate.expand(shape))";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:broadcast_all(self.rate,";
    "Fxn:log_prob" -> "Fxn:1).lgamma()";
    "Fxn:_log_normalizer" -> "Fxn:torch.exp(x)";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:torch";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:Number";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:Variable";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:constraints";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:Distribution";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:TransformedDistribution";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:SigmoidTransform";
    "/torch/distributions/relaxed_bernoulli.py" -> "Import:broadcast_all,";
    "/torch/distributions/relaxed_bernoulli.py" -> "class:LogitRelaxedBernoulli(Distribution):";
    "/torch/distributions/relaxed_bernoulli.py" -> "class:RelaxedBernoulli(TransformedDistribution):";
    "class:LogitRelaxedBernoulli(Distribution):" -> "Fxn:__init__";
    "class:LogitRelaxedBernoulli(Distribution):" -> "Fxn:_new";
    "class:LogitRelaxedBernoulli(Distribution):" -> "Fxn:logits";
    "class:LogitRelaxedBernoulli(Distribution):" -> "Fxn:probs";
    "class:LogitRelaxedBernoulli(Distribution):" -> "Fxn:param_shape";
    "class:LogitRelaxedBernoulli(Distribution):" -> "Fxn:rsample";
    "class:LogitRelaxedBernoulli(Distribution):" -> "Fxn:log_prob";
    "Fxn:__init__" -> "Fxn:ValueError("Either";
    "Fxn:__init__" -> "Fxn:broadcast_all(probs)";
    "Fxn:__init__" -> "Fxn:broadcast_all(logits)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self._param.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:_new" -> "Fxn:self._param.new(*args,";
    "Fxn:logits" -> "Fxn:probs_to_logits(self.probs,";
    "Fxn:probs" -> "Fxn:logits_to_probs(self.logits,";
    "Fxn:param_shape" -> "Fxn:self._param.size()";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:clamp_probs(self.probs.expand(shape))";
    "Fxn:rsample" -> "Fxn:clamp_probs(self.probs.new(shape).uniform_())";
    "Fxn:rsample" -> "Fxn:probs.log()";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:broadcast_all(self.logits,";
    "Fxn:log_prob" -> "Fxn:value.mul(self.temperature)";
    "Fxn:log_prob" -> "Fxn:self.temperature.log()";
    "Fxn:log_prob" -> "Fxn:diff.exp().log1p()";
    "class:RelaxedBernoulli(TransformedDistribution):" -> "Fxn:__init__";
    "class:RelaxedBernoulli(TransformedDistribution):" -> "Fxn:temperature";
    "class:RelaxedBernoulli(TransformedDistribution):" -> "Fxn:logits";
    "class:RelaxedBernoulli(TransformedDistribution):" -> "Fxn:probs";
    "Fxn:__init__" -> "Fxn:self).__init__(LogitRelaxedBernoulli(temperature,";
    "Fxn:__init__" -> "Fxn:SigmoidTransform(),";
    "/torch/distributions/relaxed_categorical.py" -> "Import:torch";
    "/torch/distributions/relaxed_categorical.py" -> "Import:Variable";
    "/torch/distributions/relaxed_categorical.py" -> "Import:constraints";
    "/torch/distributions/relaxed_categorical.py" -> "Import:Categorical";
    "/torch/distributions/relaxed_categorical.py" -> "Import:clamp_probs,";
    "/torch/distributions/relaxed_categorical.py" -> "Import:Distribution";
    "/torch/distributions/relaxed_categorical.py" -> "Import:TransformedDistribution";
    "/torch/distributions/relaxed_categorical.py" -> "Import:ExpTransform";
    "/torch/distributions/relaxed_categorical.py" -> "class:ExpRelaxedCategorical(Distribution):";
    "/torch/distributions/relaxed_categorical.py" -> "class:RelaxedOneHotCategorical(TransformedDistribution):";
    "class:ExpRelaxedCategorical(Distribution):" -> "Fxn:__init__";
    "class:ExpRelaxedCategorical(Distribution):" -> "Fxn:_new";
    "class:ExpRelaxedCategorical(Distribution):" -> "Fxn:param_shape";
    "class:ExpRelaxedCategorical(Distribution):" -> "Fxn:logits";
    "class:ExpRelaxedCategorical(Distribution):" -> "Fxn:probs";
    "class:ExpRelaxedCategorical(Distribution):" -> "Fxn:rsample";
    "class:ExpRelaxedCategorical(Distribution):" -> "Fxn:log_prob";
    "Fxn:__init__" -> "Fxn:Categorical(probs,";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:_new" -> "Fxn:self._categorical._new(*args,";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:torch.Size(sample_shape)";
    "Fxn:rsample" -> "Fxn:clamp_probs(self.logits.new(self._extended_shape(sample_shape)).uniform_())";
    "Fxn:rsample" -> "Fxn:-((-(uniforms.log())).log())";
    "Fxn:rsample" -> "Fxn:log_sum_exp(scores)";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:broadcast_all(self.logits,";
    "Fxn:log_prob" -> "Fxn:self.temperature.log().mul(-(K";
    "Fxn:log_prob" -> "Fxn:value.mul(self.temperature)";
    "Fxn:log_prob" -> "Fxn:log_sum_exp(score)).sum(-1)";
    "class:RelaxedOneHotCategorical(TransformedDistribution):" -> "Fxn:__init__";
    "class:RelaxedOneHotCategorical(TransformedDistribution):" -> "Fxn:temperature";
    "class:RelaxedOneHotCategorical(TransformedDistribution):" -> "Fxn:logits";
    "class:RelaxedOneHotCategorical(TransformedDistribution):" -> "Fxn:probs";
    "Fxn:__init__" -> "Fxn:self).__init__(ExpRelaxedCategorical(temperature,";
    "Fxn:__init__" -> "Fxn:ExpTransform(),";
    "/torch/distributions/studentT.py" -> "Import:Number";
    "/torch/distributions/studentT.py" -> "Import:torch";
    "/torch/distributions/studentT.py" -> "Import:math";
    "/torch/distributions/studentT.py" -> "Import:constraints";
    "/torch/distributions/studentT.py" -> "Import:Distribution";
    "/torch/distributions/studentT.py" -> "Import:Chi2";
    "/torch/distributions/studentT.py" -> "Import:broadcast_all";
    "/torch/distributions/studentT.py" -> "class:StudentT(Distribution):";
    "class:StudentT(Distribution):" -> "Fxn:mean";
    "class:StudentT(Distribution):" -> "Fxn:variance";
    "class:StudentT(Distribution):" -> "Fxn:__init__";
    "class:StudentT(Distribution):" -> "Fxn:rsample";
    "class:StudentT(Distribution):" -> "Fxn:log_prob";
    "class:StudentT(Distribution):" -> "Fxn:entropy";
    "Fxn:mean" -> "Fxn:self.loc.clone()";
    "Fxn:variance" -> "Fxn:self.df.clone()";
    "Fxn:variance" -> "Fxn:2].pow(2)";
    "Fxn:variance" -> "Fxn:m[(self.df";
    "Fxn:__init__" -> "Fxn:broadcast_all(df,";
    "Fxn:__init__" -> "Fxn:Chi2(df)";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.df.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:Normal(0,";
    "Fxn:rsample" -> "Fxn:Chi2(df)";
    "Fxn:rsample" -> "Fxn:StudentT(df)";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:self.df.new(shape).normal_()";
    "Fxn:rsample" -> "Fxn:self._chi2.rsample(sample_shape)";
    "Fxn:rsample" -> "Fxn:torch.rsqrt(Z";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:self.df.log()";
    "Fxn:log_prob" -> "Fxn:math.log(math.pi)";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(0.5";
    "Fxn:log_prob" -> "Fxn:torch.lgamma(0.5";
    "Fxn:log_prob" -> "Fxn:torch.log1p(y**2.";
    "Fxn:entropy" -> "Fxn:torch.lgamma(0.5";
    "Fxn:entropy" -> "Fxn:math.lgamma(0.5)";
    "Fxn:entropy" -> "Fxn:torch.lgamma(0.5";
    "Fxn:entropy" -> "Fxn:torch.digamma(0.5";
    "Fxn:entropy" -> "Fxn:self.df.log()";
    "/torch/distributions/transformed_distribution.py" -> "Import:torch";
    "/torch/distributions/transformed_distribution.py" -> "Import:constraints";
    "/torch/distributions/transformed_distribution.py" -> "Import:Distribution";
    "/torch/distributions/transformed_distribution.py" -> "Import:Transform";
    "/torch/distributions/transformed_distribution.py" -> "Import:_sum_rightmost";
    "/torch/distributions/transformed_distribution.py" -> "class:TransformedDistribution(Distribution):";
    "class:TransformedDistribution(Distribution):" -> "Fxn:__init__";
    "class:TransformedDistribution(Distribution):" -> "Fxn:params";
    "class:TransformedDistribution(Distribution):" -> "Fxn:support";
    "class:TransformedDistribution(Distribution):" -> "Fxn:has_rsample";
    "class:TransformedDistribution(Distribution):" -> "Fxn:sample";
    "class:TransformedDistribution(Distribution):" -> "Fxn:rsample";
    "class:TransformedDistribution(Distribution):" -> "Fxn:log_prob";
    "class:TransformedDistribution(Distribution):" -> "Fxn:_monotonize_cdf";
    "class:TransformedDistribution(Distribution):" -> "Fxn:cdf";
    "class:TransformedDistribution(Distribution):" -> "Fxn:icdf";
    "Fxn:__init__" -> "Fxn:ValueError("transforms";
    "Fxn:__init__" -> "Fxn:ValueError("transforms";
    "Fxn:__init__" -> "Fxn:{}".format(transforms))";
    "Fxn:__init__" -> "Fxn:shape[:len(shape)";
    "Fxn:__init__" -> "Fxn:shape[len(shape)";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:sample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:sample" -> "Fxn:`transform()`";
    "Fxn:sample" -> "Fxn:torch.no_grad():";
    "Fxn:sample" -> "Fxn:self.base_dist.sample(sample_shape)";
    "Fxn:sample" -> "Fxn:transform(x)";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:`transform()`";
    "Fxn:rsample" -> "Fxn:self.base_dist.rsample(sample_shape)";
    "Fxn:rsample" -> "Fxn:transform(x)";
    "Fxn:log_prob" -> "Fxn:transform(s)";
    "Fxn:log_prob" -> "Fxn:transform.inv(y)";
    "Fxn:log_prob" -> "Fxn:_sum_rightmost(transform.log_abs_det_jacobian(x,";
    "Fxn:log_prob" -> "Fxn:_sum_rightmost(self.base_dist.log_prob(y),";
    "Fxn:cdf" -> "Fxn:transform(s)";
    "Fxn:cdf" -> "Fxn:transform.inv(value)";
    "Fxn:cdf" -> "Fxn:self.base_dist._validate_sample(value)";
    "Fxn:cdf" -> "Fxn:self.base_dist.cdf(value)";
    "Fxn:cdf" -> "Fxn:self._monotonize_cdf(value)";
    "Fxn:icdf" -> "Fxn:transform(s)";
    "Fxn:icdf" -> "Fxn:self._monotonize_cdf(value)";
    "Fxn:icdf" -> "Fxn:self.base_dist._validate_sample(value)";
    "Fxn:icdf" -> "Fxn:self.base_dist.icdf(value)";
    "Fxn:icdf" -> "Fxn:transform(value)";
    "/torch/distributions/transforms.py" -> "Import:weakref";
    "/torch/distributions/transforms.py" -> "Import:torch";
    "/torch/distributions/transforms.py" -> "Import:Variable";
    "/torch/distributions/transforms.py" -> "Import:constraints";
    "/torch/distributions/transforms.py" -> "Import:(_sum_rightmost,";
    "/torch/distributions/transforms.py" -> "Import:sigmoid";
    "/torch/distributions/transforms.py" -> "class:Transform(object):";
    "/torch/distributions/transforms.py" -> "class:_InverseTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:ComposeTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:ExpTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:SigmoidTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:AbsTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:AffineTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:BoltzmannTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:StickBreakingTransform(Transform):";
    "/torch/distributions/transforms.py" -> "class:LowerCholeskyTransform(Transform):";
    "class:Transform(object):" -> "Fxn:__init__";
    "class:Transform(object):" -> "Fxn:inv";
    "class:Transform(object):" -> "Fxn:sign";
    "class:Transform(object):" -> "Fxn:__eq__";
    "class:Transform(object):" -> "Fxn:__ne__";
    "class:Transform(object):" -> "Fxn:__call__";
    "class:Transform(object):" -> "Fxn:_inv_call";
    "class:Transform(object):" -> "Fxn:_call";
    "class:Transform(object):" -> "Fxn:_inverse";
    "class:Transform(object):" -> "Fxn:log_abs_det_jacobian";
    "Fxn:__init__" -> "Fxn:ValueError('cache_size";
    "Fxn:inv" -> "Fxn:self._inv()";
    "Fxn:inv" -> "Fxn:_InverseTransform(self)";
    "Fxn:inv" -> "Fxn:weakref.ref(inv)";
    "Fxn:__ne__" -> "Fxn:self.__eq__(other)";
    "Fxn:__call__" -> "Fxn:self._call(x)";
    "Fxn:__call__" -> "Fxn:self._call(x)";
    "Fxn:_inv_call" -> "Fxn:self._inverse(y)";
    "Fxn:_inv_call" -> "Fxn:self._inverse(y)";
    "class:_InverseTransform(Transform):" -> "Fxn:__init__";
    "class:_InverseTransform(Transform):" -> "Fxn:domain";
    "class:_InverseTransform(Transform):" -> "Fxn:codomain";
    "class:_InverseTransform(Transform):" -> "Fxn:bijective";
    "class:_InverseTransform(Transform):" -> "Fxn:sign";
    "class:_InverseTransform(Transform):" -> "Fxn:event_dim";
    "class:_InverseTransform(Transform):" -> "Fxn:inv";
    "class:_InverseTransform(Transform):" -> "Fxn:__eq__";
    "class:_InverseTransform(Transform):" -> "Fxn:__call__";
    "class:_InverseTransform(Transform):" -> "Fxn:log_abs_det_jacobian";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__call__" -> "Fxn:self._inv._inv_call(x)";
    "Fxn:log_abs_det_jacobian" -> "Fxn:-self._inv.log_abs_det_jacobian(y,";
    "class:ComposeTransform(Transform):" -> "Fxn:__init__";
    "class:ComposeTransform(Transform):" -> "Fxn:__eq__";
    "class:ComposeTransform(Transform):" -> "Fxn:domain";
    "class:ComposeTransform(Transform):" -> "Fxn:codomain";
    "class:ComposeTransform(Transform):" -> "Fxn:bijective";
    "class:ComposeTransform(Transform):" -> "Fxn:sign";
    "class:ComposeTransform(Transform):" -> "Fxn:event_dim";
    "class:ComposeTransform(Transform):" -> "Fxn:inv";
    "class:ComposeTransform(Transform):" -> "Fxn:__call__";
    "class:ComposeTransform(Transform):" -> "Fxn:log_abs_det_jacobian";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:inv" -> "Fxn:self._inv()";
    "Fxn:inv" -> "Fxn:ComposeTransform([p.inv";
    "Fxn:inv" -> "Fxn:weakref.ref(inv)";
    "Fxn:inv" -> "Fxn:weakref.ref(self)";
    "Fxn:__call__" -> "Fxn:part(x)";
    "Fxn:log_abs_det_jacobian" -> "Fxn:x.new([0]).expand_as(x)";
    "Fxn:log_abs_det_jacobian" -> "Fxn:part(x)";
    "Fxn:log_abs_det_jacobian" -> "Fxn:_sum_rightmost(part.log_abs_det_jacobian(x,";
    "Fxn:log_abs_det_jacobian" -> "Fxn:ComposeTransform([])";
    "class:ExpTransform(Transform):" -> "Fxn:__eq__";
    "class:ExpTransform(Transform):" -> "Fxn:_call";
    "class:ExpTransform(Transform):" -> "Fxn:_inverse";
    "class:ExpTransform(Transform):" -> "Fxn:log_abs_det_jacobian";
    "Fxn:_call" -> "Fxn:x.exp()";
    "Fxn:_inverse" -> "Fxn:y.log()";
    "class:SigmoidTransform(Transform):" -> "Fxn:__eq__";
    "class:SigmoidTransform(Transform):" -> "Fxn:_call";
    "class:SigmoidTransform(Transform):" -> "Fxn:_inverse";
    "class:SigmoidTransform(Transform):" -> "Fxn:log_abs_det_jacobian";
    "Fxn:_call" -> "Fxn:sigmoid(x)";
    "Fxn:_inverse" -> "Fxn:y.log()";
    "Fxn:log_abs_det_jacobian" -> "Fxn:-(y.reciprocal()";
    "Fxn:log_abs_det_jacobian" -> "Fxn:y).reciprocal()).log()";
    "class:AbsTransform(Transform):" -> "Fxn:__eq__";
    "class:AbsTransform(Transform):" -> "Fxn:_call";
    "class:AbsTransform(Transform):" -> "Fxn:_inverse";
    "Fxn:_call" -> "Fxn:x.abs()";
    "class:AffineTransform(Transform):" -> "Fxn:__init__";
    "class:AffineTransform(Transform):" -> "Fxn:__eq__";
    "class:AffineTransform(Transform):" -> "Fxn:sign";
    "class:AffineTransform(Transform):" -> "Fxn:_call";
    "class:AffineTransform(Transform):" -> "Fxn:_inverse";
    "class:AffineTransform(Transform):" -> "Fxn:log_abs_det_jacobian";
    "Fxn:__init__" -> "Fxn:self).__init__(cache_size=cache_size)";
    "Fxn:__init__" -> "Fxn:broadcast_all(loc,";
    "Fxn:__eq__" -> "Fxn:self.loc.eq(other.loc).all()";
    "Fxn:__eq__" -> "Fxn:self.scale.eq(other.scale).all()";
    "Fxn:__eq__" -> "Fxn:result.data.view(-1)[0]";
    "Fxn:sign" -> "Fxn:self.scale.sign()";
    "Fxn:log_abs_det_jacobian" -> "Fxn:torch.abs(self.scale).log()";
    "Fxn:log_abs_det_jacobian" -> "Fxn:result.size()[:-self.event_dim]";
    "Fxn:log_abs_det_jacobian" -> "Fxn:result.view(result_size).sum(-1)";
    "Fxn:log_abs_det_jacobian" -> "Fxn:result.expand(shape)";
    "class:BoltzmannTransform(Transform):" -> "Fxn:__eq__";
    "class:BoltzmannTransform(Transform):" -> "Fxn:_call";
    "class:BoltzmannTransform(Transform):" -> "Fxn:_inverse";
    "Fxn:_call" -> "Fxn:logprobs.max(-1,";
    "Fxn:_call" -> "Fxn:True)[0]).exp()";
    "Fxn:_call" -> "Fxn:probs.sum(-1,";
    "Fxn:_inverse" -> "Fxn:probs.log()";
    "class:StickBreakingTransform(Transform):" -> "Fxn:__eq__";
    "class:StickBreakingTransform(Transform):" -> "Fxn:_call";
    "class:StickBreakingTransform(Transform):" -> "Fxn:_inverse";
    "Fxn:_call" -> "Fxn:x.new([1]).expand(x.shape[:-1]";
    "Fxn:_call" -> "Fxn:sigmoid(x)";
    "Fxn:_call" -> "Fxn:numer).cumprod(-1)";
    "Fxn:_call" -> "Fxn:torch.cat([numer,";
    "Fxn:_call" -> "Fxn:torch.cat([one,";
    "Fxn:_inverse" -> "Fxn:pmf.cumsum(-1)";
    "Fxn:_inverse" -> "Fxn:units.log()";
    "Fxn:_inverse" -> "Fxn:.log_abs_det_jacobian()";
    "class:LowerCholeskyTransform(Transform):" -> "Fxn:__eq__";
    "class:LowerCholeskyTransform(Transform):" -> "Fxn:_call";
    "class:LowerCholeskyTransform(Transform):" -> "Fxn:_inverse";
    "Fxn:_call" -> "Fxn:x.dim()";
    "Fxn:_call" -> "Fxn:x.tril(-1)";
    "Fxn:_call" -> "Fxn:x.diag().exp().diag()";
    "Fxn:_inverse" -> "Fxn:y.dim()";
    "Fxn:_inverse" -> "Fxn:y.tril(-1)";
    "Fxn:_inverse" -> "Fxn:y.diag().log().diag()";
    "/torch/distributions/uniform.py" -> "Import:math";
    "/torch/distributions/uniform.py" -> "Import:Number";
    "/torch/distributions/uniform.py" -> "Import:torch";
    "/torch/distributions/uniform.py" -> "Import:Variable";
    "/torch/distributions/uniform.py" -> "Import:constraints";
    "/torch/distributions/uniform.py" -> "Import:Distribution";
    "/torch/distributions/uniform.py" -> "Import:broadcast_all";
    "/torch/distributions/uniform.py" -> "class:Uniform(Distribution):";
    "class:Uniform(Distribution):" -> "Fxn:mean";
    "class:Uniform(Distribution):" -> "Fxn:stddev";
    "class:Uniform(Distribution):" -> "Fxn:variance";
    "class:Uniform(Distribution):" -> "Fxn:__init__";
    "class:Uniform(Distribution):" -> "Fxn:support";
    "class:Uniform(Distribution):" -> "Fxn:rsample";
    "class:Uniform(Distribution):" -> "Fxn:log_prob";
    "class:Uniform(Distribution):" -> "Fxn:cdf";
    "class:Uniform(Distribution):" -> "Fxn:icdf";
    "class:Uniform(Distribution):" -> "Fxn:entropy";
    "Fxn:variance" -> "Fxn:self.low).pow(2)";
    "Fxn:__init__" -> "Fxn:broadcast_all(low,";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self.low.size()";
    "Fxn:__init__" -> "Fxn:self).__init__(batch_shape,";
    "Fxn:__init__" -> "Fxn:torch.lt(self.low,";
    "Fxn:__init__" -> "Fxn:self.high).all():";
    "Fxn:__init__" -> "Fxn:ValueError("Uniform";
    "Fxn:support" -> "Fxn:constraints.interval(self.low,";
    "Fxn:rsample" -> "Fxn:sample_shape=torch.Size()):";
    "Fxn:rsample" -> "Fxn:self._extended_shape(sample_shape)";
    "Fxn:rsample" -> "Fxn:self.low.new(shape).uniform_()";
    "Fxn:log_prob" -> "Fxn:self._validate_sample(value)";
    "Fxn:log_prob" -> "Fxn:value.ge(self.low).type_as(self.low)";
    "Fxn:log_prob" -> "Fxn:value.lt(self.high).type_as(self.low)";
    "Fxn:log_prob" -> "Fxn:torch.log(lb.mul(ub))";
    "Fxn:log_prob" -> "Fxn:torch.log(self.high";
    "Fxn:cdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:icdf" -> "Fxn:self._validate_sample(value)";
    "Fxn:entropy" -> "Fxn:torch.log(self.high";
    "/torch/distributions/utils.py" -> "Import:namedtuple";
    "/torch/distributions/utils.py" -> "Import:update_wrapper";
    "/torch/distributions/utils.py" -> "Import:Number";
    "/torch/distributions/utils.py" -> "Import:math";
    "/torch/distributions/utils.py" -> "Import:torch";
    "/torch/distributions/utils.py" -> "Import:torch.nn.functional";
    "/torch/distributions/utils.py" -> "Import:Variable";
    "/torch/distributions/utils.py" -> "Fxn:_finfo";
    "/torch/distributions/utils.py" -> "Fxn:expand_n";
    "/torch/distributions/utils.py" -> "Fxn:_broadcast_shape";
    "/torch/distributions/utils.py" -> "Fxn:broadcast_all";
    "/torch/distributions/utils.py" -> "Fxn:_sum_rightmost";
    "/torch/distributions/utils.py" -> "Fxn:softmax";
    "/torch/distributions/utils.py" -> "Fxn:log_sum_exp";
    "/torch/distributions/utils.py" -> "Fxn:logits_to_probs";
    "/torch/distributions/utils.py" -> "Fxn:clamp_probs";
    "/torch/distributions/utils.py" -> "Fxn:probs_to_logits";
    "/torch/distributions/utils.py" -> "class:lazy_property(object):";
    "class:lazy_property(object):" -> "Fxn:__init__";
    "class:lazy_property(object):" -> "Fxn:__get__";
    "Fxn:__init__" -> "Fxn:update_wrapper(self,";
    "Fxn:__get__" -> "Fxn:self.wrapped(instance)";
    "/torch/distributions/__init__.py" -> "Import:Bernoulli";
    "/torch/distributions/__init__.py" -> "Import:Beta";
    "/torch/distributions/__init__.py" -> "Import:.binomial";
    "/torch/distributions/__init__.py" -> "Import:Binomial";
    "/torch/distributions/__init__.py" -> "Import:Categorical";
    "/torch/distributions/__init__.py" -> "Import:Cauchy";
    "/torch/distributions/__init__.py" -> "Import:Chi2";
    "/torch/distributions/__init__.py" -> "Import:biject_to,";
    "/torch/distributions/__init__.py" -> "Import:Dirichlet";
    "/torch/distributions/__init__.py" -> "Import:Distribution";
    "/torch/distributions/__init__.py" -> "Import:Exponential";
    "/torch/distributions/__init__.py" -> "Import:ExponentialFamily";
    "/torch/distributions/__init__.py" -> "Import:FisherSnedecor";
    "/torch/distributions/__init__.py" -> "Import:Gamma";
    "/torch/distributions/__init__.py" -> "Import:Geometric";
    "/torch/distributions/__init__.py" -> "Import:Gumbel";
    "/torch/distributions/__init__.py" -> "Import:kl_divergence,";
    "/torch/distributions/__init__.py" -> "Import:Laplace";
    "/torch/distributions/__init__.py" -> "Import:LogNormal";
    "/torch/distributions/__init__.py" -> "Import:Multinomial";
    "/torch/distributions/__init__.py" -> "Import:Normal";
    "/torch/distributions/__init__.py" -> "Import:OneHotCategorical";
    "/torch/distributions/__init__.py" -> "Import:Pareto";
    "/torch/distributions/__init__.py" -> "Import:Poisson";
    "/torch/distributions/__init__.py" -> "Import:RelaxedBernoulli";
    "/torch/distributions/__init__.py" -> "Import:RelaxedOneHotCategorical";
    "/torch/distributions/__init__.py" -> "Import:StudentT";
    "/torch/distributions/__init__.py" -> "Import:TransformedDistribution";
    "/torch/distributions/__init__.py" -> "Import:Uniform";
    "/torch/jit/frontend.py" -> "Import:torch";
    "/torch/jit/frontend.py" -> "Import:sys";
    "/torch/jit/frontend.py" -> "Import:ast";
    "/torch/jit/frontend.py" -> "Import:inspect";
    "/torch/jit/frontend.py" -> "Import:string";
    "/torch/jit/frontend.py" -> "Import:dedent";
    "/torch/jit/frontend.py" -> "Import:partial";
    "/torch/jit/frontend.py" -> "Import:namedtuple";
    "/torch/jit/frontend.py" -> "Import:PY2";
    "/torch/jit/frontend.py" -> "Fxn:is_reserved_name";
    "/torch/jit/frontend.py" -> "class:FrontendError(Exception):";
    "/torch/jit/frontend.py" -> "class:NotSupportedError(FrontendError):";
    "/torch/jit/frontend.py" -> "class:UnsupportedNodeError(NotSupportedError):";
    "/torch/jit/frontend.py" -> "class:FrontendTypeError(FrontendError):";
    "/torch/jit/frontend.py" -> "class:Builder(object):";
    "/torch/jit/frontend.py" -> "class:StmtBuilder(Builder):";
    "/torch/jit/frontend.py" -> "class:ExprBuilder(Builder):";
    "class:FrontendError(Exception):" -> "Fxn:__init__";
    "class:FrontendError(Exception):" -> "Fxn:__str__";
    "Fxn:__str__" -> "Fxn:self.source_range.highlight()";
    "class:UnsupportedNodeError(NotSupportedError):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:ctx.make_range(offending_node.lineno,";
    "Fxn:__init__" -> "Fxn:pretty_node_names.get(node_type,";
    "Fxn:__init__" -> "Fxn:supported".format(feature_name)";
    "Fxn:__init__" -> "Fxn:self).__init__(source_range,";
    "class:FrontendTypeError(FrontendError):" -> "Fxn:get_jit_ast";
    "Fxn:get_jit_ast" -> "Fxn:dedent(inspect.getsource(fn))";
    "Fxn:get_jit_ast" -> "Fxn:ast.parse(source)";
    "Fxn:get_jit_ast" -> "Fxn:RuntimeError("expected";
    "Fxn:get_jit_ast" -> "Fxn:build_def(SourceRangeFactory(source),";
    "class:Builder(object):" -> "Fxn:__call__";
    "class:Builder(object):" -> "Fxn:build_def";
    "class:Builder(object):" -> "Fxn:build_param_list";
    "class:Builder(object):" -> "Fxn:build_param";
    "Fxn:__call__" -> "Fxn:UnsupportedNodeError(ctx,";
    "Fxn:__call__" -> "Fxn:method(ctx,";
    "Fxn:build_def" -> "Fxn:ctx.make_range(py_def.lineno,";
    "Fxn:build_def" -> "Fxn:Def(Ident(r,";
    "Fxn:build_def" -> "Fxn:build_param_list(ctx,";
    "Fxn:build_def" -> "Fxn:[build_stmt(ctx,";
    "Fxn:build_param_list" -> "Fxn:ValueError(_vararg_kwarg_err)";
    "Fxn:build_param_list" -> "Fxn:ValueError(_vararg_kwarg_err)";
    "Fxn:build_param_list" -> "Fxn:[build_param(ctx,";
    "Fxn:build_param" -> "Fxn:ValueError("Compiled";
    "Fxn:build_param" -> "Fxn:ctx.make_range(py_arg.lineno,";
    "Fxn:build_param" -> "Fxn:Param(TensorType(r),";
    "Fxn:build_param" -> "Fxn:Ident(r,";
    "class:StmtBuilder(Builder):" -> "Fxn:build_Expr";
    "class:StmtBuilder(Builder):" -> "Fxn:get_assign_ident";
    "class:StmtBuilder(Builder):" -> "Fxn:build_Assign";
    "class:StmtBuilder(Builder):" -> "Fxn:build_Return";
    "class:StmtBuilder(Builder):" -> "Fxn:build_AugAssign";
    "class:StmtBuilder(Builder):" -> "Fxn:build_While";
    "class:StmtBuilder(Builder):" -> "Fxn:build_If";
    "class:StmtBuilder(Builder):" -> "Fxn:build_Print";
    "Fxn:build_Expr" -> "Fxn:ExprStmt(build_expr(ctx,";
    "Fxn:get_assign_ident" -> "Fxn:build_expr(ctx,";
    "Fxn:get_assign_ident" -> "Fxn:NotSupportedError(var.range(),";
    "Fxn:build_Assign" -> "Fxn:build_expr(ctx,";
    "Fxn:build_Assign" -> "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:build_Assign" -> "Fxn:NotSupportedError(ctx.make_raw_range(start_point.start,";
    "Fxn:build_Assign" -> "Fxn:rhs.range().end),";
    "Fxn:build_Assign" -> "Fxn:Assign([StmtBuilder.get_assign_ident(ctx,";
    "Fxn:build_Return" -> "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:build_Return" -> "Fxn:Return(r,";
    "Fxn:build_Return" -> "Fxn:[build_expr(ctx,";
    "Fxn:build_AugAssign" -> "Fxn:[StmtBuilder.get_assign_ident(ctx,";
    "Fxn:build_AugAssign" -> "Fxn:build_expr(ctx,";
    "Fxn:build_AugAssign" -> "Fxn:NotSupportedError(";
    "Fxn:build_AugAssign" -> "Fxn:find_before(ctx,";
    "Fxn:build_AugAssign" -> "Fxn:rhs.range().start,";
    "Fxn:build_AugAssign" -> "Fxn:offsets=(-1,";
    "Fxn:build_AugAssign" -> "Fxn:Assign(lhs,";
    "Fxn:build_While" -> "Fxn:NotSupportedError(None,";
    "Fxn:build_While" -> "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:build_While" -> "Fxn:While(r,";
    "Fxn:build_While" -> "Fxn:build_expr(ctx,";
    "Fxn:build_While" -> "Fxn:[build_stmt(ctx,";
    "Fxn:build_If" -> "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:build_If" -> "Fxn:If(r,";
    "Fxn:build_If" -> "Fxn:build_expr(ctx,";
    "Fxn:build_If" -> "Fxn:[build_stmt(ctx,";
    "Fxn:build_If" -> "Fxn:[build_stmt(ctx,";
    "Fxn:build_Print" -> "Fxn:ctx.make_range(stmt.lineno,";
    "Fxn:build_Print" -> "Fxn:NotSupportedError(r,";
    "Fxn:build_Print" -> "Fxn:[build_expr(ctx,";
    "Fxn:build_Print" -> "Fxn:ExprStmt(Apply(Var(Ident(r,";
    "class:ExprBuilder(Builder):" -> "Fxn:build_Attribute";
    "class:ExprBuilder(Builder):" -> "Fxn:build_Call";
    "class:ExprBuilder(Builder):" -> "Fxn:build_Name";
    "class:ExprBuilder(Builder):" -> "Fxn:build_BinOp";
    "class:ExprBuilder(Builder):" -> "Fxn:build_UnaryOp";
    "class:ExprBuilder(Builder):" -> "Fxn:build_BoolOp";
    "class:ExprBuilder(Builder):" -> "Fxn:build_IfExp";
    "class:ExprBuilder(Builder):" -> "Fxn:build_Compare";
    "class:ExprBuilder(Builder):" -> "Fxn:build_Num";
    "class:ExprBuilder(Builder):" -> "Fxn:find_after";
    "class:ExprBuilder(Builder):" -> "Fxn:find_before";
    "Fxn:build_Attribute" -> "Fxn:build_expr(ctx,";
    "Fxn:build_Attribute" -> "Fxn:find_after(ctx,";
    "Fxn:build_Attribute" -> "Fxn:value.range().end,";
    "Fxn:build_Attribute" -> "Fxn:ctx.make_raw_range(start_pos,";
    "Fxn:build_Attribute" -> "Fxn:Select(value,";
    "Fxn:build_Attribute" -> "Fxn:Ident(name_range,";
    "Fxn:build_Call" -> "Fxn:build_expr(ctx,";
    "Fxn:build_Call" -> "Fxn:[build_expr(ctx,";
    "Fxn:build_Call" -> "Fxn:build_expr(ctx,";
    "Fxn:build_Call" -> "Fxn:kwargs.append(Attribute(Ident(kw_expr.range(),";
    "Fxn:build_Call" -> "Fxn:Apply(func,";
    "Fxn:build_Name" -> "Fxn:ctx.make_range(expr.lineno,";
    "Fxn:build_Name" -> "Fxn:expr.id.startswith(_reserved_prefix):";
    "Fxn:build_Name" -> "Fxn:NotSupportedError(r,";
    "Fxn:build_Name" -> "Fxn:Var(Ident(r,";
    "Fxn:build_BinOp" -> "Fxn:build_expr(ctx,";
    "Fxn:build_BinOp" -> "Fxn:build_expr(ctx,";
    "Fxn:build_BinOp" -> "Fxn:ExprBuilder.binop_map.get(op)";
    "Fxn:build_BinOp" -> "Fxn:ctx.make_range(lhs.range().end,";
    "Fxn:build_BinOp" -> "Fxn:rhs.range().start)";
    "Fxn:build_BinOp" -> "Fxn:NotSupportedError(err_range,";
    "Fxn:build_BinOp" -> "Fxn:BinOp(op_token,";
    "Fxn:build_UnaryOp" -> "Fxn:build_expr(ctx,";
    "Fxn:build_UnaryOp" -> "Fxn:ExprBuilder.unop_map.get(op)";
    "Fxn:build_UnaryOp" -> "Fxn:ctx.make_range(expr.lineno,";
    "Fxn:build_UnaryOp" -> "Fxn:ctx.make_raw_range(r.start,";
    "Fxn:build_UnaryOp" -> "Fxn:sub_expr.range().end)";
    "Fxn:build_UnaryOp" -> "Fxn:NotSupportedError(err_range,";
    "Fxn:build_UnaryOp" -> "Fxn:UnaryOp(r,";
    "Fxn:build_BoolOp" -> "Fxn:AssertionError("expected";
    "Fxn:build_BoolOp" -> "Fxn:[build_expr(ctx,";
    "Fxn:build_BoolOp" -> "Fxn:ExprBuilder.boolop_map.get(op)";
    "Fxn:build_BoolOp" -> "Fxn:ctx.make_raw_range(sub_exprs[0].range().end,";
    "Fxn:build_BoolOp" -> "Fxn:sub_exprs[1].range().start)";
    "Fxn:build_BoolOp" -> "Fxn:NotSupportedError(err_range,";
    "Fxn:build_BoolOp" -> "Fxn:BinOp(op_token,";
    "Fxn:build_IfExp" -> "Fxn:TernaryIf(build_expr(ctx,";
    "Fxn:build_IfExp" -> "Fxn:build_expr(ctx,";
    "Fxn:build_IfExp" -> "Fxn:build_expr(ctx,";
    "Fxn:build_Compare" -> "Fxn:[build_expr(ctx,";
    "Fxn:build_Compare" -> "Fxn:ExprBuilder.cmpop_map.get(op)";
    "Fxn:build_Compare" -> "Fxn:ctx.make_raw_range(lhs.range().end,";
    "Fxn:build_Compare" -> "Fxn:rhs.range().start)";
    "Fxn:build_Compare" -> "Fxn:NotSupportedError(err_range,";
    "Fxn:build_Compare" -> "Fxn:BinOp(op_token,";
    "Fxn:build_Compare" -> "Fxn:BinOp('and',";
    "Fxn:build_Num" -> "Fxn:ctx.make_range(expr.lineno,";
    "Fxn:build_Num" -> "Fxn:NotSupportedError(err_range,";
    "Fxn:build_Num" -> "Fxn:ExprBuilder()";
    "Fxn:build_Num" -> "Fxn:StmtBuilder()";
    "Fxn:find_after" -> "Fxn:offsets=(0,";
    "Fxn:find_after" -> "Fxn:ctx.source[pos:].index(substr)";
    "Fxn:find_after" -> "Fxn:ctx.make_raw_range(new_pos";
    "Fxn:find_before" -> "Fxn:offsets=(0,";
    "Fxn:find_before" -> "Fxn:ctx.source[:pos].rindex(substr)";
    "Fxn:find_before" -> "Fxn:ctx.make_raw_range(new_pos";
    "/torch/jit/__init__.py" -> "Import:torch._C";
    "/torch/jit/__init__.py" -> "Import:Tensor";
    "/torch/jit/__init__.py" -> "Import:Variable,";
    "/torch/jit/__init__.py" -> "Import:Module,";
    "/torch/jit/__init__.py" -> "Import:get_jit_ast";
    "/torch/jit/__init__.py" -> "Import:raise_from,";
    "/torch/jit/__init__.py" -> "Import:defaultdict,";
    "/torch/jit/__init__.py" -> "Import:sys";
    "/torch/jit/__init__.py" -> "Import:warnings";
    "/torch/jit/__init__.py" -> "Import:itertools";
    "/torch/jit/__init__.py" -> "Import:weakref";
    "/torch/jit/__init__.py" -> "Import:types";
    "/torch/jit/__init__.py" -> "Import:contextlib";
    "/torch/jit/__init__.py" -> "Import:import";
    "/torch/jit/__init__.py" -> "Import:functools";
    "/torch/jit/__init__.py" -> "Import:inspect";
    "/torch/jit/__init__.py" -> "Import:copy";
    "/torch/jit/__init__.py" -> "Fxn:get_tracing_state";
    "/torch/jit/__init__.py" -> "Fxn:scope";
    "/torch/jit/__init__.py" -> "Fxn:compile";
    "/torch/jit/__init__.py" -> "class:MyModel(nn.Module):";
    "/torch/jit/__init__.py" -> "class:MyModel(nn.Module):";
    "/torch/jit/__init__.py" -> "class:Foo(Module):";
    "/torch/jit/__init__.py" -> "class:(unrelated";
    "/torch/jit/__init__.py" -> "class:LegacyTracedModule(Module):";
    "/torch/jit/__init__.py" -> "Import:torch.contrib._graph_vis";
    "/torch/jit/__init__.py" -> "class:TracedModuleBase(torch.nn.Module):";
    "/torch/jit/__init__.py" -> "class:TracedSubmodule(TracedModuleBase):";
    "/torch/jit/__init__.py" -> "class:TracedModule(TracedModuleBase):";
    "/torch/jit/__init__.py" -> "Import:inspect";
    "/torch/jit/__init__.py" -> "class:CompilationUnit(object):";
    "/torch/jit/__init__.py" -> "class:ScriptMeta(type(torch._C.ScriptModule)):";
    "/torch/jit/__init__.py" -> "class:ScriptModule(with_metaclass(ScriptMeta,";
    "class:MyModel(nn.Module):" -> "Fxn:f";
    "class:MyModel(nn.Module):" -> "Fxn:_compile";
    "Fxn:_compile" -> "Fxn:inspect.isclass(arg):";
    "class:Foo(Module):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "class:(unrelated" -> "Fxn:__init__";
    "class:(unrelated" -> "Fxn:get_trace_graph";
    "class:(unrelated" -> "Fxn:_unique_state_dict";
    "Fxn:__init__" -> "Fxn:torch._C.CompiledFunction.__init__(self,";
    "Fxn:__init__" -> "Fxn:old_init(self,";
    "Fxn:get_trace_graph" -> "Fxn:args=tuple(),";
    "Fxn:get_trace_graph" -> "Fxn:`backward()`";
    "Fxn:get_trace_graph" -> "Fxn:jit.trace(nn.LSTMCell(),";
    "Fxn:get_trace_graph" -> "Fxn:jit.trace(nn.LSTMCell(),";
    "Fxn:get_trace_graph" -> "Fxn:out.sum().backward()";
    "Fxn:get_trace_graph" -> "Fxn:LegacyTracedModule(f,";
    "Fxn:get_trace_graph" -> "Fxn:nderivs=nderivs)(*args,";
    "Fxn:_unique_state_dict" -> "Fxn:module.state_dict(keep_vars=keep_vars)";
    "Fxn:_unique_state_dict" -> "Fxn:state_dict.items():";
    "Fxn:_unique_state_dict" -> "Fxn:seen_ids.add(id(v))";
    "class:LegacyTracedModule(Module):" -> "Fxn:__init__";
    "class:LegacyTracedModule(Module):" -> "Fxn:forward";
    "class:LegacyTracedModule(Module):" -> "Fxn:_clone_inputs";
    "class:LegacyTracedModule(Module):" -> "Fxn:clone_input";
    "class:LegacyTracedModule(Module):" -> "Fxn:_dump_trace";
    "class:LegacyTracedModule(Module):" -> "Fxn:_time";
    "class:LegacyTracedModule(Module):" -> "Fxn:verify";
    "class:LegacyTracedModule(Module):" -> "Fxn:run_fwd_bwd";
    "class:LegacyTracedModule(Module):" -> "Fxn:_verify_equal";
    "class:LegacyTracedModule(Module):" -> "Fxn:trace";
    "class:LegacyTracedModule(Module):" -> "Fxn:f";
    "class:LegacyTracedModule(Module):" -> "Fxn:wrapper";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:_flatten(args)";
    "Fxn:forward" -> "Fxn:keep_vars=True).values())";
    "Fxn:forward" -> "Fxn:torch._C._tracer_enter(in_vars";
    "Fxn:forward" -> "Fxn:_unflatten(all_trace_inputs[:len(in_vars)],";
    "Fxn:forward" -> "Fxn:self.inner(*trace_inputs)";
    "Fxn:forward" -> "Fxn:_flatten(out)";
    "Fxn:forward" -> "Fxn:torch._C._tracer_exit(out_vars)";
    "Fxn:clone_input" -> "Fxn:Variable(a.data.clone(),";
    "Fxn:clone_input" -> "Fxn:clone_input(v.grad)";
    "Fxn:clone_input" -> "Fxn:a.clone()";
    "Fxn:clone_input" -> "Fxn:function._nested_map(lambda";
    "Fxn:clone_input" -> "Fxn:torch.is_tensor(o),";
    "Fxn:clone_input" -> "Fxn:condition_msg="Variables")(args)";
    "Fxn:clone_input" -> "Fxn:os.environ.get('PYTORCH_JIT_DUMP',";
    "Fxn:clone_input" -> "Fxn:os.environ.get('PYTORCH_JIT_TIME',";
    "Fxn:clone_input" -> "Fxn:os.environ.get('PYTORCH_JIT_DISABLE',";
    "Fxn:clone_input" -> "Fxn:os.environ.get('PYTORCH_JIT_STATS',";
    "Fxn:_dump_trace" -> "Fxn:"{}_{}".format(trace_name,";
    "Fxn:_dump_trace" -> "Fxn:f.write("Input";
    "Fxn:_dump_trace" -> "Fxn:{}\n\n{}".format(input_key,";
    "Fxn:_dump_trace" -> "Fxn:graph_vis.write(trace.graph(),";
    "Fxn:_time" -> "Fxn:torch.cuda.is_available():";
    "Fxn:_time" -> "Fxn:torch.cuda.current_stream()";
    "Fxn:_time" -> "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:_time" -> "Fxn:torch.cuda.Event(enable_timing=True)";
    "Fxn:_time" -> "Fxn:stream.record_event(start)";
    "Fxn:_time" -> "Fxn:stream.record_event(end)";
    "Fxn:_time" -> "Fxn:end.synchronize()";
    "Fxn:_time" -> "Fxn:ms".format(trace_name,";
    "Fxn:_time" -> "Fxn:start.elapsed_time(end)))";
    "Fxn:verify" -> "Fxn:TypeError("Cannot";
    "Fxn:verify" -> "Fxn:_clone_inputs(args)";
    "Fxn:verify" -> "Fxn:copy.deepcopy(model.state_dict())";
    "Fxn:run_fwd_bwd" -> "Fxn:_flatten((args,";
    "Fxn:run_fwd_bwd" -> "Fxn:compiled_fn.clear_cache()";
    "Fxn:run_fwd_bwd" -> "Fxn:model(*args)";
    "Fxn:run_fwd_bwd" -> "Fxn:RuntimeError("failed";
    "Fxn:run_fwd_bwd" -> "Fxn:ValueError(("Model";
    "Fxn:run_fwd_bwd" -> "Fxn:"(torch.sum)";
    "Fxn:run_fwd_bwd" -> "Fxn:output").format(len(out)))";
    "Fxn:run_fwd_bwd" -> "Fxn:_flatten(out)";
    "Fxn:run_fwd_bwd" -> "Fxn:[v.data.clone()";
    "Fxn:run_fwd_bwd" -> "Fxn:loss_fn(*out)";
    "Fxn:run_fwd_bwd" -> "Fxn:torch.autograd.grad([loss],";
    "Fxn:run_fwd_bwd" -> "Fxn:[v.data.clone()";
    "Fxn:run_fwd_bwd" -> "Fxn:torch.random.fork_rng(devices,";
    "Fxn:run_fwd_bwd" -> "Fxn:run_fwd_bwd(args,";
    "Fxn:run_fwd_bwd" -> "Fxn:model.has_trace_for(*args)";
    "Fxn:run_fwd_bwd" -> "Fxn:model.load_state_dict(saved_state)";
    "Fxn:run_fwd_bwd" -> "Fxn:run_fwd_bwd(args,";
    "Fxn:run_fwd_bwd" -> "Fxn:_verify_equal(uncompiled_outs,";
    "Fxn:run_fwd_bwd" -> "Fxn:_verify_equal(uncompiled_grads,";
    "Fxn:_verify_equal" -> "Fxn:x.sub(y).abs().max()";
    "Fxn:_verify_equal" -> "Fxn:RuntimeError("JIT";
    "Fxn:trace" -> "Fxn:@jit.trace(torch.autograd.Variable(torch.rand(1)))";
    "Fxn:wrapper" -> "Fxn:kwargs.pop(name,";
    "Fxn:wrapper" -> "Fxn:ValueError("TracedModules";
    "Fxn:wrapper" -> "Fxn:torch._C.GraphExecutor(func,";
    "Fxn:wrapper" -> "Fxn:TracedModule(func,";
    "Fxn:wrapper" -> "Fxn:torch._C.GraphExecutor(func,";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:__init__";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:_freeze";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:__setattr__";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:__delattr__";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:__getstate__";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:_recompute_captures";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:register_parameter";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:load_state_dict";
    "class:TracedModuleBase(torch.nn.Module):" -> "Fxn:_get_name";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:orig._parameters.items():";
    "Fxn:__init__" -> "Fxn:orig._buffers.items():";
    "Fxn:__init__" -> "Fxn:ValueError("Modules";
    "Fxn:__setattr__" -> "Fxn:self).__setattr__(name,";
    "Fxn:__setattr__" -> "Fxn:self).__setattr__(name,";
    "Fxn:__setattr__" -> "Fxn:self._recompute_captures()";
    "Fxn:__setattr__" -> "Fxn:RuntimeError("Only";
    "Fxn:__delattr__" -> "Fxn:RuntimeError("Deleting";
    "Fxn:__getstate__" -> "Fxn:RuntimeError("TracedModules";
    "Fxn:_recompute_captures" -> "Fxn:NotImplementedError()";
    "Fxn:register_parameter" -> "Fxn:RuntimeError("Can't";
    "Fxn:register_parameter" -> "Fxn:RuntimeError("Can't";
    "Fxn:register_parameter" -> "Fxn:self).register_parameter(name,";
    "Fxn:load_state_dict" -> "Fxn:self).load_state_dict(state)";
    "Fxn:load_state_dict" -> "Fxn:self._recompute_captures()";
    "class:TracedSubmodule(TracedModuleBase):" -> "Fxn:__init__";
    "class:TracedSubmodule(TracedModuleBase):" -> "Fxn:_recompute_captures";
    "class:TracedSubmodule(TracedModuleBase):" -> "Fxn:__call__";
    "Fxn:__init__" -> "Fxn:self).__init__(orig)";
    "Fxn:__init__" -> "Fxn:orig._modules.items():";
    "Fxn:__init__" -> "Fxn:TracedSubmodule(submodule,";
    "Fxn:__init__" -> "Fxn:weakref.ref(root)";
    "Fxn:__init__" -> "Fxn:self._freeze()";
    "Fxn:_recompute_captures" -> "Fxn:self._root()";
    "Fxn:_recompute_captures" -> "Fxn:RuntimeError("Submodules";
    "Fxn:_recompute_captures" -> "Fxn:root._recompute_captures()";
    "Fxn:__call__" -> "Fxn:RuntimeError("Only";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:__init__";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:__call__";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:_recompute_captures";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:_apply";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:_get_methods";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:_make_fail";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:fail";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:createResolutionCallback";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:bar";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:baz";
    "class:TracedModule(TracedModuleBase):" -> "Fxn:env";
    "Fxn:__init__" -> "Fxn:self).__init__(orig)";
    "Fxn:__init__" -> "Fxn:orig._modules.items():";
    "Fxn:__init__" -> "Fxn:TracedSubmodule(submodule,";
    "Fxn:__init__" -> "Fxn:self._recompute_captures()";
    "Fxn:__init__" -> "Fxn:self._freeze()";
    "Fxn:__call__" -> "Fxn:self._executor(*args)";
    "Fxn:_recompute_captures" -> "Fxn:self._executor.set_captures(*self.state_dict().values())";
    "Fxn:_apply" -> "Fxn:itertools.chain((self,),";
    "Fxn:_apply" -> "Fxn:self.modules()):";
    "Fxn:_apply" -> "Fxn:module._parameters.values():";
    "Fxn:_apply" -> "Fxn:fn(param.data)";
    "Fxn:_apply" -> "Fxn:fn(param._grad.data)";
    "Fxn:_apply" -> "Fxn:module._buffers.items():";
    "Fxn:_apply" -> "Fxn:fn(buf)";
    "Fxn:_apply" -> "Fxn:self._recompute_captures()";
    "Fxn:_get_methods" -> "Fxn:inspect.getmembers(cls,";
    "Fxn:_get_methods" -> "Fxn:inspect.isfunction(x)";
    "Fxn:_get_methods" -> "Fxn:inspect.ismethod(x))";
    "Fxn:fail" -> "Fxn:RuntimeError(name";
    "Fxn:fail" -> "Fxn:_get_methods(torch.nn.Module):";
    "Fxn:fail" -> "Fxn:name.startswith('__'):";
    "Fxn:fail" -> "Fxn:_make_fail(name))";
    "Fxn:bar" -> "Fxn:createResolutionCallback()";
    "Fxn:baz" -> "Fxn:bar()";
    "Fxn:baz" -> "Fxn:baz()";
    "Fxn:baz" -> "Fxn:inspect.stack()[frame_id][0]";
    "class:CompilationUnit(object):" -> "Fxn:__init__";
    "class:CompilationUnit(object):" -> "Fxn:define";
    "class:CompilationUnit(object):" -> "Fxn:__getattr__";
    "class:CompilationUnit(object):" -> "Fxn:script";
    "class:CompilationUnit(object):" -> "Fxn:script_method";
    "Fxn:__init__" -> "Fxn:torch._C.ScriptModule(optimize)";
    "Fxn:__init__" -> "Fxn:self.define(lang,";
    "Fxn:define" -> "Fxn:createResolutionCallback(frame_id)";
    "Fxn:define" -> "Fxn:self.module._define(lang,";
    "Fxn:__getattr__" -> "Fxn:self.module._get_method(attr)";
    "Fxn:script" -> "Fxn:createResolutionCallback()";
    "Fxn:script" -> "Fxn:get_jit_ast(fn)";
    "Fxn:script" -> "Fxn:_jit_script_compile(ast,";
    "Fxn:script" -> "Fxn:torch._C.GraphExecutor(graph,";
    "Fxn:script" -> "Fxn:namedtuple('ScriptMethodStub',";
    "Fxn:script_method" -> "Fxn:ScriptMethodStub(createResolutionCallback(),";
    "Fxn:script_method" -> "Fxn:get_jit_ast(fn))";
    "class:ScriptMeta(type(torch._C.ScriptModule)):" -> "Fxn:__init__";
    "class:ScriptMeta(type(torch._C.ScriptModule)):" -> "Fxn:init_then_register";
    "Fxn:__init__" -> "Fxn:methods.append(v)";
    "Fxn:init_then_register" -> "Fxn:original_init(self,";
    "Fxn:init_then_register" -> "Fxn:self._create_method(m.ast,";
    "Fxn:init_then_register" -> "Fxn:cls).__init__(name,";
    "class:ScriptModule(with_metaclass(ScriptMeta," -> "Fxn:__setattr__";
    "class:ScriptModule(with_metaclass(ScriptMeta," -> "Fxn:__getattr__";
    "class:ScriptModule(with_metaclass(ScriptMeta," -> "Fxn:define";
    "Fxn:__setattr__" -> "Fxn:self._register_or_set_parameter(name,";
    "Fxn:__setattr__" -> "Fxn:self._register_module(name,";
    "Fxn:__getattr__" -> "Fxn:self._get_attribute(attr)";
    "Fxn:__getattr__" -> "Fxn:AttributeError("'{}'";
    "Fxn:__getattr__" -> "Fxn:'{}'".format(self.__class__.__name__,";
    "Fxn:define" -> "Fxn:createResolutionCallback()";
    "Fxn:define" -> "Fxn:self._define(lang,";
    "Fxn:define" -> "Fxn:torch._C._jit_init():";
    "Fxn:define" -> "Fxn:RuntimeError("JIT";
    "/torch/legacy/nn/Abs.py" -> "Import:torch";
    "/torch/legacy/nn/Abs.py" -> "Import:Module";
    "/torch/legacy/nn/Abs.py" -> "class:Abs(Module):";
    "class:Abs(Module):" -> "Fxn:__init__";
    "class:Abs(Module):" -> "Fxn:updateOutput";
    "class:Abs(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.Abs_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.Abs_updateGradInput(";
    "/torch/legacy/nn/AbsCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/AbsCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/AbsCriterion.py" -> "class:AbsCriterion(Criterion):";
    "class:AbsCriterion(Criterion):" -> "Fxn:__init__";
    "class:AbsCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:AbsCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(1)";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.AbsCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.AbsCriterion_updateGradInput(";
    "/torch/legacy/nn/Add.py" -> "Import:math";
    "/torch/legacy/nn/Add.py" -> "Import:torch";
    "/torch/legacy/nn/Add.py" -> "Import:Module";
    "/torch/legacy/nn/Add.py" -> "class:Add(Module):";
    "class:Add(Module):" -> "Fxn:__init__";
    "class:Add(Module):" -> "Fxn:reset";
    "class:Add(Module):" -> "Fxn:updateOutput";
    "class:Add(Module):" -> "Fxn:updateGradInput";
    "class:Add(Module):" -> "Fxn:accGradParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(size)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(size)";
    "Fxn:__init__" -> "Fxn:torch.Tensor((1,))";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.bias.size(0))";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(self.bias[0])";
    "Fxn:updateOutput" -> "Fxn:input.size(0)";
    "Fxn:updateOutput" -> "Fxn:self._ones.size(0)";
    "Fxn:updateOutput" -> "Fxn:self._ones.resize_(batchSize).fill_(1)";
    "Fxn:updateOutput" -> "Fxn:self.bias.view(-1)";
    "Fxn:updateOutput" -> "Fxn:self.output.view(batchSize,";
    "Fxn:updateOutput" -> "Fxn:output.addr_(self._ones,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:accGradParameters" -> "Fxn:self.gradBias.size(0)";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.sum()";
    "Fxn:accGradParameters" -> "Fxn:input.is_same_size(self.bias):";
    "Fxn:accGradParameters" -> "Fxn:self.gradBias.add_(scale,";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.contiguous().view(input.size(0),";
    "Fxn:accGradParameters" -> "Fxn:self.gradBias.view(-1).addmv_(scale,";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.t(),";
    "/torch/legacy/nn/AddConstant.py" -> "Import:torch";
    "/torch/legacy/nn/AddConstant.py" -> "Import:Module";
    "/torch/legacy/nn/AddConstant.py" -> "class:AddConstant(Module):";
    "class:AddConstant(Module):" -> "Fxn:__init__";
    "class:AddConstant(Module):" -> "Fxn:updateOutput";
    "class:AddConstant(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.add_(self.constant_scalar)";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(self.constant_scalar)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.set_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:input.add_(-self.constant_scalar)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(gradOutput)";
    "/torch/legacy/nn/BatchNormalization.py" -> "Import:torch";
    "/torch/legacy/nn/BatchNormalization.py" -> "Import:Module";
    "/torch/legacy/nn/BatchNormalization.py" -> "Import:clear";
    "/torch/legacy/nn/BatchNormalization.py" -> "class:BatchNormalization(Module):";
    "class:BatchNormalization(Module):" -> "Fxn:__init__";
    "class:BatchNormalization(Module):" -> "Fxn:reset";
    "class:BatchNormalization(Module):" -> "Fxn:_checkInputDim";
    "class:BatchNormalization(Module):" -> "Fxn:_makeContiguous";
    "class:BatchNormalization(Module):" -> "Fxn:updateOutput";
    "class:BatchNormalization(Module):" -> "Fxn:_backward";
    "class:BatchNormalization(Module):" -> "Fxn:backward";
    "class:BatchNormalization(Module):" -> "Fxn:updateGradInput";
    "class:BatchNormalization(Module):" -> "Fxn:accGradParameters";
    "class:BatchNormalization(Module):" -> "Fxn:read";
    "class:BatchNormalization(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.zeros(nOutput)";
    "Fxn:__init__" -> "Fxn:torch.ones(nOutput)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutput)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutput)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutput)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutput)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:self.weight.uniform_()";
    "Fxn:reset" -> "Fxn:self.bias.zero_()";
    "Fxn:reset" -> "Fxn:self.running_mean.zero_()";
    "Fxn:reset" -> "Fxn:self.running_var.fill_(1)";
    "Fxn:_checkInputDim" -> "Fxn:input.dim()";
    "Fxn:_checkInputDim" -> "Fxn:RuntimeError(";
    "Fxn:_checkInputDim" -> "Fxn:instead'.format(self.nDim,";
    "Fxn:_checkInputDim" -> "Fxn:input.dim()))";
    "Fxn:_checkInputDim" -> "Fxn:input.size(1)";
    "Fxn:_checkInputDim" -> "Fxn:self.running_mean.nelement():";
    "Fxn:_checkInputDim" -> "Fxn:RuntimeError('got";
    "Fxn:_checkInputDim" -> "Fxn:{}'.format(input.size(1),";
    "Fxn:_checkInputDim" -> "Fxn:self.running_mean.nelement()))";
    "Fxn:_makeContiguous" -> "Fxn:input.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateOutput" -> "Fxn:self._checkInputDim(input)";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(input)[0]";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.save_mean.resize_as_(self.running_mean)";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.save_std.resize_as_(self.running_var)";
    "Fxn:updateOutput" -> "Fxn:self._backend.BatchNormalization_updateOutput(";
    "Fxn:_backward" -> "Fxn:self._checkInputDim(input)";
    "Fxn:_backward" -> "Fxn:self._checkInputDim(gradOutput)";
    "Fxn:_backward" -> "Fxn:RuntimeError('you";
    "Fxn:_backward" -> "Fxn:updateOutput()";
    "Fxn:_backward" -> "Fxn:backward()')";
    "Fxn:_backward" -> "Fxn:self._makeContiguous(input,";
    "Fxn:_backward" -> "Fxn:gradInput.resize_as_(gradOutput)";
    "Fxn:_backward" -> "Fxn:self._backend.BatchNormalization_backward(";
    "Fxn:backward" -> "Fxn:self._backward(input,";
    "Fxn:updateGradInput" -> "Fxn:self._backward(input,";
    "Fxn:accGradParameters" -> "Fxn:self._backward(input,";
    "Fxn:read" -> "Fxn:self).read(self,";
    "Fxn:read" -> "Fxn:self.running_std.pow_(-2).add_(-self.eps)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/BCECriterion.py" -> "Import:torch";
    "/torch/legacy/nn/BCECriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/BCECriterion.py" -> "class:BCECriterion(Criterion):";
    "class:BCECriterion(Criterion):" -> "Fxn:__init__";
    "class:BCECriterion(Criterion):" -> "Fxn:updateOutput";
    "class:BCECriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:weights.dim()";
    "Fxn:__init__" -> "Fxn:ValueError("weights";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:log(input)";
    "Fxn:updateOutput" -> "Fxn:log(1";
    "Fxn:updateOutput" -> "Fxn:input.nelement()";
    "Fxn:updateOutput" -> "Fxn:target.nelement():";
    "Fxn:updateOutput" -> "Fxn:RuntimeError("input";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:buffer.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:target.dim()";
    "Fxn:updateOutput" -> "Fxn:self.weights.view(1,";
    "Fxn:updateOutput" -> "Fxn:target.size(1)).expand_as(target)";
    "Fxn:updateOutput" -> "Fxn:log(input)";
    "Fxn:updateOutput" -> "Fxn:torch.add(input,";
    "Fxn:updateOutput" -> "Fxn:out=buffer).log_()";
    "Fxn:updateOutput" -> "Fxn:buffer.mul_(weights)";
    "Fxn:updateOutput" -> "Fxn:target.contiguous().view(-1)";
    "Fxn:updateOutput" -> "Fxn:torch.dot(target_1d,";
    "Fxn:updateOutput" -> "Fxn:buffer.contiguous().view(-1))";
    "Fxn:updateOutput" -> "Fxn:log(1";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input,";
    "Fxn:updateOutput" -> "Fxn:out=buffer).add_(1";
    "Fxn:updateOutput" -> "Fxn:self.eps).log_()";
    "Fxn:updateOutput" -> "Fxn:buffer.mul_(weights)";
    "Fxn:updateOutput" -> "Fxn:torch.sum(buffer)";
    "Fxn:updateOutput" -> "Fxn:torch.dot(target_1d,";
    "Fxn:updateOutput" -> "Fxn:buffer.contiguous().view(-1))";
    "Fxn:updateOutput" -> "Fxn:input.nelement()";
    "Fxn:updateOutput" -> "Fxn:output.item()";
    "Fxn:updateGradInput" -> "Fxn:input.nelement()";
    "Fxn:updateGradInput" -> "Fxn:target.nelement():";
    "Fxn:updateGradInput" -> "Fxn:RuntimeError("input";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:target.dim()";
    "Fxn:updateGradInput" -> "Fxn:self.weights.view(1,";
    "Fxn:updateGradInput" -> "Fxn:target.size(1)).expand_as(target)";
    "Fxn:updateGradInput" -> "Fxn:buffer.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:torch.add(input,";
    "Fxn:updateGradInput" -> "Fxn:out=buffer).add_(-self.eps).mul_(input).add_(-self.eps)";
    "Fxn:updateGradInput" -> "Fxn:gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:torch.add(target,";
    "Fxn:updateGradInput" -> "Fxn:gradInput.div_(buffer)";
    "Fxn:updateGradInput" -> "Fxn:gradInput.mul_(weights)";
    "Fxn:updateGradInput" -> "Fxn:gradInput.div_(target.nelement())";
    "/torch/legacy/nn/Bilinear.py" -> "Import:math";
    "/torch/legacy/nn/Bilinear.py" -> "Import:torch";
    "/torch/legacy/nn/Bilinear.py" -> "Import:Module";
    "/torch/legacy/nn/Bilinear.py" -> "Import:clear";
    "/torch/legacy/nn/Bilinear.py" -> "class:Bilinear(Module):";
    "class:Bilinear(Module):" -> "Fxn:_assertInput";
    "class:Bilinear(Module):" -> "Fxn:_assertInputGradOutput";
    "class:Bilinear(Module):" -> "Fxn:__init__";
    "class:Bilinear(Module):" -> "Fxn:reset";
    "class:Bilinear(Module):" -> "Fxn:updateOutput";
    "class:Bilinear(Module):" -> "Fxn:updateGradInput";
    "class:Bilinear(Module):" -> "Fxn:accGradParameters";
    "class:Bilinear(Module):" -> "Fxn:__repr__";
    "class:Bilinear(Module):" -> "Fxn:clearState";
    "Fxn:_assertInput" -> "Fxn:torch.is_tensor(input[0])";
    "Fxn:_assertInput" -> "Fxn:torch.is_tensor(input[1]):";
    "Fxn:_assertInput" -> "Fxn:RuntimeError('input";
    "Fxn:_assertInput" -> "Fxn:input[0].ndimension()";
    "Fxn:_assertInput" -> "Fxn:input[1].ndimension()";
    "Fxn:_assertInput" -> "Fxn:RuntimeError('input";
    "Fxn:_assertInput" -> "Fxn:input[0].size(0)";
    "Fxn:_assertInput" -> "Fxn:input[1].size(0):";
    "Fxn:_assertInput" -> "Fxn:RuntimeError('input";
    "Fxn:_assertInput" -> "Fxn:input[0].size(1)";
    "Fxn:_assertInput" -> "Fxn:self.weight.size(1):";
    "Fxn:_assertInput" -> "Fxn:RuntimeError('dimensionality";
    "Fxn:_assertInput" -> "Fxn:input[1].size(1)";
    "Fxn:_assertInput" -> "Fxn:self.weight.size(2):";
    "Fxn:_assertInput" -> "Fxn:RuntimeError('dimensionality";
    "Fxn:_assertInputGradOutput" -> "Fxn:input[0].size(0)";
    "Fxn:_assertInputGradOutput" -> "Fxn:gradOutput.size(0):";
    "Fxn:_assertInputGradOutput" -> "Fxn:RuntimeError('number";
    "Fxn:_assertInputGradOutput" -> "Fxn:gradOutput.size(1)";
    "Fxn:_assertInputGradOutput" -> "Fxn:self.weight.size(0):";
    "Fxn:_assertInputGradOutput" -> "Fxn:RuntimeError('number";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize)";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self._assertInput(input)";
    "Fxn:updateOutput" -> "Fxn:input[0].new()";
    "Fxn:updateOutput" -> "Fxn:self.buff2.resize_as_(input[1])";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(input[0].size(0),";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(0))";
    "Fxn:updateOutput" -> "Fxn:torch.mm(input[0],";
    "Fxn:updateOutput" -> "Fxn:self.buff2.mul_(input[1])";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buff2,";
    "Fxn:updateOutput" -> "Fxn:out=self.output.narrow(1,";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(self.bias.view(1,";
    "Fxn:updateOutput" -> "Fxn:self.bias.nelement()).expand_as(self.output))";
    "Fxn:updateGradInput" -> "Fxn:self._assertInputGradOutput(input,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_as_(input[0]).fill_(0)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_as_(input[1]).fill_(0)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].addmm_(input[1],";
    "Fxn:updateGradInput" -> "Fxn:self.weight[0].t())";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].mul_(gradOutput.narrow(1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(self.gradInput[0].size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].size(1)))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].addmm_(input[0],";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].mul_(gradOutput.narrow(1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(self.gradInput[1].size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].size(1)))";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(0)";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:self.buff1.resize_as_(input[0])";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(0)):";
    "Fxn:updateGradInput" -> "Fxn:torch.mm(input[1],";
    "Fxn:updateGradInput" -> "Fxn:self.weight[k].t(),";
    "Fxn:updateGradInput" -> "Fxn:self.buff1.mul_(gradOutput.narrow(1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(self.gradInput[0].size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].size(1)))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].add_(self.buff1)";
    "Fxn:updateGradInput" -> "Fxn:torch.mm(input[0],";
    "Fxn:updateGradInput" -> "Fxn:self.buff2.mul_(gradOutput.narrow(1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(self.gradInput[1].size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].size(1)))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].add_(self.buff2)";
    "Fxn:accGradParameters" -> "Fxn:self._assertInputGradOutput(input,";
    "Fxn:accGradParameters" -> "Fxn:input[0].new()";
    "Fxn:accGradParameters" -> "Fxn:self.buff1.resize_as_(input[0])";
    "Fxn:accGradParameters" -> "Fxn:torch.mul(input[0],";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.narrow(1,";
    "Fxn:accGradParameters" -> "Fxn:1).expand_as(input[0]),";
    "Fxn:accGradParameters" -> "Fxn:self.gradWeight[k].addmm_(self.buff1.t(),";
    "Fxn:accGradParameters" -> "Fxn:self.gradBias.add_(scale,";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.sum(0,";
    "Fxn:__repr__" -> "Fxn:'({}x{}";
    "Fxn:__repr__" -> "Fxn:{}'.format(";
    "Fxn:__repr__" -> "Fxn:self.weight.size(1),";
    "Fxn:__repr__" -> "Fxn:self.weight.size(2),";
    "Fxn:__repr__" -> "Fxn:self.weight.size(0),";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/CAddTable.py" -> "Import:torch";
    "/torch/legacy/nn/CAddTable.py" -> "Import:Module";
    "/torch/legacy/nn/CAddTable.py" -> "class:CAddTable(Module):";
    "class:CAddTable(Module):" -> "Fxn:__init__";
    "class:CAddTable(Module):" -> "Fxn:updateOutput";
    "class:CAddTable(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input[0])";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(input[i])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[i].set_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[i].resize_as_(input[i]).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[len(input):]";
    "/torch/legacy/nn/CDivTable.py" -> "Import:torch";
    "/torch/legacy/nn/CDivTable.py" -> "Import:Module";
    "/torch/legacy/nn/CDivTable.py" -> "class:CDivTable(Module):";
    "class:CDivTable(Module):" -> "Fxn:__init__";
    "class:CDivTable(Module):" -> "Fxn:updateOutput";
    "class:CDivTable(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:updateOutput" -> "Fxn:self.output.div_(input[1])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.contiguous().view_as(input[0])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_as_(input[0]).copy_(gradOutput).div_(input[1])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_as_(input[1]).zero_().addcdiv_(-1,";
    "Fxn:updateGradInput" -> "Fxn:input[1]).mul_(input[0])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[len(input):]";
    "/torch/legacy/nn/Clamp.py" -> "Import:torch";
    "/torch/legacy/nn/Clamp.py" -> "Import:HardTanh";
    "/torch/legacy/nn/Clamp.py" -> "class:Clamp(HardTanh):";
    "class:Clamp(HardTanh):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self,).__init__(min_value,";
    "/torch/legacy/nn/ClassNLLCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/ClassNLLCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/ClassNLLCriterion.py" -> "class:ClassNLLCriterion(Criterion):";
    "class:ClassNLLCriterion(Criterion):" -> "Fxn:__init__";
    "class:ClassNLLCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:ClassNLLCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:weights.dim()";
    "Fxn:__init__" -> "Fxn:torch.zeros(1)";
    "Fxn:__init__" -> "Fxn:torch.ones(1)";
    "Fxn:updateOutput" -> "Fxn:target.long()";
    "Fxn:updateOutput" -> "Fxn:self._backend.ClassNLLCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:target.long()";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.ClassNLLCriterion_updateGradInput(";
    "/torch/legacy/nn/ClassSimplexCriterion.py" -> "Import:math";
    "/torch/legacy/nn/ClassSimplexCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/ClassSimplexCriterion.py" -> "Import:MSECriterion";
    "/torch/legacy/nn/ClassSimplexCriterion.py" -> "class:ClassSimplexCriterion(MSECriterion):";
    "class:ClassSimplexCriterion(MSECriterion):" -> "Fxn:__init__";
    "class:ClassSimplexCriterion(MSECriterion):" -> "Fxn:_regsplex";
    "class:ClassSimplexCriterion(MSECriterion):" -> "Fxn:_transformTarget";
    "class:ClassSimplexCriterion(MSECriterion):" -> "Fxn:updateOutput";
    "class:ClassSimplexCriterion(MSECriterion):" -> "Fxn:updateGradInput";
    "class:ClassSimplexCriterion(MSECriterion):" -> "Fxn:getPredictions";
    "class:ClassSimplexCriterion(MSECriterion):" -> "Fxn:getTopPrediction";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:self._regsplex(nClasses";
    "Fxn:__init__" -> "Fxn:torch.cat((simp,";
    "Fxn:__init__" -> "Fxn:torch.zeros(simp.size(0),";
    "Fxn:__init__" -> "Fxn:simp.size(1))),";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nClasses)";
    "Fxn:_regsplex" -> "Fxn:torch.zeros(n";
    "Fxn:_regsplex" -> "Fxn:math.sqrt(1";
    "Fxn:_regsplex" -> "Fxn:1].norm()";
    "Fxn:_regsplex" -> "Fxn:1].fill_(c)";
    "Fxn:_transformTarget" -> "Fxn:target.dim()";
    "Fxn:_transformTarget" -> "Fxn:target.size(0)";
    "Fxn:_transformTarget" -> "Fxn:self._target.resize_(nSamples,";
    "Fxn:_transformTarget" -> "Fxn:self._target[i].copy_(self.simplex[int(target[i])])";
    "Fxn:updateOutput" -> "Fxn:self._transformTarget(target)";
    "Fxn:updateOutput" -> "Fxn:input.nelement()";
    "Fxn:updateOutput" -> "Fxn:self._target.nelement()";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.MSECriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:input.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self._target.nelement()";
    "Fxn:updateGradInput" -> "Fxn:torch.Tensor([1]).type(input.type())";
    "Fxn:updateGradInput" -> "Fxn:self._backend.MSECriterion_updateGradInput(";
    "Fxn:getPredictions" -> "Fxn:torch.mm(input,";
    "Fxn:getPredictions" -> "Fxn:self.simplex.t())";
    "Fxn:getTopPrediction" -> "Fxn:self.getPredictions(input)";
    "Fxn:getTopPrediction" -> "Fxn:prod.max(prod.ndimension()";
    "Fxn:getTopPrediction" -> "Fxn:maxs.view(-1)";
    "/torch/legacy/nn/CMul.py" -> "Import:math";
    "/torch/legacy/nn/CMul.py" -> "Import:torch";
    "/torch/legacy/nn/CMul.py" -> "Import:Module";
    "/torch/legacy/nn/CMul.py" -> "Import:clear,";
    "/torch/legacy/nn/CMul.py" -> "class:CMul(Module):";
    "class:CMul(Module):" -> "Fxn:__init__";
    "class:CMul(Module):" -> "Fxn:reset";
    "class:CMul(Module):" -> "Fxn:updateOutput";
    "class:CMul(Module):" -> "Fxn:updateGradInput";
    "class:CMul(Module):" -> "Fxn:accGradParameters";
    "class:CMul(Module):" -> "Fxn:type";
    "class:CMul(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Size(args)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.size)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.size)";
    "Fxn:__init__" -> "Fxn:self.output.resize_(self.size)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.weight.nelement())";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:input.size(0)";
    "Fxn:updateOutput" -> "Fxn:self.output.view(batchSize,";
    "Fxn:updateOutput" -> "Fxn:self.weight.view(1,";
    "Fxn:updateOutput" -> "Fxn:self._weight.expand_as(self._output)";
    "Fxn:updateOutput" -> "Fxn:torch.typename(input)";
    "Fxn:updateOutput" -> "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:updateOutput" -> "Fxn:self._output.mul_(self._repeat)";
    "Fxn:updateOutput" -> "Fxn:self._output.mul_(self._expand)";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:contiguousView(self._gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:contiguousView(self._gradInput,";
    "Fxn:updateGradInput" -> "Fxn:self.weight.view(1,";
    "Fxn:updateGradInput" -> "Fxn:self._weight.expand_as(self._gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:torch.typename(input)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:updateGradInput" -> "Fxn:self._gradInput.addcmul_(1,";
    "Fxn:updateGradInput" -> "Fxn:self._gradInput.addcmul_(1,";
    "Fxn:accGradParameters" -> "Fxn:input.new()";
    "Fxn:accGradParameters" -> "Fxn:input.new()";
    "Fxn:accGradParameters" -> "Fxn:input.new()";
    "Fxn:accGradParameters" -> "Fxn:input.size(0)";
    "Fxn:accGradParameters" -> "Fxn:contiguousView(self._input,";
    "Fxn:accGradParameters" -> "Fxn:contiguousView(self._gradOutput,";
    "Fxn:accGradParameters" -> "Fxn:self.gradWeight.view(1,";
    "Fxn:accGradParameters" -> "Fxn:torch.mul(self._input,";
    "Fxn:accGradParameters" -> "Fxn:torch.sum(self._repeat,";
    "Fxn:accGradParameters" -> "Fxn:self._gradWeight.add_(scale,";
    "Fxn:type" -> "Fxn:self.clearState()";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/CMulTable.py" -> "Import:torch";
    "/torch/legacy/nn/CMulTable.py" -> "Import:Module";
    "/torch/legacy/nn/CMulTable.py" -> "Import:clear";
    "/torch/legacy/nn/CMulTable.py" -> "class:CMulTable(Module):";
    "class:CMulTable(Module):" -> "Fxn:__init__";
    "class:CMulTable(Module):" -> "Fxn:updateOutput";
    "class:CMulTable(Module):" -> "Fxn:updateGradInput_efficient";
    "class:CMulTable(Module):" -> "Fxn:updateGradInput";
    "class:CMulTable(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(input[i])";
    "Fxn:updateGradInput_efficient" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput_efficient" -> "Fxn:self.tout.resize_as_(self.output)";
    "Fxn:updateGradInput_efficient" -> "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:updateGradInput_efficient" -> "Fxn:self.gradInput[i].resize_as_(input[i]).copy_(gradOutput)";
    "Fxn:updateGradInput_efficient" -> "Fxn:self.tout.copy_(self.output).div_(input[i])";
    "Fxn:updateGradInput_efficient" -> "Fxn:self.gradInput[i].mul_(self.tout)";
    "Fxn:updateGradInput_efficient" -> "Fxn:self.gradInput[:len(input)]";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.append(input[0].new())";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[i].resize_as_(input[i]).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[i].mul_(input[j])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[:len(input)]";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Concat.py" -> "Import:torch";
    "/torch/legacy/nn/Concat.py" -> "Import:Container";
    "/torch/legacy/nn/Concat.py" -> "class:Concat(Container):";
    "class:Concat(Container):" -> "Fxn:__init__";
    "class:Concat(Container):" -> "Fxn:updateOutput";
    "class:Concat(Container):" -> "Fxn:updateGradInput";
    "class:Concat(Container):" -> "Fxn:accGradParameters";
    "class:Concat(Container):" -> "Fxn:backward";
    "class:Concat(Container):" -> "Fxn:accUpdateGradParameters";
    "class:Concat(Container):" -> "Fxn:__tostring__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:updateOutput" -> "Fxn:self.modules[i].updateOutput(input)";
    "Fxn:updateOutput" -> "Fxn:outs.append(currentOutput)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:updateOutput" -> "Fxn:torch.Size(size)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(self.outputSize)";
    "Fxn:updateOutput" -> "Fxn:self.output.narrow(self.dimension,";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.dimension)).copy_(currentOutput)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:module.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.narrow(";
    "Fxn:updateGradInput" -> "Fxn:currentOutput.size(self.dimension)))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:updateGradInput" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accGradParameters" -> "Fxn:module.accGradParameters(";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.narrow(self.dimension,";
    "Fxn:accGradParameters" -> "Fxn:currentOutput.size(self.dimension)),";
    "Fxn:accGradParameters" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:backward" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:backward" -> "Fxn:module.backward(input,";
    "Fxn:backward" -> "Fxn:gradOutput.narrow(";
    "Fxn:backward" -> "Fxn:currentOutput.size(self.dimension)),";
    "Fxn:backward" -> "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:backward" -> "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:backward" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accUpdateGradParameters" -> "Fxn:module.accUpdateGradParameters(";
    "Fxn:accUpdateGradParameters" -> "Fxn:gradOutput.narrow(self.dimension,";
    "Fxn:accUpdateGradParameters" -> "Fxn:currentOutput.size(self.dimension)),";
    "Fxn:accUpdateGradParameters" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:__tostring__" -> "Fxn:torch.type(self)";
    "Fxn:__tostring__" -> "Fxn:'('";
    "Fxn:__tostring__" -> "Fxn:'('";
    "/torch/legacy/nn/ConcatTable.py" -> "Import:torch";
    "/torch/legacy/nn/ConcatTable.py" -> "Import:Container";
    "/torch/legacy/nn/ConcatTable.py" -> "class:ConcatTable(Container):";
    "class:ConcatTable(Container):" -> "Fxn:__init__";
    "class:ConcatTable(Container):" -> "Fxn:updateOutput";
    "class:ConcatTable(Container):" -> "Fxn:_map_list";
    "class:ConcatTable(Container):" -> "Fxn:_backward";
    "class:ConcatTable(Container):" -> "Fxn:fn";
    "class:ConcatTable(Container):" -> "Fxn:fn";
    "class:ConcatTable(Container):" -> "Fxn:updateGradInput";
    "class:ConcatTable(Container):" -> "Fxn:backward";
    "class:ConcatTable(Container):" -> "Fxn:accGradParameters";
    "class:ConcatTable(Container):" -> "Fxn:accUpdateGradParameters";
    "class:ConcatTable(Container):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:[module.updateOutput(input)";
    "Fxn:_map_list" -> "Fxn:self._map_list(l1[i]";
    "Fxn:_map_list" -> "Fxn:l1.append(res)";
    "Fxn:_map_list" -> "Fxn:f(l1,";
    "Fxn:_backward" -> "Fxn:module.updateGradInput(input,";
    "Fxn:_backward" -> "Fxn:module.backward(input,";
    "Fxn:_backward" -> "Fxn:RuntimeError("currentGradInput";
    "Fxn:_backward" -> "Fxn:RuntimeError("table";
    "Fxn:fn" -> "Fxn:l.append(v.clone())";
    "Fxn:fn" -> "Fxn:l[i].resize_as_(v)";
    "Fxn:fn" -> "Fxn:l[i].copy_(v)";
    "Fxn:fn" -> "Fxn:self._map_list(self.gradInput,";
    "Fxn:fn" -> "Fxn:l[i].add_(v)";
    "Fxn:fn" -> "Fxn:l.append(v.clone())";
    "Fxn:fn" -> "Fxn:self._map_list(self.gradInput,";
    "Fxn:fn" -> "Fxn:input.clone()";
    "Fxn:fn" -> "Fxn:module.updateGradInput(input,";
    "Fxn:fn" -> "Fxn:module.backward(input,";
    "Fxn:fn" -> "Fxn:self.gradInput.resize_as_(currentGradInput).copy_(currentGradInput)";
    "Fxn:fn" -> "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:updateGradInput" -> "Fxn:self._backward('updateGradInput',";
    "Fxn:backward" -> "Fxn:self._backward('backward',";
    "Fxn:accGradParameters" -> "Fxn:ipairs(self.modules):";
    "Fxn:accGradParameters" -> "Fxn:self.rethrowErrors(module,";
    "Fxn:accUpdateGradParameters" -> "Fxn:ipairs(self.modules):";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.rethrowErrors(module,";
    "Fxn:__repr__" -> "Fxn:torch.typename(self)";
    "Fxn:__repr__" -> "Fxn:'('";
    "Fxn:__repr__" -> "Fxn:'('";
    "/torch/legacy/nn/Container.py" -> "Import:torch";
    "/torch/legacy/nn/Container.py" -> "Import:Module";
    "/torch/legacy/nn/Container.py" -> "Import:clear";
    "/torch/legacy/nn/Container.py" -> "Import:wraps";
    "/torch/legacy/nn/Container.py" -> "Import:sys";
    "/torch/legacy/nn/Container.py" -> "class:Container(Module):";
    "class:Container(Module):" -> "Fxn:__init__";
    "class:Container(Module):" -> "Fxn:add";
    "class:Container(Module):" -> "Fxn:get";
    "class:Container(Module):" -> "Fxn:size";
    "class:Container(Module):" -> "Fxn:applyToModules";
    "class:Container(Module):" -> "Fxn:zeroGradParameters";
    "class:Container(Module):" -> "Fxn:updateParameters";
    "class:Container(Module):" -> "Fxn:training";
    "class:Container(Module):" -> "Fxn:evaluate";
    "class:Container(Module):" -> "Fxn:share";
    "class:Container(Module):" -> "Fxn:reset";
    "class:Container(Module):" -> "Fxn:parameters";
    "class:Container(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__(*args)";
    "Fxn:add" -> "Fxn:self.modules.append(module)";
    "Fxn:applyToModules" -> "Fxn:func(module)";
    "Fxn:zeroGradParameters" -> "Fxn:self.applyToModules(lambda";
    "Fxn:zeroGradParameters" -> "Fxn:m.zeroGradParameters())";
    "Fxn:updateParameters" -> "Fxn:self.applyToModules(lambda";
    "Fxn:updateParameters" -> "Fxn:m.updateParameters(learningRate))";
    "Fxn:training" -> "Fxn:self.applyToModules(lambda";
    "Fxn:training" -> "Fxn:m.training())";
    "Fxn:training" -> "Fxn:self).training()";
    "Fxn:evaluate" -> "Fxn:self.applyToModules(lambda";
    "Fxn:evaluate" -> "Fxn:m.evaluate())";
    "Fxn:evaluate" -> "Fxn:self).evaluate()";
    "Fxn:share" -> "Fxn:module.share(other_module,";
    "Fxn:reset" -> "Fxn:self.applyToModules(lambda";
    "Fxn:reset" -> "Fxn:m.reset(stdv))";
    "Fxn:parameters" -> "Fxn:module.parameters()";
    "Fxn:parameters" -> "Fxn:w.extend(mparam[0])";
    "Fxn:parameters" -> "Fxn:gw.extend(mparam[1])";
    "Fxn:clearState" -> "Fxn:clear('output')";
    "Fxn:clearState" -> "Fxn:clear('gradInput')";
    "Fxn:clearState" -> "Fxn:module.clearState()";
    "/torch/legacy/nn/Contiguous.py" -> "Import:torch";
    "/torch/legacy/nn/Contiguous.py" -> "Import:Module";
    "/torch/legacy/nn/Contiguous.py" -> "class:Contiguous(Module):";
    "class:Contiguous(Module):" -> "Fxn:updateOutput";
    "class:Contiguous(Module):" -> "Fxn:updateGradInput";
    "Fxn:updateOutput" -> "Fxn:input.is_contiguous():";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.set_(gradOutput)";
    "/torch/legacy/nn/Copy.py" -> "Import:torch";
    "/torch/legacy/nn/Copy.py" -> "Import:Module";
    "/torch/legacy/nn/Copy.py" -> "class:Copy(Module):";
    "class:Copy(Module):" -> "Fxn:__init__";
    "class:Copy(Module):" -> "Fxn:updateOutput";
    "class:Copy(Module):" -> "Fxn:updateGradInput";
    "class:Copy(Module):" -> "Fxn:type";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:intype()";
    "Fxn:__init__" -> "Fxn:outtype()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(input.size()).copy_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_(gradOutput.size()).copy_(gradOutput)";
    "Fxn:type" -> "Fxn:self).type(self,";
    "/torch/legacy/nn/Cosine.py" -> "Import:math";
    "/torch/legacy/nn/Cosine.py" -> "Import:torch";
    "/torch/legacy/nn/Cosine.py" -> "Import:Module";
    "/torch/legacy/nn/Cosine.py" -> "Import:clear";
    "/torch/legacy/nn/Cosine.py" -> "class:Cosine(Module):";
    "class:Cosine(Module):" -> "Fxn:__init__";
    "class:Cosine(Module):" -> "Fxn:reset";
    "class:Cosine(Module):" -> "Fxn:updateOutput";
    "class:Cosine(Module):" -> "Fxn:updateGradInput";
    "class:Cosine(Module):" -> "Fxn:accGradParameters";
    "class:Cosine(Module):" -> "Fxn:type";
    "class:Cosine(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize,";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.weight.size(0))";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(1)";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(0)";
    "Fxn:updateOutput" -> "Fxn:self.weight.new()";
    "Fxn:updateOutput" -> "Fxn:self.weight.new()";
    "Fxn:updateOutput" -> "Fxn:torch.norm(self.weight,";
    "Fxn:updateOutput" -> "Fxn:keepdim=True).add_(1e-12)";
    "Fxn:updateOutput" -> "Fxn:input.size(0)";
    "Fxn:updateOutput" -> "Fxn:self.output.nelement()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(batchSize,";
    "Fxn:updateOutput" -> "Fxn:self.output.nelement()";
    "Fxn:updateOutput" -> "Fxn:self.output.zero_()";
    "Fxn:updateOutput" -> "Fxn:self.output.addmm_(0.,";
    "Fxn:updateOutput" -> "Fxn:self.weight.t())";
    "Fxn:updateOutput" -> "Fxn:torch.norm(input,";
    "Fxn:updateOutput" -> "Fxn:keepdim=True).add_(1e-12)";
    "Fxn:updateOutput" -> "Fxn:self.output.div_(self._weightNorm.view(1,";
    "Fxn:updateOutput" -> "Fxn:outputSize).expand_as(self.output))";
    "Fxn:updateOutput" -> "Fxn:self.output.div_(self._inputNorm.expand_as(self.output))";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(1)";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(0)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.zero_()";
    "Fxn:updateGradInput" -> "Fxn:self._inputNorm.expand_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._weightNorm.view(1,";
    "Fxn:updateGradInput" -> "Fxn:outputSize).expand_as(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(input).div_(inputNorm)";
    "Fxn:updateGradInput" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self._gradOutput.mul_(self.output)";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self._gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(self._sum.expand_as(input))";
    "Fxn:updateGradInput" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self._gradOutput.div_(weightNorm)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.addmm_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.div_(inputNorm)";
    "Fxn:accGradParameters" -> "Fxn:input.dim()";
    "Fxn:accGradParameters" -> "Fxn:self.weight.size(1)";
    "Fxn:accGradParameters" -> "Fxn:self.weight.size(0)";
    "Fxn:accGradParameters" -> "Fxn:self.weight.new()";
    "Fxn:accGradParameters" -> "Fxn:input.new()";
    "Fxn:accGradParameters" -> "Fxn:self._weight.resize_as_(self.weight).copy_(self.weight)";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.new()";
    "Fxn:accGradParameters" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:accGradParameters" -> "Fxn:self._gradOutput.mul_(self.output)";
    "Fxn:accGradParameters" -> "Fxn:torch.sum(self._gradOutput,";
    "Fxn:accGradParameters" -> "Fxn:grad.div_(self._weightNorm.select(1,";
    "Fxn:accGradParameters" -> "Fxn:self._weight.mul_(grad.view(outputSize,";
    "Fxn:accGradParameters" -> "Fxn:1).expand_as(self._weight))";
    "Fxn:accGradParameters" -> "Fxn:input_.resize_as_(input).copy_(input)";
    "Fxn:accGradParameters" -> "Fxn:input_.div_(self._inputNorm.expand_as(input))";
    "Fxn:accGradParameters" -> "Fxn:self._weight.addmm_(-1,";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.t(),";
    "Fxn:accGradParameters" -> "Fxn:self._weight.div_(self._weightNorm.expand_as(self._weight))";
    "Fxn:accGradParameters" -> "Fxn:self.gradWeight.add_(self._weight)";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/CosineDistance.py" -> "Import:torch";
    "/torch/legacy/nn/CosineDistance.py" -> "Import:Module";
    "/torch/legacy/nn/CosineDistance.py" -> "Import:clear";
    "/torch/legacy/nn/CosineDistance.py" -> "class:CosineDistance(Module):";
    "class:CosineDistance(Module):" -> "Fxn:__init__";
    "class:CosineDistance(Module):" -> "Fxn:_makeContiguous";
    "class:CosineDistance(Module):" -> "Fxn:updateOutput";
    "class:CosineDistance(Module):" -> "Fxn:updateGradInput";
    "class:CosineDistance(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:_makeContiguous" -> "Fxn:input1.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input1.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input1.resize_as_(input1).copy_(input1)";
    "Fxn:_makeContiguous" -> "Fxn:input2.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input2.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input2.resize_as_(input2).copy_(input2)";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(input1,";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input1,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input1,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:updateOutput" -> "Fxn:self.w22.reciprocal_()";
    "Fxn:updateOutput" -> "Fxn:self.w.resize_as_(self.w22).copy_(self.w22)";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input2,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:updateOutput" -> "Fxn:self.w32.reciprocal_()";
    "Fxn:updateOutput" -> "Fxn:self.w.mul_(self.w32)";
    "Fxn:updateOutput" -> "Fxn:self.w.sqrt_()";
    "Fxn:updateOutput" -> "Fxn:torch.mul(self.w1,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(input1.size(0))";
    "Fxn:updateGradInput" -> "Fxn:self._makeContiguous(v1,";
    "Fxn:updateGradInput" -> "Fxn:v1.new()";
    "Fxn:updateGradInput" -> "Fxn:v1.new()";
    "Fxn:updateGradInput" -> "Fxn:gw1.resize_as_(v1).copy_(v2)";
    "Fxn:updateGradInput" -> "Fxn:gw2.resize_as_(v1).copy_(v1)";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.w1,";
    "Fxn:updateGradInput" -> "Fxn:gw1.addcmul_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.expand_as(v1),";
    "Fxn:updateGradInput" -> "Fxn:gw1.mul_(self.w.expand_as(v1))";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.w1,";
    "Fxn:updateGradInput" -> "Fxn:gw2.addcmul_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.expand_as(v1),";
    "Fxn:updateGradInput" -> "Fxn:gw2.mul_(self.w.expand_as(v1))";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.contiguous().view(-1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand_as(v1)";
    "Fxn:updateGradInput" -> "Fxn:gw1.mul_(go)";
    "Fxn:updateGradInput" -> "Fxn:gw2.mul_(go)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/CosineEmbeddingCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/CosineEmbeddingCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/CosineEmbeddingCriterion.py" -> "class:CosineEmbeddingCriterion(Criterion):";
    "class:CosineEmbeddingCriterion(Criterion):" -> "Fxn:__init__";
    "class:CosineEmbeddingCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:CosineEmbeddingCriterion(Criterion):" -> "Fxn:updateGradInput";
    "class:CosineEmbeddingCriterion(Criterion):" -> "Fxn:type";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:input1.type()";
    "Fxn:updateOutput" -> "Fxn:torch.cuda.ByteTensor()";
    "Fxn:updateOutput" -> "Fxn:torch.ByteTensor()";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input1,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input1,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:updateOutput" -> "Fxn:self._outputs.resize_as_(self.w22).fill_(1)";
    "Fxn:updateOutput" -> "Fxn:torch.div(self._outputs,";
    "Fxn:updateOutput" -> "Fxn:self.w.resize_as_(self.w22).copy_(self.w22)";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input2,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:keepdim=True).add_(epsilon)";
    "Fxn:updateOutput" -> "Fxn:torch.div(self._outputs,";
    "Fxn:updateOutput" -> "Fxn:self.w.mul_(self.w32)";
    "Fxn:updateOutput" -> "Fxn:self.w.sqrt_()";
    "Fxn:updateOutput" -> "Fxn:torch.mul(self.w1,";
    "Fxn:updateOutput" -> "Fxn:self._outputs.select(1,";
    "Fxn:updateOutput" -> "Fxn:torch.eq(y,";
    "Fxn:updateOutput" -> "Fxn:self._outputs[self._idx].add_(-self.margin).clamp_(min=0)";
    "Fxn:updateOutput" -> "Fxn:torch.eq(y,";
    "Fxn:updateOutput" -> "Fxn:self._outputs[self._idx].mul_(-1).add_(1)";
    "Fxn:updateOutput" -> "Fxn:self._outputs.sum().item()";
    "Fxn:updateOutput" -> "Fxn:y.size(0)";
    "Fxn:updateGradInput" -> "Fxn:gw1.resize_as_(v1).copy_(v2)";
    "Fxn:updateGradInput" -> "Fxn:gw2.resize_as_(v1).copy_(v1)";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.w1,";
    "Fxn:updateGradInput" -> "Fxn:gw1.addcmul_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.expand_as(v1),";
    "Fxn:updateGradInput" -> "Fxn:gw1.mul_(self.w.expand_as(v1))";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.w1,";
    "Fxn:updateGradInput" -> "Fxn:gw2.addcmul_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.expand_as(v1),";
    "Fxn:updateGradInput" -> "Fxn:gw2.mul_(self.w.expand_as(v1))";
    "Fxn:updateGradInput" -> "Fxn:torch.le(self._outputs,";
    "Fxn:updateGradInput" -> "Fxn:self._idx.view(-1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(gw1.size())";
    "Fxn:updateGradInput" -> "Fxn:torch.eq(y,";
    "Fxn:updateGradInput" -> "Fxn:self._idx.view(-1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(gw2.size())";
    "Fxn:updateGradInput" -> "Fxn:gw1[self._idx].mul_(-1)";
    "Fxn:updateGradInput" -> "Fxn:gw2[self._idx].mul_(-1)";
    "Fxn:updateGradInput" -> "Fxn:gw1.div_(y.size(0))";
    "Fxn:updateGradInput" -> "Fxn:gw2.div_(y.size(0))";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:torch.cuda.ByteTensor()";
    "Fxn:type" -> "Fxn:torch.ByteTensor()";
    "/torch/legacy/nn/Criterion.py" -> "Import:torch";
    "/torch/legacy/nn/Criterion.py" -> "Import:Module";
    "/torch/legacy/nn/Criterion.py" -> "Import:recursiveType";
    "/torch/legacy/nn/Criterion.py" -> "Import:torch._thnn";
    "/torch/legacy/nn/Criterion.py" -> "class:Criterion(object):";
    "class:Criterion(object):" -> "Fxn:__init__";
    "class:Criterion(object):" -> "Fxn:updateOutput";
    "class:Criterion(object):" -> "Fxn:forward";
    "class:Criterion(object):" -> "Fxn:backward";
    "class:Criterion(object):" -> "Fxn:updateGradInput";
    "class:Criterion(object):" -> "Fxn:clone";
    "class:Criterion(object):" -> "Fxn:type";
    "class:Criterion(object):" -> "Fxn:float";
    "class:Criterion(object):" -> "Fxn:double";
    "class:Criterion(object):" -> "Fxn:cuda";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:torch._thnn.type2backend[self.gradInput.type()]";
    "Fxn:forward" -> "Fxn:self.updateOutput(input,";
    "Fxn:backward" -> "Fxn:self.updateGradInput(input,";
    "Fxn:type" -> "Fxn:self.__dict__.items():";
    "Fxn:type" -> "Fxn:recursiveType(param,";
    "Fxn:float" -> "Fxn:self.type('torch.FloatTensor')";
    "Fxn:double" -> "Fxn:self.type('torch.DoubleTensor')";
    "Fxn:cuda" -> "Fxn:self.type('torch.cuda.FloatTensor')";
    "/torch/legacy/nn/CriterionTable.py" -> "Import:torch";
    "/torch/legacy/nn/CriterionTable.py" -> "Import:Module";
    "/torch/legacy/nn/CriterionTable.py" -> "class:CriterionTable(Module):";
    "class:CriterionTable(Module):" -> "Fxn:__init__";
    "class:CriterionTable(Module):" -> "Fxn:updateOutput";
    "class:CriterionTable(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.criterion.updateOutput(*input)";
    "Fxn:updateGradInput" -> "Fxn:self.criterion.updateGradInput(*input)";
    "/torch/legacy/nn/CrossEntropyCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/CrossEntropyCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/CrossEntropyCriterion.py" -> "Import:LogSoftMax";
    "/torch/legacy/nn/CrossEntropyCriterion.py" -> "Import:ClassNLLCriterion";
    "/torch/legacy/nn/CrossEntropyCriterion.py" -> "class:CrossEntropyCriterion(Criterion):";
    "class:CrossEntropyCriterion(Criterion):" -> "Fxn:__init__";
    "class:CrossEntropyCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:CrossEntropyCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:LogSoftMax()";
    "Fxn:__init__" -> "Fxn:ClassNLLCriterion(weights)";
    "Fxn:updateOutput" -> "Fxn:input.squeeze()";
    "Fxn:updateOutput" -> "Fxn:target.squeeze()";
    "Fxn:updateOutput" -> "Fxn:self.lsm.updateOutput(input)";
    "Fxn:updateOutput" -> "Fxn:self.nll.updateOutput(self.lsm.output,";
    "Fxn:updateGradInput" -> "Fxn:input.size()";
    "Fxn:updateGradInput" -> "Fxn:input.squeeze()";
    "Fxn:updateGradInput" -> "Fxn:target.squeeze()";
    "Fxn:updateGradInput" -> "Fxn:self.nll.updateGradInput(self.lsm.output,";
    "Fxn:updateGradInput" -> "Fxn:self.lsm.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:self.lsm.gradInput.view(size)";
    "/torch/legacy/nn/CSubTable.py" -> "Import:torch";
    "/torch/legacy/nn/CSubTable.py" -> "Import:Module";
    "/torch/legacy/nn/CSubTable.py" -> "class:CSubTable(Module):";
    "class:CSubTable(Module):" -> "Fxn:__init__";
    "class:CSubTable(Module):" -> "Fxn:updateOutput";
    "class:CSubTable(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input[0]).copy_(input[0])";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(-1,";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:input[1].new()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_as_(input[0]).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_as_(input[1]).copy_(gradOutput).mul_(-1)";
    "/torch/legacy/nn/DepthConcat.py" -> "Import:math";
    "/torch/legacy/nn/DepthConcat.py" -> "Import:torch";
    "/torch/legacy/nn/DepthConcat.py" -> "Import:Concat";
    "/torch/legacy/nn/DepthConcat.py" -> "class:DepthConcat(Concat):";
    "class:DepthConcat(Concat):" -> "Fxn:windowNarrow";
    "class:DepthConcat(Concat):" -> "Fxn:updateOutput";
    "class:DepthConcat(Concat):" -> "Fxn:updateGradInput";
    "class:DepthConcat(Concat):" -> "Fxn:accGradParameters";
    "class:DepthConcat(Concat):" -> "Fxn:backward";
    "class:DepthConcat(Concat):" -> "Fxn:accUpdateGradParameters";
    "Fxn:windowNarrow" -> "Fxn:output.narrow(self.dimension,";
    "Fxn:windowNarrow" -> "Fxn:currentOutput.size(self.dimension))";
    "Fxn:windowNarrow" -> "Fxn:currentOutput.size(dim)";
    "Fxn:windowNarrow" -> "Fxn:[(5-3)/2]";
    "Fxn:windowNarrow" -> "Fxn:[(9-5)/2]";
    "Fxn:windowNarrow" -> "Fxn:[(9-4)/2]";
    "Fxn:windowNarrow" -> "Fxn:outputWindow.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:self.modules[i].updateOutput(input)";
    "Fxn:updateOutput" -> "Fxn:outs.append(currentOutput)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(dim))";
    "Fxn:updateOutput" -> "Fxn:torch.Size(size)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(self.outputSize).zero_()";
    "Fxn:updateOutput" -> "Fxn:self.windowNarrow(self.output,";
    "Fxn:updateOutput" -> "Fxn:outputWindow.copy_(currentOutput)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:module.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:updateGradInput" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accGradParameters" -> "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:accGradParameters" -> "Fxn:module.accGradParameters(input,";
    "Fxn:accGradParameters" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:backward" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:backward" -> "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:backward" -> "Fxn:module.backward(input,";
    "Fxn:backward" -> "Fxn:self.gradInput.copy_(currentGradInput)";
    "Fxn:backward" -> "Fxn:self.gradInput.add_(currentGradInput)";
    "Fxn:backward" -> "Fxn:currentOutput.size(self.dimension)";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.windowNarrow(gradOutput,";
    "Fxn:accUpdateGradParameters" -> "Fxn:module.accUpdateGradParameters(input,";
    "Fxn:accUpdateGradParameters" -> "Fxn:currentOutput.size(self.dimension)";
    "/torch/legacy/nn/DistKLDivCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/DistKLDivCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/DistKLDivCriterion.py" -> "class:DistKLDivCriterion(Criterion):";
    "class:DistKLDivCriterion(Criterion):" -> "Fxn:__init__";
    "class:DistKLDivCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:DistKLDivCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(1)";
    "Fxn:updateOutput" -> "Fxn:input.is_same_size(target)";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.DistKLDivCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:input.is_same_size(target)";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.DistKLDivCriterion_updateGradInput(";
    "/torch/legacy/nn/DotProduct.py" -> "Import:torch";
    "/torch/legacy/nn/DotProduct.py" -> "Import:Module";
    "/torch/legacy/nn/DotProduct.py" -> "Import:clear";
    "/torch/legacy/nn/DotProduct.py" -> "class:DotProduct(Module):";
    "class:DotProduct(Module):" -> "Fxn:__init__";
    "class:DotProduct(Module):" -> "Fxn:updateOutput";
    "class:DotProduct(Module):" -> "Fxn:updateGradInput";
    "class:DotProduct(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:updateOutput" -> "Fxn:input1.new()";
    "Fxn:updateOutput" -> "Fxn:torch.mul(input1,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(input1.size(0))";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:input[1].new()";
    "Fxn:updateGradInput" -> "Fxn:gw1.resize_as_(v1).copy_(v2)";
    "Fxn:updateGradInput" -> "Fxn:gw2.resize_as_(v2).copy_(v1)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.contiguous().view(-1,";
    "Fxn:updateGradInput" -> "Fxn:1).expand_as(v1)";
    "Fxn:updateGradInput" -> "Fxn:gw1.mul_(go)";
    "Fxn:updateGradInput" -> "Fxn:gw2.mul_(go)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Dropout.py" -> "Import:torch";
    "/torch/legacy/nn/Dropout.py" -> "Import:Module";
    "/torch/legacy/nn/Dropout.py" -> "Import:clear";
    "/torch/legacy/nn/Dropout.py" -> "class:Dropout(Module):";
    "class:Dropout(Module):" -> "Fxn:__init__";
    "class:Dropout(Module):" -> "Fxn:updateOutput";
    "class:Dropout(Module):" -> "Fxn:updateGradInput";
    "class:Dropout(Module):" -> "Fxn:setp";
    "class:Dropout(Module):" -> "Fxn:__repr__";
    "class:Dropout(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.noise.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:self.noise.bernoulli_(1";
    "Fxn:updateOutput" -> "Fxn:self.noise.div_(1";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(self.noise)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.set_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(self.noise)";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({:.4f})'.format(self.p)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/ELU.py" -> "Import:torch";
    "/torch/legacy/nn/ELU.py" -> "Import:Module";
    "/torch/legacy/nn/ELU.py" -> "class:ELU(Module):";
    "class:ELU(Module):" -> "Fxn:__init__";
    "class:ELU(Module):" -> "Fxn:updateOutput";
    "class:ELU(Module):" -> "Fxn:updateGradInput";
    "class:ELU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.ELU_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.ELU_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:'{}(alpha={:.3f})'.format(str(type(self)),";
    "/torch/legacy/nn/Euclidean.py" -> "Import:math";
    "/torch/legacy/nn/Euclidean.py" -> "Import:torch";
    "/torch/legacy/nn/Euclidean.py" -> "Import:Module";
    "/torch/legacy/nn/Euclidean.py" -> "Import:clear";
    "/torch/legacy/nn/Euclidean.py" -> "class:Euclidean(Module):";
    "class:Euclidean(Module):" -> "Fxn:__init__";
    "class:Euclidean(Module):" -> "Fxn:reset";
    "class:Euclidean(Module):" -> "Fxn:_view";
    "class:Euclidean(Module):" -> "Fxn:updateOutput";
    "class:Euclidean(Module):" -> "Fxn:updateGradInput";
    "class:Euclidean(Module):" -> "Fxn:accGradParameters";
    "class:Euclidean(Module):" -> "Fxn:type";
    "class:Euclidean(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputSize,";
    "Fxn:__init__" -> "Fxn:self.gradInput.resize_(inputSize)";
    "Fxn:__init__" -> "Fxn:self.output.resize_(outputSize)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.weight.size(0))";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:_view" -> "Fxn:src.is_contiguous():";
    "Fxn:_view" -> "Fxn:res.set_(src.view(*args))";
    "Fxn:_view" -> "Fxn:res.set_(src.contiguous().view(*args))";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.weight.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(0),";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(1)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.size(0)";
    "Fxn:updateOutput" -> "Fxn:self._view(self._input,";
    "Fxn:updateOutput" -> "Fxn:self._input.expand(batchSize,";
    "Fxn:updateOutput" -> "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:updateOutput" -> "Fxn:self.weight.view(1,";
    "Fxn:updateOutput" -> "Fxn:self._weight.expand_as(self._repeat)";
    "Fxn:updateOutput" -> "Fxn:torch.typename(input)";
    "Fxn:updateOutput" -> "Fxn:self._repeat2.resize_as_(self._expand2).copy_(self._expand2)";
    "Fxn:updateOutput" -> "Fxn:self._repeat.add_(-1,";
    "Fxn:updateOutput" -> "Fxn:self._repeat.add_(-1,";
    "Fxn:updateOutput" -> "Fxn:torch.norm(self._repeat,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(batchSize,";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.output.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.updateOutput(input)";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(1)";
    "Fxn:updateGradInput" -> "Fxn:self._output.resize_as_(self.output).copy_(self.output).add_(0.0000001)";
    "Fxn:updateGradInput" -> "Fxn:self._view(self._gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size())";
    "Fxn:updateGradInput" -> "Fxn:torch.div(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:self._div.resize_(batchSize,";
    "Fxn:updateGradInput" -> "Fxn:self._div.expand(batchSize,";
    "Fxn:updateGradInput" -> "Fxn:torch.typename(input)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.resize_as_(self._expand3).copy_(self._expand3)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self._repeat,";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self._repeat2,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:accGradParameters" -> "Fxn:self.weight.size(0),";
    "Fxn:accGradParameters" -> "Fxn:self.weight.size(1)";
    "Fxn:accGradParameters" -> "Fxn:input.dim()";
    "Fxn:accGradParameters" -> "Fxn:input.new()";
    "Fxn:accGradParameters" -> "Fxn:torch.sum(self._repeat2,";
    "Fxn:accGradParameters" -> "Fxn:self._sum.resize_(inputSize,";
    "Fxn:accGradParameters" -> "Fxn:self.gradWeight.add_(-scale,";
    "Fxn:type" -> "Fxn:self.clearState()";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Exp.py" -> "Import:torch";
    "/torch/legacy/nn/Exp.py" -> "Import:Module";
    "/torch/legacy/nn/Exp.py" -> "class:Exp(Module):";
    "class:Exp(Module):" -> "Fxn:updateOutput";
    "class:Exp(Module):" -> "Fxn:updateGradInput";
    "Fxn:updateOutput" -> "Fxn:torch.exp(input,";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.output,";
    "/torch/legacy/nn/FlattenTable.py" -> "Import:torch";
    "/torch/legacy/nn/FlattenTable.py" -> "Import:Module";
    "/torch/legacy/nn/FlattenTable.py" -> "class:FlattenTable(Module):";
    "class:FlattenTable(Module):" -> "Fxn:__init__";
    "class:FlattenTable(Module):" -> "Fxn:_flatten";
    "class:FlattenTable(Module):" -> "Fxn:_checkMapping";
    "class:FlattenTable(Module):" -> "Fxn:_inverseFlatten";
    "class:FlattenTable(Module):" -> "Fxn:updateOutput";
    "class:FlattenTable(Module):" -> "Fxn:updateGradInput";
    "class:FlattenTable(Module):" -> "Fxn:type";
    "class:FlattenTable(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_flatten" -> "Fxn:input_map.append(self._flatten(output,";
    "Fxn:_flatten" -> "Fxn:output.append(input)";
    "Fxn:_checkMapping" -> "Fxn:self._checkMapping(output,";
    "Fxn:_inverseFlatten" -> "Fxn:gradInput.append(self._inverseFlatten(gradOutput,";
    "Fxn:updateOutput" -> "Fxn:self._checkMapping(self.output,";
    "Fxn:updateOutput" -> "Fxn:self._flatten(self.output,";
    "Fxn:updateGradInput" -> "Fxn:self._checkMapping(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:self._inverseFlatten(gradOutput,";
    "Fxn:type" -> "Fxn:self.clearState()";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/GradientReversal.py" -> "Import:torch";
    "/torch/legacy/nn/GradientReversal.py" -> "Import:Module";
    "/torch/legacy/nn/GradientReversal.py" -> "class:GradientReversal(Module):";
    "class:GradientReversal(Module):" -> "Fxn:__init__";
    "class:GradientReversal(Module):" -> "Fxn:setLambda";
    "class:GradientReversal(Module):" -> "Fxn:updateOutput";
    "class:GradientReversal(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(-self.lambd)";
    "/torch/legacy/nn/HardShrink.py" -> "Import:torch";
    "/torch/legacy/nn/HardShrink.py" -> "Import:Module";
    "/torch/legacy/nn/HardShrink.py" -> "class:HardShrink(Module):";
    "class:HardShrink(Module):" -> "Fxn:__init__";
    "class:HardShrink(Module):" -> "Fxn:updateOutput";
    "class:HardShrink(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.HardShrink_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.HardShrink_updateGradInput(";
    "/torch/legacy/nn/HardTanh.py" -> "Import:torch";
    "/torch/legacy/nn/HardTanh.py" -> "Import:Module";
    "/torch/legacy/nn/HardTanh.py" -> "class:HardTanh(Module):";
    "class:HardTanh(Module):" -> "Fxn:__init__";
    "class:HardTanh(Module):" -> "Fxn:updateOutput";
    "class:HardTanh(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.HardTanh_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.HardTanh_updateGradInput(";
    "/torch/legacy/nn/HingeEmbeddingCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/HingeEmbeddingCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/HingeEmbeddingCriterion.py" -> "class:HingeEmbeddingCriterion(Criterion):";
    "class:HingeEmbeddingCriterion(Criterion):" -> "Fxn:__init__";
    "class:HingeEmbeddingCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:HingeEmbeddingCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.buffer.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.buffer[torch.eq(y,";
    "Fxn:updateOutput" -> "Fxn:self.buffer.sum().item()";
    "Fxn:updateOutput" -> "Fxn:self.buffer.fill_(self.margin).add_(-1,";
    "Fxn:updateOutput" -> "Fxn:self.buffer.clamp_(min=0)";
    "Fxn:updateOutput" -> "Fxn:self.buffer[torch.eq(y,";
    "Fxn:updateOutput" -> "Fxn:self.buffer.sum().item()";
    "Fxn:updateOutput" -> "Fxn:input.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).copy_(y)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[torch.mul(torch.eq(y,";
    "Fxn:updateGradInput" -> "Fxn:torch.gt(input,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(1.";
    "Fxn:updateGradInput" -> "Fxn:input.nelement())";
    "/torch/legacy/nn/Identity.py" -> "Import:torch";
    "/torch/legacy/nn/Identity.py" -> "Import:Module";
    "/torch/legacy/nn/Identity.py" -> "Import:clear";
    "/torch/legacy/nn/Identity.py" -> "class:Identity(Module):";
    "class:Identity(Module):" -> "Fxn:updateOutput";
    "class:Identity(Module):" -> "Fxn:updateGradInput";
    "class:Identity(Module):" -> "Fxn:clearState";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "/torch/legacy/nn/Index.py" -> "Import:torch";
    "/torch/legacy/nn/Index.py" -> "Import:Module";
    "/torch/legacy/nn/Index.py" -> "class:Index(Module):";
    "class:Index(Module):" -> "Fxn:__init__";
    "class:Index(Module):" -> "Fxn:updateOutput";
    "class:Index(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:torch.index_select(t,";
    "Fxn:updateGradInput" -> "Fxn:gradInput.resize_as_(t).zero_()";
    "Fxn:updateGradInput" -> "Fxn:gradInput.index_add_(self.dimension,";
    "/torch/legacy/nn/JoinTable.py" -> "Import:torch";
    "/torch/legacy/nn/JoinTable.py" -> "Import:Module";
    "/torch/legacy/nn/JoinTable.py" -> "class:JoinTable(Module):";
    "class:JoinTable(Module):" -> "Fxn:__init__";
    "class:JoinTable(Module):" -> "Fxn:_getPositiveDimension";
    "class:JoinTable(Module):" -> "Fxn:updateOutput";
    "class:JoinTable(Module):" -> "Fxn:updateGradInput";
    "class:JoinTable(Module):" -> "Fxn:type";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:_getPositiveDimension" -> "Fxn:input[0].dim()";
    "Fxn:updateOutput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(dim)";
    "Fxn:updateOutput" -> "Fxn:torch.Size(size)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(self.size)";
    "Fxn:updateOutput" -> "Fxn:self.output.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(dim)).copy_(currentOutput)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(dim)";
    "Fxn:updateGradInput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.append(input[i].new())";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[i].resize_as_(input[i])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[:len(input)]";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.narrow(dim,";
    "Fxn:updateGradInput" -> "Fxn:currentOutput.size(dim))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[i].copy_(currentGradInput)";
    "Fxn:updateGradInput" -> "Fxn:currentOutput.size(dim)";
    "Fxn:type" -> "Fxn:self).type(type,";
    "/torch/legacy/nn/L1Cost.py" -> "Import:torch";
    "/torch/legacy/nn/L1Cost.py" -> "Import:Criterion";
    "/torch/legacy/nn/L1Cost.py" -> "Import:clear";
    "/torch/legacy/nn/L1Cost.py" -> "class:L1Cost(Criterion):";
    "class:L1Cost(Criterion):" -> "Fxn:__init__";
    "class:L1Cost(Criterion):" -> "Fxn:updateOutput";
    "class:L1Cost(Criterion):" -> "Fxn:updateGradInput";
    "class:L1Cost(Criterion):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(1)";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.L1Cost_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.L1Cost_updateGradInput(";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/L1HingeEmbeddingCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/L1HingeEmbeddingCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/L1HingeEmbeddingCriterion.py" -> "class:L1HingeEmbeddingCriterion(Criterion):";
    "class:L1HingeEmbeddingCriterion(Criterion):" -> "Fxn:__init__";
    "class:L1HingeEmbeddingCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:L1HingeEmbeddingCriterion(Criterion):" -> "Fxn:_mathsign";
    "class:L1HingeEmbeddingCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_as_(input[0])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_as_(input[1])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].copy_(input[0])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].add_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].norm(1)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].sign_()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].mul_(-1)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].zero_().add_(-1,";
    "/torch/legacy/nn/L1Penalty.py" -> "Import:torch";
    "/torch/legacy/nn/L1Penalty.py" -> "Import:Module";
    "/torch/legacy/nn/L1Penalty.py" -> "class:L1Penalty(Module):";
    "class:L1Penalty(Module):" -> "Fxn:__init__";
    "class:L1Penalty(Module):" -> "Fxn:updateOutput";
    "class:L1Penalty(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.nelement()";
    "Fxn:updateOutput" -> "Fxn:input.norm(1)";
    "Fxn:updateGradInput" -> "Fxn:input.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).copy_(input).sign_().mul_(m)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(gradOutput)";
    "/torch/legacy/nn/LeakyReLU.py" -> "Import:torch";
    "/torch/legacy/nn/LeakyReLU.py" -> "Import:Module";
    "/torch/legacy/nn/LeakyReLU.py" -> "class:LeakyReLU(Module):";
    "class:LeakyReLU(Module):" -> "Fxn:__init__";
    "class:LeakyReLU(Module):" -> "Fxn:updateOutput";
    "class:LeakyReLU(Module):" -> "Fxn:updateGradInput";
    "class:LeakyReLU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.LeakyReLU_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.LeakyReLU_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:'({:.4f})'.format(self.negval)";
    "/torch/legacy/nn/Linear.py" -> "Import:math";
    "/torch/legacy/nn/Linear.py" -> "Import:torch";
    "/torch/legacy/nn/Linear.py" -> "Import:Module";
    "/torch/legacy/nn/Linear.py" -> "Import:clear";
    "/torch/legacy/nn/Linear.py" -> "class:Linear(Module):";
    "class:Linear(Module):" -> "Fxn:__init__";
    "class:Linear(Module):" -> "Fxn:noBias";
    "class:Linear(Module):" -> "Fxn:reset";
    "class:Linear(Module):" -> "Fxn:_updateAddBuffer";
    "class:Linear(Module):" -> "Fxn:updateOutput";
    "class:Linear(Module):" -> "Fxn:updateGradInput";
    "class:Linear(Module):" -> "Fxn:accGradParameters";
    "class:Linear(Module):" -> "Fxn:clearState";
    "class:Linear(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputSize)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_updateAddBuffer" -> "Fxn:input.size(0)";
    "Fxn:_updateAddBuffer" -> "Fxn:input.new()";
    "Fxn:_updateAddBuffer" -> "Fxn:self.addBuffer.nelement()";
    "Fxn:_updateAddBuffer" -> "Fxn:self.addBuffer.resize_(nframe).fill_(1)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.size(0)";
    "Fxn:updateOutput" -> "Fxn:self.output.nelement()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(nframe,";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(0))";
    "Fxn:updateOutput" -> "Fxn:self.output.nelement()";
    "Fxn:updateOutput" -> "Fxn:self.output.zero_()";
    "Fxn:updateOutput" -> "Fxn:self._updateAddBuffer(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.addmm_(0,";
    "Fxn:updateOutput" -> "Fxn:self.weight.t())";
    "Fxn:updateOutput" -> "Fxn:self.output.addr_(self.addBuffer,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.zero_()";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.addmm_(0,";
    "Fxn:accGradParameters" -> "Fxn:input.dim()";
    "Fxn:accGradParameters" -> "Fxn:self.gradWeight.addmm_(scale,";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.t(),";
    "Fxn:accGradParameters" -> "Fxn:self._updateAddBuffer(input)";
    "Fxn:accGradParameters" -> "Fxn:self.gradBias.addmv_(scale,";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.t(),";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}";
    "Fxn:__repr__" -> "Fxn:{})'.format(self.weight.size(1),";
    "Fxn:__repr__" -> "Fxn:self.weight.size(0))";
    "/torch/legacy/nn/Log.py" -> "Import:torch";
    "/torch/legacy/nn/Log.py" -> "Import:Module";
    "/torch/legacy/nn/Log.py" -> "class:Log(Module):";
    "class:Log(Module):" -> "Fxn:updateOutput";
    "class:Log(Module):" -> "Fxn:updateGradInput";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.log_()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.fill_(1)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.div_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(gradOutput)";
    "/torch/legacy/nn/LogSigmoid.py" -> "Import:torch";
    "/torch/legacy/nn/LogSigmoid.py" -> "Import:Module";
    "/torch/legacy/nn/LogSigmoid.py" -> "Import:clear";
    "/torch/legacy/nn/LogSigmoid.py" -> "class:LogSigmoid(Module):";
    "class:LogSigmoid(Module):" -> "Fxn:__init__";
    "class:LogSigmoid(Module):" -> "Fxn:updateOutput";
    "class:LogSigmoid(Module):" -> "Fxn:updateGradInput";
    "class:LogSigmoid(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self._backend.LogSigmoid_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.LogSigmoid_updateGradInput(";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/LogSoftMax.py" -> "Import:torch";
    "/torch/legacy/nn/LogSoftMax.py" -> "Import:Module";
    "/torch/legacy/nn/LogSoftMax.py" -> "class:LogSoftMax(Module):";
    "class:LogSoftMax(Module):" -> "Fxn:__init__";
    "class:LogSoftMax(Module):" -> "Fxn:_get_dim";
    "class:LogSoftMax(Module):" -> "Fxn:updateOutput";
    "class:LogSoftMax(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_get_dim" -> "Fxn:input.dim()";
    "Fxn:_get_dim" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._backend.LogSoftMax_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self._get_dim(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.LogSoftMax_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self._get_dim(input)";
    "/torch/legacy/nn/LookupTable.py" -> "Import:torch";
    "/torch/legacy/nn/LookupTable.py" -> "Import:Module";
    "/torch/legacy/nn/LookupTable.py" -> "Import:clear";
    "/torch/legacy/nn/LookupTable.py" -> "class:LookupTable(Module):";
    "class:LookupTable(Module):" -> "Fxn:__init__";
    "class:LookupTable(Module):" -> "Fxn:accUpdateOnly";
    "class:LookupTable(Module):" -> "Fxn:setPadding";
    "class:LookupTable(Module):" -> "Fxn:setMaxNorm";
    "class:LookupTable(Module):" -> "Fxn:setNormType";
    "class:LookupTable(Module):" -> "Fxn:scaleGradByFreq";
    "class:LookupTable(Module):" -> "Fxn:reset";
    "class:LookupTable(Module):" -> "Fxn:_makeInputContiguous";
    "class:LookupTable(Module):" -> "Fxn:updateOutput";
    "class:LookupTable(Module):" -> "Fxn:updateGradInput";
    "class:LookupTable(Module):" -> "Fxn:accGradParameters";
    "class:LookupTable(Module):" -> "Fxn:renorm";
    "class:LookupTable(Module):" -> "Fxn:type";
    "class:LookupTable(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nIndex,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nIndex,";
    "Fxn:__init__" -> "Fxn:nOutput).zero_()";
    "Fxn:__init__" -> "Fxn:torch.IntTensor()";
    "Fxn:__init__" -> "Fxn:torch.LongTensor()";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:self.weight.normal_(0,";
    "Fxn:_makeInputContiguous" -> "Fxn:input.is_contiguous()";
    "Fxn:_makeInputContiguous" -> "Fxn:input.type()";
    "Fxn:_makeInputContiguous" -> "Fxn:self._input.type():";
    "Fxn:_makeInputContiguous" -> "Fxn:self._input.resize_(input.size()).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.renorm(input)";
    "Fxn:updateOutput" -> "Fxn:self._makeInputContiguous(input)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:torch.index_select(self.weight,";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:torch.index_select(self.weight,";
    "Fxn:updateOutput" -> "Fxn:input.view(-1),";
    "Fxn:updateOutput" -> "Fxn:self.output.view(input.size(0),";
    "Fxn:updateOutput" -> "Fxn:input.size(1),";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(1))";
    "Fxn:updateOutput" -> "Fxn:RuntimeError("input";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.type()";
    "Fxn:updateGradInput" -> "Fxn:input.type():";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.is_same_size(input):";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:accGradParameters" -> "Fxn:input.dim()";
    "Fxn:accGradParameters" -> "Fxn:input.view(-1)";
    "Fxn:accGradParameters" -> "Fxn:input.dim()";
    "Fxn:accGradParameters" -> "Fxn:RuntimeError("input";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.new()";
    "Fxn:accGradParameters" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:accGradParameters" -> "Fxn:self._backend.LookupTable_accGradParameters(";
    "Fxn:renorm" -> "Fxn:self._input.resize_(input.size()).copy_(input)";
    "Fxn:renorm" -> "Fxn:row_idx.dim()";
    "Fxn:renorm" -> "Fxn:row_idx.view(-1)";
    "Fxn:renorm" -> "Fxn:row_idx.dim()";
    "Fxn:renorm" -> "Fxn:RuntimeError("input";
    "Fxn:renorm" -> "Fxn:self._backend.LookupTable_renorm(";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:torch.cuda.LongTensor()";
    "Fxn:type" -> "Fxn:torch.cuda.LongTensor()";
    "Fxn:type" -> "Fxn:torch.cuda.LongTensor()";
    "Fxn:type" -> "Fxn:torch.cuda.LongTensor()";
    "Fxn:type" -> "Fxn:torch.IntTensor()";
    "Fxn:type" -> "Fxn:torch.LongTensor()";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/MarginCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/MarginCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/MarginCriterion.py" -> "class:MarginCriterion(Criterion):";
    "class:MarginCriterion(Criterion):" -> "Fxn:__init__";
    "class:MarginCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:MarginCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.MarginCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.MarginCriterion_updateGradInput(";
    "/torch/legacy/nn/MarginRankingCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/MarginRankingCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/MarginRankingCriterion.py" -> "class:MarginRankingCriterion(Criterion):";
    "class:MarginRankingCriterion(Criterion):" -> "Fxn:__init__";
    "class:MarginRankingCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:MarginRankingCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:updateOutput" -> "Fxn:input[0].size(0)";
    "Fxn:updateOutput" -> "Fxn:input[0].clone()";
    "Fxn:updateOutput" -> "Fxn:self._output.resize_as_(input[0])";
    "Fxn:updateOutput" -> "Fxn:self._output.copy_(input[0])";
    "Fxn:updateOutput" -> "Fxn:self._output.add_(-1,";
    "Fxn:updateOutput" -> "Fxn:self._output.mul_(-1).mul_(y)";
    "Fxn:updateOutput" -> "Fxn:self._output.add_(self.margin)";
    "Fxn:updateOutput" -> "Fxn:self._output.clamp_(min=0)";
    "Fxn:updateOutput" -> "Fxn:self._output.sum().item()";
    "Fxn:updateOutput" -> "Fxn:y.size(0)";
    "Fxn:updateGradInput" -> "Fxn:input[0].size(0)";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:self.dist.resize_as_(input[0]).copy_(input[0])";
    "Fxn:updateGradInput" -> "Fxn:dist.add_(-1,";
    "Fxn:updateGradInput" -> "Fxn:dist.mul_(-1).mul_(y)";
    "Fxn:updateGradInput" -> "Fxn:dist.add_(self.margin)";
    "Fxn:updateGradInput" -> "Fxn:torch.ge(dist,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_(dist.size())";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_(dist.size())";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].copy_(mask)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].mul_(-1).mul_(y)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].copy_(mask)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].mul_(y)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].div_(y.size(0))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].div_(y.size(0))";
    "/torch/legacy/nn/MaskedSelect.py" -> "Import:torch";
    "/torch/legacy/nn/MaskedSelect.py" -> "Import:Module";
    "/torch/legacy/nn/MaskedSelect.py" -> "Import:clear";
    "/torch/legacy/nn/MaskedSelect.py" -> "class:MaskedSelect(Module):";
    "class:MaskedSelect(Module):" -> "Fxn:__init__";
    "class:MaskedSelect(Module):" -> "Fxn:updateOutput";
    "class:MaskedSelect(Module):" -> "Fxn:updateGradInput";
    "class:MaskedSelect(Module):" -> "Fxn:type";
    "class:MaskedSelect(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.LongTensor()";
    "Fxn:__init__" -> "Fxn:torch.LongTensor()";
    "Fxn:__init__" -> "Fxn:torch.FloatTensor()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:torch.ByteTensor()";
    "Fxn:updateOutput" -> "Fxn:torch.masked_select(input,";
    "Fxn:updateGradInput" -> "Fxn:input.type()";
    "Fxn:updateGradInput" -> "Fxn:torch.arange(0,";
    "Fxn:updateGradInput" -> "Fxn:mask.nelement(),";
    "Fxn:updateGradInput" -> "Fxn:out=self._maskIndexBufferCPU).resize_(mask.size())";
    "Fxn:updateGradInput" -> "Fxn:self._maskIndexBuffer.resize_(self._maskIndexBufferCPU.size()).copy_(self._maskIndexBufferCPU)";
    "Fxn:updateGradInput" -> "Fxn:torch.arange(0,";
    "Fxn:updateGradInput" -> "Fxn:mask.nelement(),";
    "Fxn:updateGradInput" -> "Fxn:out=self._maskIndexBuffer).resize_(mask.size())";
    "Fxn:updateGradInput" -> "Fxn:torch.masked_select(self._maskIndexBuffer,";
    "Fxn:updateGradInput" -> "Fxn:self._gradBuffer.resize_(input.nelement()).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self._gradBuffer.scatter_(0,";
    "Fxn:updateGradInput" -> "Fxn:self._gradBuffer.resize_(input.size())";
    "Fxn:updateGradInput" -> "Fxn:self._gradMask.resize_(mask.size()).fill_(0)]";
    "Fxn:type" -> "Fxn:self._gradBuffer.type(type)";
    "Fxn:type" -> "Fxn:self.gradInput.type(type)";
    "Fxn:type" -> "Fxn:self.output.type(type)";
    "Fxn:type" -> "Fxn:self._maskIndexBuffer.long()";
    "Fxn:type" -> "Fxn:self._maskIndices.long()";
    "Fxn:type" -> "Fxn:self._gradMask.byte()";
    "Fxn:type" -> "Fxn:self._maskIndexBuffer.cuda()";
    "Fxn:type" -> "Fxn:self._maskIndices.cuda()";
    "Fxn:type" -> "Fxn:self._gradMask.cuda()";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "/torch/legacy/nn/Max.py" -> "Import:torch";
    "/torch/legacy/nn/Max.py" -> "Import:Module";
    "/torch/legacy/nn/Max.py" -> "Import:clear,";
    "/torch/legacy/nn/Max.py" -> "class:Max(Module):";
    "class:Max(Module):" -> "Fxn:__init__";
    "class:Max(Module):" -> "Fxn:_getPositiveDimension";
    "class:Max(Module):" -> "Fxn:_lazyInit";
    "class:Max(Module):" -> "Fxn:updateOutput";
    "class:Max(Module):" -> "Fxn:updateGradInput";
    "class:Max(Module):" -> "Fxn:type";
    "class:Max(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension" -> "Fxn:input.dim()";
    "Fxn:_lazyInit" -> "Fxn:self.output.new()";
    "Fxn:_lazyInit" -> "Fxn:torch.LongTensor())";
    "Fxn:updateOutput" -> "Fxn:self._lazyInit()";
    "Fxn:updateOutput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateOutput" -> "Fxn:torch.max(input,";
    "Fxn:updateOutput" -> "Fxn:out=(self._output,";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(self._output.select(dimension,";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(self._output)";
    "Fxn:updateGradInput" -> "Fxn:self._lazyInit()";
    "Fxn:updateGradInput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:addSingletondimension(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_().scatter_(dimension,";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:indices.type('torch.cuda.LongTensor')";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:indices.long()";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Mean.py" -> "Import:torch";
    "/torch/legacy/nn/Mean.py" -> "Import:Sum";
    "/torch/legacy/nn/Mean.py" -> "class:Mean(Sum):";
    "class:Mean(Sum):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__(dimension,";
    "/torch/legacy/nn/Min.py" -> "Import:torch";
    "/torch/legacy/nn/Min.py" -> "Import:Module";
    "/torch/legacy/nn/Min.py" -> "Import:clear,";
    "/torch/legacy/nn/Min.py" -> "class:Min(Module):";
    "class:Min(Module):" -> "Fxn:__init__";
    "class:Min(Module):" -> "Fxn:_getPositiveDimension";
    "class:Min(Module):" -> "Fxn:_lazyInit";
    "class:Min(Module):" -> "Fxn:updateOutput";
    "class:Min(Module):" -> "Fxn:updateGradInput";
    "class:Min(Module):" -> "Fxn:type";
    "class:Min(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension" -> "Fxn:input.dim()";
    "Fxn:_lazyInit" -> "Fxn:self.output.new()";
    "Fxn:_lazyInit" -> "Fxn:self.output.type()";
    "Fxn:_lazyInit" -> "Fxn:torch.LongTensor())";
    "Fxn:updateOutput" -> "Fxn:self._lazyInit()";
    "Fxn:updateOutput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateOutput" -> "Fxn:torch.min(input,";
    "Fxn:updateOutput" -> "Fxn:out=(self._output,";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(self._output.select(dimension,";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(self._output)";
    "Fxn:updateGradInput" -> "Fxn:self._lazyInit()";
    "Fxn:updateGradInput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:addSingletondimension(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_().scatter_(dimension,";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:indices.type('torch.cuda.LongTensor')";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:indices.long()";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/MixtureTable.py" -> "Import:torch";
    "/torch/legacy/nn/MixtureTable.py" -> "Import:Module";
    "/torch/legacy/nn/MixtureTable.py" -> "Import:clear,";
    "/torch/legacy/nn/MixtureTable.py" -> "class:MixtureTable(Module):";
    "class:MixtureTable(Module):" -> "Fxn:__init__";
    "class:MixtureTable(Module):" -> "Fxn:updateOutput";
    "class:MixtureTable(Module):" -> "Fxn:updateGradInput";
    "class:MixtureTable(Module):" -> "Fxn:type";
    "class:MixtureTable(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:updateOutput" -> "Fxn:input[0].new()";
    "Fxn:updateOutput" -> "Fxn:input[0].new()";
    "Fxn:updateOutput" -> "Fxn:input[0].new()";
    "Fxn:updateOutput" -> "Fxn:gaterInput.size(0)";
    "Fxn:updateOutput" -> "Fxn:gaterInput.size(self.dimG)";
    "Fxn:updateOutput" -> "Fxn:RuntimeError("Should";
    "Fxn:updateOutput" -> "Fxn:gaterInput.size(0)";
    "Fxn:updateOutput" -> "Fxn:gaterInput.size(self.dimG)";
    "Fxn:updateOutput" -> "Fxn:torch.Size(size)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(expertInput)";
    "Fxn:updateOutput" -> "Fxn:gaterInput.view(self.size)";
    "Fxn:updateOutput" -> "Fxn:self.output.zero_()";
    "Fxn:updateOutput" -> "Fxn:self._gaterView.select(self.dim,";
    "Fxn:updateOutput" -> "Fxn:i).expand_as(expertInput)";
    "Fxn:updateOutput" -> "Fxn:self.output.addcmul_(expertInput,";
    "Fxn:updateOutput" -> "Fxn:expertInputs.dim()";
    "Fxn:updateOutput" -> "Fxn:gaterInput.size(0)";
    "Fxn:updateOutput" -> "Fxn:gaterInput.size(self.dimG)";
    "Fxn:updateOutput" -> "Fxn:torch.Size(size)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(expertInputs.select(self.dim,";
    "Fxn:updateOutput" -> "Fxn:gaterInput.view(self.size)";
    "Fxn:updateOutput" -> "Fxn:torch.mul(self._gaterView.expand_as(expertInputs),";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self._expert,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(expertInputs.select(self.dim,";
    "Fxn:updateGradInput" -> "Fxn:recursiveResizeAs(self.gradInput,";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:expertInput.clone()";
    "Fxn:updateGradInput" -> "Fxn:expertGradInput.resize_as_(expertInput)";
    "Fxn:updateGradInput" -> "Fxn:gaterGradInput.resize_as_(gaterInput)";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:self._expert.view(-1)";
    "Fxn:updateGradInput" -> "Fxn:self._expert.view(gradOutput.size(0),";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self._expertView,";
    "Fxn:updateGradInput" -> "Fxn:self._sum.select(self.dimG,";
    "Fxn:updateGradInput" -> "Fxn:gaterGradInput.select(self.dimG,";
    "Fxn:updateGradInput" -> "Fxn:i).copy_(self._sum.select(self.dimG,";
    "Fxn:updateGradInput" -> "Fxn:self._gaterView.select(self.dim,";
    "Fxn:updateGradInput" -> "Fxn:i).expand_as(expertGradInput)";
    "Fxn:updateGradInput" -> "Fxn:expertGradInput.mul_(gate,";
    "Fxn:updateGradInput" -> "Fxn:torch.Size(size2)";
    "Fxn:updateGradInput" -> "Fxn:gaterGradInput.resize_as_(gaterInput)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.contiguous().view(torch.Size(self.size2))";
    "Fxn:updateGradInput" -> "Fxn:self._expertView.expand_as(expertInputs)";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:self._expert.transpose(self.dim,";
    "Fxn:updateGradInput" -> "Fxn:expert.is_contiguous():";
    "Fxn:updateGradInput" -> "Fxn:self._expert2.resize_as_(expert)";
    "Fxn:updateGradInput" -> "Fxn:self._expert2.copy_(expert)";
    "Fxn:updateGradInput" -> "Fxn:expert.view(gaterInput.size(0),";
    "Fxn:updateGradInput" -> "Fxn:expert.view(gaterInput.size(0),";
    "Fxn:updateGradInput" -> "Fxn:gaterInput.size(1),";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self._expertView2,";
    "Fxn:updateGradInput" -> "Fxn:gaterGradInput.resize_as_(gaterInput)";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self._gaterView.expand_as(expertInputs),";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/MM.py" -> "Import:torch";
    "/torch/legacy/nn/MM.py" -> "Import:Module";
    "/torch/legacy/nn/MM.py" -> "class:MM(Module):";
    "class:MM(Module):" -> "Fxn:__init__";
    "class:MM(Module):" -> "Fxn:updateOutput";
    "class:MM(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:updateOutput" -> "Fxn:a.ndimension()";
    "Fxn:updateOutput" -> "Fxn:a.ndimension()";
    "Fxn:updateOutput" -> "Fxn:a.dim()";
    "Fxn:updateOutput" -> "Fxn:b.dim()";
    "Fxn:updateOutput" -> "Fxn:a.ndimension()";
    "Fxn:updateOutput" -> "Fxn:a.t()";
    "Fxn:updateOutput" -> "Fxn:b.t()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(a.size(0),";
    "Fxn:updateOutput" -> "Fxn:b.size(1))";
    "Fxn:updateOutput" -> "Fxn:torch.mm(a,";
    "Fxn:updateOutput" -> "Fxn:a.transpose(1,";
    "Fxn:updateOutput" -> "Fxn:b.transpose(1,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(a.size(0),";
    "Fxn:updateOutput" -> "Fxn:a.size(1),";
    "Fxn:updateOutput" -> "Fxn:b.size(2))";
    "Fxn:updateOutput" -> "Fxn:torch.bmm(a,";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:input[1].new()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_as_(a)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_as_(b)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:a.dim()";
    "Fxn:updateGradInput" -> "Fxn:b.dim()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.dim()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:a.transpose(h_dim,";
    "Fxn:updateGradInput" -> "Fxn:b.transpose(h_dim,";
    "Fxn:updateGradInput" -> "Fxn:f)(b,";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.transpose(h_dim,";
    "Fxn:updateGradInput" -> "Fxn:f)(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:f)(gradOutput.transpose(h_dim,";
    "Fxn:updateGradInput" -> "Fxn:f)(a,";
    "/torch/legacy/nn/Module.py" -> "Import:torch";
    "/torch/legacy/nn/Module.py" -> "Import:torch._thnn";
    "/torch/legacy/nn/Module.py" -> "Import:clear,";
    "/torch/legacy/nn/Module.py" -> "class:Module(object):";
    "class:Module(object):" -> "Fxn:__init__";
    "class:Module(object):" -> "Fxn:__repr__";
    "class:Module(object):" -> "Fxn:parameters";
    "class:Module(object):" -> "Fxn:updateOutput";
    "class:Module(object):" -> "Fxn:forward";
    "class:Module(object):" -> "Fxn:backward";
    "class:Module(object):" -> "Fxn:backwardUpdate";
    "class:Module(object):" -> "Fxn:updateGradInput";
    "class:Module(object):" -> "Fxn:accGradParameters";
    "class:Module(object):" -> "Fxn:accUpdateGradParameters";
    "class:Module(object):" -> "Fxn:sharedAccUpdateGradParameters";
    "class:Module(object):" -> "Fxn:zeroGradParameters";
    "class:Module(object):" -> "Fxn:updateParameters";
    "class:Module(object):" -> "Fxn:training";
    "class:Module(object):" -> "Fxn:evaluate";
    "class:Module(object):" -> "Fxn:share";
    "class:Module(object):" -> "Fxn:clone";
    "class:Module(object):" -> "Fxn:type";
    "class:Module(object):" -> "Fxn:float";
    "class:Module(object):" -> "Fxn:double";
    "class:Module(object):" -> "Fxn:cuda";
    "class:Module(object):" -> "Fxn:reset";
    "class:Module(object):" -> "Fxn:write";
    "class:Module(object):" -> "Fxn:read";
    "class:Module(object):" -> "Fxn:_flatten";
    "class:Module(object):" -> "Fxn:isCompact";
    "class:Module(object):" -> "Fxn:flattenParameters";
    "class:Module(object):" -> "Fxn:apply";
    "class:Module(object):" -> "Fxn:findModules";
    "class:Module(object):" -> "Fxn:listModules";
    "class:Module(object):" -> "Fxn:clearState";
    "class:Module(object):" -> "Fxn:replace";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:self.output.type()";
    "Fxn:__init__" -> "Fxn:torch._thnn.type2backend[self.output.type()]";
    "Fxn:forward" -> "Fxn:self.updateOutput(input)";
    "Fxn:backward" -> "Fxn:self.updateGradInput(input,";
    "Fxn:backward" -> "Fxn:self.accGradParameters(input,";
    "Fxn:backwardUpdate" -> "Fxn:self.updateGradInput(input,";
    "Fxn:backwardUpdate" -> "Fxn:self.accUpdateGradParameters(input,";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.accGradParameters(input,";
    "Fxn:sharedAccUpdateGradParameters" -> "Fxn:self.parameters():";
    "Fxn:sharedAccUpdateGradParameters" -> "Fxn:self.zeroGradParameters()";
    "Fxn:sharedAccUpdateGradParameters" -> "Fxn:self.accGradParameters(input,";
    "Fxn:sharedAccUpdateGradParameters" -> "Fxn:self.updateParameters(lr)";
    "Fxn:zeroGradParameters" -> "Fxn:self.parameters()";
    "Fxn:zeroGradParameters" -> "Fxn:grad.zero_()";
    "Fxn:updateParameters" -> "Fxn:self.parameters()";
    "Fxn:updateParameters" -> "Fxn:self.parameters()";
    "Fxn:updateParameters" -> "Fxn:p.add_(-learningRate,";
    "Fxn:type" -> "Fxn:self.__dict__.items():";
    "Fxn:type" -> "Fxn:recursiveType(param,";
    "Fxn:float" -> "Fxn:self.type('torch.FloatTensor',";
    "Fxn:double" -> "Fxn:self.type('torch.DoubleTensor',";
    "Fxn:cuda" -> "Fxn:self.type('torch.cuda.FloatTensor',";
    "Fxn:read" -> "Fxn:for_each()";
    "Fxn:isCompact" -> "Fxn:size.cumprod(0)?";
    "Fxn:isCompact" -> "Fxn:torch.sort(torch.LongTensor(tensor.stride()),";
    "Fxn:isCompact" -> "Fxn:torch.LongTensor(list(tensor.size())).index_select(0,";
    "Fxn:isCompact" -> "Fxn:1).sum())";
    "Fxn:isCompact" -> "Fxn:sortedStride.narrow(0,";
    "Fxn:isCompact" -> "Fxn:nRealDim).clone()";
    "Fxn:isCompact" -> "Fxn:sortedSize.narrow(0,";
    "Fxn:isCompact" -> "Fxn:nRealDim).clone()";
    "Fxn:isCompact" -> "Fxn:tensor.new().set_(tensor.storage(),";
    "Fxn:isCompact" -> "Fxn:t.is_contiguous()";
    "Fxn:isCompact" -> "Fxn:torch.Tensor()";
    "Fxn:isCompact" -> "Fxn:Module._flattenTensorBuffer.get(type(parameters[0]),";
    "Fxn:isCompact" -> "Fxn:param.storage()";
    "Fxn:isCompact" -> "Fxn:storage.size()";
    "Fxn:isCompact" -> "Fxn:parameterMeta.append({";
    "Fxn:isCompact" -> "Fxn:param.storage_offset()";
    "Fxn:isCompact" -> "Fxn:param.size(),";
    "Fxn:isCompact" -> "Fxn:param.stride()";
    "Fxn:isCompact" -> "Fxn:BufferTensor(num_parameters).zero_()";
    "Fxn:isCompact" -> "Fxn:BufferTensor().set_(flatParameters.storage(),";
    "Fxn:isCompact" -> "Fxn:tmp.fill_(1)";
    "Fxn:isCompact" -> "Fxn:isCompact(tmp)";
    "Fxn:isCompact" -> "Fxn:flatParameters.byte().clone()";
    "Fxn:isCompact" -> "Fxn:flatParameters.long().cumsum(0)";
    "Fxn:isCompact" -> "Fxn:storages.values():";
    "Fxn:isCompact" -> "Fxn:flatParameters[slice(offset,";
    "Fxn:isCompact" -> "Fxn:storage.size())].copy_(Tensor().set_(storage))";
    "Fxn:isCompact" -> "Fxn:param.set_()";
    "Fxn:isCompact" -> "Fxn:BufferTensor(used_parameters).copy_(";
    "Fxn:isCompact" -> "Fxn:flatParameters.masked_select(maskParameters))";
    "Fxn:isCompact" -> "Fxn:Tensor(flatParameters.nelement()).copy_(flatParameters)";
    "Fxn:isCompact" -> "Fxn:param.set_(flatParameters.storage(),";
    "Fxn:flattenParameters" -> "Fxn:self.parameters()";
    "Fxn:flattenParameters" -> "Fxn:self._flatten(parameters),";
    "Fxn:flattenParameters" -> "Fxn:self._flatten(gradParameters)";
    "Fxn:flattenParameters" -> "Fxn:p.nelement()";
    "Fxn:flattenParameters" -> "Fxn:g.nelement()";
    "Fxn:flattenParameters" -> "Fxn:param.storage_offset()";
    "Fxn:flattenParameters" -> "Fxn:grad.storage_offset()";
    "Fxn:apply" -> "Fxn:callback(self)";
    "Fxn:apply" -> "Fxn:module.apply(callback)";
    "Fxn:findModules" -> "Fxn:nodes.append(self)";
    "Fxn:findModules" -> "Fxn:containers.append(container)";
    "Fxn:findModules" -> "Fxn:child.findModules(cls,";
    "Fxn:findModules" -> "Fxn:nodes.extend(child_nodes)";
    "Fxn:findModules" -> "Fxn:containers.extend(child_containers)";
    "Fxn:listModules" -> "Fxn:modules.extend(child.listModules())";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:replace" -> "Fxn:callback(self)";
    "Fxn:replace" -> "Fxn:module.replace(callback)";
    "/torch/legacy/nn/MSECriterion.py" -> "Import:torch";
    "/torch/legacy/nn/MSECriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/MSECriterion.py" -> "class:MSECriterion(Criterion):";
    "class:MSECriterion(Criterion):" -> "Fxn:__init__";
    "class:MSECriterion(Criterion):" -> "Fxn:updateOutput";
    "class:MSECriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.MSECriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:torch.Tensor([1]).type(input.type())";
    "Fxn:updateGradInput" -> "Fxn:self._backend.MSECriterion_updateGradInput(";
    "/torch/legacy/nn/Mul.py" -> "Import:math";
    "/torch/legacy/nn/Mul.py" -> "Import:torch";
    "/torch/legacy/nn/Mul.py" -> "Import:Module";
    "/torch/legacy/nn/Mul.py" -> "class:Mul(Module):";
    "class:Mul(Module):" -> "Fxn:__init__";
    "class:Mul(Module):" -> "Fxn:reset";
    "class:Mul(Module):" -> "Fxn:updateOutput";
    "class:Mul(Module):" -> "Fxn:updateGradInput";
    "class:Mul(Module):" -> "Fxn:accGradParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(1)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(1)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.weight.size(0))";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(self.weight[0])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(self.weight[0],";
    "Fxn:accGradParameters" -> "Fxn:input.contiguous().view(-1).dot(gradOutput.contiguous().view(-1)))";
    "/torch/legacy/nn/MulConstant.py" -> "Import:torch";
    "/torch/legacy/nn/MulConstant.py" -> "Import:Module";
    "/torch/legacy/nn/MulConstant.py" -> "class:MulConstant(Module):";
    "class:MulConstant(Module):" -> "Fxn:__init__";
    "class:MulConstant(Module):" -> "Fxn:updateOutput";
    "class:MulConstant(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.mul_(self.constant_scalar)";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(self.constant_scalar)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.mul_(self.constant_scalar)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.set_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:input.div_(self.constant_scalar)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(self.constant_scalar)";
    "/torch/legacy/nn/MultiCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/MultiCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/MultiCriterion.py" -> "Import:recursiveResizeAs,";
    "/torch/legacy/nn/MultiCriterion.py" -> "class:MultiCriterion(Criterion):";
    "class:MultiCriterion(Criterion):" -> "Fxn:__init__";
    "class:MultiCriterion(Criterion):" -> "Fxn:add";
    "class:MultiCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:MultiCriterion(Criterion):" -> "Fxn:updateGradInput";
    "class:MultiCriterion(Criterion):" -> "Fxn:type";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.DoubleStorage()";
    "Fxn:add" -> "Fxn:self.criterions.append(criterion)";
    "Fxn:add" -> "Fxn:torch.DoubleStorage(len(self.criterions))";
    "Fxn:add" -> "Fxn:new_weights[len(self.criterions)";
    "Fxn:updateOutput" -> "Fxn:self.criterions[i].updateOutput(input,";
    "Fxn:updateGradInput" -> "Fxn:recursiveResizeAs(self.gradInput,";
    "Fxn:updateGradInput" -> "Fxn:recursiveFill(self.gradInput,";
    "Fxn:updateGradInput" -> "Fxn:recursiveAdd(self.gradInput,";
    "Fxn:updateGradInput" -> "Fxn:self.criterions[i].updateGradInput(input,";
    "Fxn:type" -> "Fxn:criterion.type(type)";
    "Fxn:type" -> "Fxn:self).type(type)";
    "/torch/legacy/nn/MultiLabelMarginCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/MultiLabelMarginCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/MultiLabelMarginCriterion.py" -> "class:MultiLabelMarginCriterion(Criterion):";
    "class:MultiLabelMarginCriterion(Criterion):" -> "Fxn:__init__";
    "class:MultiLabelMarginCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:MultiLabelMarginCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:target.long()";
    "Fxn:updateOutput" -> "Fxn:self._backend.MultiLabelMarginCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:target.long()";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.MultiLabelMarginCriterion_updateGradInput(";
    "/torch/legacy/nn/MultiLabelSoftMarginCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/MultiLabelSoftMarginCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/MultiLabelSoftMarginCriterion.py" -> "Import:Sigmoid";
    "/torch/legacy/nn/MultiLabelSoftMarginCriterion.py" -> "Import:BCECriterion";
    "/torch/legacy/nn/MultiLabelSoftMarginCriterion.py" -> "class:MultiLabelSoftMarginCriterion(Criterion):";
    "class:MultiLabelSoftMarginCriterion(Criterion):" -> "Fxn:__init__";
    "class:MultiLabelSoftMarginCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:MultiLabelSoftMarginCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Sigmoid()";
    "Fxn:__init__" -> "Fxn:BCECriterion(weights)";
    "Fxn:updateOutput" -> "Fxn:input.nelement()";
    "Fxn:updateOutput" -> "Fxn:input.squeeze()";
    "Fxn:updateOutput" -> "Fxn:target.nelement()";
    "Fxn:updateOutput" -> "Fxn:target.squeeze()";
    "Fxn:updateOutput" -> "Fxn:self.lsm.updateOutput(input)";
    "Fxn:updateOutput" -> "Fxn:self.nll.updateOutput(self.lsm.output,";
    "Fxn:updateGradInput" -> "Fxn:input.size()";
    "Fxn:updateGradInput" -> "Fxn:input.nelement()";
    "Fxn:updateGradInput" -> "Fxn:input.squeeze()";
    "Fxn:updateGradInput" -> "Fxn:target.nelement()";
    "Fxn:updateGradInput" -> "Fxn:target.squeeze()";
    "Fxn:updateGradInput" -> "Fxn:self.nll.updateGradInput(self.lsm.output,";
    "Fxn:updateGradInput" -> "Fxn:self.lsm.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:self.lsm.gradInput.view(size)";
    "/torch/legacy/nn/MultiMarginCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/MultiMarginCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/MultiMarginCriterion.py" -> "class:MultiMarginCriterion(Criterion):";
    "class:MultiMarginCriterion(Criterion):" -> "Fxn:__init__";
    "class:MultiMarginCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:MultiMarginCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError("only";
    "Fxn:__init__" -> "Fxn:weights.dim()";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:target.long()";
    "Fxn:updateOutput" -> "Fxn:self._backend.MultiMarginCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:target.long()";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.MultiMarginCriterion_updateGradInput(";
    "/torch/legacy/nn/MV.py" -> "Import:torch";
    "/torch/legacy/nn/MV.py" -> "Import:Module";
    "/torch/legacy/nn/MV.py" -> "class:MV(Module):";
    "class:MV(Module):" -> "Fxn:__init__";
    "class:MV(Module):" -> "Fxn:updateOutput";
    "class:MV(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:[torch.Tensor(),";
    "Fxn:__init__" -> "Fxn:torch.Tensor()]";
    "Fxn:updateOutput" -> "Fxn:M.ndimension()";
    "Fxn:updateOutput" -> "Fxn:M.ndimension()";
    "Fxn:updateOutput" -> "Fxn:M.ndimension()";
    "Fxn:updateOutput" -> "Fxn:v.ndimension()";
    "Fxn:updateOutput" -> "Fxn:M.transpose(0,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(M.size(0))";
    "Fxn:updateOutput" -> "Fxn:torch.mv(M,";
    "Fxn:updateOutput" -> "Fxn:v.ndimension()";
    "Fxn:updateOutput" -> "Fxn:M.transpose(1,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(M.size(0),";
    "Fxn:updateOutput" -> "Fxn:M.size(1),";
    "Fxn:updateOutput" -> "Fxn:torch.bmm(M,";
    "Fxn:updateOutput" -> "Fxn:v.view(v.size(0),";
    "Fxn:updateOutput" -> "Fxn:v.size(1),";
    "Fxn:updateOutput" -> "Fxn:out=self.output).resize_(M.size(0),";
    "Fxn:updateOutput" -> "Fxn:M.size(1))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_as_(M)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_as_(v)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.contiguous()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:M.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:v.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:M.size(0)";
    "Fxn:updateGradInput" -> "Fxn:M.size(1)";
    "Fxn:updateGradInput" -> "Fxn:M.size(2)";
    "Fxn:updateGradInput" -> "Fxn:torch.bmm(v.view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:torch.bmm(M,";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:out=self.gradInput[1].view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:torch.bmm(gradOutput.view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:v.view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:torch.bmm(M.transpose(1,";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:out=self.gradInput[1].view(bdim,";
    "Fxn:updateGradInput" -> "Fxn:M.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:v.ndimension()";
    "Fxn:updateGradInput" -> "Fxn:torch.ger(v,";
    "Fxn:updateGradInput" -> "Fxn:torch.ger(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:M.t()";
    "/torch/legacy/nn/Narrow.py" -> "Import:torch";
    "/torch/legacy/nn/Narrow.py" -> "Import:Module";
    "/torch/legacy/nn/Narrow.py" -> "class:Narrow(Module):";
    "class:Narrow(Module):" -> "Fxn:__init__";
    "class:Narrow(Module):" -> "Fxn:updateOutput";
    "class:Narrow(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.size(self.dimension)";
    "Fxn:updateOutput" -> "Fxn:input.narrow(self.dimension,";
    "Fxn:updateOutput" -> "Fxn:self.output.type_as(output)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(output).copy_(output)";
    "Fxn:updateGradInput" -> "Fxn:input.size(self.dimension)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.narrow(self.dimension,";
    "Fxn:updateGradInput" -> "Fxn:length).copy_(gradOutput)";
    "/torch/legacy/nn/NarrowTable.py" -> "Import:torch";
    "/torch/legacy/nn/NarrowTable.py" -> "Import:Module";
    "/torch/legacy/nn/NarrowTable.py" -> "Import:clear,";
    "/torch/legacy/nn/NarrowTable.py" -> "class:NarrowTable(Module):";
    "class:NarrowTable(Module):" -> "Fxn:__init__";
    "class:NarrowTable(Module):" -> "Fxn:updateOutput";
    "class:NarrowTable(Module):" -> "Fxn:updateGradInput";
    "class:NarrowTable(Module):" -> "Fxn:type";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateGradInput" -> "Fxn:input[i].new()";
    "Fxn:updateGradInput" -> "Fxn:recursiveResizeAs(gi,";
    "Fxn:updateGradInput" -> "Fxn:recursiveFill(self.gradInput[i],";
    "Fxn:type" -> "Fxn:clear(self,";
    "Fxn:type" -> "Fxn:self).type(self,";
    "/torch/legacy/nn/Normalize.py" -> "Import:torch";
    "/torch/legacy/nn/Normalize.py" -> "Import:Module";
    "/torch/legacy/nn/Normalize.py" -> "Import:clear";
    "/torch/legacy/nn/Normalize.py" -> "class:Normalize(Module):";
    "class:Normalize(Module):" -> "Fxn:__init__";
    "class:Normalize(Module):" -> "Fxn:updateOutput";
    "class:Normalize(Module):" -> "Fxn:updateGradInput";
    "class:Normalize(Module):" -> "Fxn:__repr__";
    "class:Normalize(Module):" -> "Fxn:type";
    "class:Normalize(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.size()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self._output.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:torch.cuda.FloatTensor()";
    "Fxn:updateOutput" -> "Fxn:torch.typename(self.output)";
    "Fxn:updateOutput" -> "Fxn:torch.LongTensor()";
    "Fxn:updateOutput" -> "Fxn:torch.abs(input,";
    "Fxn:updateOutput" -> "Fxn:torch.max(self._indices,";
    "Fxn:updateOutput" -> "Fxn:self.norm.add_(self.eps)";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:torch.abs(input,";
    "Fxn:updateOutput" -> "Fxn:out=self.buffer).pow_(self.p)";
    "Fxn:updateOutput" -> "Fxn:torch.pow(input,";
    "Fxn:updateOutput" -> "Fxn:torch.sum(self.buffer,";
    "Fxn:updateOutput" -> "Fxn:keepdim=True).add_(self.eps)";
    "Fxn:updateOutput" -> "Fxn:torch.pow(self.normp,";
    "Fxn:updateOutput" -> "Fxn:torch.div(input,";
    "Fxn:updateOutput" -> "Fxn:self.norm.view(-1,";
    "Fxn:updateOutput" -> "Fxn:1).expand_as(input),";
    "Fxn:updateOutput" -> "Fxn:self._output.view(input_size)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.size()";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:input.size(1)";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self._gradInput.resize_(n,";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.norm.view(n,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(n,";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.cross.resize_(n,";
    "Fxn:updateGradInput" -> "Fxn:torch.gather(input,";
    "Fxn:updateGradInput" -> "Fxn:self.cross.div_(self.norm)";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.scatter_(1,";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.normp.view(n,";
    "Fxn:updateGradInput" -> "Fxn:1).expand(n,";
    "Fxn:updateGradInput" -> "Fxn:input*|input|^(p-2)";
    "Fxn:updateGradInput" -> "Fxn:torch.abs(input,";
    "Fxn:updateGradInput" -> "Fxn:out=self.buffer).add_(self.eps).pow_(self.p";
    "Fxn:updateGradInput" -> "Fxn:2).mul_(input)";
    "Fxn:updateGradInput" -> "Fxn:torch.abs(input,";
    "Fxn:updateGradInput" -> "Fxn:out=self.buffer).pow_(self.p";
    "Fxn:updateGradInput" -> "Fxn:2).mul_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.copy_(input)";
    "Fxn:updateGradInput" -> "Fxn:torch.pow(input,";
    "Fxn:updateGradInput" -> "Fxn:out=self.buffer).mul_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.cross.resize_(n,";
    "Fxn:updateGradInput" -> "Fxn:b1*(b2*gradOutput).";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(input,";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self.buffer2,";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.mul_(self.cross.expand_as(self.buffer))";
    "Fxn:updateGradInput" -> "Fxn:self._gradInput.add_(-1,";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.norm,";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self.normp,";
    "Fxn:updateGradInput" -> "Fxn:self._gradInput.div_(self.cross.expand(n,";
    "Fxn:updateGradInput" -> "Fxn:self._gradInput.view(input_size)";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({})'.format(self.p)";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:indices.long()";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Padding.py" -> "Import:torch";
    "/torch/legacy/nn/Padding.py" -> "Import:Module";
    "/torch/legacy/nn/Padding.py" -> "class:Padding(Module):";
    "class:Padding(Module):" -> "Fxn:__init__";
    "class:Padding(Module):" -> "Fxn:updateOutput";
    "class:Padding(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:torch.Size()";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:torch.Size(outputSize)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(self.outputSize)";
    "Fxn:updateOutput" -> "Fxn:self.output.fill_(self.value)";
    "Fxn:updateOutput" -> "Fxn:input.size(dim)";
    "Fxn:updateOutput" -> "Fxn:self.output.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:input.size(dim)).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:input.size(dim):";
    "Fxn:updateOutput" -> "Fxn:self.output.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:input.size(dim)).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:index).copy_(input.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:self.output.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:input.size(dim)";
    "Fxn:updateOutput" -> "Fxn:index).copy_(input.narrow(dim,";
    "Fxn:updateOutput" -> "Fxn:input.size(dim)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.size(dim)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(gradOutput.narrow(dim,";
    "Fxn:updateGradInput" -> "Fxn:input.size(dim)))";
    "Fxn:updateGradInput" -> "Fxn:input.size(dim):";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(gradOutput.narrow(dim,";
    "Fxn:updateGradInput" -> "Fxn:input.size(dim)))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.narrow(dim,";
    "Fxn:updateGradInput" -> "Fxn:index).copy_(gradOutput.narrow(dim,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.narrow(dim,";
    "Fxn:updateGradInput" -> "Fxn:input.size(";
    "Fxn:updateGradInput" -> "Fxn:index).copy_(gradOutput.narrow(dim,";
    "Fxn:updateGradInput" -> "Fxn:input.size(dim)";
    "/torch/legacy/nn/PairwiseDistance.py" -> "Import:torch";
    "/torch/legacy/nn/PairwiseDistance.py" -> "Import:Module";
    "/torch/legacy/nn/PairwiseDistance.py" -> "Import:clear";
    "/torch/legacy/nn/PairwiseDistance.py" -> "class:PairwiseDistance(Module):";
    "class:PairwiseDistance(Module):" -> "Fxn:__init__";
    "class:PairwiseDistance(Module):" -> "Fxn:updateOutput";
    "class:PairwiseDistance(Module):" -> "Fxn:updateGradInput";
    "class:PairwiseDistance(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(1)";
    "Fxn:updateOutput" -> "Fxn:input[0].dim()";
    "Fxn:updateOutput" -> "Fxn:input[0].new()";
    "Fxn:updateOutput" -> "Fxn:torch.add(input[0],";
    "Fxn:updateOutput" -> "Fxn:out=self.diff).abs_()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(input[0].size(0))";
    "Fxn:updateOutput" -> "Fxn:self.output.zero_()";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(self.diff.pow_(self.norm).sum(1,";
    "Fxn:updateOutput" -> "Fxn:self.output.pow_(1.";
    "Fxn:updateGradInput" -> "Fxn:input[0].dim()";
    "Fxn:updateGradInput" -> "Fxn:input[0].new()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].resize_(input[0].size())";
    "Fxn:updateGradInput" -> "Fxn:input[1].new()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].resize_(input[1].size())";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].copy_(input[0])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].add_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].sign_()";
    "Fxn:updateGradInput" -> "Fxn:d/dx_k(||x||_p)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].mul_(self.gradInput[0].abs().pow_(self.norm";
    "Fxn:updateGradInput" -> "Fxn:self.output.new()";
    "Fxn:updateGradInput" -> "Fxn:self.outExpand.resize_(self.output.size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.outExpand.copy_(self.output.view(self.output.size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.outExpand.add_(1e-6)";
    "Fxn:updateGradInput" -> "Fxn:self.outExpand.pow_(-(self.norm";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].mul_(self.outExpand.expand(self.gradInput[0].size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].size(1)))";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.new()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.new()";
    "Fxn:updateGradInput" -> "Fxn:self.grad.resize_as_(input[0]).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.ones.resize_(input[0].size(1)).fill_(1)";
    "Fxn:updateGradInput" -> "Fxn:self.grad.addr_(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[0].mul_(self.grad)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[1].zero_().add_(-1,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Parallel.py" -> "Import:torch";
    "/torch/legacy/nn/Parallel.py" -> "Import:Container";
    "/torch/legacy/nn/Parallel.py" -> "class:Parallel(Container):";
    "class:Parallel(Container):" -> "Fxn:__init__";
    "class:Parallel(Container):" -> "Fxn:updateOutput";
    "class:Parallel(Container):" -> "Fxn:updateGradInput";
    "class:Parallel(Container):" -> "Fxn:accGradParameters";
    "class:Parallel(Container):" -> "Fxn:accUpdateGradParameters";
    "class:Parallel(Container):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.size(self.inputDimension)";
    "Fxn:updateOutput" -> "Fxn:input.select(self.inputDimension,";
    "Fxn:updateOutput" -> "Fxn:self.modules[i].updateOutput(currentInput)";
    "Fxn:updateOutput" -> "Fxn:outputs.append(currentOutput)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:updateOutput" -> "Fxn:torch.Size(totalOutputSize)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(self.totalOutputSize)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:updateOutput" -> "Fxn:self.output.narrow(self.outputDimension,";
    "Fxn:updateOutput" -> "Fxn:outputSize).copy_(currentOutput)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:updateGradInput" -> "Fxn:input.size(self.inputDimension)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:input.select(self.inputDimension,";
    "Fxn:updateGradInput" -> "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.narrow(self.outputDimension,";
    "Fxn:updateGradInput" -> "Fxn:module.updateGradInput(currentInput,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.select(self.inputDimension,";
    "Fxn:updateGradInput" -> "Fxn:i).copy_(currentGradInput)";
    "Fxn:accGradParameters" -> "Fxn:input.size(self.inputDimension)";
    "Fxn:accGradParameters" -> "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:accGradParameters" -> "Fxn:module.accGradParameters(";
    "Fxn:accGradParameters" -> "Fxn:input.select(self.inputDimension,";
    "Fxn:accGradParameters" -> "Fxn:gradOutput.narrow(self.outputDimension,";
    "Fxn:accUpdateGradParameters" -> "Fxn:input.size(self.inputDimension)";
    "Fxn:accUpdateGradParameters" -> "Fxn:module.accupdateGradParameters(";
    "Fxn:accUpdateGradParameters" -> "Fxn:input.select(self.inputDimension,";
    "Fxn:accUpdateGradParameters" -> "Fxn:gradOutput.narrow(self.outputDimension,";
    "Fxn:accUpdateGradParameters" -> "Fxn:currentOutput.size(self.outputDimension)),";
    "Fxn:accUpdateGradParameters" -> "Fxn:currentOutput.size(self.outputDimension)";
    "Fxn:__repr__" -> "Fxn:torch.typename(self)";
    "Fxn:__repr__" -> "Fxn:'('";
    "Fxn:__repr__" -> "Fxn:'('";
    "/torch/legacy/nn/ParallelCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/ParallelCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/ParallelCriterion.py" -> "Import:recursiveResizeAs,";
    "/torch/legacy/nn/ParallelCriterion.py" -> "class:ParallelCriterion(Criterion):";
    "class:ParallelCriterion(Criterion):" -> "Fxn:__init__";
    "class:ParallelCriterion(Criterion):" -> "Fxn:add";
    "class:ParallelCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:ParallelCriterion(Criterion):" -> "Fxn:updateGradInput";
    "class:ParallelCriterion(Criterion):" -> "Fxn:type";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:add" -> "Fxn:self.criterions.append(criterion)";
    "Fxn:add" -> "Fxn:self.weights.append(weight)";
    "Fxn:updateOutput" -> "Fxn:criterion.updateOutput(input[i],";
    "Fxn:updateGradInput" -> "Fxn:recursiveResizeAs(self.gradInput,";
    "Fxn:updateGradInput" -> "Fxn:recursiveFill(self.gradInput,";
    "Fxn:updateGradInput" -> "Fxn:recursiveAdd(self.gradInput[i],";
    "Fxn:updateGradInput" -> "Fxn:criterion.updateGradInput(input[i],";
    "Fxn:type" -> "Fxn:self).type(type,";
    "/torch/legacy/nn/ParallelTable.py" -> "Import:torch";
    "/torch/legacy/nn/ParallelTable.py" -> "Import:Container";
    "/torch/legacy/nn/ParallelTable.py" -> "class:ParallelTable(Container):";
    "class:ParallelTable(Container):" -> "Fxn:__init__";
    "class:ParallelTable(Container):" -> "Fxn:updateOutput";
    "class:ParallelTable(Container):" -> "Fxn:updateGradInput";
    "class:ParallelTable(Container):" -> "Fxn:accGradParameters";
    "class:ParallelTable(Container):" -> "Fxn:accUpdateGradParameters";
    "class:ParallelTable(Container):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.modules[i].updateOutput(input[i])";
    "Fxn:updateOutput" -> "Fxn:self.output.append(tmp)";
    "Fxn:updateGradInput" -> "Fxn:module.updateGradInput(input[i],";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.append(tmp)";
    "Fxn:accGradParameters" -> "Fxn:module.accGradParameters(input[i],";
    "Fxn:accUpdateGradParameters" -> "Fxn:module.accUpdateGradParameters(input[i],";
    "Fxn:__repr__" -> "Fxn:torch.typename(self)";
    "Fxn:__repr__" -> "Fxn:'('";
    "Fxn:__repr__" -> "Fxn:'('";
    "/torch/legacy/nn/PartialLinear.py" -> "Import:torch";
    "/torch/legacy/nn/PartialLinear.py" -> "Import:Module";
    "/torch/legacy/nn/PartialLinear.py" -> "Import:Identity";
    "/torch/legacy/nn/PartialLinear.py" -> "Import:LookupTable";
    "/torch/legacy/nn/PartialLinear.py" -> "Import:Sequential";
    "/torch/legacy/nn/PartialLinear.py" -> "Import:ParallelTable";
    "/torch/legacy/nn/PartialLinear.py" -> "Import:class";
    "/torch/legacy/nn/PartialLinear.py" -> "class:PartialLinear(Module):";
    "class:PartialLinear(Module):" -> "Fxn:__init__";
    "class:PartialLinear(Module):" -> "Fxn:setPartition";
    "class:PartialLinear(Module):" -> "Fxn:resetPartition";
    "class:PartialLinear(Module):" -> "Fxn:parameters";
    "class:PartialLinear(Module):" -> "Fxn:updateOutput";
    "class:PartialLinear(Module):" -> "Fxn:updateGradInput";
    "class:PartialLinear(Module):" -> "Fxn:accGradParameters";
    "class:PartialLinear(Module):" -> "Fxn:accUpdateGradParameters";
    "class:PartialLinear(Module):" -> "Fxn:zeroGradParameters";
    "class:PartialLinear(Module):" -> "Fxn:updateParameters";
    "class:PartialLinear(Module):" -> "Fxn:type";
    "class:PartialLinear(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ParallelTable()";
    "Fxn:__init__" -> "Fxn:pt.add(Identity()).add(LookupTable(outputsize,";
    "Fxn:__init__" -> "Fxn:Sequential().add(pt).add(MM(False,";
    "Fxn:__init__" -> "Fxn:torch.zeros(1,";
    "Fxn:__init__" -> "Fxn:torch.zeros(1,";
    "Fxn:__init__" -> "Fxn:torch.arange(0,";
    "Fxn:__init__" -> "Fxn:self.outputsize).long()";
    "Fxn:__init__" -> "Fxn:self.resetPartition()";
    "Fxn:setPartition" -> "Fxn:indices.type(self.allcolumns.type())";
    "Fxn:parameters" -> "Fxn:[self.network.get(0).get(1).weight,";
    "Fxn:parameters" -> "Fxn:[self.network.get(0).get(1).gradWeight,";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(self.network.forward([input,";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(torch.index_select(self.bias,";
    "Fxn:updateOutput" -> "Fxn:self.partition).expand_as(self.output))";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.addBuffer.nelement()";
    "Fxn:updateOutput" -> "Fxn:input.size(0):";
    "Fxn:updateOutput" -> "Fxn:self.addBuffer.resize_(input.size(0)).fill_(1)";
    "Fxn:updateGradInput" -> "Fxn:self.network.updateGradInput([input,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.set_(self.network.gradInput[0])";
    "Fxn:accGradParameters" -> "Fxn:self.network.accGradParameters([input,";
    "Fxn:accGradParameters" -> "Fxn:input.new()";
    "Fxn:accGradParameters" -> "Fxn:self.buffer.resize_(gradOutput.size(1))";
    "Fxn:accGradParameters" -> "Fxn:torch.mv(gradOutput.t(),";
    "Fxn:accGradParameters" -> "Fxn:out=self.buffer).mul_(scale)";
    "Fxn:accGradParameters" -> "Fxn:self.gradBias.index_add_(";
    "Fxn:accGradParameters" -> "Fxn:self.buffer.view(1,";
    "Fxn:accGradParameters" -> "Fxn:self.buffer.nelement())";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.network.get(0).get(1).gradWeight";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.network.get(0).get(1).gradWeight";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.network.get(0).get(1).weight";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.accGradParameters(input,";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.network.get(0).get(1).gradWeight";
    "Fxn:zeroGradParameters" -> "Fxn:self.network.zeroGradParameters()";
    "Fxn:zeroGradParameters" -> "Fxn:self.gradBias.zero_()";
    "Fxn:updateParameters" -> "Fxn:self.network.updateParameters(learningRate)";
    "Fxn:updateParameters" -> "Fxn:self.bias._add(-learningRate,";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:type" -> "Fxn:self.partition.long()";
    "Fxn:type" -> "Fxn:self.allcolumns.long()";
    "Fxn:type" -> "Fxn:self.allcolumns.cuda()";
    "Fxn:type" -> "Fxn:self.partition.cuda()";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}";
    "Fxn:__repr__" -> "Fxn:{})'.format(self.inputsize,";
    "/torch/legacy/nn/Power.py" -> "Import:torch";
    "/torch/legacy/nn/Power.py" -> "Import:Module";
    "/torch/legacy/nn/Power.py" -> "class:Power(Module):";
    "class:Power(Module):" -> "Fxn:__init__";
    "class:Power(Module):" -> "Fxn:updateOutput";
    "class:Power(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.pow_(self.pow)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).copy_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.pow_(self.pow";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(gradOutput).mul_(self.pow)";
    "/torch/legacy/nn/PReLU.py" -> "Import:torch";
    "/torch/legacy/nn/PReLU.py" -> "Import:Module";
    "/torch/legacy/nn/PReLU.py" -> "Import:clear";
    "/torch/legacy/nn/PReLU.py" -> "class:PReLU(Module):";
    "class:PReLU(Module):" -> "Fxn:__init__";
    "class:PReLU(Module):" -> "Fxn:updateOutput";
    "class:PReLU(Module):" -> "Fxn:updateGradInput";
    "class:PReLU(Module):" -> "Fxn:accGradParameters";
    "class:PReLU(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane";
    "Fxn:__init__" -> "Fxn:1).fill_(0.25)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane";
    "Fxn:updateOutput" -> "Fxn:self._backend.PReLU_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.PReLU_updateGradInput(";
    "Fxn:accGradParameters" -> "Fxn:self._backend.PReLU_accGradParameters(";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/ReLU.py" -> "Import:torch";
    "/torch/legacy/nn/ReLU.py" -> "Import:Threshold";
    "/torch/legacy/nn/ReLU.py" -> "class:ReLU(Threshold):";
    "class:ReLU(Threshold):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__(0,";
    "/torch/legacy/nn/ReLU6.py" -> "Import:torch";
    "/torch/legacy/nn/ReLU6.py" -> "Import:Module";
    "/torch/legacy/nn/ReLU6.py" -> "class:ReLU6(Module):";
    "class:ReLU6(Module):" -> "Fxn:__init__";
    "class:ReLU6(Module):" -> "Fxn:updateOutput";
    "class:ReLU6(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.HardTanh_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.HardTanh_updateGradInput(";
    "/torch/legacy/nn/Replicate.py" -> "Import:torch";
    "/torch/legacy/nn/Replicate.py" -> "Import:Module";
    "/torch/legacy/nn/Replicate.py" -> "class:Replicate(Module):";
    "class:Replicate(Module):" -> "Fxn:__init__";
    "class:Replicate(Module):" -> "Fxn:updateOutput";
    "class:Replicate(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:size.insert(self.dim,";
    "Fxn:updateOutput" -> "Fxn:stride.insert(self.dim,";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input.storage(),";
    "Fxn:updateOutput" -> "Fxn:input.storage_offset(),";
    "Fxn:updateOutput" -> "Fxn:torch.Size(size),";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:size.insert(self.dim,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.view(*size)";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(gradOutput,";
    "/torch/legacy/nn/Reshape.py" -> "Import:torch";
    "/torch/legacy/nn/Reshape.py" -> "Import:Module";
    "/torch/legacy/nn/Reshape.py" -> "Import:clear";
    "/torch/legacy/nn/Reshape.py" -> "class:Reshape(Module):";
    "class:Reshape(Module):" -> "Fxn:__init__";
    "class:Reshape(Module):" -> "Fxn:updateOutput";
    "class:Reshape(Module):" -> "Fxn:updateGradInput";
    "class:Reshape(Module):" -> "Fxn:__repr__";
    "class:Reshape(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Size(args)";
    "Fxn:updateOutput" -> "Fxn:input.is_contiguous():";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self._input.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:self._input.copy_(input)";
    "Fxn:updateOutput" -> "Fxn:[input.size(0)]";
    "Fxn:updateOutput" -> "Fxn:input.view(torch.Size(batchsize))";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.new()";
    "Fxn:updateGradInput" -> "Fxn:self._gradOutput.resize_as_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self._gradOutput.copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.view_as(input)";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({})'.format('x'.join(map(lambda";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/RReLU.py" -> "Import:torch";
    "/torch/legacy/nn/RReLU.py" -> "Import:Module";
    "/torch/legacy/nn/RReLU.py" -> "Import:clear";
    "/torch/legacy/nn/RReLU.py" -> "class:RReLU(Module):";
    "class:RReLU(Module):" -> "Fxn:__init__";
    "class:RReLU(Module):" -> "Fxn:updateOutput";
    "class:RReLU(Module):" -> "Fxn:updateGradInput";
    "class:RReLU(Module):" -> "Fxn:__repr__";
    "class:RReLU(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:updateOutput" -> "Fxn:self._backend.RReLU_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.RReLU_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({:.4f},";
    "Fxn:__repr__" -> "Fxn:{:.4f})'.format(self.lower,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Select.py" -> "Import:torch";
    "/torch/legacy/nn/Select.py" -> "Import:Module";
    "/torch/legacy/nn/Select.py" -> "class:Select(Module):";
    "class:Select(Module):" -> "Fxn:__init__";
    "class:Select(Module):" -> "Fxn:updateOutput";
    "class:Select(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.size(self.dimension)";
    "Fxn:updateOutput" -> "Fxn:input.select(self.dimension,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(output)";
    "Fxn:updateOutput" -> "Fxn:self.output.copy_(output)";
    "Fxn:updateGradInput" -> "Fxn:input.size(self.dimension)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.select(self.dimension,";
    "Fxn:updateGradInput" -> "Fxn:index).copy_(gradOutput)";
    "/torch/legacy/nn/SelectTable.py" -> "Import:torch";
    "/torch/legacy/nn/SelectTable.py" -> "Import:Module";
    "/torch/legacy/nn/SelectTable.py" -> "Import:recursiveCopy,";
    "/torch/legacy/nn/SelectTable.py" -> "class:SelectTable(Module):";
    "class:SelectTable(Module):" -> "Fxn:__init__";
    "class:SelectTable(Module):" -> "Fxn:updateOutput";
    "class:SelectTable(Module):" -> "Fxn:_zeroTableCopy";
    "class:SelectTable(Module):" -> "Fxn:updateGradInput";
    "class:SelectTable(Module):" -> "Fxn:type";
    "class:SelectTable(Module):" -> "Fxn:__repr__";
    "class:SelectTable(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.size(self.dimension)";
    "Fxn:_zeroTableCopy" -> "Fxn:self._zeroTableCopy(l1[i],";
    "Fxn:_zeroTableCopy" -> "Fxn:l1.append(self._zeroTableCopy([],";
    "Fxn:_zeroTableCopy" -> "Fxn:l1.append(v.new().resize_as_(v).zero_())";
    "Fxn:_zeroTableCopy" -> "Fxn:l1[i].resize_as_(v)";
    "Fxn:_zeroTableCopy" -> "Fxn:l1[i].zero_()";
    "Fxn:_zeroTableCopy" -> "Fxn:l1[len(l2):]";
    "Fxn:updateGradInput" -> "Fxn:self._zeroTableCopy(self.gradInput,";
    "Fxn:updateGradInput" -> "Fxn:input.size(self.dimension)";
    "Fxn:updateGradInput" -> "Fxn:recursiveCopy(self.gradInput[index],";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({})'.format(self.index)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "/torch/legacy/nn/Sequential.py" -> "Import:torch";
    "/torch/legacy/nn/Sequential.py" -> "Import:Container";
    "/torch/legacy/nn/Sequential.py" -> "class:Sequential(Container):";
    "class:Sequential(Container):" -> "Fxn:__len__";
    "class:Sequential(Container):" -> "Fxn:add";
    "class:Sequential(Container):" -> "Fxn:insert";
    "class:Sequential(Container):" -> "Fxn:remove";
    "class:Sequential(Container):" -> "Fxn:updateOutput";
    "class:Sequential(Container):" -> "Fxn:_iter_with_prev";
    "class:Sequential(Container):" -> "Fxn:updateGradInput";
    "class:Sequential(Container):" -> "Fxn:accGradParameters";
    "class:Sequential(Container):" -> "Fxn:backward";
    "class:Sequential(Container):" -> "Fxn:accUpdateGradParameters";
    "class:Sequential(Container):" -> "Fxn:__repr__";
    "Fxn:add" -> "Fxn:self.modules.append(module)";
    "Fxn:insert" -> "Fxn:self.modules.insert(module,";
    "Fxn:remove" -> "Fxn:torch.Tensor()";
    "Fxn:remove" -> "Fxn:torch.Tensor()";
    "Fxn:updateOutput" -> "Fxn:module.updateOutput(currentOutput)";
    "Fxn:updateGradInput" -> "Fxn:self._iter_with_prev():";
    "Fxn:updateGradInput" -> "Fxn:current.updateGradInput(prev.output,";
    "Fxn:updateGradInput" -> "Fxn:self.modules[0].updateGradInput(input,";
    "Fxn:accGradParameters" -> "Fxn:self._iter_with_prev():";
    "Fxn:accGradParameters" -> "Fxn:current.accGradParameters(prev.output,";
    "Fxn:accGradParameters" -> "Fxn:self.modules[0].accGradParameters(input,";
    "Fxn:backward" -> "Fxn:self._iter_with_prev():";
    "Fxn:backward" -> "Fxn:current.backward(prev.output,";
    "Fxn:backward" -> "Fxn:self.modules[0].backward(input,";
    "Fxn:accUpdateGradParameters" -> "Fxn:self._iter_with_prev():";
    "Fxn:accUpdateGradParameters" -> "Fxn:current.accUpdateGradParameters(prev.output,";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.modules[0].accUpdateGradParameters(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "Fxn:__repr__" -> "Fxn:'('";
    "/torch/legacy/nn/Sigmoid.py" -> "Import:torch";
    "/torch/legacy/nn/Sigmoid.py" -> "Import:Module";
    "/torch/legacy/nn/Sigmoid.py" -> "class:Sigmoid(Module):";
    "class:Sigmoid(Module):" -> "Fxn:updateOutput";
    "class:Sigmoid(Module):" -> "Fxn:updateGradInput";
    "Fxn:updateOutput" -> "Fxn:self._backend.Sigmoid_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.Sigmoid_updateGradInput(";
    "/torch/legacy/nn/SmoothL1Criterion.py" -> "Import:torch";
    "/torch/legacy/nn/SmoothL1Criterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/SmoothL1Criterion.py" -> "class:SmoothL1Criterion(Criterion):";
    "class:SmoothL1Criterion(Criterion):" -> "Fxn:__init__";
    "class:SmoothL1Criterion(Criterion):" -> "Fxn:updateOutput";
    "class:SmoothL1Criterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SmoothL1Criterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SmoothL1Criterion_updateGradInput(";
    "/torch/legacy/nn/SoftMarginCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/SoftMarginCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/SoftMarginCriterion.py" -> "class:SoftMarginCriterion(Criterion):";
    "class:SoftMarginCriterion(Criterion):" -> "Fxn:__init__";
    "class:SoftMarginCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:SoftMarginCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SoftMarginCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SoftMarginCriterion_updateGradInput(";
    "/torch/legacy/nn/SoftMax.py" -> "Import:torch";
    "/torch/legacy/nn/SoftMax.py" -> "Import:Module";
    "/torch/legacy/nn/SoftMax.py" -> "class:SoftMax(Module):";
    "class:SoftMax(Module):" -> "Fxn:__init__";
    "class:SoftMax(Module):" -> "Fxn:_get_dim";
    "class:SoftMax(Module):" -> "Fxn:updateOutput";
    "class:SoftMax(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_get_dim" -> "Fxn:input.dim()";
    "Fxn:_get_dim" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SoftMax_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self._get_dim(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SoftMax_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self._get_dim(input)";
    "/torch/legacy/nn/SoftMin.py" -> "Import:torch";
    "/torch/legacy/nn/SoftMin.py" -> "Import:Module";
    "/torch/legacy/nn/SoftMin.py" -> "Import:clear";
    "/torch/legacy/nn/SoftMin.py" -> "class:SoftMin(Module):";
    "class:SoftMin(Module):" -> "Fxn:__init__";
    "class:SoftMin(Module):" -> "Fxn:_get_dim";
    "class:SoftMin(Module):" -> "Fxn:updateOutput";
    "class:SoftMin(Module):" -> "Fxn:updateGradInput";
    "class:SoftMin(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_get_dim" -> "Fxn:input.dim()";
    "Fxn:_get_dim" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.mininput.resize_as_(input).copy_(input).mul_(-1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SoftMax_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self._get_dim(input)";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.mininput.resize_as_(input).copy_(input).mul_(-1)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SoftMax_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self._get_dim(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(-1)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SoftPlus.py" -> "Import:torch";
    "/torch/legacy/nn/SoftPlus.py" -> "Import:Module";
    "/torch/legacy/nn/SoftPlus.py" -> "class:SoftPlus(Module):";
    "class:SoftPlus(Module):" -> "Fxn:__init__";
    "class:SoftPlus(Module):" -> "Fxn:updateOutput";
    "class:SoftPlus(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:exp(x),";
    "Fxn:updateOutput" -> "Fxn:f(x)";
    "Fxn:updateOutput" -> "Fxn:log(1";
    "Fxn:updateOutput" -> "Fxn:exp(beta";
    "Fxn:updateOutput" -> "Fxn:self._backend.SoftPlus_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:d/dx[log(1+exp(k*x))/k]";
    "Fxn:updateGradInput" -> "Fxn:exp(kx)";
    "Fxn:updateGradInput" -> "Fxn:d/dx(f(x))";
    "Fxn:updateGradInput" -> "Fxn:exp(k*y)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SoftPlus_updateGradInput(";
    "/torch/legacy/nn/SoftShrink.py" -> "Import:torch";
    "/torch/legacy/nn/SoftShrink.py" -> "Import:Module";
    "/torch/legacy/nn/SoftShrink.py" -> "class:SoftShrink(Module):";
    "class:SoftShrink(Module):" -> "Fxn:__init__";
    "class:SoftShrink(Module):" -> "Fxn:updateOutput";
    "class:SoftShrink(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SoftShrink_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SoftShrink_updateGradInput(";
    "/torch/legacy/nn/SoftSign.py" -> "Import:torch";
    "/torch/legacy/nn/SoftSign.py" -> "Import:Module";
    "/torch/legacy/nn/SoftSign.py" -> "Import:clear";
    "/torch/legacy/nn/SoftSign.py" -> "class:SoftSign(Module):";
    "class:SoftSign(Module):" -> "Fxn:__init__";
    "class:SoftSign(Module):" -> "Fxn:updateOutput";
    "class:SoftSign(Module):" -> "Fxn:updateGradInput";
    "class:SoftSign(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.temp.resize_as_(input).copy_(input).abs_().add_(1)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input).div_(self.temp)";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.tempgrad.resize_as_(self.output).copy_(input).abs_().add_(1).mul_(self.tempgrad)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).copy_(gradOutput).div_(self.tempgrad)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialAdaptiveMaxPooling.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialAdaptiveMaxPooling.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialAdaptiveMaxPooling.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialAdaptiveMaxPooling.py" -> "class:SpatialAdaptiveMaxPooling(Module):";
    "class:SpatialAdaptiveMaxPooling(Module):" -> "Fxn:__init__";
    "class:SpatialAdaptiveMaxPooling(Module):" -> "Fxn:updateOutput";
    "class:SpatialAdaptiveMaxPooling(Module):" -> "Fxn:updateGradInput";
    "class:SpatialAdaptiveMaxPooling(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.indices.long()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialAdaptiveMaxPooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialAdaptiveMaxPooling_updateGradInput(";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialAveragePooling.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialAveragePooling.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialAveragePooling.py" -> "class:SpatialAveragePooling(Module):";
    "class:SpatialAveragePooling(Module):" -> "Fxn:__init__";
    "class:SpatialAveragePooling(Module):" -> "Fxn:ceil";
    "class:SpatialAveragePooling(Module):" -> "Fxn:floor";
    "class:SpatialAveragePooling(Module):" -> "Fxn:setCountIncludePad";
    "class:SpatialAveragePooling(Module):" -> "Fxn:setCountExcludePad";
    "class:SpatialAveragePooling(Module):" -> "Fxn:updateOutput";
    "class:SpatialAveragePooling(Module):" -> "Fxn:updateGradInput";
    "class:SpatialAveragePooling(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialAveragePooling_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(self.kW";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialAveragePooling_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(self.kW";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}x{},";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.kW,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padW,";
    "/torch/legacy/nn/SpatialBatchNormalization.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialBatchNormalization.py" -> "Import:BatchNormalization";
    "/torch/legacy/nn/SpatialBatchNormalization.py" -> "class:SpatialBatchNormalization(BatchNormalization):";
    "/torch/legacy/nn/SpatialClassNLLCriterion.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialClassNLLCriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/SpatialClassNLLCriterion.py" -> "class:SpatialClassNLLCriterion(Criterion):";
    "class:SpatialClassNLLCriterion(Criterion):" -> "Fxn:__init__";
    "class:SpatialClassNLLCriterion(Criterion):" -> "Fxn:updateOutput";
    "class:SpatialClassNLLCriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:weights.dim()";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.zeros(1)";
    "Fxn:__init__" -> "Fxn:torch.ones(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialClassNLLCriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:torch.ones(1).type_as(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialClassNLLCriterion_updateGradInput(";
    "/torch/legacy/nn/SpatialContrastiveNormalization.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialContrastiveNormalization.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialContrastiveNormalization.py" -> "Import:Sequential";
    "/torch/legacy/nn/SpatialContrastiveNormalization.py" -> "Import:SpatialSubtractiveNormalization";
    "/torch/legacy/nn/SpatialContrastiveNormalization.py" -> "Import:SpatialDivisiveNormalization";
    "/torch/legacy/nn/SpatialContrastiveNormalization.py" -> "class:SpatialContrastiveNormalization(Module):";
    "class:SpatialContrastiveNormalization(Module):" -> "Fxn:__init__";
    "class:SpatialContrastiveNormalization(Module):" -> "Fxn:updateOutput";
    "class:SpatialContrastiveNormalization(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(9,";
    "Fxn:__init__" -> "Fxn:9).fill_(1)";
    "Fxn:__init__" -> "Fxn:self.kernel.ndimension()";
    "Fxn:__init__" -> "Fxn:ValueError('SpatialContrastiveNormalization";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0)";
    "Fxn:__init__" -> "Fxn:ValueError('SpatialContrastiveNormalization";
    "Fxn:__init__" -> "Fxn:Sequential()";
    "Fxn:__init__" -> "Fxn:self.normalizer.add(SpatialSubtractiveNormalization(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.normalizer.add(SpatialDivisiveNormalization(self.nInputPlane,";
    "Fxn:updateOutput" -> "Fxn:self.normalizer.forward(input)";
    "Fxn:updateGradInput" -> "Fxn:self.normalizer.backward(input,";
    "/torch/legacy/nn/SpatialConvolution.py" -> "Import:math";
    "/torch/legacy/nn/SpatialConvolution.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialConvolution.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialConvolution.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialConvolution.py" -> "class:SpatialConvolution(Module):";
    "class:SpatialConvolution(Module):" -> "Fxn:__init__";
    "class:SpatialConvolution(Module):" -> "Fxn:noBias";
    "class:SpatialConvolution(Module):" -> "Fxn:reset";
    "class:SpatialConvolution(Module):" -> "Fxn:_makeContiguous";
    "class:SpatialConvolution(Module):" -> "Fxn:_init";
    "class:SpatialConvolution(Module):" -> "Fxn:_viewWeight";
    "class:SpatialConvolution(Module):" -> "Fxn:_unviewWeight";
    "class:SpatialConvolution(Module):" -> "Fxn:updateOutput";
    "class:SpatialConvolution(Module):" -> "Fxn:updateGradInput";
    "class:SpatialConvolution(Module):" -> "Fxn:accGradParameters";
    "class:SpatialConvolution(Module):" -> "Fxn:type";
    "class:SpatialConvolution(Module):" -> "Fxn:__repr__";
    "class:SpatialConvolution(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous" -> "Fxn:input.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_init" -> "Fxn:self.weight.new()";
    "Fxn:_init" -> "Fxn:self.weight.new()";
    "Fxn:_viewWeight" -> "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:_viewWeight" -> "Fxn:self.gradWeight.dim()";
    "Fxn:_viewWeight" -> "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:_unviewWeight" -> "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:_unviewWeight" -> "Fxn:self.gradWeight.dim()";
    "Fxn:_unviewWeight" -> "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:updateOutput" -> "Fxn:self._init()";
    "Fxn:updateOutput" -> "Fxn:self._viewWeight()";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(input)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialConvolutionMM_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self._unviewWeight()";
    "Fxn:updateGradInput" -> "Fxn:self._init()";
    "Fxn:updateGradInput" -> "Fxn:self._viewWeight()";
    "Fxn:updateGradInput" -> "Fxn:self._makeContiguous(input,";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialConvolutionMM_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self._unviewWeight()";
    "Fxn:accGradParameters" -> "Fxn:self._init()";
    "Fxn:accGradParameters" -> "Fxn:self._makeContiguous(input,";
    "Fxn:accGradParameters" -> "Fxn:self._viewWeight()";
    "Fxn:accGradParameters" -> "Fxn:self._backend.SpatialConvolutionMM_accGradParameters(";
    "Fxn:accGradParameters" -> "Fxn:self._unviewWeight()";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}";
    "Fxn:__repr__" -> "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.dW,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padW,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialConvolutionLocal.py" -> "Import:math";
    "/torch/legacy/nn/SpatialConvolutionLocal.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialConvolutionLocal.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialConvolutionLocal.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialConvolutionLocal.py" -> "class:SpatialConvolutionLocal(Module):";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:__init__";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:reset";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:_makeContiguous";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:_viewWeight";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:_unviewWeight";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:_checkInputSize";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:_checkOutputSize";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:updateOutput";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:updateGradInput";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:accGradParameters";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:type";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:__tostring__";
    "class:SpatialConvolutionLocal(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.oH,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor().resize_as_(self.weight)";
    "Fxn:__init__" -> "Fxn:torch.Tensor().resize_as_(self.bias)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous" -> "Fxn:input.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_viewWeight" -> "Fxn:self.weight.view(self.oH";
    "Fxn:_viewWeight" -> "Fxn:self.gradWeight.dim()";
    "Fxn:_viewWeight" -> "Fxn:self.gradWeight.view(";
    "Fxn:_unviewWeight" -> "Fxn:self.weight.view(self.oH,";
    "Fxn:_unviewWeight" -> "Fxn:self.gradWeight.dim()";
    "Fxn:_unviewWeight" -> "Fxn:self.gradWeight.view(";
    "Fxn:_checkInputSize" -> "Fxn:input.ndimension()";
    "Fxn:_checkInputSize" -> "Fxn:input.size(0)";
    "Fxn:_checkInputSize" -> "Fxn:input.size(1)";
    "Fxn:_checkInputSize" -> "Fxn:input.size(1)";
    "Fxn:_checkInputSize" -> "Fxn:RuntimeError(";
    "Fxn:_checkInputSize" -> "Fxn:input.size(0),";
    "Fxn:_checkInputSize" -> "Fxn:input.size(1),";
    "Fxn:_checkInputSize" -> "Fxn:input.size(2),";
    "Fxn:_checkInputSize" -> "Fxn:input.ndimension()";
    "Fxn:_checkInputSize" -> "Fxn:input.size(1)";
    "Fxn:_checkInputSize" -> "Fxn:input.size(2)";
    "Fxn:_checkInputSize" -> "Fxn:input.size(3)";
    "Fxn:_checkInputSize" -> "Fxn:RuntimeError(";
    "Fxn:_checkInputSize" -> "Fxn:input.size(0),";
    "Fxn:_checkInputSize" -> "Fxn:input.size(1),";
    "Fxn:_checkInputSize" -> "Fxn:input.size(2),";
    "Fxn:_checkInputSize" -> "Fxn:input.size(3),";
    "Fxn:_checkInputSize" -> "Fxn:RuntimeError('3D";
    "Fxn:_checkOutputSize" -> "Fxn:output.ndimension()";
    "Fxn:_checkOutputSize" -> "Fxn:input.ndimension():";
    "Fxn:_checkOutputSize" -> "Fxn:RuntimeError('inconsistent";
    "Fxn:_checkOutputSize" -> "Fxn:output.ndimension()";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(0)";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(1)";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(2)";
    "Fxn:_checkOutputSize" -> "Fxn:RuntimeError(";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(0),";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(1),";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(2),";
    "Fxn:_checkOutputSize" -> "Fxn:output.ndimension()";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(1)";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(2)";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(3)";
    "Fxn:_checkOutputSize" -> "Fxn:RuntimeError('Given";
    "Fxn:_checkOutputSize" -> "Fxn:'(batchsize";
    "Fxn:_checkOutputSize" -> "Fxn:x{}x{}x{}).'.format(";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(0),";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(1),";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(2),";
    "Fxn:_checkOutputSize" -> "Fxn:output.size(3),";
    "Fxn:_checkOutputSize" -> "Fxn:RuntimeError('3D";
    "Fxn:_checkOutputSize" -> "Fxn:4D(batch";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self._checkInputSize(input)";
    "Fxn:updateOutput" -> "Fxn:self._viewWeight()";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(input)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialConvolutionLocal_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self._unviewWeight()";
    "Fxn:updateGradInput" -> "Fxn:self._checkInputSize(input)";
    "Fxn:updateGradInput" -> "Fxn:self._checkOutputSize(input,";
    "Fxn:updateGradInput" -> "Fxn:self._viewWeight()";
    "Fxn:updateGradInput" -> "Fxn:self._makeContiguous(input,";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialConvolutionLocal_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self._unviewWeight()";
    "Fxn:accGradParameters" -> "Fxn:self._checkInputSize(input)";
    "Fxn:accGradParameters" -> "Fxn:self._checkOutputSize(input,";
    "Fxn:accGradParameters" -> "Fxn:self._makeContiguous(input,";
    "Fxn:accGradParameters" -> "Fxn:self._viewWeight()";
    "Fxn:accGradParameters" -> "Fxn:self._backend.SpatialConvolutionLocal_accGradParameters(";
    "Fxn:accGradParameters" -> "Fxn:self._unviewWeight()";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:__tostring__" -> "Fxn:self).__repr__()";
    "Fxn:__tostring__" -> "Fxn:'({}";
    "Fxn:__tostring__" -> "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:__tostring__" -> "Fxn:{}'.format(self.dW,";
    "Fxn:__tostring__" -> "Fxn:{}'.format(self.padW,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialConvolutionMap.py" -> "Import:random";
    "/torch/legacy/nn/SpatialConvolutionMap.py" -> "Import:math";
    "/torch/legacy/nn/SpatialConvolutionMap.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialConvolutionMap.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialConvolutionMap.py" -> "class:SpatialConvolutionMap(Module):";
    "/torch/legacy/nn/SpatialConvolutionMap.py" -> "class:maps(object):";
    "class:maps(object):" -> "Fxn:full";
    "class:maps(object):" -> "Fxn:oneToOne";
    "class:maps(object):" -> "Fxn:random";
    "class:maps(object):" -> "Fxn:__init__";
    "class:maps(object):" -> "Fxn:reset";
    "class:maps(object):" -> "Fxn:updateOutput";
    "class:maps(object):" -> "Fxn:updateGradInput";
    "class:maps(object):" -> "Fxn:accGradParameters";
    "Fxn:full" -> "Fxn:torch.Tensor(nin";
    "Fxn:oneToOne" -> "Fxn:torch.Tensor(nfeat,";
    "Fxn:random" -> "Fxn:torch.Tensor(nker,";
    "Fxn:random" -> "Fxn:torch.randperm(nin)";
    "Fxn:random" -> "Fxn:math.floor(nin";
    "Fxn:random" -> "Fxn:tbl.select(1,";
    "Fxn:random" -> "Fxn:tbl.select(1,";
    "Fxn:random" -> "Fxn:fi.narrow(0,";
    "Fxn:random" -> "Fxn:frtbl.unfold(0,";
    "Fxn:random" -> "Fxn:totbl.unfold(0,";
    "Fxn:random" -> "Fxn:fitbl.unfold(0,";
    "Fxn:random" -> "Fxn:ufrtbl.select(0,";
    "Fxn:random" -> "Fxn:i).copy_(ufitbl.select(0,";
    "Fxn:random" -> "Fxn:fi.copy_(torch.randperm(nin))";
    "Fxn:random" -> "Fxn:utotbl.select(0,";
    "Fxn:random" -> "Fxn:tocntr).fill_(tocntr)";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:0).max())";
    "Fxn:__init__" -> "Fxn:1).max())";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:torch.Tensor(self.nOutputPlane).zero_()";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:self.weight.select(0,";
    "Fxn:reset" -> "Fxn:k).uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:random.uniform(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialConvolutionMap_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialConvolutionMap_updateGradInput(";
    "Fxn:accGradParameters" -> "Fxn:self._backend.SpatialConvolutionMap_accGradParameters(";
    "/torch/legacy/nn/SpatialCrossMapLRN.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialCrossMapLRN.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialCrossMapLRN.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialCrossMapLRN.py" -> "class:SpatialCrossMapLRN(Module):";
    "class:SpatialCrossMapLRN(Module):" -> "Fxn:__init__";
    "class:SpatialCrossMapLRN(Module):" -> "Fxn:updateOutput";
    "class:SpatialCrossMapLRN(Module):" -> "Fxn:updateGradInput";
    "class:SpatialCrossMapLRN(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.type()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialCrossMapLRN_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:input.size(0)";
    "Fxn:updateOutput" -> "Fxn:input.size(1)";
    "Fxn:updateOutput" -> "Fxn:input.size(2)";
    "Fxn:updateOutput" -> "Fxn:input.size(3)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:self.scale.resize_as_(input)";
    "Fxn:updateOutput" -> "Fxn:torch.pow(input,";
    "Fxn:updateOutput" -> "Fxn:self.scale.select(1,";
    "Fxn:updateOutput" -> "Fxn:scaleFirst.zero_()";
    "Fxn:updateOutput" -> "Fxn:scaleFirst.add_(inputSquare.select(1,";
    "Fxn:updateOutput" -> "Fxn:self.scale.select(1,";
    "Fxn:updateOutput" -> "Fxn:self.scale.select(1,";
    "Fxn:updateOutput" -> "Fxn:scaleCurrent.copy_(scalePrevious)";
    "Fxn:updateOutput" -> "Fxn:inputSquare.select(1,";
    "Fxn:updateOutput" -> "Fxn:scaleCurrent.add_(1,";
    "Fxn:updateOutput" -> "Fxn:inputSquare.select(1,";
    "Fxn:updateOutput" -> "Fxn:scaleCurrent.add_(-1,";
    "Fxn:updateOutput" -> "Fxn:self.scale.mul_(self.alpha";
    "Fxn:updateOutput" -> "Fxn:self.size).add_(self.k)";
    "Fxn:updateOutput" -> "Fxn:torch.pow(self.scale,";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(input)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.type()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialCrossMapLRN_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:input.size(1)";
    "Fxn:updateGradInput" -> "Fxn:input.size(2)";
    "Fxn:updateGradInput" -> "Fxn:input.size(3)";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.paddedRatio.resize_(channels";
    "Fxn:updateGradInput" -> "Fxn:self.accumRatio.resize_(inputHeight,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:torch.pow(self.scale,";
    "Fxn:updateGradInput" -> "Fxn:out=self.gradInput).mul_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.paddedRatio.zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.paddedRatio.narrow(0,";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(gradOutput[n],";
    "Fxn:updateGradInput" -> "Fxn:paddedRatioCenter.div_(self.scale[n])";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self.paddedRatio.narrow(0,";
    "Fxn:updateGradInput" -> "Fxn:self.accumRatio.add_(self.paddedRatio[c";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput[n][c].addcmul_(-cacheRatioValue,";
    "Fxn:updateGradInput" -> "Fxn:self.accumRatio.add_(-1,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialDilatedConvolution.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialDilatedConvolution.py" -> "Import:SpatialConvolution";
    "/torch/legacy/nn/SpatialDilatedConvolution.py" -> "class:SpatialDilatedConvolution(SpatialConvolution):";
    "class:SpatialDilatedConvolution(SpatialConvolution):" -> "Fxn:__init__";
    "class:SpatialDilatedConvolution(SpatialConvolution):" -> "Fxn:updateOutput";
    "class:SpatialDilatedConvolution(SpatialConvolution):" -> "Fxn:updateGradInput";
    "class:SpatialDilatedConvolution(SpatialConvolution):" -> "Fxn:accGradParameters";
    "class:SpatialDilatedConvolution(SpatialConvolution):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__(nInputPlane,";
    "Fxn:updateOutput" -> "Fxn:self.weight.new()";
    "Fxn:updateOutput" -> "Fxn:self.weight.new()";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(input)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialDilatedConvolution_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._makeContiguous(input,";
    "Fxn:updateGradInput" -> "Fxn:self.weight.new()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialDilatedConvolution_updateGradInput(";
    "Fxn:accGradParameters" -> "Fxn:self._makeContiguous(input,";
    "Fxn:accGradParameters" -> "Fxn:self.weight.new()";
    "Fxn:accGradParameters" -> "Fxn:self._backend.SpatialDilatedConvolution_accGradParameters(";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}";
    "Fxn:__repr__" -> "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.dW,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padW,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.dilationW,";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:math";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:Sequential";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:SpatialZeroPadding";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:SpatialConvolution";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:SpatialConvolutionMap";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:Replicate";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:Square";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:Sqrt";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:CDivTable";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:Threshold";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialDivisiveNormalization.py" -> "class:SpatialDivisiveNormalization(Module):";
    "class:SpatialDivisiveNormalization(Module):" -> "Fxn:__init__";
    "class:SpatialDivisiveNormalization(Module):" -> "Fxn:updateOutput";
    "class:SpatialDivisiveNormalization(Module):" -> "Fxn:updateGradInput";
    "class:SpatialDivisiveNormalization(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(9,";
    "Fxn:__init__" -> "Fxn:9).fill_(1)";
    "Fxn:__init__" -> "Fxn:self.kernel.ndimension()";
    "Fxn:__init__" -> "Fxn:ValueError('SpatialDivisiveNormalization";
    "Fxn:__init__" -> "Fxn:ValueError('SpatialDivisiveNormalization";
    "Fxn:__init__" -> "Fxn:Sequential()";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialZeroPadding(padW,";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.kernel.size(1),";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0)))";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialConvolutionMap(";
    "Fxn:__init__" -> "Fxn:SpatialConvolutionMap.maps.oneToOne(self.nInputPlane),";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0),";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0)))";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(Replicate(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:Sequential()";
    "Fxn:__init__" -> "Fxn:self.stdestimator.add(Square())";
    "Fxn:__init__" -> "Fxn:self.stdestimator.add(SpatialZeroPadding(padW,";
    "Fxn:__init__" -> "Fxn:self.stdestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.kernel.size(1),";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0)))";
    "Fxn:__init__" -> "Fxn:self.stdestimator.add(SpatialConvolutionMap(";
    "Fxn:__init__" -> "Fxn:SpatialConvolutionMap.maps.oneToOne(self.nInputPlane),";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0),";
    "Fxn:__init__" -> "Fxn:self.stdestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0)))";
    "Fxn:__init__" -> "Fxn:self.stdestimator.add(Replicate(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.stdestimator.add(Sqrt())";
    "Fxn:__init__" -> "Fxn:self.kernel.div_(self.kernel.sum()";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:__init__" -> "Fxn:self.stdestimator.modules[2].bias.zero_()";
    "Fxn:__init__" -> "Fxn:self.kernel.div_(self.kernel.sum()";
    "Fxn:__init__" -> "Fxn:math.sqrt(self.nInputPlane))";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[1].weight[i].copy_(self.kernel)";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[2].weight[0][i].copy_(self.kernel)";
    "Fxn:__init__" -> "Fxn:self.stdestimator.modules[2].weight[i].copy_(self.kernel)";
    "Fxn:__init__" -> "Fxn:self.stdestimator.modules[3].weight[0][i].copy_(self.kernel)";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[2].bias.zero_()";
    "Fxn:__init__" -> "Fxn:self.stdestimator.modules[2].bias.zero_()";
    "Fxn:__init__" -> "Fxn:self.stdestimator.modules[3].bias.zero_()";
    "Fxn:__init__" -> "Fxn:CDivTable()";
    "Fxn:__init__" -> "Fxn:CDivTable()";
    "Fxn:__init__" -> "Fxn:Threshold(self.threshold,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(1,";
    "Fxn:updateOutput" -> "Fxn:self.stdestimator.updateOutput(input)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.coef.dim()";
    "Fxn:updateOutput" -> "Fxn:self.coef.size(dim";
    "Fxn:updateOutput" -> "Fxn:self.coef.size(dim";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.ones.resize_as_(input[0:1]).fill_(1)";
    "Fxn:updateOutput" -> "Fxn:self.meanestimator.updateOutput(self.ones).squeeze(0)";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self._coef.resize_as_(coef).copy_(coef)";
    "Fxn:updateOutput" -> "Fxn:self._coef.view(1,";
    "Fxn:updateOutput" -> "Fxn:*self._coef.size()).expand_as(self.localstds)";
    "Fxn:updateOutput" -> "Fxn:self.divider.updateOutput([self.localstds,";
    "Fxn:updateOutput" -> "Fxn:self.coef.contiguous().view_as(self.localstds)])";
    "Fxn:updateOutput" -> "Fxn:self.thresholder.updateOutput(self.adjustedstds)";
    "Fxn:updateOutput" -> "Fxn:self.normalizer.updateOutput([input,";
    "Fxn:updateOutput" -> "Fxn:self.thresholdedstds.contiguous().view_as(input)])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.thresholdedstds.contiguous().view_as(input)],";
    "Fxn:updateGradInput" -> "Fxn:self.thresholder.updateGradInput(self.adjustedstds,";
    "Fxn:updateGradInput" -> "Fxn:self.coef.contiguous().view_as(self.localstds)],";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(self.stdestimator.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(gradnorm[0])";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self.meanestimator.clearState()";
    "Fxn:clearState" -> "Fxn:self.stdestimator.clearState()";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialDropout.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialDropout.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialDropout.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialDropout.py" -> "class:SpatialDropout(Module):";
    "class:SpatialDropout(Module):" -> "Fxn:__init__";
    "class:SpatialDropout(Module):" -> "Fxn:updateOutput";
    "class:SpatialDropout(Module):" -> "Fxn:updateGradInput";
    "class:SpatialDropout(Module):" -> "Fxn:setp";
    "class:SpatialDropout(Module):" -> "Fxn:__repr__";
    "class:SpatialDropout(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.noise.resize_(input.size(0),";
    "Fxn:updateOutput" -> "Fxn:input.size(1),";
    "Fxn:updateOutput" -> "Fxn:RuntimeError('Input";
    "Fxn:updateOutput" -> "Fxn:self.noise.bernoulli_(1";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(self.noise.expand_as(input))";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(1";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(self.noise.expand_as(input))";
    "Fxn:updateGradInput" -> "Fxn:RuntimeError('backprop";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialFractionalMaxPooling.py" -> "Import:math";
    "/torch/legacy/nn/SpatialFractionalMaxPooling.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialFractionalMaxPooling.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialFractionalMaxPooling.py" -> "class:SpatialFractionalMaxPooling(Module):";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:__init__";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:_getBufferSize";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:_initSampleBuffer";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:_getOutputSizes";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:fixPoolingRegions";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:updateOutput";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:updateGradInput";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:empty";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:clearState";
    "class:SpatialFractionalMaxPooling(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:.fixPoolingRegions().";
    "Fxn:_getBufferSize" -> "Fxn:input.ndimension()";
    "Fxn:_getBufferSize" -> "Fxn:input.size(0)";
    "Fxn:_getBufferSize" -> "Fxn:input.size(1)";
    "Fxn:_getBufferSize" -> "Fxn:torch.Size([batchSize,";
    "Fxn:_initSampleBuffer" -> "Fxn:self._getBufferSize(input)";
    "Fxn:_initSampleBuffer" -> "Fxn:input.new().resize_(sampleBufferSize).uniform_()";
    "Fxn:_initSampleBuffer" -> "Fxn:self.randomSamples.size(0)";
    "Fxn:_initSampleBuffer" -> "Fxn:self.randomSamples.size(1)";
    "Fxn:_initSampleBuffer" -> "Fxn:self.randomSamples.resize_(sampleBufferSize).uniform_()";
    "Fxn:_initSampleBuffer" -> "Fxn:self.randomSamples.uniform_()";
    "Fxn:_getOutputSizes" -> "Fxn:input.ndimension()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.indices.long()";
    "Fxn:updateOutput" -> "Fxn:self._initSampleBuffer(input)";
    "Fxn:updateOutput" -> "Fxn:self._getOutputSizes(input)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialFractionalMaxPooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._getOutputSizes(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialFractionalMaxPooling_updateGradInput(";
    "Fxn:empty" -> "Fxn:self.clearState()";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}x{},";
    "Fxn:__repr__" -> "Fxn:{})'.format(self.outW";
    "/torch/legacy/nn/SpatialFullConvolution.py" -> "Import:math";
    "/torch/legacy/nn/SpatialFullConvolution.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialFullConvolution.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialFullConvolution.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialFullConvolution.py" -> "class:SpatialFullConvolution(Module):";
    "class:SpatialFullConvolution(Module):" -> "Fxn:__init__";
    "class:SpatialFullConvolution(Module):" -> "Fxn:noBias";
    "class:SpatialFullConvolution(Module):" -> "Fxn:reset";
    "class:SpatialFullConvolution(Module):" -> "Fxn:_makeContiguous";
    "class:SpatialFullConvolution(Module):" -> "Fxn:_calculateAdj";
    "class:SpatialFullConvolution(Module):" -> "Fxn:updateOutput";
    "class:SpatialFullConvolution(Module):" -> "Fxn:updateGradInput";
    "class:SpatialFullConvolution(Module):" -> "Fxn:accGradParameters";
    "class:SpatialFullConvolution(Module):" -> "Fxn:type";
    "class:SpatialFullConvolution(Module):" -> "Fxn:__repr__";
    "class:SpatialFullConvolution(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError('adjW";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(kW";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous" -> "Fxn:input.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateOutput" -> "Fxn:targetTensor.dim()";
    "Fxn:updateOutput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateOutput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateOutput" -> "Fxn:self._calculateAdj(tW,";
    "Fxn:updateOutput" -> "Fxn:self._calculateAdj(tH,";
    "Fxn:updateOutput" -> "Fxn:input[0].new()";
    "Fxn:updateOutput" -> "Fxn:input[0].new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(inputTensor)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialFullConvolution_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:targetTensor.dim()";
    "Fxn:updateGradInput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateGradInput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateGradInput" -> "Fxn:self._calculateAdj(tW,";
    "Fxn:updateGradInput" -> "Fxn:self._calculateAdj(tH,";
    "Fxn:updateGradInput" -> "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialFullConvolution_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:input[1].new(1).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.ones.resize_(input[1].dim()).fill_(1)";
    "Fxn:updateGradInput" -> "Fxn:self.zeroScalar.view_as(self.ones).expand_as(input[1])";
    "Fxn:accGradParameters" -> "Fxn:targetTensor.dim()";
    "Fxn:accGradParameters" -> "Fxn:targetTensor.size(tDims";
    "Fxn:accGradParameters" -> "Fxn:targetTensor.size(tDims";
    "Fxn:accGradParameters" -> "Fxn:calculateAdj(tW,";
    "Fxn:accGradParameters" -> "Fxn:calculateAdj(tH,";
    "Fxn:accGradParameters" -> "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:accGradParameters" -> "Fxn:self._backend.SpatialFullConvolution_accGradParameters(";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}";
    "Fxn:__repr__" -> "Fxn:{}x{}'.format(self.nInputPlane,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.dW,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padW,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.adjW,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialFullConvolutionMap.py" -> "Import:random";
    "/torch/legacy/nn/SpatialFullConvolutionMap.py" -> "Import:math";
    "/torch/legacy/nn/SpatialFullConvolutionMap.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialFullConvolutionMap.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialFullConvolutionMap.py" -> "class:SpatialFullConvolutionMap(Module):";
    "class:SpatialFullConvolutionMap(Module):" -> "Fxn:__init__";
    "class:SpatialFullConvolutionMap(Module):" -> "Fxn:reset";
    "class:SpatialFullConvolutionMap(Module):" -> "Fxn:updateOutput";
    "class:SpatialFullConvolutionMap(Module):" -> "Fxn:updateGradInput";
    "class:SpatialFullConvolutionMap(Module):" -> "Fxn:accGradParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:0).max())";
    "Fxn:__init__" -> "Fxn:1).max())";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.connTable.size(0),";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:torch.Tensor(self.nOutputPlane).zero_()";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:self.weight[k].uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:random.uniform(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialFullConvolutionMap_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialFullConvolutionMap_updateGradInput(";
    "Fxn:accGradParameters" -> "Fxn:self._backend.SpatialFullConvolutionMap_accGradParameters(";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:Sequential";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:Square";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:Power";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:SpatialAveragePooling";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:MulConstant";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "Import:Sqrt";
    "/torch/legacy/nn/SpatialLPPooling.py" -> "class:SpatialLPPooling(Sequential):";
    "class:SpatialLPPooling(Sequential):" -> "Fxn:__init__";
    "class:SpatialLPPooling(Sequential):" -> "Fxn:reset";
    "class:SpatialLPPooling(Sequential):" -> "Fxn:accGradParameters";
    "class:SpatialLPPooling(Sequential):" -> "Fxn:accUpdateGradParameters";
    "class:SpatialLPPooling(Sequential):" -> "Fxn:zeroGradParameters";
    "class:SpatialLPPooling(Sequential):" -> "Fxn:updateParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:self.add(Square())";
    "Fxn:__init__" -> "Fxn:self.add(Power(pnorm))";
    "Fxn:__init__" -> "Fxn:self.add(SpatialAveragePooling(kW,";
    "Fxn:__init__" -> "Fxn:self.add(MulConstant(kW";
    "Fxn:__init__" -> "Fxn:self.add(Sqrt())";
    "Fxn:__init__" -> "Fxn:self.add(Power(1.";
    "/torch/legacy/nn/SpatialMaxPooling.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialMaxPooling.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialMaxPooling.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialMaxPooling.py" -> "class:SpatialMaxPooling(Module):";
    "class:SpatialMaxPooling(Module):" -> "Fxn:__init__";
    "class:SpatialMaxPooling(Module):" -> "Fxn:ceil";
    "class:SpatialMaxPooling(Module):" -> "Fxn:floor";
    "class:SpatialMaxPooling(Module):" -> "Fxn:updateOutput";
    "class:SpatialMaxPooling(Module):" -> "Fxn:updateGradInput";
    "class:SpatialMaxPooling(Module):" -> "Fxn:__repr__";
    "class:SpatialMaxPooling(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.LongTensor()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.indices.long()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.size(dims";
    "Fxn:updateOutput" -> "Fxn:input.size(dims";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialMaxPooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialMaxPooling_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}x{},";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.kW,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padW,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialMaxUnpooling.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialMaxUnpooling.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialMaxUnpooling.py" -> "Import:SpatialMaxPooling";
    "/torch/legacy/nn/SpatialMaxUnpooling.py" -> "class:SpatialMaxUnpooling(Module):";
    "class:SpatialMaxUnpooling(Module):" -> "Fxn:__init__";
    "class:SpatialMaxUnpooling(Module):" -> "Fxn:_setParams";
    "class:SpatialMaxUnpooling(Module):" -> "Fxn:updateOutput";
    "class:SpatialMaxUnpooling(Module):" -> "Fxn:updateGradInput";
    "class:SpatialMaxUnpooling(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._setParams()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialMaxUnpooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._setParams()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialMaxUnpooling_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self.pooling.__repr__()";
    "/torch/legacy/nn/SpatialReflectionPadding.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialReflectionPadding.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialReflectionPadding.py" -> "class:SpatialReflectionPadding(Module):";
    "class:SpatialReflectionPadding(Module):" -> "Fxn:__init__";
    "class:SpatialReflectionPadding(Module):" -> "Fxn:updateOutput";
    "class:SpatialReflectionPadding(Module):" -> "Fxn:updateGradInput";
    "class:SpatialReflectionPadding(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialReflectionPadding_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(0)";
    "Fxn:updateGradInput" -> "Fxn:input.size(1)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(1)";
    "Fxn:updateGradInput" -> "Fxn:input.size(2)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(2)";
    "Fxn:updateGradInput" -> "Fxn:input.size(3)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(3)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialReflectionPadding_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({},";
    "Fxn:__repr__" -> "Fxn:{})'.format(self.pad_l,";
    "/torch/legacy/nn/SpatialReplicationPadding.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialReplicationPadding.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialReplicationPadding.py" -> "class:SpatialReplicationPadding(Module):";
    "class:SpatialReplicationPadding(Module):" -> "Fxn:__init__";
    "class:SpatialReplicationPadding(Module):" -> "Fxn:updateOutput";
    "class:SpatialReplicationPadding(Module):" -> "Fxn:updateGradInput";
    "class:SpatialReplicationPadding(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialReplicationPadding_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(0)";
    "Fxn:updateGradInput" -> "Fxn:input.size(1)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(1)";
    "Fxn:updateGradInput" -> "Fxn:input.size(2)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(2)";
    "Fxn:updateGradInput" -> "Fxn:input.size(3)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(3)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialReplicationPadding_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({},";
    "Fxn:__repr__" -> "Fxn:{})'.format(self.pad_l,";
    "/torch/legacy/nn/SpatialSoftMax.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialSoftMax.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialSoftMax.py" -> "class:SpatialSoftMax(Module):";
    "class:SpatialSoftMax(Module):" -> "Fxn:updateOutput";
    "class:SpatialSoftMax(Module):" -> "Fxn:updateGradInput";
    "Fxn:updateOutput" -> "Fxn:self._backend.SoftMax_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SoftMax_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "/torch/legacy/nn/SpatialSubSampling.py" -> "Import:math";
    "/torch/legacy/nn/SpatialSubSampling.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialSubSampling.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialSubSampling.py" -> "class:SpatialSubSampling(Module):";
    "class:SpatialSubSampling(Module):" -> "Fxn:__init__";
    "class:SpatialSubSampling(Module):" -> "Fxn:reset";
    "class:SpatialSubSampling(Module):" -> "Fxn:updateOutput";
    "class:SpatialSubSampling(Module):" -> "Fxn:updateGradInput";
    "class:SpatialSubSampling(Module):" -> "Fxn:accGradParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialSubSampling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialSubSampling_updateGradInput(";
    "Fxn:accGradParameters" -> "Fxn:self._backend.SpatialSubSampling_accGradParameters(";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:math";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:Sequential";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:SpatialZeroPadding";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:SpatialConvolution";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:SpatialConvolutionMap";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:Replicate";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:CSubTable";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:CDivTable";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:clear";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "Import:warnings";
    "/torch/legacy/nn/SpatialSubtractiveNormalization.py" -> "class:SpatialSubtractiveNormalization(Module):";
    "class:SpatialSubtractiveNormalization(Module):" -> "Fxn:__init__";
    "class:SpatialSubtractiveNormalization(Module):" -> "Fxn:updateOutput";
    "class:SpatialSubtractiveNormalization(Module):" -> "Fxn:updateGradInput";
    "class:SpatialSubtractiveNormalization(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(9,";
    "Fxn:__init__" -> "Fxn:9).fill_(1)";
    "Fxn:__init__" -> "Fxn:self.kernel.ndimension()";
    "Fxn:__init__" -> "Fxn:ValueError('SpatialSubtractiveNormalization";
    "Fxn:__init__" -> "Fxn:ValueError('SpatialSubtractiveNormalization";
    "Fxn:__init__" -> "Fxn:self.kernel.div_(self.kernel.sum()";
    "Fxn:__init__" -> "Fxn:Sequential()";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialZeroPadding(padW,";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.kernel.size(1),";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0)))";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialConvolutionMap(";
    "Fxn:__init__" -> "Fxn:SpatialConvolutionMap.maps.oneToOne(self.nInputPlane),";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0),";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(SpatialConvolution(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.kernel.size(0)))";
    "Fxn:__init__" -> "Fxn:self.meanestimator.add(Replicate(self.nInputPlane,";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:__init__" -> "Fxn:self.kernel.unsqueeze(0)";
    "Fxn:__init__" -> "Fxn:self.kernel.unsqueeze(1)";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[1].bias.zero_()";
    "Fxn:__init__" -> "Fxn:self.meanestimator.modules[2].bias.zero_()";
    "Fxn:__init__" -> "Fxn:CSubTable()";
    "Fxn:__init__" -> "Fxn:CDivTable()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(1,";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.coef.dim()";
    "Fxn:updateOutput" -> "Fxn:self.coef.size(dim";
    "Fxn:updateOutput" -> "Fxn:self.coef.size(dim";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.coef.new()";
    "Fxn:updateOutput" -> "Fxn:self.ones.resize_as_(input[0:1]).fill_(1)";
    "Fxn:updateOutput" -> "Fxn:self.meanestimator.updateOutput(self.ones).squeeze(0)";
    "Fxn:updateOutput" -> "Fxn:self._coef.resize_as_(coef).copy_(coef)";
    "Fxn:updateOutput" -> "Fxn:[input.size(0)]";
    "Fxn:updateOutput" -> "Fxn:self._coef.view(1,";
    "Fxn:updateOutput" -> "Fxn:*self._coef.size()).expand(*size)";
    "Fxn:updateOutput" -> "Fxn:self.meanestimator.updateOutput(input)";
    "Fxn:updateOutput" -> "Fxn:self.coef.contiguous().view_as(self.localsums)]))";
    "Fxn:updateOutput" -> "Fxn:self.subtractor.updateOutput([input,";
    "Fxn:updateOutput" -> "Fxn:self.adjustedsums.contiguous().view_as(input)])";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.subtractor.updateGradInput([input,";
    "Fxn:updateGradInput" -> "Fxn:self.adjustedsums.contiguous().view_as(input)],";
    "Fxn:updateGradInput" -> "Fxn:self.coef.contiguous().view_as(self.localsums)],";
    "Fxn:updateGradInput" -> "Fxn:self.meanestimator.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:graddiv[0]).size()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(self.meanestimator.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(gradsub[0])";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self.meanestimator.clearState()";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/SpatialUpSamplingNearest.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialUpSamplingNearest.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialUpSamplingNearest.py" -> "class:SpatialUpSamplingNearest(Module):";
    "class:SpatialUpSamplingNearest(Module):" -> "Fxn:__init__";
    "class:SpatialUpSamplingNearest(Module):" -> "Fxn:updateOutput";
    "class:SpatialUpSamplingNearest(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError('scale_factor";
    "Fxn:__init__" -> "Fxn:ValueError('scale_factor";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(*outputSize)";
    "Fxn:updateOutput" -> "Fxn:self._backend.SpatialUpSamplingNearest_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.SpatialUpSamplingNearest_updateGradInput(";
    "/torch/legacy/nn/SpatialZeroPadding.py" -> "Import:torch";
    "/torch/legacy/nn/SpatialZeroPadding.py" -> "Import:Module";
    "/torch/legacy/nn/SpatialZeroPadding.py" -> "class:SpatialZeroPadding(Module):";
    "class:SpatialZeroPadding(Module):" -> "Fxn:__init__";
    "class:SpatialZeroPadding(Module):" -> "Fxn:updateOutput";
    "class:SpatialZeroPadding(Module):" -> "Fxn:updateGradInput";
    "class:SpatialZeroPadding(Module):" -> "Fxn:__tostring__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.size(2)";
    "Fxn:updateOutput" -> "Fxn:input.size(3)";
    "Fxn:updateOutput" -> "Fxn:RuntimeError('input";
    "Fxn:updateOutput" -> "Fxn:{}x{})'.format(h,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(input.size(0),";
    "Fxn:updateOutput" -> "Fxn:input.size(1),";
    "Fxn:updateOutput" -> "Fxn:self.output.zero_()";
    "Fxn:updateOutput" -> "Fxn:c_input.narrow(2,";
    "Fxn:updateOutput" -> "Fxn:c_input.size(2)";
    "Fxn:updateOutput" -> "Fxn:c_input.narrow(2,";
    "Fxn:updateOutput" -> "Fxn:c_input.size(2)";
    "Fxn:updateOutput" -> "Fxn:c_input.narrow(3,";
    "Fxn:updateOutput" -> "Fxn:c_input.size(3)";
    "Fxn:updateOutput" -> "Fxn:c_input.narrow(3,";
    "Fxn:updateOutput" -> "Fxn:c_input.size(3)";
    "Fxn:updateOutput" -> "Fxn:c_output.narrow(2,";
    "Fxn:updateOutput" -> "Fxn:c_output.size(2)";
    "Fxn:updateOutput" -> "Fxn:c_output.narrow(2,";
    "Fxn:updateOutput" -> "Fxn:c_output.size(2)";
    "Fxn:updateOutput" -> "Fxn:c_output.narrow(3,";
    "Fxn:updateOutput" -> "Fxn:c_output.size(3)";
    "Fxn:updateOutput" -> "Fxn:c_output.narrow(3,";
    "Fxn:updateOutput" -> "Fxn:c_output.size(3)";
    "Fxn:updateOutput" -> "Fxn:c_output.copy_(c_input)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).zero_()";
    "Fxn:updateGradInput" -> "Fxn:cg_input.narrow(2,";
    "Fxn:updateGradInput" -> "Fxn:cg_input.size(2)";
    "Fxn:updateGradInput" -> "Fxn:cg_input.narrow(2,";
    "Fxn:updateGradInput" -> "Fxn:cg_input.size(2)";
    "Fxn:updateGradInput" -> "Fxn:cg_input.narrow(3,";
    "Fxn:updateGradInput" -> "Fxn:cg_input.size(3)";
    "Fxn:updateGradInput" -> "Fxn:cg_input.narrow(3,";
    "Fxn:updateGradInput" -> "Fxn:cg_input.size(3)";
    "Fxn:updateGradInput" -> "Fxn:cg_output.narrow(2,";
    "Fxn:updateGradInput" -> "Fxn:cg_output.size(2)";
    "Fxn:updateGradInput" -> "Fxn:cg_output.narrow(2,";
    "Fxn:updateGradInput" -> "Fxn:cg_output.size(2)";
    "Fxn:updateGradInput" -> "Fxn:cg_output.narrow(3,";
    "Fxn:updateGradInput" -> "Fxn:cg_output.size(3)";
    "Fxn:updateGradInput" -> "Fxn:cg_output.narrow(3,";
    "Fxn:updateGradInput" -> "Fxn:cg_output.size(3)";
    "Fxn:updateGradInput" -> "Fxn:cg_input.copy_(cg_output)";
    "Fxn:__tostring__" -> "Fxn:self).__repr__()";
    "Fxn:__tostring__" -> "Fxn:'({},";
    "Fxn:__tostring__" -> "Fxn:{})'.foramat(self.pad_l,";
    "/torch/legacy/nn/SplitTable.py" -> "Import:torch";
    "/torch/legacy/nn/SplitTable.py" -> "Import:Module";
    "/torch/legacy/nn/SplitTable.py" -> "class:SplitTable(Module):";
    "class:SplitTable(Module):" -> "Fxn:__init__";
    "class:SplitTable(Module):" -> "Fxn:_getPositiveDimension";
    "class:SplitTable(Module):" -> "Fxn:updateOutput";
    "class:SplitTable(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateOutput" -> "Fxn:input.size(dimension)";
    "Fxn:updateOutput" -> "Fxn:currentOutput.append(input.select(dimension,";
    "Fxn:updateGradInput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateGradInput" -> "Fxn:input.size(dimension)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.select(dimension,";
    "Fxn:updateGradInput" -> "Fxn:i).copy_(gradOutput[i])";
    "/torch/legacy/nn/Sqrt.py" -> "Import:torch";
    "/torch/legacy/nn/Sqrt.py" -> "Import:Module";
    "/torch/legacy/nn/Sqrt.py" -> "class:Sqrt(Module):";
    "class:Sqrt(Module):" -> "Fxn:__init__";
    "class:Sqrt(Module):" -> "Fxn:updateOutput";
    "class:Sqrt(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._backend.Sqrt_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.Sqrt_updateGradInput(";
    "/torch/legacy/nn/Square.py" -> "Import:torch";
    "/torch/legacy/nn/Square.py" -> "Import:Module";
    "/torch/legacy/nn/Square.py" -> "class:Square(Module):";
    "class:Square(Module):" -> "Fxn:updateOutput";
    "class:Square(Module):" -> "Fxn:updateGradInput";
    "Fxn:updateOutput" -> "Fxn:self._backend.Square_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.Square_updateGradInput(";
    "/torch/legacy/nn/Squeeze.py" -> "Import:torch";
    "/torch/legacy/nn/Squeeze.py" -> "Import:Module";
    "/torch/legacy/nn/Squeeze.py" -> "class:Squeeze(Module):";
    "class:Squeeze(Module):" -> "Fxn:__init__";
    "class:Squeeze(Module):" -> "Fxn:updateOutput";
    "class:Squeeze(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(input.squeeze(dim)";
    "Fxn:updateOutput" -> "Fxn:input.squeeze())";
    "Fxn:updateGradInput" -> "Fxn:input.nelement()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.nelement()";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.set_(gradOutput.contiguous().view_as(input))";
    "/torch/legacy/nn/Sum.py" -> "Import:torch";
    "/torch/legacy/nn/Sum.py" -> "Import:Module";
    "/torch/legacy/nn/Sum.py" -> "Import:clear";
    "/torch/legacy/nn/Sum.py" -> "class:Sum(Module):";
    "class:Sum(Module):" -> "Fxn:__init__";
    "class:Sum(Module):" -> "Fxn:_getPositiveDimension";
    "class:Sum(Module):" -> "Fxn:updateOutput";
    "class:Sum(Module):" -> "Fxn:updateGradInput";
    "class:Sum(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_getPositiveDimension" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateOutput" -> "Fxn:torch.sum(input,";
    "Fxn:updateOutput" -> "Fxn:self.output.div_(input.size(dimension))";
    "Fxn:updateOutput" -> "Fxn:self.output.dim()";
    "Fxn:updateOutput" -> "Fxn:self.output.set_(self.output.select(dimension,";
    "Fxn:updateGradInput" -> "Fxn:self._getPositiveDimension(input)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.new()";
    "Fxn:updateGradInput" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.view(*size)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.copy_(gradOutput.expand_as(input))";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.div_(input.size(dimension))";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/Tanh.py" -> "Import:torch";
    "/torch/legacy/nn/Tanh.py" -> "Import:Module";
    "/torch/legacy/nn/Tanh.py" -> "class:Tanh(Module):";
    "class:Tanh(Module):" -> "Fxn:updateOutput";
    "class:Tanh(Module):" -> "Fxn:updateGradInput";
    "Fxn:updateOutput" -> "Fxn:self._backend.Tanh_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.Tanh_updateGradInput(";
    "/torch/legacy/nn/TanhShrink.py" -> "Import:torch";
    "/torch/legacy/nn/TanhShrink.py" -> "Import:Module";
    "/torch/legacy/nn/TanhShrink.py" -> "Import:Tanh";
    "/torch/legacy/nn/TanhShrink.py" -> "class:TanhShrink(Module):";
    "class:TanhShrink(Module):" -> "Fxn:__init__";
    "class:TanhShrink(Module):" -> "Fxn:updateOutput";
    "class:TanhShrink(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Tanh()";
    "Fxn:updateOutput" -> "Fxn:self.tanh.updateOutput(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:self.output.add_(-1,";
    "Fxn:updateGradInput" -> "Fxn:self.tanh.updateGradInput(input,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.add_(-1,";
    "/torch/legacy/nn/TemporalConvolution.py" -> "Import:math";
    "/torch/legacy/nn/TemporalConvolution.py" -> "Import:torch";
    "/torch/legacy/nn/TemporalConvolution.py" -> "Import:Module";
    "/torch/legacy/nn/TemporalConvolution.py" -> "class:TemporalConvolution(Module):";
    "class:TemporalConvolution(Module):" -> "Fxn:__init__";
    "class:TemporalConvolution(Module):" -> "Fxn:reset";
    "class:TemporalConvolution(Module):" -> "Fxn:updateOutput";
    "class:TemporalConvolution(Module):" -> "Fxn:updateGradInput";
    "class:TemporalConvolution(Module):" -> "Fxn:accGradParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputFrameSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputFrameSize)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputFrameSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(outputFrameSize)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self._backend.TemporalConvolution_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.TemporalConvolution_updateGradInput(";
    "Fxn:accGradParameters" -> "Fxn:self._backend.TemporalConvolution_accGradParameters(";
    "/torch/legacy/nn/TemporalMaxPooling.py" -> "Import:torch";
    "/torch/legacy/nn/TemporalMaxPooling.py" -> "Import:Module";
    "/torch/legacy/nn/TemporalMaxPooling.py" -> "Import:clear";
    "/torch/legacy/nn/TemporalMaxPooling.py" -> "class:TemporalMaxPooling(Module):";
    "class:TemporalMaxPooling(Module):" -> "Fxn:__init__";
    "class:TemporalMaxPooling(Module):" -> "Fxn:updateOutput";
    "class:TemporalMaxPooling(Module):" -> "Fxn:updateGradInput";
    "class:TemporalMaxPooling(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self._backend.TemporalMaxPooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.TemporalMaxPooling_updateGradInput(";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/TemporalSubSampling.py" -> "Import:math";
    "/torch/legacy/nn/TemporalSubSampling.py" -> "Import:torch";
    "/torch/legacy/nn/TemporalSubSampling.py" -> "Import:Module";
    "/torch/legacy/nn/TemporalSubSampling.py" -> "class:TemporalSubSampling(Module):";
    "class:TemporalSubSampling(Module):" -> "Fxn:__init__";
    "class:TemporalSubSampling(Module):" -> "Fxn:reset";
    "class:TemporalSubSampling(Module):" -> "Fxn:updateOutput";
    "class:TemporalSubSampling(Module):" -> "Fxn:updateGradInput";
    "class:TemporalSubSampling(Module):" -> "Fxn:accGradParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputFrameSize)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kW)";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:updateOutput" -> "Fxn:self._backend.TemporalSubSampling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.TemporalSubSampling_updateGradInput(";
    "Fxn:accGradParameters" -> "Fxn:self._backend.TemporalSubSampling_accGradParameters(";
    "/torch/legacy/nn/Threshold.py" -> "Import:torch";
    "/torch/legacy/nn/Threshold.py" -> "Import:Module";
    "/torch/legacy/nn/Threshold.py" -> "class:Threshold(Module):";
    "class:Threshold(Module):" -> "Fxn:__init__";
    "class:Threshold(Module):" -> "Fxn:updateOutput";
    "class:Threshold(Module):" -> "Fxn:updateGradInput";
    "class:Threshold(Module):" -> "Fxn:validateParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:self.validateParameters()";
    "Fxn:updateOutput" -> "Fxn:self.validateParameters()";
    "Fxn:updateOutput" -> "Fxn:self._backend.Threshold_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self.validateParameters()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.Threshold_updateGradInput(";
    "Fxn:validateParameters" -> "Fxn:RuntimeError('in-place";
    "/torch/legacy/nn/Transpose.py" -> "Import:torch";
    "/torch/legacy/nn/Transpose.py" -> "Import:Module";
    "/torch/legacy/nn/Transpose.py" -> "class:Transpose(Module):";
    "class:Transpose(Module):" -> "Fxn:__init__";
    "class:Transpose(Module):" -> "Fxn:updateOutput";
    "class:Transpose(Module):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.transpose(*perm)";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.transpose(*perm)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "/torch/legacy/nn/Unsqueeze.py" -> "Import:torch";
    "/torch/legacy/nn/Unsqueeze.py" -> "Import:Module";
    "/torch/legacy/nn/Unsqueeze.py" -> "Import:addSingletondimension";
    "/torch/legacy/nn/Unsqueeze.py" -> "class:Unsqueeze(Module):";
    "class:Unsqueeze(Module):" -> "Fxn:__init__";
    "class:Unsqueeze(Module):" -> "Fxn:updateOutput";
    "class:Unsqueeze(Module):" -> "Fxn:updateGradInput";
    "class:Unsqueeze(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:addSingletondimension(self.output,";
    "Fxn:updateGradInput" -> "Fxn:input.nelement()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.nelement()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.contiguous().view(input.size())";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({})'.format(self.dim)";
    "/torch/legacy/nn/utils.py" -> "Import:torch";
    "/torch/legacy/nn/utils.py" -> "Fxn:recursiveType";
    "/torch/legacy/nn/utils.py" -> "Import:Criterion";
    "/torch/legacy/nn/utils.py" -> "Import:Module";
    "/torch/legacy/nn/utils.py" -> "Fxn:recursiveResizeAs";
    "/torch/legacy/nn/utils.py" -> "Fxn:recursiveFill";
    "/torch/legacy/nn/utils.py" -> "Fxn:recursiveAdd";
    "/torch/legacy/nn/utils.py" -> "Fxn:recursiveCopy";
    "/torch/legacy/nn/utils.py" -> "Fxn:addSingletondimension";
    "/torch/legacy/nn/utils.py" -> "Fxn:contiguousView";
    "/torch/legacy/nn/utils.py" -> "Fxn:clear";
    "/torch/legacy/nn/utils.py" -> "Fxn:_clear";
    "/torch/legacy/nn/View.py" -> "Import:torch";
    "/torch/legacy/nn/View.py" -> "Import:Module";
    "/torch/legacy/nn/View.py" -> "class:View(Module):";
    "class:View(Module):" -> "Fxn:resetSize";
    "class:View(Module):" -> "Fxn:__init__";
    "class:View(Module):" -> "Fxn:updateOutput";
    "class:View(Module):" -> "Fxn:updateGradInput";
    "class:View(Module):" -> "Fxn:__repr__";
    "Fxn:resetSize" -> "Fxn:torch.Size(args)";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:self.resetSize(*args)";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.view(self.size)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.new()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.contiguous().view(input.size())";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({})'.format(',";
    "Fxn:__repr__" -> "Fxn:'.join(map(str,";
    "/torch/legacy/nn/VolumetricAveragePooling.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricAveragePooling.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricAveragePooling.py" -> "class:VolumetricAveragePooling(Module):";
    "class:VolumetricAveragePooling(Module):" -> "Fxn:__init__";
    "class:VolumetricAveragePooling(Module):" -> "Fxn:__setstate__";
    "class:VolumetricAveragePooling(Module):" -> "Fxn:updateOutput";
    "class:VolumetricAveragePooling(Module):" -> "Fxn:updateGradInput";
    "class:VolumetricAveragePooling(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.update(d)";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('padT',";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('padH',";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('padW',";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('ceil_mode',";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('count_include_pad',";
    "Fxn:updateOutput" -> "Fxn:self._backend.VolumetricAveragePooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.VolumetricAveragePooling_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}x{}x{},";
    "Fxn:__repr__" -> "Fxn:{}'.format(";
    "/torch/legacy/nn/VolumetricBatchNormalization.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricBatchNormalization.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricBatchNormalization.py" -> "Import:BatchNormalization";
    "/torch/legacy/nn/VolumetricBatchNormalization.py" -> "class:VolumetricBatchNormalization(BatchNormalization):";
    "/torch/legacy/nn/VolumetricConvolution.py" -> "Import:math";
    "/torch/legacy/nn/VolumetricConvolution.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricConvolution.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricConvolution.py" -> "Import:clear";
    "/torch/legacy/nn/VolumetricConvolution.py" -> "class:VolumetricConvolution(Module):";
    "class:VolumetricConvolution(Module):" -> "Fxn:__init__";
    "class:VolumetricConvolution(Module):" -> "Fxn:reset";
    "class:VolumetricConvolution(Module):" -> "Fxn:_makeContiguous";
    "class:VolumetricConvolution(Module):" -> "Fxn:_viewWeight";
    "class:VolumetricConvolution(Module):" -> "Fxn:_unviewWeight";
    "class:VolumetricConvolution(Module):" -> "Fxn:updateOutput";
    "class:VolumetricConvolution(Module):" -> "Fxn:updateGradInput";
    "class:VolumetricConvolution(Module):" -> "Fxn:accGradParameters";
    "class:VolumetricConvolution(Module):" -> "Fxn:type";
    "class:VolumetricConvolution(Module):" -> "Fxn:clearState";
    "class:VolumetricConvolution(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nOutputPlane)";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.kT";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous" -> "Fxn:input.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:_viewWeight" -> "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:_viewWeight" -> "Fxn:self.gradWeight.dim()";
    "Fxn:_viewWeight" -> "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:_unviewWeight" -> "Fxn:self.weight.view(self.nOutputPlane,";
    "Fxn:_unviewWeight" -> "Fxn:self.gradWeight.dim()";
    "Fxn:_unviewWeight" -> "Fxn:self.gradWeight.view(self.nOutputPlane,";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:input.type()";
    "Fxn:updateOutput" -> "Fxn:self._backend.VolumetricConvolution_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self._viewWeight()";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(input)";
    "Fxn:updateOutput" -> "Fxn:self._backend.VolumetricConvolutionMM_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self._unviewWeight()";
    "Fxn:updateGradInput" -> "Fxn:input.type()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.VolumetricConvolution_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self._viewWeight()";
    "Fxn:updateGradInput" -> "Fxn:self._makeContiguous(input,";
    "Fxn:updateGradInput" -> "Fxn:self._backend.VolumetricConvolutionMM_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:self._unviewWeight()";
    "Fxn:accGradParameters" -> "Fxn:input.type()";
    "Fxn:accGradParameters" -> "Fxn:self._backend.VolumetricConvolution_accGradParameters(";
    "Fxn:accGradParameters" -> "Fxn:self._makeContiguous(input,";
    "Fxn:accGradParameters" -> "Fxn:self._viewWeight()";
    "Fxn:accGradParameters" -> "Fxn:self._backend.VolumetricConvolutionMM_accGradParameters(";
    "Fxn:accGradParameters" -> "Fxn:self._unviewWeight()";
    "Fxn:type" -> "Fxn:clear(self,";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}";
    "Fxn:__repr__" -> "Fxn:{}x{}x{}'.format(self.nInputPlane,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.dT,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padT,";
    "/torch/legacy/nn/VolumetricDropout.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricDropout.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricDropout.py" -> "Import:clear";
    "/torch/legacy/nn/VolumetricDropout.py" -> "class:VolumetricDropout(Module):";
    "class:VolumetricDropout(Module):" -> "Fxn:__init__";
    "class:VolumetricDropout(Module):" -> "Fxn:updateOutput";
    "class:VolumetricDropout(Module):" -> "Fxn:updateGradInput";
    "class:VolumetricDropout(Module):" -> "Fxn:setp";
    "class:VolumetricDropout(Module):" -> "Fxn:__repr__";
    "class:VolumetricDropout(Module):" -> "Fxn:clearState";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_as_(input).copy_(input)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.noise.resize_(input.size(0),";
    "Fxn:updateOutput" -> "Fxn:input.size(1),";
    "Fxn:updateOutput" -> "Fxn:self.noise.bernoulli_(1";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(self.noise.expand_as(input))";
    "Fxn:updateOutput" -> "Fxn:self.output.mul_(1";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.mul_(self.noise.expand_as(input))";
    "Fxn:updateGradInput" -> "Fxn:RuntimeError('backprop";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({:.4f})'.format(self.p)";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "/torch/legacy/nn/VolumetricFullConvolution.py" -> "Import:math";
    "/torch/legacy/nn/VolumetricFullConvolution.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricFullConvolution.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricFullConvolution.py" -> "class:VolumetricFullConvolution(Module):";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:__init__";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:reset";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:_makeContiguous";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:_calculateAdj";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:updateOutput";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:updateGradInput";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:accGradParameters";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:type";
    "class:VolumetricFullConvolution(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:RuntimeError('adjW,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(nInputPlane,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor(self.nOutputPlane)";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:torch.Tensor()";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(kW";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.bias.uniform_(-stdv,";
    "Fxn:_makeContiguous" -> "Fxn:input.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:input.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._input.resize_as_(input).copy_(input)";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.is_contiguous():";
    "Fxn:_makeContiguous" -> "Fxn:gradOutput.new()";
    "Fxn:_makeContiguous" -> "Fxn:self._gradOutput.resize_as_(gradOutput).copy_(gradOutput)";
    "Fxn:updateOutput" -> "Fxn:targetTensor.dim()";
    "Fxn:updateOutput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateOutput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateOutput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateOutput" -> "Fxn:self._calculateAdj(tT,";
    "Fxn:updateOutput" -> "Fxn:self._calculateAdj(tW,";
    "Fxn:updateOutput" -> "Fxn:self._calculateAdj(tH,";
    "Fxn:updateOutput" -> "Fxn:self._makeContiguous(inputTensor)";
    "Fxn:updateOutput" -> "Fxn:self._backend.VolumetricFullConvolution_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:targetTensor.dim()";
    "Fxn:updateGradInput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateGradInput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateGradInput" -> "Fxn:targetTensor.size(tDims";
    "Fxn:updateGradInput" -> "Fxn:self._calculateAdj(tT,";
    "Fxn:updateGradInput" -> "Fxn:self._calculateAdj(tW,";
    "Fxn:updateGradInput" -> "Fxn:self._calculateAdj(tH,";
    "Fxn:updateGradInput" -> "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:updateGradInput" -> "Fxn:self._backend.VolumetricFullConvolution_updateGradInput(";
    "Fxn:updateGradInput" -> "Fxn:input[1].new(1).zero_()";
    "Fxn:updateGradInput" -> "Fxn:self.ones.resize_(input[1].dim()).fill_(1)";
    "Fxn:updateGradInput" -> "Fxn:self.zeroScalar.view(self.ones.tolist()).expand_as(input[1])";
    "Fxn:accGradParameters" -> "Fxn:targetTensor.dim()";
    "Fxn:accGradParameters" -> "Fxn:targetTensor.size(tDims";
    "Fxn:accGradParameters" -> "Fxn:targetTensor.size(tDims";
    "Fxn:accGradParameters" -> "Fxn:targetTensor.size(tDims";
    "Fxn:accGradParameters" -> "Fxn:self._calculateAdj(tT,";
    "Fxn:accGradParameters" -> "Fxn:self._calculateAdj(tW,";
    "Fxn:accGradParameters" -> "Fxn:self._calculateAdj(tH,";
    "Fxn:accGradParameters" -> "Fxn:self._makeContiguous(inputTensor,";
    "Fxn:accGradParameters" -> "Fxn:self._backend.VolumetricFullConvolution_accGradParameters(";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:torch.Tensor()";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}";
    "Fxn:__repr__" -> "Fxn:{}x{}x{}'.format(self.nInputPlane,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.dT,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padT,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.adjT,";
    "/torch/legacy/nn/VolumetricMaxPooling.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricMaxPooling.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricMaxPooling.py" -> "Import:clear";
    "/torch/legacy/nn/VolumetricMaxPooling.py" -> "class:VolumetricMaxPooling(Module):";
    "class:VolumetricMaxPooling(Module):" -> "Fxn:__init__";
    "class:VolumetricMaxPooling(Module):" -> "Fxn:ceil";
    "class:VolumetricMaxPooling(Module):" -> "Fxn:floor";
    "class:VolumetricMaxPooling(Module):" -> "Fxn:updateOutput";
    "class:VolumetricMaxPooling(Module):" -> "Fxn:updateGradInput";
    "class:VolumetricMaxPooling(Module):" -> "Fxn:clearState";
    "class:VolumetricMaxPooling(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.LongTensor()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.size(dims";
    "Fxn:updateOutput" -> "Fxn:input.size(dims";
    "Fxn:updateOutput" -> "Fxn:input.size(dims";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.indices.long()";
    "Fxn:updateOutput" -> "Fxn:self._backend.VolumetricMaxPooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._backend.VolumetricMaxPooling_updateGradInput(";
    "Fxn:clearState" -> "Fxn:clear(self,";
    "Fxn:clearState" -> "Fxn:self).clearState()";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({}x{}x{},";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.kT,";
    "Fxn:__repr__" -> "Fxn:{}'.format(self.padT,";
    "/torch/legacy/nn/VolumetricMaxUnpooling.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricMaxUnpooling.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricMaxUnpooling.py" -> "Import:VolumetricMaxPooling";
    "/torch/legacy/nn/VolumetricMaxUnpooling.py" -> "class:VolumetricMaxUnpooling(Module):";
    "class:VolumetricMaxUnpooling(Module):" -> "Fxn:__init__";
    "class:VolumetricMaxUnpooling(Module):" -> "Fxn:_setParams";
    "class:VolumetricMaxUnpooling(Module):" -> "Fxn:updateOutput";
    "class:VolumetricMaxUnpooling(Module):" -> "Fxn:updateGradInput";
    "class:VolumetricMaxUnpooling(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:self._setParams()";
    "Fxn:updateOutput" -> "Fxn:self._backend.VolumetricMaxUnpooling_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:self._setParams()";
    "Fxn:updateGradInput" -> "Fxn:self._backend.VolumetricMaxUnpooling_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self.pooling.__repr__()";
    "/torch/legacy/nn/VolumetricReplicationPadding.py" -> "Import:torch";
    "/torch/legacy/nn/VolumetricReplicationPadding.py" -> "Import:Module";
    "/torch/legacy/nn/VolumetricReplicationPadding.py" -> "class:VolumetricReplicationPadding(Module):";
    "class:VolumetricReplicationPadding(Module):" -> "Fxn:__init__";
    "class:VolumetricReplicationPadding(Module):" -> "Fxn:updateOutput";
    "class:VolumetricReplicationPadding(Module):" -> "Fxn:updateGradInput";
    "class:VolumetricReplicationPadding(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._backend.VolumetricReplicationPadding_updateOutput(";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(0)";
    "Fxn:updateGradInput" -> "Fxn:input.size(1)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(1)";
    "Fxn:updateGradInput" -> "Fxn:input.size(2)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(2)";
    "Fxn:updateGradInput" -> "Fxn:input.size(3)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(3)";
    "Fxn:updateGradInput" -> "Fxn:input.size(4)";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size(4)";
    "Fxn:updateGradInput" -> "Fxn:self._backend.VolumetricReplicationPadding_updateGradInput(";
    "Fxn:__repr__" -> "Fxn:self).__repr__()";
    "Fxn:__repr__" -> "Fxn:'({},";
    "Fxn:__repr__" -> "Fxn:{})'.format(self.pleft,";
    "/torch/legacy/nn/WeightedEuclidean.py" -> "Import:math";
    "/torch/legacy/nn/WeightedEuclidean.py" -> "Import:torch";
    "/torch/legacy/nn/WeightedEuclidean.py" -> "Import:Module";
    "/torch/legacy/nn/WeightedEuclidean.py" -> "class:WeightedEuclidean(Module):";
    "class:WeightedEuclidean(Module):" -> "Fxn:__init__";
    "class:WeightedEuclidean(Module):" -> "Fxn:reset";
    "class:WeightedEuclidean(Module):" -> "Fxn:_view";
    "class:WeightedEuclidean(Module):" -> "Fxn:updateOutput";
    "class:WeightedEuclidean(Module):" -> "Fxn:updateGradInput";
    "class:WeightedEuclidean(Module):" -> "Fxn:accGradParameters";
    "class:WeightedEuclidean(Module):" -> "Fxn:type";
    "class:WeightedEuclidean(Module):" -> "Fxn:parameters";
    "class:WeightedEuclidean(Module):" -> "Fxn:accUpdateGradParameters";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputSize,";
    "Fxn:__init__" -> "Fxn:torch.Tensor(inputSize,";
    "Fxn:__init__" -> "Fxn:self.reset()";
    "Fxn:__init__" -> "Fxn:self.output.new()";
    "Fxn:reset" -> "Fxn:math.sqrt(3)";
    "Fxn:reset" -> "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:reset" -> "Fxn:self.weight.uniform_(-stdv,";
    "Fxn:reset" -> "Fxn:self.diagCov.fill_(1)";
    "Fxn:_view" -> "Fxn:src.is_contiguous():";
    "Fxn:_view" -> "Fxn:res.set_(src.view(*args))";
    "Fxn:_view" -> "Fxn:res.set_(src.contiguous().view(*args))";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.weight.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.output.new()";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(0),";
    "Fxn:updateOutput" -> "Fxn:self.weight.size(1)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self._view(self._input,";
    "Fxn:updateOutput" -> "Fxn:self._expand.expand_as(self._input,";
    "Fxn:updateOutput" -> "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:updateOutput" -> "Fxn:self._repeat.add_(-1,";
    "Fxn:updateOutput" -> "Fxn:self._repeat.mul_(self.diagCov)";
    "Fxn:updateOutput" -> "Fxn:torch.norm(self._repeat,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(outputSize)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:input.size(0)";
    "Fxn:updateOutput" -> "Fxn:self._view(self._input,";
    "Fxn:updateOutput" -> "Fxn:self._input.expand(batchSize,";
    "Fxn:updateOutput" -> "Fxn:self._repeat.resize_as_(self._expand).copy_(self._expand)";
    "Fxn:updateOutput" -> "Fxn:self.weight.view(1,";
    "Fxn:updateOutput" -> "Fxn:self._weight.expand_as(self._repeat)";
    "Fxn:updateOutput" -> "Fxn:self.diagCov.view(1,";
    "Fxn:updateOutput" -> "Fxn:self._diagCov.expand_as(self._repeat)";
    "Fxn:updateOutput" -> "Fxn:input.type()";
    "Fxn:updateOutput" -> "Fxn:self._repeat2.resize_as_(self._expand2).copy_(self._expand2)";
    "Fxn:updateOutput" -> "Fxn:self._repeat.add_(-1,";
    "Fxn:updateOutput" -> "Fxn:self._repeat3.resize_as_(self._expand3).copy_(self._expand3)";
    "Fxn:updateOutput" -> "Fxn:self._repeat.mul_(self._repeat3)";
    "Fxn:updateOutput" -> "Fxn:self._repeat.add_(-1,";
    "Fxn:updateOutput" -> "Fxn:self._repeat.mul_(self._expand3)";
    "Fxn:updateOutput" -> "Fxn:torch.norm(self._repeat,";
    "Fxn:updateOutput" -> "Fxn:self.output.resize_(batchSize,";
    "Fxn:updateOutput" -> "Fxn:RuntimeError("1D";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.output.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:input.new()";
    "Fxn:updateGradInput" -> "Fxn:self.updateOutput(input)";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(0),";
    "Fxn:updateGradInput" -> "Fxn:self.weight.size(1)";
    "Fxn:updateGradInput" -> "Fxn:self._output.resize_as_(self.output).copy_(self.output).add_(1e-7)";
    "Fxn:updateGradInput" -> "Fxn:self._view(self._gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:gradOutput.size())";
    "Fxn:updateGradInput" -> "Fxn:torch.div(gradOutput,";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:self._div.resize_(1,";
    "Fxn:updateGradInput" -> "Fxn:self._div.expand_as(self.weight)";
    "Fxn:updateGradInput" -> "Fxn:torch.type(input)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.mul_(self._repeat,";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.mul_(self.diagCov)";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self._repeat2,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:input.size(0)";
    "Fxn:updateGradInput" -> "Fxn:self._div.resize_(batchSize,";
    "Fxn:updateGradInput" -> "Fxn:self._div.expand(batchSize,";
    "Fxn:updateGradInput" -> "Fxn:input.type()";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.mul_(self._repeat3)";
    "Fxn:updateGradInput" -> "Fxn:torch.mul(self._repeat,";
    "Fxn:updateGradInput" -> "Fxn:self._repeat2.mul_(self._expand3)";
    "Fxn:updateGradInput" -> "Fxn:torch.sum(self._repeat2,";
    "Fxn:updateGradInput" -> "Fxn:self.gradInput.resize_as_(input)";
    "Fxn:updateGradInput" -> "Fxn:RuntimeError("1D";
    "Fxn:accGradParameters" -> "Fxn:self.weight.size(0),";
    "Fxn:accGradParameters" -> "Fxn:self.weight.size(1)";
    "Fxn:accGradParameters" -> "Fxn:input.dim()";
    "Fxn:accGradParameters" -> "Fxn:self.gradWeight.add_(-scale,";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.div_(self.diagCov)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self._repeat)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self.diagCov)";
    "Fxn:accGradParameters" -> "Fxn:torch.type(input)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat2.mul_(self._repeat)";
    "Fxn:accGradParameters" -> "Fxn:torch.mul(self._repeat,";
    "Fxn:accGradParameters" -> "Fxn:self.gradDiagCov.add_(self._repeat2)";
    "Fxn:accGradParameters" -> "Fxn:input.dim()";
    "Fxn:accGradParameters" -> "Fxn:input.new()";
    "Fxn:accGradParameters" -> "Fxn:torch.sum(self._repeat2,";
    "Fxn:accGradParameters" -> "Fxn:self._sum.resize_(inputSize,";
    "Fxn:accGradParameters" -> "Fxn:self.gradWeight.add_(-scale,";
    "Fxn:accGradParameters" -> "Fxn:input.type()";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.div_(self._repeat3)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self._repeat)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self._repeat3)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat2.resize_as_(self._expand4).copy_(self._expand4)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self._repeat2)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.div_(self._expand3)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self._repeat)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self._expand3)";
    "Fxn:accGradParameters" -> "Fxn:self._repeat.mul_(self._expand4)";
    "Fxn:accGradParameters" -> "Fxn:torch.sum(self._repeat,";
    "Fxn:accGradParameters" -> "Fxn:self._sum.resize_(inputSize,";
    "Fxn:accGradParameters" -> "Fxn:self.gradDiagCov.add_(scale,";
    "Fxn:accGradParameters" -> "Fxn:RuntimeError("1D";
    "Fxn:type" -> "Fxn:self).type(type,";
    "Fxn:accUpdateGradParameters" -> "Fxn:self.accGradParameters(input,";
    "/torch/legacy/nn/WeightedMSECriterion.py" -> "Import:torch";
    "/torch/legacy/nn/WeightedMSECriterion.py" -> "Import:Criterion";
    "/torch/legacy/nn/WeightedMSECriterion.py" -> "class:WeightedMSECriterion(Criterion):";
    "class:WeightedMSECriterion(Criterion):" -> "Fxn:__init__";
    "class:WeightedMSECriterion(Criterion):" -> "Fxn:updateOutput";
    "class:WeightedMSECriterion(Criterion):" -> "Fxn:updateGradInput";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:weight.clone()";
    "Fxn:updateOutput" -> "Fxn:input.new()";
    "Fxn:updateOutput" -> "Fxn:self.buffer.resize_as_(input).copy_(target)";
    "Fxn:updateOutput" -> "Fxn:input.dim()";
    "Fxn:updateOutput" -> "Fxn:self.weight.dim():";
    "Fxn:updateOutput" -> "Fxn:self.buffer[i].mul_(self.weight)";
    "Fxn:updateOutput" -> "Fxn:self.buffer.mul_(self.weight)";
    "Fxn:updateOutput" -> "Fxn:input.new(1)";
    "Fxn:updateOutput" -> "Fxn:self._backend.MSECriterion_updateOutput(";
    "Fxn:updateOutput" -> "Fxn:self.output_tensor[0].item()";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.resize_as_(input).copy_(target)";
    "Fxn:updateGradInput" -> "Fxn:input.dim()";
    "Fxn:updateGradInput" -> "Fxn:self.weight.dim():";
    "Fxn:updateGradInput" -> "Fxn:self.buffer[i].mul_(self.weight)";
    "Fxn:updateGradInput" -> "Fxn:self.buffer.mul_(self.weight)";
    "Fxn:updateGradInput" -> "Fxn:torch.Tensor([1]).type(input.type())";
    "Fxn:updateGradInput" -> "Fxn:self._backend.MSECriterion_updateGradInput(";
    "/torch/legacy/nn/__init__.py" -> "Import:type2backend";
    "/torch/legacy/nn/__init__.py" -> "Import:utils";
    "/torch/legacy/nn/__init__.py" -> "Import:Module";
    "/torch/legacy/nn/__init__.py" -> "Import:Criterion";
    "/torch/legacy/nn/__init__.py" -> "Import:Container";
    "/torch/legacy/nn/__init__.py" -> "Import:Sequential";
    "/torch/legacy/nn/__init__.py" -> "Import:Parallel";
    "/torch/legacy/nn/__init__.py" -> "Import:Concat";
    "/torch/legacy/nn/__init__.py" -> "Import:DepthConcat";
    "/torch/legacy/nn/__init__.py" -> "Import:ConcatTable";
    "/torch/legacy/nn/__init__.py" -> "Import:JoinTable";
    "/torch/legacy/nn/__init__.py" -> "Import:ParallelTable";
    "/torch/legacy/nn/__init__.py" -> "Import:Abs";
    "/torch/legacy/nn/__init__.py" -> "Import:AbsCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:Add";
    "/torch/legacy/nn/__init__.py" -> "Import:AddConstant";
    "/torch/legacy/nn/__init__.py" -> "Import:BCECriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:BatchNormalization";
    "/torch/legacy/nn/__init__.py" -> "Import:Bilinear";
    "/torch/legacy/nn/__init__.py" -> "Import:CAddTable";
    "/torch/legacy/nn/__init__.py" -> "Import:CDivTable";
    "/torch/legacy/nn/__init__.py" -> "Import:CMul";
    "/torch/legacy/nn/__init__.py" -> "Import:CMulTable";
    "/torch/legacy/nn/__init__.py" -> "Import:CSubTable";
    "/torch/legacy/nn/__init__.py" -> "Import:ClassNLLCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:Contiguous";
    "/torch/legacy/nn/__init__.py" -> "Import:Copy";
    "/torch/legacy/nn/__init__.py" -> "Import:Cosine";
    "/torch/legacy/nn/__init__.py" -> "Import:CosineDistance";
    "/torch/legacy/nn/__init__.py" -> "Import:CosineEmbeddingCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:CriterionTable";
    "/torch/legacy/nn/__init__.py" -> "Import:CrossEntropyCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:DistKLDivCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:DotProduct";
    "/torch/legacy/nn/__init__.py" -> "Import:Dropout";
    "/torch/legacy/nn/__init__.py" -> "Import:ELU";
    "/torch/legacy/nn/__init__.py" -> "Import:Euclidean";
    "/torch/legacy/nn/__init__.py" -> "Import:Exp";
    "/torch/legacy/nn/__init__.py" -> "Import:FlattenTable";
    "/torch/legacy/nn/__init__.py" -> "Import:GradientReversal";
    "/torch/legacy/nn/__init__.py" -> "Import:HardShrink";
    "/torch/legacy/nn/__init__.py" -> "Import:HardTanh";
    "/torch/legacy/nn/__init__.py" -> "Import:HingeEmbeddingCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:Identity";
    "/torch/legacy/nn/__init__.py" -> "Import:Index";
    "/torch/legacy/nn/__init__.py" -> "Import:L1Cost";
    "/torch/legacy/nn/__init__.py" -> "Import:L1HingeEmbeddingCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:L1Penalty";
    "/torch/legacy/nn/__init__.py" -> "Import:LeakyReLU";
    "/torch/legacy/nn/__init__.py" -> "Import:Linear";
    "/torch/legacy/nn/__init__.py" -> "Import:Log";
    "/torch/legacy/nn/__init__.py" -> "Import:LogSigmoid";
    "/torch/legacy/nn/__init__.py" -> "Import:LogSoftMax";
    "/torch/legacy/nn/__init__.py" -> "Import:LookupTable";
    "/torch/legacy/nn/__init__.py" -> "Import:.MSECriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:MSECriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:MarginCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:MarginRankingCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:MaskedSelect";
    "/torch/legacy/nn/__init__.py" -> "Import:Max";
    "/torch/legacy/nn/__init__.py" -> "Import:Min";
    "/torch/legacy/nn/__init__.py" -> "Import:MixtureTable";
    "/torch/legacy/nn/__init__.py" -> "Import:Mul";
    "/torch/legacy/nn/__init__.py" -> "Import:MulConstant";
    "/torch/legacy/nn/__init__.py" -> "Import:MultiCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:.MultiLabelMarginCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:MultiLabelMarginCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:MultiLabelSoftMarginCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:MultiMarginCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:Narrow";
    "/torch/legacy/nn/__init__.py" -> "Import:NarrowTable";
    "/torch/legacy/nn/__init__.py" -> "Import:Normalize";
    "/torch/legacy/nn/__init__.py" -> "Import:PReLU";
    "/torch/legacy/nn/__init__.py" -> "Import:Padding";
    "/torch/legacy/nn/__init__.py" -> "Import:PairwiseDistance";
    "/torch/legacy/nn/__init__.py" -> "Import:ParallelCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:PartialLinear";
    "/torch/legacy/nn/__init__.py" -> "Import:Power";
    "/torch/legacy/nn/__init__.py" -> "Import:RReLU";
    "/torch/legacy/nn/__init__.py" -> "Import:ReLU6";
    "/torch/legacy/nn/__init__.py" -> "Import:Replicate";
    "/torch/legacy/nn/__init__.py" -> "Import:Reshape";
    "/torch/legacy/nn/__init__.py" -> "Import:Select";
    "/torch/legacy/nn/__init__.py" -> "Import:SelectTable";
    "/torch/legacy/nn/__init__.py" -> "Import:Sigmoid";
    "/torch/legacy/nn/__init__.py" -> "Import:SmoothL1Criterion";
    "/torch/legacy/nn/__init__.py" -> "Import:SoftMarginCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:SoftMax";
    "/torch/legacy/nn/__init__.py" -> "Import:SoftMin";
    "/torch/legacy/nn/__init__.py" -> "Import:SoftPlus";
    "/torch/legacy/nn/__init__.py" -> "Import:SoftShrink";
    "/torch/legacy/nn/__init__.py" -> "Import:SoftSign";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialAdaptiveMaxPooling";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialAveragePooling";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialBatchNormalization";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialClassNLLCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialContrastiveNormalization";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialConvolution";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialConvolutionLocal";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialConvolutionMap";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialCrossMapLRN";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialDilatedConvolution";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialDivisiveNormalization";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialDropout";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialFractionalMaxPooling";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialFullConvolution";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialFullConvolutionMap";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialLPPooling";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialMaxPooling";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialMaxUnpooling";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialReflectionPadding";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialReplicationPadding";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialSoftMax";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialSubSampling";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialSubtractiveNormalization";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialUpSamplingNearest";
    "/torch/legacy/nn/__init__.py" -> "Import:SpatialZeroPadding";
    "/torch/legacy/nn/__init__.py" -> "Import:SplitTable";
    "/torch/legacy/nn/__init__.py" -> "Import:Sqrt";
    "/torch/legacy/nn/__init__.py" -> "Import:Square";
    "/torch/legacy/nn/__init__.py" -> "Import:Squeeze";
    "/torch/legacy/nn/__init__.py" -> "Import:Sum";
    "/torch/legacy/nn/__init__.py" -> "Import:Tanh";
    "/torch/legacy/nn/__init__.py" -> "Import:TanhShrink";
    "/torch/legacy/nn/__init__.py" -> "Import:Threshold";
    "/torch/legacy/nn/__init__.py" -> "Import:Transpose";
    "/torch/legacy/nn/__init__.py" -> "Import:Unsqueeze";
    "/torch/legacy/nn/__init__.py" -> "Import:View";
    "/torch/legacy/nn/__init__.py" -> "Import:WeightedEuclidean";
    "/torch/legacy/nn/__init__.py" -> "Import:WeightedMSECriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:TemporalConvolution";
    "/torch/legacy/nn/__init__.py" -> "Import:TemporalMaxPooling";
    "/torch/legacy/nn/__init__.py" -> "Import:TemporalSubSampling";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricAveragePooling";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricBatchNormalization";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricConvolution";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricDropout";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricFullConvolution";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricMaxPooling";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricMaxUnpooling";
    "/torch/legacy/nn/__init__.py" -> "Import:VolumetricReplicationPadding";
    "/torch/legacy/nn/__init__.py" -> "Import:Clamp";
    "/torch/legacy/nn/__init__.py" -> "Import:ClassSimplexCriterion";
    "/torch/legacy/nn/__init__.py" -> "Import:ReLU";
    "/torch/legacy/nn/__init__.py" -> "Import:Mean";
    "/torch/legacy/optim/adadelta.py" -> "Fxn:adadelta";
    "/torch/legacy/optim/adagrad.py" -> "Fxn:adagrad";
    "/torch/legacy/optim/adam.py" -> "Import:math";
    "/torch/legacy/optim/adam.py" -> "Fxn:adam";
    "/torch/legacy/optim/adamax.py" -> "Import:torch";
    "/torch/legacy/optim/adamax.py" -> "Fxn:adamax";
    "/torch/legacy/optim/asgd.py" -> "Import:math";
    "/torch/legacy/optim/asgd.py" -> "Fxn:asgd";
    "/torch/legacy/optim/cg.py" -> "Import:math";
    "/torch/legacy/optim/cg.py" -> "Fxn:sqrt_nothrow";
    "/torch/legacy/optim/cg.py" -> "Fxn:cg";
    "/torch/legacy/optim/lbfgs.py" -> "Import:torch";
    "/torch/legacy/optim/lbfgs.py" -> "Fxn:lbfgs";
    "/torch/legacy/optim/lbfgs.py" -> "Fxn:verbose";
    "/torch/legacy/optim/lbfgs.py" -> "Fxn:verbose";
    "/torch/legacy/optim/nag.py" -> "Fxn:nag";
    "/torch/legacy/optim/rmsprop.py" -> "Import:torch";
    "/torch/legacy/optim/rmsprop.py" -> "Fxn:rmsprop";
    "/torch/legacy/optim/rprop.py" -> "Import:torch";
    "/torch/legacy/optim/rprop.py" -> "Fxn:rprop";
    "/torch/legacy/optim/sgd.py" -> "Import:torch";
    "/torch/legacy/optim/sgd.py" -> "Fxn:sgd";
    "/torch/legacy/optim/__init__.py" -> "Import:adadelta";
    "/torch/legacy/optim/__init__.py" -> "Import:adagrad";
    "/torch/legacy/optim/__init__.py" -> "Import:adam";
    "/torch/legacy/optim/__init__.py" -> "Import:adamax";
    "/torch/legacy/optim/__init__.py" -> "Import:asgd";
    "/torch/legacy/optim/__init__.py" -> "Import:.nag";
    "/torch/legacy/optim/__init__.py" -> "Import:nag";
    "/torch/legacy/optim/__init__.py" -> "Import:rmsprop";
    "/torch/legacy/optim/__init__.py" -> "Import:rprop";
    "/torch/legacy/optim/__init__.py" -> "Import:sgd";
    "/torch/legacy/optim/__init__.py" -> "Import:lbfgs";
    "/torch/lib/THD/benchmark/benchmark.py" -> "Import:argparse";
    "/torch/lib/THD/benchmark/benchmark.py" -> "Import:timeit";
    "/torch/lib/THD/benchmark/benchmark.py" -> "Import:default_timer";
    "/torch/lib/THD/benchmark/benchmark.py" -> "Import:torch";
    "/torch/lib/THD/benchmark/benchmark.py" -> "Import:torch.distributed";
    "/torch/lib/THD/benchmark/benchmark.py" -> "Fxn:print_header";
    "/torch/lib/THD/benchmark/benchmark.py" -> "Fxn:print_stats";
    "/torch/multiprocessing/pool.py" -> "Import:multiprocessing";
    "/torch/multiprocessing/pool.py" -> "Import:multiprocessing.pool";
    "/torch/multiprocessing/pool.py" -> "Import:multiprocessing.util";
    "/torch/multiprocessing/pool.py" -> "Import:SimpleQueue";
    "/torch/multiprocessing/pool.py" -> "Fxn:clean_worker";
    "/torch/multiprocessing/pool.py" -> "Import:multiprocessing.pool.worker(*args,";
    "/torch/multiprocessing/pool.py" -> "class:Pool(multiprocessing.pool.Pool):";
    "class:Pool(multiprocessing.pool.Pool):" -> "Fxn:_setup_queues";
    "class:Pool(multiprocessing.pool.Pool):" -> "Fxn:_repopulate_pool";
    "Fxn:_setup_queues" -> "Fxn:SimpleQueue()";
    "Fxn:_setup_queues" -> "Fxn:SimpleQueue()";
    "Fxn:_repopulate_pool" -> "Fxn:self.Process(target=clean_worker,";
    "Fxn:_repopulate_pool" -> "Fxn:self._pool.append(w)";
    "Fxn:_repopulate_pool" -> "Fxn:w.name.replace('Process',";
    "Fxn:_repopulate_pool" -> "Fxn:w.start()";
    "Fxn:_repopulate_pool" -> "Fxn:util.debug('added";
    "/torch/multiprocessing/queue.py" -> "Import:import";
    "/torch/multiprocessing/queue.py" -> "Import:multiprocessing";
    "/torch/multiprocessing/queue.py" -> "Import:multiprocessing.queues";
    "/torch/multiprocessing/queue.py" -> "Import:ForkingPickler";
    "/torch/multiprocessing/queue.py" -> "Import:pickle";
    "/torch/multiprocessing/queue.py" -> "class:ConnectionWrapper(object):";
    "/torch/multiprocessing/queue.py" -> "class:Queue(multiprocessing.queues.Queue):";
    "/torch/multiprocessing/queue.py" -> "class:SimpleQueue(multiprocessing.queues.SimpleQueue):";
    "class:ConnectionWrapper(object):" -> "Fxn:__init__";
    "class:ConnectionWrapper(object):" -> "Fxn:send";
    "class:ConnectionWrapper(object):" -> "Fxn:recv";
    "class:ConnectionWrapper(object):" -> "Fxn:__getattr__";
    "Fxn:send" -> "Fxn:io.BytesIO()";
    "Fxn:send" -> "Fxn:ForkingPickler(buf,";
    "Fxn:send" -> "Fxn:pickle.HIGHEST_PROTOCOL).dump(obj)";
    "Fxn:send" -> "Fxn:self.send_bytes(buf.getvalue())";
    "Fxn:recv" -> "Fxn:self.recv_bytes()";
    "Fxn:recv" -> "Fxn:pickle.loads(buf)";
    "Fxn:__getattr__" -> "Fxn:AttributeError("'{}'";
    "Fxn:__getattr__" -> "Fxn:'{}'".format(";
    "class:Queue(multiprocessing.queues.Queue):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:__init__" -> "Fxn:ConnectionWrapper(self._reader)";
    "Fxn:__init__" -> "Fxn:ConnectionWrapper(self._writer)";
    "class:SimpleQueue(multiprocessing.queues.SimpleQueue):" -> "Fxn:_make_methods";
    "Fxn:_make_methods" -> "Fxn:ConnectionWrapper(self._reader)";
    "Fxn:_make_methods" -> "Fxn:ConnectionWrapper(self._writer)";
    "Fxn:_make_methods" -> "Fxn:self)._make_methods()";
    "/torch/multiprocessing/reductions.py" -> "Import:torch";
    "/torch/multiprocessing/reductions.py" -> "Import:import";
    "/torch/multiprocessing/reductions.py" -> "Import:weakref";
    "/torch/multiprocessing/reductions.py" -> "Import:multiprocessing";
    "/torch/multiprocessing/reductions.py" -> "Import:ForkingPickler";
    "/torch/multiprocessing/reductions.py" -> "Import:sys";
    "/torch/multiprocessing/reductions.py" -> "Import:multiprocessing.resource_sharer";
    "/torch/multiprocessing/reductions.py" -> "class:StorageRef(object):";
    "/torch/multiprocessing/reductions.py" -> "Import:get_sharing_strategy";
    "class:StorageRef(object):" -> "Fxn:__init__";
    "class:StorageRef(object):" -> "Fxn:rebuild_event";
    "class:StorageRef(object):" -> "Fxn:reduce_event";
    "class:StorageRef(object):" -> "Fxn:rebuild_tensor";
    "class:StorageRef(object):" -> "Fxn:reduce_tensor";
    "class:StorageRef(object):" -> "Fxn:fd_id";
    "class:StorageRef(object):" -> "Fxn:storage_from_cache";
    "class:StorageRef(object):" -> "Fxn:rebuild_storage_fd";
    "class:StorageRef(object):" -> "Fxn:rebuild_storage_filename";
    "class:StorageRef(object):" -> "Fxn:rebuild_storage_cuda";
    "class:StorageRef(object):" -> "Fxn:reduce_storage";
    "class:StorageRef(object):" -> "Fxn:init_reductions";
    "Fxn:__init__" -> "Fxn:weakref.WeakValueDictionary()";
    "Fxn:rebuild_event" -> "Fxn:torch.cuda.Event(_handle=handle)";
    "Fxn:rebuild_tensor" -> "Fxn:cls()";
    "Fxn:rebuild_tensor" -> "Fxn:new_tensor.set_(storage,";
    "Fxn:reduce_tensor" -> "Fxn:tensor.size(),";
    "Fxn:reduce_tensor" -> "Fxn:tensor.stride())";
    "Fxn:reduce_tensor" -> "Fxn:tensor.storage()";
    "Fxn:fd_id" -> "Fxn:os.fstat(fd)";
    "Fxn:storage_from_cache" -> "Fxn:shared_cache.get(key)";
    "Fxn:storage_from_cache" -> "Fxn:cls._new_with_weak_ptr(storage_ref)";
    "Fxn:rebuild_storage_fd" -> "Fxn:multiprocessing.reduction.rebuild_handle(df)";
    "Fxn:rebuild_storage_fd" -> "Fxn:df.detach()";
    "Fxn:rebuild_storage_fd" -> "Fxn:storage_from_cache(cls,";
    "Fxn:rebuild_storage_fd" -> "Fxn:fd_id(fd))";
    "Fxn:rebuild_storage_fd" -> "Fxn:cls._new_shared_fd(fd,";
    "Fxn:rebuild_storage_fd" -> "Fxn:shared_cache[fd_id(fd)]";
    "Fxn:rebuild_storage_fd" -> "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:rebuild_storage_fd" -> "Fxn:os.close(fd)";
    "Fxn:rebuild_storage_filename" -> "Fxn:storage_from_cache(cls,";
    "Fxn:rebuild_storage_filename" -> "Fxn:storage._shared_decref()";
    "Fxn:rebuild_storage_filename" -> "Fxn:cls._new_shared_filename(manager,";
    "Fxn:rebuild_storage_filename" -> "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:rebuild_storage_filename" -> "Fxn:storage._shared_decref()";
    "Fxn:rebuild_storage_cuda" -> "Fxn:storage_from_cache(cls,";
    "Fxn:rebuild_storage_cuda" -> "Fxn:storage._new_view(offset,";
    "Fxn:rebuild_storage_cuda" -> "Fxn:torch.cuda._lazy_init()";
    "Fxn:rebuild_storage_cuda" -> "Fxn:cls._new_shared_cuda(device,";
    "Fxn:rebuild_storage_cuda" -> "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:reduce_storage" -> "Fxn:storage._share_cuda_()";
    "Fxn:reduce_storage" -> "Fxn:get_sharing_strategy()";
    "Fxn:reduce_storage" -> "Fxn:storage._share_filename_()";
    "Fxn:reduce_storage" -> "Fxn:storage._shared_incref()";
    "Fxn:reduce_storage" -> "Fxn:storage._share_fd_()";
    "Fxn:reduce_storage" -> "Fxn:multiprocessing.reduction.reduce_handle(fd)";
    "Fxn:reduce_storage" -> "Fxn:multiprocessing.reduction.DupFd(fd)";
    "Fxn:reduce_storage" -> "Fxn:fd_id(fd)";
    "Fxn:reduce_storage" -> "Fxn:storage._weak_ref(StorageRef)";
    "Fxn:init_reductions" -> "Fxn:ForkingPickler.register(torch.cuda.Event,";
    "Fxn:init_reductions" -> "Fxn:ForkingPickler.register(t,";
    "Fxn:init_reductions" -> "Fxn:ForkingPickler.register(t,";
    "/torch/multiprocessing/__init__.py" -> "Import:sys";
    "/torch/multiprocessing/__init__.py" -> "Import:init_reductions";
    "/torch/multiprocessing/__init__.py" -> "Import:multiprocessing";
    "/torch/multiprocessing/__init__.py" -> "Import:__all__";
    "/torch/multiprocessing/__init__.py" -> "Import:Queue,";
    "/torch/multiprocessing/__init__.py" -> "Import:Pool";
    "/torch/multiprocessing/__init__.py" -> "Fxn:set_sharing_strategy";
    "/torch/multiprocessing/__init__.py" -> "Fxn:get_sharing_strategy";
    "/torch/multiprocessing/__init__.py" -> "Fxn:get_all_sharing_strategies";
    "/torch/nn/functional.py" -> "Import:warnings";
    "/torch/nn/functional.py" -> "Import:math";
    "/torch/nn/functional.py" -> "Import:mul";
    "/torch/nn/functional.py" -> "Import:reduce";
    "/torch/nn/functional.py" -> "Import:torch";
    "/torch/nn/functional.py" -> "Import:_infer_size,";
    "/torch/nn/functional.py" -> "Import:_functions";
    "/torch/nn/functional.py" -> "Import:utils";
    "/torch/nn/functional.py" -> "Import:Bilinear";
    "/torch/nn/functional.py" -> "Import:ConstantPadNd";
    "/torch/nn/functional.py" -> "Import:vision";
    "/torch/nn/functional.py" -> "Import:Col2Im,";
    "/torch/nn/functional.py" -> "Import:Variable";
    "/torch/nn/functional.py" -> "Import:_single,";
    "/torch/nn/functional.py" -> "Fxn:conv_tbc";
    "/torch/nn/functional.py" -> "Fxn:avg_pool1d";
    "/torch/nn/functional.py" -> "Fxn:fractional_max_pool2d";
    "/torch/nn/functional.py" -> "Fxn:max_pool1d";
    "/torch/nn/functional.py" -> "Fxn:max_pool2d";
    "/torch/nn/functional.py" -> "Fxn:max_pool3d";
    "/torch/nn/functional.py" -> "Fxn:_unpool_output_size";
    "/torch/nn/functional.py" -> "Fxn:max_unpool1d";
    "/torch/nn/functional.py" -> "Fxn:max_unpool2d";
    "/torch/nn/functional.py" -> "Fxn:max_unpool3d";
    "/torch/nn/functional.py" -> "Fxn:lp_pool2d";
    "/torch/nn/functional.py" -> "Fxn:lp_pool1d";
    "/torch/nn/functional.py" -> "Fxn:adaptive_max_pool1d";
    "/torch/nn/functional.py" -> "Fxn:adaptive_max_pool2d";
    "/torch/nn/functional.py" -> "Fxn:adaptive_max_pool3d";
    "/torch/nn/functional.py" -> "Fxn:dropout";
    "/torch/nn/functional.py" -> "Fxn:alpha_dropout";
    "/torch/nn/functional.py" -> "Fxn:dropout2d";
    "/torch/nn/functional.py" -> "Fxn:dropout3d";
    "/torch/nn/functional.py" -> "Fxn:threshold";
    "/torch/nn/functional.py" -> "Fxn:relu";
    "/torch/nn/functional.py" -> "Fxn:glu";
    "/torch/nn/functional.py" -> "Fxn:hardtanh";
    "/torch/nn/functional.py" -> "Fxn:relu6";
    "/torch/nn/functional.py" -> "Fxn:elu";
    "/torch/nn/functional.py" -> "Fxn:selu";
    "/torch/nn/functional.py" -> "Fxn:leaky_relu";
    "/torch/nn/functional.py" -> "Fxn:rrelu";
    "/torch/nn/functional.py" -> "Fxn:tanhshrink";
    "/torch/nn/functional.py" -> "Fxn:softsign";
    "/torch/nn/functional.py" -> "Fxn:_get_softmax_dim";
    "/torch/nn/functional.py" -> "Fxn:softmin";
    "/torch/nn/functional.py" -> "Fxn:softmax";
    "/torch/nn/functional.py" -> "Fxn:_sample_gumbel";
    "/torch/nn/functional.py" -> "Fxn:_gumbel_softmax_sample";
    "/torch/nn/functional.py" -> "Fxn:gumbel_softmax";
    "/torch/nn/functional.py" -> "Fxn:log_softmax";
    "/torch/nn/functional.py" -> "Fxn:tanh";
    "/torch/nn/functional.py" -> "Fxn:sigmoid";
    "/torch/nn/functional.py" -> "Fxn:linear";
    "/torch/nn/functional.py" -> "Fxn:bilinear";
    "/torch/nn/functional.py" -> "Fxn:embedding";
    "/torch/nn/functional.py" -> "Fxn:embedding_bag";
    "/torch/nn/functional.py" -> "Fxn:batch_norm";
    "/torch/nn/functional.py" -> "Fxn:instance_norm";
    "/torch/nn/functional.py" -> "Import:torch.onnx.symbolic";
    "/torch/nn/functional.py" -> "Fxn:_instance_norm";
    "/torch/nn/functional.py" -> "Fxn:layer_norm";
    "/torch/nn/functional.py" -> "Fxn:local_response_norm";
    "/torch/nn/functional.py" -> "Fxn:nll_loss";
    "/torch/nn/functional.py" -> "Fxn:poisson_nll_loss";
    "/torch/nn/functional.py" -> "Fxn:cross_entropy";
    "/torch/nn/functional.py" -> "Fxn:binary_cross_entropy";
    "/torch/nn/functional.py" -> "Fxn:binary_cross_entropy_with_logits";
    "/torch/nn/functional.py" -> "Fxn:_pointwise_loss";
    "/torch/nn/functional.py" -> "Fxn:l1_loss";
    "/torch/nn/functional.py" -> "Fxn:mse_loss";
    "/torch/nn/functional.py" -> "Fxn:margin_ranking_loss";
    "/torch/nn/functional.py" -> "Fxn:hinge_embedding_loss";
    "/torch/nn/functional.py" -> "Fxn:multilabel_soft_margin_loss";
    "/torch/nn/functional.py" -> "Fxn:cosine_embedding_loss";
    "/torch/nn/functional.py" -> "Fxn:multi_margin_loss";
    "/torch/nn/functional.py" -> "Fxn:pixel_shuffle";
    "/torch/nn/functional.py" -> "Fxn:upsample";
    "/torch/nn/functional.py" -> "Import:Integral";
    "/torch/nn/functional.py" -> "Import:_ntuple";
    "/torch/nn/functional.py" -> "Fxn:_check_size_scale_factor";
    "/torch/nn/functional.py" -> "Fxn:_scale_factor";
    "/torch/nn/functional.py" -> "Fxn:_output_size";
    "/torch/nn/functional.py" -> "Fxn:upsample_nearest";
    "/torch/nn/functional.py" -> "Fxn:upsample_bilinear";
    "/torch/nn/functional.py" -> "Fxn:grid_sample";
    "/torch/nn/functional.py" -> "Fxn:affine_grid";
    "/torch/nn/functional.py" -> "Fxn:pad";
    "/torch/nn/functional.py" -> "Fxn:pairwise_distance";
    "/torch/nn/functional.py" -> "Fxn:cosine_similarity";
    "/torch/nn/functional.py" -> "Fxn:triplet_margin_loss";
    "/torch/nn/functional.py" -> "Fxn:normalize";
    "/torch/nn/functional.py" -> "Fxn:assert_int_or_pair";
    "/torch/nn/functional.py" -> "Fxn:unfold";
    "/torch/nn/functional.py" -> "Fxn:fold";
    "/torch/nn/init.py" -> "Import:math";
    "/torch/nn/init.py" -> "Import:random";
    "/torch/nn/init.py" -> "Import:torch";
    "/torch/nn/init.py" -> "Fxn:calculate_gain";
    "/torch/nn/init.py" -> "Fxn:uniform";
    "/torch/nn/init.py" -> "Fxn:normal";
    "/torch/nn/init.py" -> "Fxn:constant";
    "/torch/nn/init.py" -> "Fxn:eye";
    "/torch/nn/init.py" -> "Fxn:dirac";
    "/torch/nn/init.py" -> "Fxn:_calculate_fan_in_and_fan_out";
    "/torch/nn/init.py" -> "Fxn:xavier_uniform";
    "/torch/nn/init.py" -> "Fxn:xavier_normal";
    "/torch/nn/init.py" -> "Fxn:_calculate_correct_fan";
    "/torch/nn/init.py" -> "Fxn:kaiming_uniform";
    "/torch/nn/init.py" -> "Fxn:kaiming_normal";
    "/torch/nn/init.py" -> "Fxn:orthogonal";
    "/torch/nn/init.py" -> "Fxn:sparse";
    "/torch/nn/parameter.py" -> "Import:Variable";
    "/torch/nn/parameter.py" -> "class:Parameter(Variable):";
    "class:Parameter(Variable):" -> "Fxn:__new__";
    "class:Parameter(Variable):" -> "Fxn:__repr__";
    "Fxn:__new__" -> "Fxn:cls).__new__(cls,";
    "Fxn:__repr__" -> "Fxn:self).__repr__().replace('Variable',";
    "/torch/nn/__init__.py" -> "Import:.parameter";
    "/torch/nn/__init__.py" -> "Import:Parameter";
    "/torch/nn/__init__.py" -> "Import:DataParallel";
    "/torch/nn/__init__.py" -> "Import:init";
    "/torch/nn/__init__.py" -> "Import:utils";
    "/torch/nn/backends/backend.py" -> "class:FunctionBackend(object):";
    "class:FunctionBackend(object):" -> "Fxn:__init__";
    "class:FunctionBackend(object):" -> "Fxn:__getattr__";
    "class:FunctionBackend(object):" -> "Fxn:register_function";
    "Fxn:__getattr__" -> "Fxn:self.function_classes.get(name)";
    "Fxn:register_function" -> "Fxn:self.function_classes.get(name):";
    "Fxn:register_function" -> "Fxn:RuntimeError("Trying";
    "/torch/nn/backends/thnn.py" -> "Import:FunctionBackend";
    "/torch/nn/backends/thnn.py" -> "class:THNNFunctionBackend(FunctionBackend):";
    "/torch/nn/backends/thnn.py" -> "Import:_all_functions";
    "/torch/nn/backends/thnn.py" -> "Import:RNN,";
    "/torch/nn/backends/thnn.py" -> "Import:Dropout,";
    "/torch/nn/backends/thnn.py" -> "Import:MarginRankingLoss";
    "class:THNNFunctionBackend(FunctionBackend):" -> "Fxn:__reduce__";
    "class:THNNFunctionBackend(FunctionBackend):" -> "Fxn:__deepcopy__";
    "class:THNNFunctionBackend(FunctionBackend):" -> "Fxn:__copy__";
    "class:THNNFunctionBackend(FunctionBackend):" -> "Fxn:_get_thnn_function_backend";
    "class:THNNFunctionBackend(FunctionBackend):" -> "Fxn:_initialize_backend";
    "Fxn:__deepcopy__" -> "Fxn:memo[id(self)]";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('RNN',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('RNNTanhCell',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('RNNReLUCell',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('LSTMCell',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('GRUCell',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('Dropout',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('Dropout2d',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('Dropout3d',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function('MarginRankingLoss',";
    "Fxn:_initialize_backend" -> "Fxn:backend.register_function(name,";
    "Fxn:_initialize_backend" -> "Fxn:THNNFunctionBackend()";
    "Fxn:_initialize_backend" -> "Fxn:_initialize_backend()";
    "/torch/nn/modules/activation.py" -> "Import:warnings";
    "/torch/nn/modules/activation.py" -> "Import:torch";
    "/torch/nn/modules/activation.py" -> "Import:Parameter";
    "/torch/nn/modules/activation.py" -> "Import:Module";
    "/torch/nn/modules/activation.py" -> "Import:functional";
    "/torch/nn/modules/activation.py" -> "class:Threshold(Module):";
    "/torch/nn/modules/activation.py" -> "class:ReLU(Threshold):";
    "/torch/nn/modules/activation.py" -> "class:RReLU(Module):";
    "/torch/nn/modules/activation.py" -> "class:Hardtanh(Module):";
    "/torch/nn/modules/activation.py" -> "class:ReLU6(Hardtanh):";
    "/torch/nn/modules/activation.py" -> "class:Sigmoid(Module):";
    "/torch/nn/modules/activation.py" -> "class:Tanh(Module):";
    "/torch/nn/modules/activation.py" -> "class:ELU(Module):";
    "/torch/nn/modules/activation.py" -> "class:SELU(Module):";
    "/torch/nn/modules/activation.py" -> "class:GLU(Module):";
    "/torch/nn/modules/activation.py" -> "class:Hardshrink(Module):";
    "/torch/nn/modules/activation.py" -> "class:LeakyReLU(Module):";
    "/torch/nn/modules/activation.py" -> "class:LogSigmoid(Module):";
    "/torch/nn/modules/activation.py" -> "class:Softplus(Module):";
    "/torch/nn/modules/activation.py" -> "class:Softshrink(Module):";
    "/torch/nn/modules/activation.py" -> "class:PReLU(Module):";
    "/torch/nn/modules/activation.py" -> "class:Softsign(Module):";
    "/torch/nn/modules/activation.py" -> "class:Tanhshrink(Module):";
    "/torch/nn/modules/activation.py" -> "class:Softmin(Module):";
    "/torch/nn/modules/activation.py" -> "class:Softmax(Module):";
    "/torch/nn/modules/activation.py" -> "class:Softmax2d(Module):";
    "/torch/nn/modules/activation.py" -> "class:LogSoftmax(Module):";
    "class:Threshold(Module):" -> "Fxn:__init__";
    "class:Threshold(Module):" -> "Fxn:forward";
    "class:Threshold(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.threshold(input,";
    "class:ReLU(Threshold):" -> "Fxn:__init__";
    "class:ReLU(Threshold):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__(0,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:RReLU(Module):" -> "Fxn:__init__";
    "class:RReLU(Module):" -> "Fxn:forward";
    "class:RReLU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.rrelu(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:Hardtanh(Module):" -> "Fxn:__init__";
    "class:Hardtanh(Module):" -> "Fxn:forward";
    "class:Hardtanh(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:warnings.warn("keyword";
    "Fxn:__init__" -> "Fxn:warnings.warn("keyword";
    "Fxn:forward" -> "Fxn:F.hardtanh(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ReLU6(Hardtanh):" -> "Fxn:__init__";
    "class:ReLU6(Hardtanh):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__(0,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:Sigmoid(Module):" -> "Fxn:forward";
    "class:Sigmoid(Module):" -> "Fxn:__repr__";
    "Fxn:forward" -> "Fxn:torch.sigmoid(input)";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:Tanh(Module):" -> "Fxn:forward";
    "class:Tanh(Module):" -> "Fxn:__repr__";
    "Fxn:forward" -> "Fxn:torch.tanh(input)";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:ELU(Module):" -> "Fxn:__init__";
    "class:ELU(Module):" -> "Fxn:forward";
    "class:ELU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.elu(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:SELU(Module):" -> "Fxn:__init__";
    "class:SELU(Module):" -> "Fxn:forward";
    "class:SELU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.selu(input,";
    "Fxn:__repr__" -> "Fxn:'(inplace)'";
    "class:GLU(Module):" -> "Fxn:__init__";
    "class:GLU(Module):" -> "Fxn:forward";
    "class:GLU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.glu(input,";
    "Fxn:__repr__" -> "Fxn:'{}(dim={})'.format(self.__class__.__name__,";
    "class:Hardshrink(Module):" -> "Fxn:__init__";
    "class:Hardshrink(Module):" -> "Fxn:forward";
    "class:Hardshrink(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.hardshrink(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:LeakyReLU(Module):" -> "Fxn:__init__";
    "class:LeakyReLU(Module):" -> "Fxn:forward";
    "class:LeakyReLU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.leaky_relu(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:LogSigmoid(Module):" -> "Fxn:forward";
    "class:LogSigmoid(Module):" -> "Fxn:__repr__";
    "Fxn:forward" -> "Fxn:F.logsigmoid(input)";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:Softplus(Module):" -> "Fxn:__init__";
    "class:Softplus(Module):" -> "Fxn:forward";
    "class:Softplus(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.softplus(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:Softshrink(Module):" -> "Fxn:__init__";
    "class:Softshrink(Module):" -> "Fxn:forward";
    "class:Softshrink(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.softshrink(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:PReLU(Module):" -> "Fxn:__init__";
    "class:PReLU(Module):" -> "Fxn:forward";
    "class:PReLU(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(num_parameters).fill_(init))";
    "Fxn:forward" -> "Fxn:F.prelu(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:Softsign(Module):" -> "Fxn:forward";
    "class:Softsign(Module):" -> "Fxn:__repr__";
    "Fxn:forward" -> "Fxn:F.softsign(input)";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:Tanhshrink(Module):" -> "Fxn:forward";
    "class:Tanhshrink(Module):" -> "Fxn:__repr__";
    "Fxn:forward" -> "Fxn:F.tanhshrink(input)";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:Softmin(Module):" -> "Fxn:__init__";
    "class:Softmin(Module):" -> "Fxn:forward";
    "class:Softmin(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.softmin(input,";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:Softmax(Module):" -> "Fxn:__init__";
    "class:Softmax(Module):" -> "Fxn:__setstate__";
    "class:Softmax(Module):" -> "Fxn:forward";
    "class:Softmax(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.update(state)";
    "Fxn:forward" -> "Fxn:F.softmax(input,";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:Softmax2d(Module):" -> "Fxn:forward";
    "class:Softmax2d(Module):" -> "Fxn:__repr__";
    "Fxn:forward" -> "Fxn:input.dim()";
    "Fxn:forward" -> "Fxn:F.softmax(input,";
    "Fxn:__repr__" -> "Fxn:'()'";
    "class:LogSoftmax(Module):" -> "Fxn:__init__";
    "class:LogSoftmax(Module):" -> "Fxn:__setstate__";
    "class:LogSoftmax(Module):" -> "Fxn:forward";
    "class:LogSoftmax(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.update(state)";
    "Fxn:forward" -> "Fxn:F.log_softmax(input,";
    "Fxn:__repr__" -> "Fxn:'()'";
    "/torch/nn/modules/batchnorm.py" -> "Import:torch";
    "/torch/nn/modules/batchnorm.py" -> "Import:Module";
    "/torch/nn/modules/batchnorm.py" -> "Import:Parameter";
    "/torch/nn/modules/batchnorm.py" -> "Import:functional";
    "/torch/nn/modules/batchnorm.py" -> "class:_BatchNorm(Module):";
    "/torch/nn/modules/batchnorm.py" -> "class:BatchNorm1d(_BatchNorm):";
    "/torch/nn/modules/batchnorm.py" -> "class:BatchNorm2d(_BatchNorm):";
    "/torch/nn/modules/batchnorm.py" -> "class:BatchNorm3d(_BatchNorm):";
    "class:_BatchNorm(Module):" -> "Fxn:__init__";
    "class:_BatchNorm(Module):" -> "Fxn:reset_parameters";
    "class:_BatchNorm(Module):" -> "Fxn:_check_input_dim";
    "class:_BatchNorm(Module):" -> "Fxn:forward";
    "class:_BatchNorm(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(num_features))";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(num_features))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('weight',";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias',";
    "Fxn:__init__" -> "Fxn:self.register_buffer('running_mean',";
    "Fxn:__init__" -> "Fxn:torch.zeros(num_features))";
    "Fxn:__init__" -> "Fxn:self.register_buffer('running_var',";
    "Fxn:__init__" -> "Fxn:torch.ones(num_features))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('running_mean',";
    "Fxn:__init__" -> "Fxn:self.register_parameter('running_var',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:self.running_mean.zero_()";
    "Fxn:reset_parameters" -> "Fxn:self.running_var.fill_(1)";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data.uniform_()";
    "Fxn:reset_parameters" -> "Fxn:self.bias.data.zero_()";
    "Fxn:forward" -> "Fxn:self._check_input_dim(input)";
    "Fxn:forward" -> "Fxn:F.batch_norm(";
    "Fxn:__repr__" -> "Fxn:.format(name=self.__class__.__name__,";
    "class:BatchNorm1d(_BatchNorm):" -> "Fxn:_check_input_dim";
    "Fxn:_check_input_dim" -> "Fxn:input.dim()";
    "Fxn:_check_input_dim" -> "Fxn:input.dim()";
    "Fxn:_check_input_dim" -> "Fxn:ValueError('expected";
    "Fxn:_check_input_dim" -> "Fxn:.format(input.dim()))";
    "class:BatchNorm2d(_BatchNorm):" -> "Fxn:_check_input_dim";
    "Fxn:_check_input_dim" -> "Fxn:input.dim()";
    "Fxn:_check_input_dim" -> "Fxn:ValueError('expected";
    "Fxn:_check_input_dim" -> "Fxn:.format(input.dim()))";
    "class:BatchNorm3d(_BatchNorm):" -> "Fxn:_check_input_dim";
    "Fxn:_check_input_dim" -> "Fxn:input.dim()";
    "Fxn:_check_input_dim" -> "Fxn:ValueError('expected";
    "Fxn:_check_input_dim" -> "Fxn:.format(input.dim()))";
    "/torch/nn/modules/container.py" -> "Import:warnings";
    "/torch/nn/modules/container.py" -> "Import:OrderedDict,";
    "/torch/nn/modules/container.py" -> "Import:islice";
    "/torch/nn/modules/container.py" -> "Import:operator";
    "/torch/nn/modules/container.py" -> "Import:torch";
    "/torch/nn/modules/container.py" -> "Import:Module";
    "/torch/nn/modules/container.py" -> "class:Container(Module):";
    "/torch/nn/modules/container.py" -> "class:Sequential(Module):";
    "/torch/nn/modules/container.py" -> "class:ModuleList(Module):";
    "/torch/nn/modules/container.py" -> "class:MyModule(nn.Module):";
    "/torch/nn/modules/container.py" -> "class:ParameterList(Module):";
    "/torch/nn/modules/container.py" -> "class:MyModule(nn.Module):";
    "class:Container(Module):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:warnings.warn("nn.Container";
    "Fxn:__init__" -> "Fxn:kwargs.items():";
    "Fxn:__init__" -> "Fxn:self.add_module(key,";
    "class:Sequential(Module):" -> "Fxn:__init__";
    "class:Sequential(Module):" -> "Fxn:_get_item_by_idx";
    "class:Sequential(Module):" -> "Fxn:__getitem__";
    "class:Sequential(Module):" -> "Fxn:__setitem__";
    "class:Sequential(Module):" -> "Fxn:__delitem__";
    "class:Sequential(Module):" -> "Fxn:__len__";
    "class:Sequential(Module):" -> "Fxn:__dir__";
    "class:Sequential(Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:args[0].items():";
    "Fxn:__init__" -> "Fxn:self.add_module(key,";
    "Fxn:__init__" -> "Fxn:self.add_module(str(idx),";
    "Fxn:_get_item_by_idx" -> "Fxn:operator.index(idx)";
    "Fxn:_get_item_by_idx" -> "Fxn:IndexError('index";
    "Fxn:_get_item_by_idx" -> "Fxn:range'.format(idx))";
    "Fxn:__getitem__" -> "Fxn:Sequential(OrderedDict(list(self._modules.items())[idx]))";
    "Fxn:__getitem__" -> "Fxn:self._get_item_by_idx(self._modules.values(),";
    "Fxn:__setitem__" -> "Fxn:self._get_item_by_idx(self._modules.keys(),";
    "Fxn:__delitem__" -> "Fxn:self._get_item_by_idx(self._modules.keys(),";
    "Fxn:__dir__" -> "Fxn:self).__dir__()";
    "Fxn:__dir__" -> "Fxn:key.isdigit()]";
    "Fxn:forward" -> "Fxn:self._modules.values():";
    "Fxn:forward" -> "Fxn:module(input)";
    "class:MyModule(nn.Module):" -> "Fxn:__init__";
    "class:MyModule(nn.Module):" -> "Fxn:forward";
    "class:MyModule(nn.Module):" -> "Fxn:__init__";
    "class:MyModule(nn.Module):" -> "Fxn:_get_abs_string_index";
    "class:MyModule(nn.Module):" -> "Fxn:__getitem__";
    "class:MyModule(nn.Module):" -> "Fxn:__setitem__";
    "class:MyModule(nn.Module):" -> "Fxn:__delitem__";
    "class:MyModule(nn.Module):" -> "Fxn:__len__";
    "class:MyModule(nn.Module):" -> "Fxn:__iter__";
    "class:MyModule(nn.Module):" -> "Fxn:__iadd__";
    "class:MyModule(nn.Module):" -> "Fxn:__dir__";
    "class:MyModule(nn.Module):" -> "Fxn:append";
    "class:MyModule(nn.Module):" -> "Fxn:extend";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.ModuleList([nn.Linear(10,";
    "Fxn:forward" -> "Fxn:2](x)";
    "Fxn:forward" -> "Fxn:l(x)";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:_get_abs_string_index" -> "Fxn:operator.index(idx)";
    "Fxn:_get_abs_string_index" -> "Fxn:IndexError('index";
    "Fxn:_get_abs_string_index" -> "Fxn:range'.format(idx))";
    "Fxn:__getitem__" -> "Fxn:ModuleList(list(self._modules.values())[idx])";
    "Fxn:__getitem__" -> "Fxn:self._modules[self._get_abs_string_index(idx)]";
    "Fxn:__setitem__" -> "Fxn:operator.index(idx)";
    "Fxn:__delitem__" -> "Fxn:self._get_abs_string_index(idx))";
    "Fxn:__delitem__" -> "Fxn:[str(i)";
    "Fxn:__delitem__" -> "Fxn:OrderedDict(list(zip(str_indices,";
    "Fxn:__delitem__" -> "Fxn:self._modules.values())))";
    "Fxn:__iadd__" -> "Fxn:self.extend(modules)";
    "Fxn:__dir__" -> "Fxn:self).__dir__()";
    "Fxn:__dir__" -> "Fxn:key.isdigit()]";
    "Fxn:append" -> "Fxn:self.add_module(str(len(self)),";
    "Fxn:extend" -> "Fxn:TypeError("ModuleList.extend";
    "Fxn:extend" -> "Fxn:self.add_module(str(offset";
    "class:MyModule(nn.Module):" -> "Fxn:__init__";
    "class:MyModule(nn.Module):" -> "Fxn:forward";
    "class:MyModule(nn.Module):" -> "Fxn:__init__";
    "class:MyModule(nn.Module):" -> "Fxn:__getitem__";
    "class:MyModule(nn.Module):" -> "Fxn:__setitem__";
    "class:MyModule(nn.Module):" -> "Fxn:__len__";
    "class:MyModule(nn.Module):" -> "Fxn:__iter__";
    "class:MyModule(nn.Module):" -> "Fxn:__iadd__";
    "class:MyModule(nn.Module):" -> "Fxn:__dir__";
    "class:MyModule(nn.Module):" -> "Fxn:append";
    "class:MyModule(nn.Module):" -> "Fxn:extend";
    "class:MyModule(nn.Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.ParameterList([nn.Parameter(torch.randn(10,";
    "Fxn:forward" -> "Fxn:2].mm(x)";
    "Fxn:forward" -> "Fxn:p.mm(x)";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__getitem__" -> "Fxn:ParameterList(list(self._parameters.values())[idx])";
    "Fxn:__getitem__" -> "Fxn:operator.index(idx)";
    "Fxn:__getitem__" -> "Fxn:IndexError('index";
    "Fxn:__getitem__" -> "Fxn:range'.format(idx))";
    "Fxn:__getitem__" -> "Fxn:self._parameters[str(idx)]";
    "Fxn:__setitem__" -> "Fxn:operator.index(idx)";
    "Fxn:__setitem__" -> "Fxn:self.register_parameter(str(idx),";
    "Fxn:__iadd__" -> "Fxn:self.extend(parameters)";
    "Fxn:__dir__" -> "Fxn:self).__dir__()";
    "Fxn:__dir__" -> "Fxn:key.isdigit()]";
    "Fxn:append" -> "Fxn:self.register_parameter(str(len(self)),";
    "Fxn:extend" -> "Fxn:TypeError("ParameterList.extend";
    "Fxn:extend" -> "Fxn:self.register_parameter(str(offset";
    "Fxn:__repr__" -> "Fxn:'(\n'";
    "Fxn:__repr__" -> "Fxn:self._parameters.items():";
    "Fxn:__repr__" -> "Fxn:'x'.join(str(size)";
    "Fxn:__repr__" -> "Fxn:p.size())";
    "Fxn:__repr__" -> "Fxn:{})'.format(p.get_device())";
    "Fxn:__repr__" -> "Fxn:{}{}]'.format(";
    "Fxn:__repr__" -> "Fxn:torch.typename(p.data),";
    "/torch/nn/modules/conv.py" -> "Import:math";
    "/torch/nn/modules/conv.py" -> "Import:torch";
    "/torch/nn/modules/conv.py" -> "Import:Parameter";
    "/torch/nn/modules/conv.py" -> "Import:functional";
    "/torch/nn/modules/conv.py" -> "Import:Module";
    "/torch/nn/modules/conv.py" -> "Import:_single,";
    "/torch/nn/modules/conv.py" -> "class:_ConvNd(Module):";
    "/torch/nn/modules/conv.py" -> "class:Conv1d(_ConvNd):";
    "/torch/nn/modules/conv.py" -> "class:Conv2d(_ConvNd):";
    "/torch/nn/modules/conv.py" -> "class:Conv3d(_ConvNd):";
    "/torch/nn/modules/conv.py" -> "class:_ConvTransposeMixin(object):";
    "/torch/nn/modules/conv.py" -> "class:ConvTranspose1d(_ConvTransposeMixin,";
    "/torch/nn/modules/conv.py" -> "class:ConvTranspose2d(_ConvTransposeMixin,";
    "/torch/nn/modules/conv.py" -> "class:ConvTranspose3d(_ConvTransposeMixin,";
    "class:_ConvNd(Module):" -> "Fxn:__init__";
    "class:_ConvNd(Module):" -> "Fxn:reset_parameters";
    "class:_ConvNd(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError('in_channels";
    "Fxn:__init__" -> "Fxn:ValueError('out_channels";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(out_channels))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:math.sqrt(n)";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data.uniform_(-stdv,";
    "Fxn:reset_parameters" -> "Fxn:self.bias.data.uniform_(-stdv,";
    "Fxn:__repr__" -> "Fxn:s.format(name=self.__class__.__name__,";
    "class:Conv1d(_ConvNd):" -> "Fxn:__init__";
    "class:Conv1d(_ConvNd):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:_single(kernel_size)";
    "Fxn:__init__" -> "Fxn:_single(stride)";
    "Fxn:__init__" -> "Fxn:_single(padding)";
    "Fxn:__init__" -> "Fxn:_single(dilation)";
    "Fxn:__init__" -> "Fxn:self).__init__(";
    "Fxn:__init__" -> "Fxn:_single(0),";
    "Fxn:forward" -> "Fxn:F.conv1d(input,";
    "class:Conv2d(_ConvNd):" -> "Fxn:__init__";
    "class:Conv2d(_ConvNd):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:_pair(kernel_size)";
    "Fxn:__init__" -> "Fxn:_pair(stride)";
    "Fxn:__init__" -> "Fxn:_pair(padding)";
    "Fxn:__init__" -> "Fxn:_pair(dilation)";
    "Fxn:__init__" -> "Fxn:self).__init__(";
    "Fxn:__init__" -> "Fxn:_pair(0),";
    "Fxn:forward" -> "Fxn:F.conv2d(input,";
    "class:Conv3d(_ConvNd):" -> "Fxn:__init__";
    "class:Conv3d(_ConvNd):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:_triple(kernel_size)";
    "Fxn:__init__" -> "Fxn:_triple(stride)";
    "Fxn:__init__" -> "Fxn:_triple(padding)";
    "Fxn:__init__" -> "Fxn:_triple(dilation)";
    "Fxn:__init__" -> "Fxn:self).__init__(";
    "Fxn:__init__" -> "Fxn:_triple(0),";
    "Fxn:forward" -> "Fxn:F.conv3d(input,";
    "class:_ConvTransposeMixin(object):" -> "Fxn:forward";
    "class:_ConvTransposeMixin(object):" -> "Fxn:_output_padding";
    "class:_ConvTransposeMixin(object):" -> "Fxn:dim_size";
    "Fxn:forward" -> "Fxn:self._output_padding(input,";
    "Fxn:forward" -> "Fxn:self._backend.ConvNd(";
    "Fxn:forward" -> "Fxn:func(input,";
    "Fxn:forward" -> "Fxn:func(input,";
    "Fxn:_output_padding" -> "Fxn:input.dim()";
    "Fxn:_output_padding" -> "Fxn:ValueError(";
    "Fxn:_output_padding" -> "Fxn:.format(k,";
    "Fxn:dim_size" -> "Fxn:[dim_size(d)";
    "Fxn:dim_size" -> "Fxn:ValueError((";
    "Fxn:dim_size" -> "Fxn:{})").format(";
    "Fxn:dim_size" -> "Fxn:input.size()[2:]))";
    "class:ConvTranspose1d(_ConvTransposeMixin," -> "Fxn:__init__";
    "class:ConvTranspose1d(_ConvTransposeMixin," -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:_single(kernel_size)";
    "Fxn:__init__" -> "Fxn:_single(stride)";
    "Fxn:__init__" -> "Fxn:_single(padding)";
    "Fxn:__init__" -> "Fxn:_single(dilation)";
    "Fxn:__init__" -> "Fxn:_single(output_padding)";
    "Fxn:__init__" -> "Fxn:self).__init__(";
    "Fxn:forward" -> "Fxn:self._output_padding(input,";
    "Fxn:forward" -> "Fxn:F.conv_transpose1d(";
    "class:ConvTranspose2d(_ConvTransposeMixin," -> "Fxn:__init__";
    "class:ConvTranspose2d(_ConvTransposeMixin," -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:_pair(kernel_size)";
    "Fxn:__init__" -> "Fxn:_pair(stride)";
    "Fxn:__init__" -> "Fxn:_pair(padding)";
    "Fxn:__init__" -> "Fxn:_pair(dilation)";
    "Fxn:__init__" -> "Fxn:_pair(output_padding)";
    "Fxn:__init__" -> "Fxn:self).__init__(";
    "Fxn:forward" -> "Fxn:self._output_padding(input,";
    "Fxn:forward" -> "Fxn:F.conv_transpose2d(";
    "class:ConvTranspose3d(_ConvTransposeMixin," -> "Fxn:__init__";
    "class:ConvTranspose3d(_ConvTransposeMixin," -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:_triple(kernel_size)";
    "Fxn:__init__" -> "Fxn:_triple(stride)";
    "Fxn:__init__" -> "Fxn:_triple(padding)";
    "Fxn:__init__" -> "Fxn:_triple(dilation)";
    "Fxn:__init__" -> "Fxn:_triple(output_padding)";
    "Fxn:__init__" -> "Fxn:self).__init__(";
    "Fxn:forward" -> "Fxn:self._output_padding(input,";
    "Fxn:forward" -> "Fxn:F.conv_transpose3d(";
    "/torch/nn/modules/distance.py" -> "Import:torch";
    "/torch/nn/modules/distance.py" -> "Import:Module";
    "/torch/nn/modules/distance.py" -> "Import:functional";
    "/torch/nn/modules/distance.py" -> "class:PairwiseDistance(Module):";
    "/torch/nn/modules/distance.py" -> "class:CosineSimilarity(Module):";
    "class:PairwiseDistance(Module):" -> "Fxn:__init__";
    "class:PairwiseDistance(Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.pairwise_distance(x1,";
    "class:CosineSimilarity(Module):" -> "Fxn:__init__";
    "class:CosineSimilarity(Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.cosine_similarity(x1,";
    "/torch/nn/modules/dropout.py" -> "Import:Module";
    "/torch/nn/modules/dropout.py" -> "Import:functional";
    "/torch/nn/modules/dropout.py" -> "class:Dropout(Module):";
    "/torch/nn/modules/dropout.py" -> "class:Dropout2d(Module):";
    "/torch/nn/modules/dropout.py" -> "class:Dropout3d(Module):";
    "/torch/nn/modules/dropout.py" -> "class:AlphaDropout(Module):";
    "class:Dropout(Module):" -> "Fxn:__init__";
    "class:Dropout(Module):" -> "Fxn:forward";
    "class:Dropout(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError("dropout";
    "Fxn:__init__" -> "Fxn:{}".format(p))";
    "Fxn:forward" -> "Fxn:F.dropout(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:Dropout2d(Module):" -> "Fxn:__init__";
    "class:Dropout2d(Module):" -> "Fxn:forward";
    "class:Dropout2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError("dropout";
    "Fxn:__init__" -> "Fxn:{}".format(p))";
    "Fxn:forward" -> "Fxn:F.dropout2d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:Dropout3d(Module):" -> "Fxn:__init__";
    "class:Dropout3d(Module):" -> "Fxn:forward";
    "class:Dropout3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError("dropout";
    "Fxn:__init__" -> "Fxn:{}".format(p))";
    "Fxn:forward" -> "Fxn:F.dropout3d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AlphaDropout(Module):" -> "Fxn:__init__";
    "class:AlphaDropout(Module):" -> "Fxn:forward";
    "class:AlphaDropout(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:ValueError("dropout";
    "Fxn:__init__" -> "Fxn:{}".format(p))";
    "Fxn:forward" -> "Fxn:F.alpha_dropout(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "/torch/nn/modules/fold.py" -> "Import:Module";
    "/torch/nn/modules/fold.py" -> "Import:functional";
    "/torch/nn/modules/fold.py" -> "class:Fold(Module):";
    "/torch/nn/modules/fold.py" -> "class:Unfold(Module):";
    "class:Fold(Module):" -> "Fxn:__init__";
    "class:Fold(Module):" -> "Fxn:forward";
    "class:Fold(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.fold(input,";
    "class:Unfold(Module):" -> "Fxn:__init__";
    "class:Unfold(Module):" -> "Fxn:forward";
    "class:Unfold(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.unfold(input,";
    "/torch/nn/modules/instancenorm.py" -> "Import:_BatchNorm";
    "/torch/nn/modules/instancenorm.py" -> "Import:functional";
    "/torch/nn/modules/instancenorm.py" -> "class:_InstanceNorm(_BatchNorm):";
    "/torch/nn/modules/instancenorm.py" -> "class:InstanceNorm1d(_InstanceNorm):";
    "/torch/nn/modules/instancenorm.py" -> "class:InstanceNorm2d(_InstanceNorm):";
    "/torch/nn/modules/instancenorm.py" -> "class:InstanceNorm3d(_InstanceNorm):";
    "class:_InstanceNorm(_BatchNorm):" -> "Fxn:__init__";
    "class:_InstanceNorm(_BatchNorm):" -> "Fxn:_check_input_dim";
    "class:_InstanceNorm(_BatchNorm):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(";
    "Fxn:forward" -> "Fxn:self._check_input_dim(input)";
    "Fxn:forward" -> "Fxn:F.instance_norm(";
    "class:InstanceNorm1d(_InstanceNorm):" -> "Fxn:_check_input_dim";
    "Fxn:_check_input_dim" -> "Fxn:input.dim()";
    "Fxn:_check_input_dim" -> "Fxn:ValueError('expected";
    "Fxn:_check_input_dim" -> "Fxn:.format(input.dim()))";
    "class:InstanceNorm2d(_InstanceNorm):" -> "Fxn:_check_input_dim";
    "Fxn:_check_input_dim" -> "Fxn:input.dim()";
    "Fxn:_check_input_dim" -> "Fxn:ValueError('expected";
    "Fxn:_check_input_dim" -> "Fxn:.format(input.dim()))";
    "class:InstanceNorm3d(_InstanceNorm):" -> "Fxn:_check_input_dim";
    "Fxn:_check_input_dim" -> "Fxn:input.dim()";
    "Fxn:_check_input_dim" -> "Fxn:ValueError('expected";
    "Fxn:_check_input_dim" -> "Fxn:.format(input.dim()))";
    "/torch/nn/modules/linear.py" -> "Import:math";
    "/torch/nn/modules/linear.py" -> "Import:torch";
    "/torch/nn/modules/linear.py" -> "Import:Parameter";
    "/torch/nn/modules/linear.py" -> "Import:functional";
    "/torch/nn/modules/linear.py" -> "Import:Module";
    "/torch/nn/modules/linear.py" -> "class:Linear(Module):";
    "/torch/nn/modules/linear.py" -> "class:Bilinear(Module):";
    "class:Linear(Module):" -> "Fxn:__init__";
    "class:Linear(Module):" -> "Fxn:reset_parameters";
    "class:Linear(Module):" -> "Fxn:forward";
    "class:Linear(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(out_features,";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(out_features))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data.uniform_(-stdv,";
    "Fxn:reset_parameters" -> "Fxn:self.bias.data.uniform_(-stdv,";
    "Fxn:forward" -> "Fxn:F.linear(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:Bilinear(Module):" -> "Fxn:__init__";
    "class:Bilinear(Module):" -> "Fxn:reset_parameters";
    "class:Bilinear(Module):" -> "Fxn:forward";
    "class:Bilinear(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(out_features,";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(out_features))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:math.sqrt(self.weight.size(1))";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data.uniform_(-stdv,";
    "Fxn:reset_parameters" -> "Fxn:self.bias.data.uniform_(-stdv,";
    "Fxn:forward" -> "Fxn:F.bilinear(input1,";
    "Fxn:__repr__" -> "Fxn:'('";
    "/torch/nn/modules/loss.py" -> "Import:warnings";
    "/torch/nn/modules/loss.py" -> "Import:Variable";
    "/torch/nn/modules/loss.py" -> "Import:torch";
    "/torch/nn/modules/loss.py" -> "Import:Module";
    "/torch/nn/modules/loss.py" -> "Import:Sequential";
    "/torch/nn/modules/loss.py" -> "Import:LogSoftmax";
    "/torch/nn/modules/loss.py" -> "Import:functional";
    "/torch/nn/modules/loss.py" -> "Fxn:_assert_no_grad";
    "/torch/nn/modules/loss.py" -> "class:_Loss(Module):";
    "/torch/nn/modules/loss.py" -> "class:_WeightedLoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:L1Loss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:NLLLoss(_WeightedLoss):";
    "/torch/nn/modules/loss.py" -> "class:NLLLoss2d(NLLLoss):";
    "/torch/nn/modules/loss.py" -> "class:PoissonNLLLoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:KLDivLoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:MSELoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:BCELoss(_WeightedLoss):";
    "/torch/nn/modules/loss.py" -> "class:BCEWithLogitsLoss(Module):";
    "/torch/nn/modules/loss.py" -> "class:HingeEmbeddingLoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:MultiLabelMarginLoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:SmoothL1Loss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:SoftMarginLoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:CrossEntropyLoss(_WeightedLoss):";
    "/torch/nn/modules/loss.py" -> "class:MultiLabelSoftMarginLoss(_WeightedLoss):";
    "/torch/nn/modules/loss.py" -> "class:CosineEmbeddingLoss(_Loss):";
    "/torch/nn/modules/loss.py" -> "class:MarginRankingLoss(Module):";
    "/torch/nn/modules/loss.py" -> "class:MultiMarginLoss(_WeightedLoss):";
    "/torch/nn/modules/loss.py" -> "class:TripletMarginLoss(Module):";
    "class:_Loss(Module):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "class:_WeightedLoss(_Loss):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:__init__" -> "Fxn:self.register_buffer('weight',";
    "class:L1Loss(_Loss):" -> "Fxn:__init__";
    "class:L1Loss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.l1_loss(input,";
    "class:NLLLoss(_WeightedLoss):" -> "Fxn:__init__";
    "class:NLLLoss(_WeightedLoss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(weight,";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.nll_loss(input,";
    "class:NLLLoss2d(NLLLoss):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:warnings.warn("NLLLoss2d";
    "Fxn:__init__" -> "Fxn:self).__init__(weight,";
    "class:PoissonNLLLoss(_Loss):" -> "Fxn:__init__";
    "class:PoissonNLLLoss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.poisson_nll_loss(log_input,";
    "class:KLDivLoss(_Loss):" -> "Fxn:__init__";
    "class:KLDivLoss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.kl_div(input,";
    "class:MSELoss(_Loss):" -> "Fxn:__init__";
    "class:MSELoss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.mse_loss(input,";
    "class:BCELoss(_WeightedLoss):" -> "Fxn:__init__";
    "class:BCELoss(_WeightedLoss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(weight,";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.binary_cross_entropy(input,";
    "class:BCEWithLogitsLoss(Module):" -> "Fxn:__init__";
    "class:BCEWithLogitsLoss(Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:self.register_buffer('weight',";
    "Fxn:forward" -> "Fxn:Variable(self.weight)";
    "Fxn:forward" -> "Fxn:F.binary_cross_entropy_with_logits(input,";
    "Fxn:forward" -> "Fxn:F.binary_cross_entropy_with_logits(input,";
    "class:HingeEmbeddingLoss(_Loss):" -> "Fxn:__init__";
    "class:HingeEmbeddingLoss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:F.hinge_embedding_loss(input,";
    "class:MultiLabelMarginLoss(_Loss):" -> "Fxn:__init__";
    "class:MultiLabelMarginLoss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.multilabel_margin_loss(input,";
    "class:SmoothL1Loss(_Loss):" -> "Fxn:__init__";
    "class:SmoothL1Loss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.smooth_l1_loss(input,";
    "class:SoftMarginLoss(_Loss):" -> "Fxn:__init__";
    "class:SoftMarginLoss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.soft_margin_loss(input,";
    "class:CrossEntropyLoss(_WeightedLoss):" -> "Fxn:__init__";
    "class:CrossEntropyLoss(_WeightedLoss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(weight,";
    "Fxn:forward" -> "Fxn:_assert_no_grad(target)";
    "Fxn:forward" -> "Fxn:F.cross_entropy(input,";
    "class:MultiLabelSoftMarginLoss(_WeightedLoss):" -> "Fxn:__init__";
    "class:MultiLabelSoftMarginLoss(_WeightedLoss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(weight,";
    "Fxn:forward" -> "Fxn:F.multilabel_soft_margin_loss(input,";
    "class:CosineEmbeddingLoss(_Loss):" -> "Fxn:__init__";
    "class:CosineEmbeddingLoss(_Loss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size_average)";
    "Fxn:forward" -> "Fxn:F.cosine_embedding_loss(input1,";
    "class:MarginRankingLoss(Module):" -> "Fxn:__init__";
    "class:MarginRankingLoss(Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.margin_ranking_loss(input1,";
    "class:MultiMarginLoss(_WeightedLoss):" -> "Fxn:__init__";
    "class:MultiMarginLoss(_WeightedLoss):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(weight,";
    "Fxn:__init__" -> "Fxn:ValueError("only";
    "Fxn:__init__" -> "Fxn:weight.dim()";
    "Fxn:forward" -> "Fxn:F.multi_margin_loss(input,";
    "class:TripletMarginLoss(Module):" -> "Fxn:__init__";
    "class:TripletMarginLoss(Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.triplet_margin_loss(anchor,";
    "/torch/nn/modules/module.py" -> "Import:OrderedDict";
    "/torch/nn/modules/module.py" -> "Import:functools";
    "/torch/nn/modules/module.py" -> "Import:torch";
    "/torch/nn/modules/module.py" -> "Import:backend";
    "/torch/nn/modules/module.py" -> "Import:Parameter";
    "/torch/nn/modules/module.py" -> "Import:Variable";
    "/torch/nn/modules/module.py" -> "Import:torch.utils.hooks";
    "/torch/nn/modules/module.py" -> "Fxn:_addindent";
    "/torch/nn/modules/module.py" -> "class:Module(object):";
    "/torch/nn/modules/module.py" -> "Import:torch.nn";
    "/torch/nn/modules/module.py" -> "Import:torch.nn.functional";
    "/torch/nn/modules/module.py" -> "class:Model(nn.Module):";
    "class:Model(nn.Module):" -> "Fxn:__init__";
    "class:Model(nn.Module):" -> "Fxn:forward";
    "class:Model(nn.Module):" -> "Fxn:__init__";
    "class:Model(nn.Module):" -> "Fxn:forward";
    "class:Model(nn.Module):" -> "Fxn:register_buffer";
    "class:Model(nn.Module):" -> "Fxn:register_parameter";
    "class:Model(nn.Module):" -> "Fxn:add_module";
    "class:Model(nn.Module):" -> "Fxn:_apply";
    "class:Model(nn.Module):" -> "Fxn:apply";
    "class:Model(nn.Module):" -> "Fxn:init_weights";
    "class:Model(nn.Module):" -> "Fxn:cuda";
    "class:Model(nn.Module):" -> "Fxn:cpu";
    "class:Model(nn.Module):" -> "Fxn:type";
    "class:Model(nn.Module):" -> "Fxn:float";
    "class:Model(nn.Module):" -> "Fxn:double";
    "class:Model(nn.Module):" -> "Fxn:half";
    "class:Model(nn.Module):" -> "Fxn:register_backward_hook";
    "class:Model(nn.Module):" -> "Fxn:register_forward_pre_hook";
    "class:Model(nn.Module):" -> "Fxn:register_forward_hook";
    "class:Model(nn.Module):" -> "Fxn:_tracing_name";
    "class:Model(nn.Module):" -> "Fxn:_slow_forward";
    "class:Model(nn.Module):" -> "Fxn:__call__";
    "class:Model(nn.Module):" -> "Fxn:__setstate__";
    "class:Model(nn.Module):" -> "Fxn:__getattr__";
    "class:Model(nn.Module):" -> "Fxn:__setattr__";
    "class:Model(nn.Module):" -> "Fxn:remove_from";
    "class:Model(nn.Module):" -> "Fxn:__delattr__";
    "class:Model(nn.Module):" -> "Fxn:state_dict";
    "class:Model(nn.Module):" -> "Fxn:load_state_dict";
    "class:Model(nn.Module):" -> "Fxn:parameters";
    "class:Model(nn.Module):" -> "Fxn:named_parameters";
    "class:Model(nn.Module):" -> "Fxn:_all_buffers";
    "class:Model(nn.Module):" -> "Fxn:children";
    "class:Model(nn.Module):" -> "Fxn:named_children";
    "class:Model(nn.Module):" -> "Fxn:modules";
    "class:Model(nn.Module):" -> "Fxn:named_modules";
    "class:Model(nn.Module):" -> "Fxn:train";
    "class:Model(nn.Module):" -> "Fxn:eval";
    "class:Model(nn.Module):" -> "Fxn:zero_grad";
    "class:Model(nn.Module):" -> "Fxn:share_memory";
    "class:Model(nn.Module):" -> "Fxn:_get_name";
    "class:Model(nn.Module):" -> "Fxn:__repr__";
    "class:Model(nn.Module):" -> "Fxn:__dir__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:nn.Conv2d(1,";
    "Fxn:__init__" -> "Fxn:nn.Conv2d(20,";
    "Fxn:forward" -> "Fxn:F.relu(self.conv1(x))";
    "Fxn:forward" -> "Fxn:F.relu(self.conv2(x))";
    "Fxn:forward" -> "Fxn:`.cuda()`,";
    "Fxn:__init__" -> "Fxn:OrderedDict()";
    "Fxn:__init__" -> "Fxn:OrderedDict()";
    "Fxn:__init__" -> "Fxn:OrderedDict()";
    "Fxn:__init__" -> "Fxn:OrderedDict()";
    "Fxn:__init__" -> "Fxn:OrderedDict()";
    "Fxn:__init__" -> "Fxn:OrderedDict()";
    "Fxn:register_buffer" -> "Fxn:self.register_buffer('running_mean',";
    "Fxn:register_buffer" -> "Fxn:torch.zeros(num_features))";
    "Fxn:register_buffer" -> "Fxn:KeyError("attribute";
    "Fxn:register_buffer" -> "Fxn:exists".format(name))";
    "Fxn:register_buffer" -> "Fxn:TypeError("cannot";
    "Fxn:register_buffer" -> "Fxn:"(torch";
    "Fxn:register_buffer" -> "Fxn:.format(torch.typename(tensor),";
    "Fxn:register_parameter" -> "Fxn:AttributeError(";
    "Fxn:register_parameter" -> "Fxn:Module.__init__()";
    "Fxn:register_parameter" -> "Fxn:KeyError("attribute";
    "Fxn:register_parameter" -> "Fxn:exists".format(name))";
    "Fxn:register_parameter" -> "Fxn:TypeError("cannot";
    "Fxn:register_parameter" -> "Fxn:"(torch.nn.Parameter";
    "Fxn:register_parameter" -> "Fxn:.format(torch.typename(param),";
    "Fxn:register_parameter" -> "Fxn:ValueError(";
    "Fxn:register_parameter" -> "Fxn:forward()";
    "Fxn:register_parameter" -> "Fxn:method.".format(name))";
    "Fxn:add_module" -> "Fxn:TypeError("{}";
    "Fxn:add_module" -> "Fxn:subclass".format(";
    "Fxn:add_module" -> "Fxn:torch.typename(module)))";
    "Fxn:add_module" -> "Fxn:KeyError("attribute";
    "Fxn:add_module" -> "Fxn:exists".format(name))";
    "Fxn:_apply" -> "Fxn:self.children():";
    "Fxn:_apply" -> "Fxn:module._apply(fn)";
    "Fxn:_apply" -> "Fxn:self._parameters.values():";
    "Fxn:_apply" -> "Fxn:fn(param.data)";
    "Fxn:_apply" -> "Fxn:fn(param._grad.data)";
    "Fxn:_apply" -> "Fxn:self._buffers.items():";
    "Fxn:_apply" -> "Fxn:fn(buf)";
    "Fxn:apply" -> "Fxn:``.children()``)";
    "Fxn:init_weights" -> "Fxn:m.weight.data.fill_(1.0)";
    "Fxn:init_weights" -> "Fxn:nn.Sequential(nn.Linear(2,";
    "Fxn:init_weights" -> "Fxn:nn.Linear(2,";
    "Fxn:init_weights" -> "Fxn:net.apply(init_weights)";
    "Fxn:init_weights" -> "Fxn:Linear(in_features=2,";
    "Fxn:init_weights" -> "Fxn:Linear(in_features=2,";
    "Fxn:init_weights" -> "Fxn:Sequential(";
    "Fxn:init_weights" -> "Fxn:Linear(in_features=2,";
    "Fxn:init_weights" -> "Fxn:Linear(in_features=2,";
    "Fxn:init_weights" -> "Fxn:Sequential(";
    "Fxn:init_weights" -> "Fxn:Linear(in_features=2,";
    "Fxn:init_weights" -> "Fxn:Linear(in_features=2,";
    "Fxn:init_weights" -> "Fxn:self.children():";
    "Fxn:init_weights" -> "Fxn:module.apply(fn)";
    "Fxn:init_weights" -> "Fxn:fn(self)";
    "Fxn:cuda" -> "Fxn:self._apply(lambda";
    "Fxn:cuda" -> "Fxn:t.cuda(device))";
    "Fxn:cpu" -> "Fxn:self._apply(lambda";
    "Fxn:cpu" -> "Fxn:t.cpu())";
    "Fxn:type" -> "Fxn:self._apply(lambda";
    "Fxn:type" -> "Fxn:t.type(dst_type))";
    "Fxn:float" -> "Fxn:self._apply(lambda";
    "Fxn:float" -> "Fxn:t.float()";
    "Fxn:float" -> "Fxn:t.is_floating_point()";
    "Fxn:double" -> "Fxn:self._apply(lambda";
    "Fxn:double" -> "Fxn:t.double()";
    "Fxn:double" -> "Fxn:t.is_floating_point()";
    "Fxn:half" -> "Fxn:self._apply(lambda";
    "Fxn:half" -> "Fxn:t.half()";
    "Fxn:half" -> "Fxn:t.is_floating_point()";
    "Fxn:register_backward_hook" -> "Fxn:hook(module,";
    "Fxn:register_backward_hook" -> "Fxn:``handle.remove()``";
    "Fxn:register_backward_hook" -> "Fxn:hooks.RemovableHandle(self._backward_hooks)";
    "Fxn:register_forward_pre_hook" -> "Fxn:hook(module,";
    "Fxn:register_forward_pre_hook" -> "Fxn:``handle.remove()``";
    "Fxn:register_forward_pre_hook" -> "Fxn:hooks.RemovableHandle(self._forward_pre_hooks)";
    "Fxn:register_forward_hook" -> "Fxn:hook(module,";
    "Fxn:register_forward_hook" -> "Fxn:``handle.remove()``";
    "Fxn:register_forward_hook" -> "Fxn:hooks.RemovableHandle(self._forward_hooks)";
    "Fxn:_tracing_name" -> "Fxn:module.named_children():";
    "Fxn:_slow_forward" -> "Fxn:torch.jit.get_tracing_state(input_vars)";
    "Fxn:_slow_forward" -> "Fxn:self.forward(*input,";
    "Fxn:_slow_forward" -> "Fxn:self._tracing_name(tracing_state)";
    "Fxn:_slow_forward" -> "Fxn:tracing_state.push_scope('%s[%s]'";
    "Fxn:_slow_forward" -> "Fxn:tracing_state.push_scope(self.__class__.__name__)";
    "Fxn:_slow_forward" -> "Fxn:tracing_state._traced_module_stack.append(self)";
    "Fxn:_slow_forward" -> "Fxn:self.forward(*input,";
    "Fxn:_slow_forward" -> "Fxn:tracing_state.pop_scope()";
    "Fxn:_slow_forward" -> "Fxn:tracing_state._traced_module_stack.pop()";
    "Fxn:__call__" -> "Fxn:self._forward_pre_hooks.values():";
    "Fxn:__call__" -> "Fxn:hook(self,";
    "Fxn:__call__" -> "Fxn:self._slow_forward(*input,";
    "Fxn:__call__" -> "Fxn:self.forward(*input,";
    "Fxn:__call__" -> "Fxn:self._forward_hooks.values():";
    "Fxn:__call__" -> "Fxn:hook(self,";
    "Fxn:__call__" -> "Fxn:RuntimeError(";
    "Fxn:__call__" -> "Fxn:None".format(hook))";
    "Fxn:__call__" -> "Fxn:var.values()";
    "Fxn:__call__" -> "Fxn:self._backward_hooks.values():";
    "Fxn:__call__" -> "Fxn:functools.partial(hook,";
    "Fxn:__call__" -> "Fxn:functools.update_wrapper(wrapper,";
    "Fxn:__call__" -> "Fxn:grad_fn.register_hook(wrapper)";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.update(state)";
    "Fxn:__setstate__" -> "Fxn:OrderedDict()";
    "Fxn:__getattr__" -> "Fxn:AttributeError("'{}'";
    "Fxn:__getattr__" -> "Fxn:'{}'".format(";
    "Fxn:remove_from" -> "Fxn:self.__dict__.get('_parameters')";
    "Fxn:remove_from" -> "Fxn:AttributeError(";
    "Fxn:remove_from" -> "Fxn:Module.__init__()";
    "Fxn:remove_from" -> "Fxn:remove_from(self.__dict__,";
    "Fxn:remove_from" -> "Fxn:self.register_parameter(name,";
    "Fxn:remove_from" -> "Fxn:TypeError("cannot";
    "Fxn:remove_from" -> "Fxn:"(torch.nn.Parameter";
    "Fxn:remove_from" -> "Fxn:.format(torch.typename(value),";
    "Fxn:remove_from" -> "Fxn:self.register_parameter(name,";
    "Fxn:remove_from" -> "Fxn:self.__dict__.get('_modules')";
    "Fxn:remove_from" -> "Fxn:AttributeError(";
    "Fxn:remove_from" -> "Fxn:Module.__init__()";
    "Fxn:remove_from" -> "Fxn:remove_from(self.__dict__,";
    "Fxn:remove_from" -> "Fxn:TypeError("cannot";
    "Fxn:remove_from" -> "Fxn:"(torch.nn.Module";
    "Fxn:remove_from" -> "Fxn:.format(torch.typename(value),";
    "Fxn:remove_from" -> "Fxn:self.__dict__.get('_buffers')";
    "Fxn:remove_from" -> "Fxn:torch.is_tensor(value):";
    "Fxn:remove_from" -> "Fxn:TypeError("cannot";
    "Fxn:remove_from" -> "Fxn:"(torch.Tensor";
    "Fxn:remove_from" -> "Fxn:.format(torch.typename(value),";
    "Fxn:remove_from" -> "Fxn:object.__setattr__(self,";
    "Fxn:__delattr__" -> "Fxn:object.__delattr__(self,";
    "Fxn:state_dict" -> "Fxn:module.state_dict().keys()";
    "Fxn:state_dict" -> "Fxn:OrderedDict()";
    "Fxn:state_dict" -> "Fxn:self._parameters.items():";
    "Fxn:state_dict" -> "Fxn:self._buffers.items():";
    "Fxn:state_dict" -> "Fxn:self._modules.items():";
    "Fxn:state_dict" -> "Fxn:module.state_dict(destination,";
    "Fxn:load_state_dict" -> "Fxn::func:`state_dict()`";
    "Fxn:load_state_dict" -> "Fxn:`:func:`state_dict()`";
    "Fxn:load_state_dict" -> "Fxn:self.state_dict()";
    "Fxn:load_state_dict" -> "Fxn:state_dict.items():";
    "Fxn:load_state_dict" -> "Fxn:own_state[name].copy_(param)";
    "Fxn:load_state_dict" -> "Fxn:RuntimeError('While";
    "Fxn:load_state_dict" -> "Fxn:.format(name,";
    "Fxn:load_state_dict" -> "Fxn:own_state[name].size(),";
    "Fxn:load_state_dict" -> "Fxn:param.size()))";
    "Fxn:load_state_dict" -> "Fxn:KeyError('unexpected";
    "Fxn:load_state_dict" -> "Fxn:.format(name))";
    "Fxn:load_state_dict" -> "Fxn:KeyError('missing";
    "Fxn:load_state_dict" -> "Fxn:"{}"'.format(missing))";
    "Fxn:parameters" -> "Fxn:model.parameters():";
    "Fxn:parameters" -> "Fxn:param.size())";
    "Fxn:parameters" -> "Fxn:self.named_parameters():";
    "Fxn:named_parameters" -> "Fxn:self.named_parameters():";
    "Fxn:named_parameters" -> "Fxn:self._parameters.items():";
    "Fxn:named_parameters" -> "Fxn:memo.add(p)";
    "Fxn:named_parameters" -> "Fxn:self.named_children():";
    "Fxn:named_parameters" -> "Fxn:module.named_parameters(memo,";
    "Fxn:_all_buffers" -> "Fxn:self._buffers.items():";
    "Fxn:_all_buffers" -> "Fxn:memo.add(b)";
    "Fxn:_all_buffers" -> "Fxn:self.children():";
    "Fxn:_all_buffers" -> "Fxn:module._all_buffers(memo):";
    "Fxn:children" -> "Fxn:self.named_children():";
    "Fxn:named_children" -> "Fxn:model.named_children():";
    "Fxn:named_children" -> "Fxn:self._modules.items():";
    "Fxn:named_children" -> "Fxn:memo.add(module)";
    "Fxn:modules" -> "Fxn:nn.Linear(2,";
    "Fxn:modules" -> "Fxn:nn.Sequential(l,";
    "Fxn:modules" -> "Fxn:self.named_modules():";
    "Fxn:named_modules" -> "Fxn:nn.Linear(2,";
    "Fxn:named_modules" -> "Fxn:nn.Sequential(l,";
    "Fxn:named_modules" -> "Fxn:memo.add(self)";
    "Fxn:named_modules" -> "Fxn:self._modules.items():";
    "Fxn:named_modules" -> "Fxn:module.named_modules(memo,";
    "Fxn:train" -> "Fxn:self.children():";
    "Fxn:train" -> "Fxn:module.train(mode)";
    "Fxn:eval" -> "Fxn:self.train(False)";
    "Fxn:zero_grad" -> "Fxn:self.parameters():";
    "Fxn:zero_grad" -> "Fxn:p.grad.detach_()";
    "Fxn:zero_grad" -> "Fxn:p.grad.zero_()";
    "Fxn:share_memory" -> "Fxn:self._apply(lambda";
    "Fxn:share_memory" -> "Fxn:t.share_memory_())";
    "Fxn:__repr__" -> "Fxn:self._get_name()";
    "Fxn:__repr__" -> "Fxn:'(\n'";
    "Fxn:__repr__" -> "Fxn:self._modules.items():";
    "Fxn:__repr__" -> "Fxn:module.__repr__()";
    "Fxn:__repr__" -> "Fxn:_addindent(modstr,";
    "Fxn:__dir__" -> "Fxn:key[0].isdigit()]";
    "/torch/nn/modules/normalization.py" -> "Import:torch";
    "/torch/nn/modules/normalization.py" -> "Import:numbers";
    "/torch/nn/modules/normalization.py" -> "Import:Parameter";
    "/torch/nn/modules/normalization.py" -> "Import:Module";
    "/torch/nn/modules/normalization.py" -> "Import:_BatchNorm";
    "/torch/nn/modules/normalization.py" -> "Import:functional";
    "/torch/nn/modules/normalization.py" -> "class:LocalResponseNorm(Module):";
    "/torch/nn/modules/normalization.py" -> "class:CrossMapLRN2d(Module):";
    "/torch/nn/modules/normalization.py" -> "class:LayerNorm(Module):";
    "class:LocalResponseNorm(Module):" -> "Fxn:__init__";
    "class:LocalResponseNorm(Module):" -> "Fxn:forward";
    "class:LocalResponseNorm(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.local_response_norm(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:CrossMapLRN2d(Module):" -> "Fxn:__init__";
    "class:CrossMapLRN2d(Module):" -> "Fxn:forward";
    "class:CrossMapLRN2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:self._backend.CrossMapLRN2d(self.size,";
    "Fxn:forward" -> "Fxn:self.k)(input)";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:LayerNorm(Module):" -> "Fxn:__init__";
    "class:LayerNorm(Module):" -> "Fxn:reset_parameters";
    "class:LayerNorm(Module):" -> "Fxn:forward";
    "class:LayerNorm(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.Size(normalized_shape)";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(*normalized_shape))";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(*normalized_shape))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('weight',";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias',";
    "Fxn:__init__" -> "Fxn:self.register_buffer('running_mean',";
    "Fxn:__init__" -> "Fxn:torch.zeros(1))";
    "Fxn:__init__" -> "Fxn:self.register_buffer('running_var',";
    "Fxn:__init__" -> "Fxn:torch.ones(1))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('running_mean',";
    "Fxn:__init__" -> "Fxn:self.register_parameter('running_var',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:self.running_mean.zero_()";
    "Fxn:reset_parameters" -> "Fxn:self.running_var.fill_(1)";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data.fill_(1)";
    "Fxn:reset_parameters" -> "Fxn:self.bias.data.zero_()";
    "Fxn:forward" -> "Fxn:F.layer_norm(";
    "Fxn:__repr__" -> "Fxn:.format(name=self.__class__.__name__,";
    "/torch/nn/modules/padding.py" -> "Import:Module";
    "/torch/nn/modules/padding.py" -> "Import:_pair,";
    "/torch/nn/modules/padding.py" -> "Import:functional";
    "/torch/nn/modules/padding.py" -> "class:ConstantPad1d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ConstantPad2d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ConstantPad3d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ReflectionPad1d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ReflectionPad2d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ReplicationPad1d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ReplicationPad2d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ReplicationPad3d(Module):";
    "/torch/nn/modules/padding.py" -> "class:ZeroPad2d(ConstantPad2d):";
    "class:ConstantPad1d(Module):" -> "Fxn:__init__";
    "class:ConstantPad1d(Module):" -> "Fxn:forward";
    "class:ConstantPad1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_pair(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ConstantPad2d(Module):" -> "Fxn:__init__";
    "class:ConstantPad2d(Module):" -> "Fxn:forward";
    "class:ConstantPad2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_quadruple(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ConstantPad3d(Module):" -> "Fxn:__init__";
    "class:ConstantPad3d(Module):" -> "Fxn:forward";
    "class:ConstantPad3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_ntuple(6)(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ReflectionPad1d(Module):" -> "Fxn:__init__";
    "class:ReflectionPad1d(Module):" -> "Fxn:forward";
    "class:ReflectionPad1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_pair(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ReflectionPad2d(Module):" -> "Fxn:__init__";
    "class:ReflectionPad2d(Module):" -> "Fxn:forward";
    "class:ReflectionPad2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_quadruple(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ReplicationPad1d(Module):" -> "Fxn:__init__";
    "class:ReplicationPad1d(Module):" -> "Fxn:forward";
    "class:ReplicationPad1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_pair(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ReplicationPad2d(Module):" -> "Fxn:__init__";
    "class:ReplicationPad2d(Module):" -> "Fxn:forward";
    "class:ReplicationPad2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_quadruple(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ReplicationPad3d(Module):" -> "Fxn:__init__";
    "class:ReplicationPad3d(Module):" -> "Fxn:forward";
    "class:ReplicationPad3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_ntuple(6)(padding)";
    "Fxn:forward" -> "Fxn:F.pad(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:ZeroPad2d(ConstantPad2d):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__(padding,";
    "/torch/nn/modules/pixelshuffle.py" -> "Import:Module";
    "/torch/nn/modules/pixelshuffle.py" -> "Import:functional";
    "/torch/nn/modules/pixelshuffle.py" -> "class:PixelShuffle(Module):";
    "class:PixelShuffle(Module):" -> "Fxn:__init__";
    "class:PixelShuffle(Module):" -> "Fxn:forward";
    "class:PixelShuffle(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.pixel_shuffle(input,";
    "Fxn:__repr__" -> "Fxn:'(upscale_factor='";
    "/torch/nn/modules/pooling.py" -> "Import:torch";
    "/torch/nn/modules/pooling.py" -> "Import:Variable";
    "/torch/nn/modules/pooling.py" -> "Import:Module";
    "/torch/nn/modules/pooling.py" -> "Import:_single,";
    "/torch/nn/modules/pooling.py" -> "Import:functional";
    "/torch/nn/modules/pooling.py" -> "class:MaxPool1d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:MaxPool2d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:MaxUnpool1d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:MaxUnpool2d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:MaxUnpool3d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AvgPool1d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AvgPool2d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:MaxPool3d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AvgPool3d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:FractionalMaxPool2d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:LPPool2d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:LPPool1d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AdaptiveMaxPool1d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AdaptiveMaxPool2d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AdaptiveMaxPool3d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AdaptiveAvgPool1d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AdaptiveAvgPool2d(Module):";
    "/torch/nn/modules/pooling.py" -> "class:AdaptiveAvgPool3d(Module):";
    "class:MaxPool1d(Module):" -> "Fxn:__init__";
    "class:MaxPool1d(Module):" -> "Fxn:forward";
    "class:MaxPool1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.max_pool1d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:MaxPool2d(Module):" -> "Fxn:__init__";
    "class:MaxPool2d(Module):" -> "Fxn:forward";
    "class:MaxPool2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.max_pool2d(input,";
    "Fxn:__repr__" -> "Fxn:_pair(self.kernel_size)";
    "Fxn:__repr__" -> "Fxn:_pair(self.stride)";
    "Fxn:__repr__" -> "Fxn:_pair(self.padding)";
    "Fxn:__repr__" -> "Fxn:_pair(self.dilation)";
    "Fxn:__repr__" -> "Fxn:padding=('";
    "Fxn:__repr__" -> "Fxn:dilation=('";
    "Fxn:__repr__" -> "Fxn:'('";
    "Fxn:__repr__" -> "Fxn:'kernel_size=('";
    "Fxn:__repr__" -> "Fxn:stride=('";
    "class:MaxUnpool1d(Module):" -> "Fxn:__init__";
    "class:MaxUnpool1d(Module):" -> "Fxn:forward";
    "class:MaxUnpool1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_single(kernel_size)";
    "Fxn:__init__" -> "Fxn:_single(stride";
    "Fxn:__init__" -> "Fxn:_single(padding)";
    "Fxn:forward" -> "Fxn:F.max_unpool1d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:MaxUnpool2d(Module):" -> "Fxn:__init__";
    "class:MaxUnpool2d(Module):" -> "Fxn:forward";
    "class:MaxUnpool2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_pair(kernel_size)";
    "Fxn:__init__" -> "Fxn:_pair(stride";
    "Fxn:__init__" -> "Fxn:_pair(padding)";
    "Fxn:forward" -> "Fxn:F.max_unpool2d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:MaxUnpool3d(Module):" -> "Fxn:__init__";
    "class:MaxUnpool3d(Module):" -> "Fxn:forward";
    "class:MaxUnpool3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_triple(kernel_size)";
    "Fxn:__init__" -> "Fxn:_triple(stride";
    "Fxn:__init__" -> "Fxn:_triple(padding)";
    "Fxn:forward" -> "Fxn:F.max_unpool3d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AvgPool1d(Module):" -> "Fxn:__init__";
    "class:AvgPool1d(Module):" -> "Fxn:forward";
    "class:AvgPool1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_single(kernel_size)";
    "Fxn:__init__" -> "Fxn:_single(stride";
    "Fxn:__init__" -> "Fxn:_single(padding)";
    "Fxn:forward" -> "Fxn:F.avg_pool1d(";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AvgPool2d(Module):" -> "Fxn:__init__";
    "class:AvgPool2d(Module):" -> "Fxn:forward";
    "class:AvgPool2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.avg_pool2d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:MaxPool3d(Module):" -> "Fxn:__init__";
    "class:MaxPool3d(Module):" -> "Fxn:forward";
    "class:MaxPool3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.max_pool3d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AvgPool3d(Module):" -> "Fxn:__init__";
    "class:AvgPool3d(Module):" -> "Fxn:forward";
    "class:AvgPool3d(Module):" -> "Fxn:__setstate__";
    "class:AvgPool3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.avg_pool3d(input,";
    "Fxn:__setstate__" -> "Fxn:self).__setstate__(d)";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('padding',";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('ceil_mode',";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('count_include_pad',";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:FractionalMaxPool2d(Module):" -> "Fxn:__init__";
    "class:FractionalMaxPool2d(Module):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:_pair(kernel_size)";
    "Fxn:__init__" -> "Fxn:self.register_buffer('_random_samples',";
    "Fxn:__init__" -> "Fxn:_pair(output_size)";
    "Fxn:__init__" -> "Fxn:_pair(output_ratio)";
    "Fxn:__init__" -> "Fxn:ValueError("FractionalMaxPool2d";
    "Fxn:__init__" -> "Fxn:ValueError("only";
    "Fxn:__init__" -> "Fxn:ValueError("output_ratio";
    "Fxn:__init__" -> "Fxn:.format(output_ratio))";
    "Fxn:forward" -> "Fxn:F.fractional_max_pool2d(";
    "class:LPPool2d(Module):" -> "Fxn:__init__";
    "class:LPPool2d(Module):" -> "Fxn:forward";
    "class:LPPool2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.lp_pool2d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:LPPool1d(Module):" -> "Fxn:__init__";
    "class:LPPool1d(Module):" -> "Fxn:forward";
    "class:LPPool1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.lp_pool1d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AdaptiveMaxPool1d(Module):" -> "Fxn:__init__";
    "class:AdaptiveMaxPool1d(Module):" -> "Fxn:forward";
    "class:AdaptiveMaxPool1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.adaptive_max_pool1d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AdaptiveMaxPool2d(Module):" -> "Fxn:__init__";
    "class:AdaptiveMaxPool2d(Module):" -> "Fxn:forward";
    "class:AdaptiveMaxPool2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.adaptive_max_pool2d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AdaptiveMaxPool3d(Module):" -> "Fxn:__init__";
    "class:AdaptiveMaxPool3d(Module):" -> "Fxn:forward";
    "class:AdaptiveMaxPool3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.adaptive_max_pool3d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AdaptiveAvgPool1d(Module):" -> "Fxn:__init__";
    "class:AdaptiveAvgPool1d(Module):" -> "Fxn:forward";
    "class:AdaptiveAvgPool1d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.adaptive_avg_pool1d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AdaptiveAvgPool2d(Module):" -> "Fxn:__init__";
    "class:AdaptiveAvgPool2d(Module):" -> "Fxn:forward";
    "class:AdaptiveAvgPool2d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.adaptive_avg_pool2d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:AdaptiveAvgPool3d(Module):" -> "Fxn:__init__";
    "class:AdaptiveAvgPool3d(Module):" -> "Fxn:forward";
    "class:AdaptiveAvgPool3d(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.adaptive_avg_pool3d(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "/torch/nn/modules/rnn.py" -> "Import:math";
    "/torch/nn/modules/rnn.py" -> "Import:torch";
    "/torch/nn/modules/rnn.py" -> "Import:warnings";
    "/torch/nn/modules/rnn.py" -> "Import:itertools";
    "/torch/nn/modules/rnn.py" -> "Import:Module";
    "/torch/nn/modules/rnn.py" -> "Import:Parameter";
    "/torch/nn/modules/rnn.py" -> "Import:PackedSequence";
    "/torch/nn/modules/rnn.py" -> "class:RNNBase(Module):";
    "/torch/nn/modules/rnn.py" -> "Import:torch.backends.cudnn.rnn";
    "/torch/nn/modules/rnn.py" -> "class:RNN(RNNBase):";
    "/torch/nn/modules/rnn.py" -> "class:LSTM(RNNBase):";
    "/torch/nn/modules/rnn.py" -> "class:GRU(RNNBase):";
    "/torch/nn/modules/rnn.py" -> "class:RNNCellBase(Module):";
    "/torch/nn/modules/rnn.py" -> "class:RNNCell(RNNCellBase):";
    "/torch/nn/modules/rnn.py" -> "class:LSTMCell(RNNCellBase):";
    "/torch/nn/modules/rnn.py" -> "class:GRUCell(RNNCellBase):";
    "class:RNNBase(Module):" -> "Fxn:__init__";
    "class:RNNBase(Module):" -> "Fxn:flatten_parameters";
    "class:RNNBase(Module):" -> "Fxn:_apply";
    "class:RNNBase(Module):" -> "Fxn:reset_parameters";
    "class:RNNBase(Module):" -> "Fxn:check_forward_args";
    "class:RNNBase(Module):" -> "Fxn:check_hidden_size";
    "class:RNNBase(Module):" -> "Fxn:forward";
    "class:RNNBase(Module):" -> "Fxn:__repr__";
    "class:RNNBase(Module):" -> "Fxn:__setstate__";
    "class:RNNBase(Module):" -> "Fxn:all_weights";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(gate_size,";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(gate_size,";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(gate_size))";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(gate_size))";
    "Fxn:__init__" -> "Fxn:[x.format(layer,";
    "Fxn:__init__" -> "Fxn:self._all_weights.append(param_names)";
    "Fxn:__init__" -> "Fxn:self.flatten_parameters()";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:flatten_parameters" -> "Fxn:torch.backends.cudnn.is_acceptable(any_param):";
    "Fxn:flatten_parameters" -> "Fxn:Module.named_parameters().";
    "Fxn:flatten_parameters" -> "Fxn:torch.cuda.device_of(any_param):";
    "Fxn:flatten_parameters" -> "Fxn:torch.no_grad():";
    "Fxn:flatten_parameters" -> "Fxn:no_grad()";
    "Fxn:flatten_parameters" -> "Fxn:torch._cudnn_rnn_flatten_weight(";
    "Fxn:flatten_parameters" -> "Fxn:rnn.get_cudnn_mode(self.mode),";
    "Fxn:flatten_parameters" -> "Fxn:weight_buf.size(0)";
    "Fxn:flatten_parameters" -> "Fxn:self.parameters())";
    "Fxn:_apply" -> "Fxn:self)._apply(fn)";
    "Fxn:_apply" -> "Fxn:self.flatten_parameters()";
    "Fxn:reset_parameters" -> "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:reset_parameters" -> "Fxn:self.parameters():";
    "Fxn:reset_parameters" -> "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:check_forward_args" -> "Fxn:input.dim()";
    "Fxn:check_forward_args" -> "Fxn:RuntimeError(";
    "Fxn:check_forward_args" -> "Fxn:{}'.format(";
    "Fxn:check_forward_args" -> "Fxn:input.dim()))";
    "Fxn:check_forward_args" -> "Fxn:input.size(-1):";
    "Fxn:check_forward_args" -> "Fxn:RuntimeError(";
    "Fxn:check_forward_args" -> "Fxn:'input.size(-1)";
    "Fxn:check_forward_args" -> "Fxn:{}'.format(";
    "Fxn:check_forward_args" -> "Fxn:input.size(-1)))";
    "Fxn:check_forward_args" -> "Fxn:input.size(0)";
    "Fxn:check_forward_args" -> "Fxn:input.size(1)";
    "Fxn:check_hidden_size" -> "Fxn:RuntimeError(msg.format(expected_hidden_size,";
    "Fxn:check_hidden_size" -> "Fxn:check_hidden_size(hidden[0],";
    "Fxn:check_hidden_size" -> "Fxn:check_hidden_size(hidden[1],";
    "Fxn:check_hidden_size" -> "Fxn:check_hidden_size(hidden,";
    "Fxn:forward" -> "Fxn:input.size(0)";
    "Fxn:forward" -> "Fxn:input.size(1)";
    "Fxn:forward" -> "Fxn:torch.autograd.Variable(input.data.new(self.num_layers";
    "Fxn:forward" -> "Fxn:self.hidden_size).zero_(),";
    "Fxn:forward" -> "Fxn:self.parameters())";
    "Fxn:forward" -> "Fxn:first_data.storage().size()";
    "Fxn:forward" -> "Fxn:first_data.new().set_(first_data.storage(),";
    "Fxn:forward" -> "Fxn:torch.Size([self._param_buf_size]))";
    "Fxn:forward" -> "Fxn:self.check_forward_args(input,";
    "Fxn:forward" -> "Fxn:self._backend.RNN(";
    "Fxn:forward" -> "Fxn:func(input,";
    "Fxn:forward" -> "Fxn:PackedSequence(output,";
    "Fxn:__repr__" -> "Fxn:'{name}({input_size},";
    "Fxn:__repr__" -> "Fxn:s.format(name=self.__class__.__name__,";
    "Fxn:__setstate__" -> "Fxn:self).__setstate__(d)";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.setdefault('_data_ptrs',";
    "Fxn:__setstate__" -> "Fxn:[x.format(layer,";
    "Fxn:all_weights" -> "Fxn:[[getattr(self,";
    "class:RNN(RNNBase):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:ValueError("Unknown";
    "Fxn:__init__" -> "Fxn:'{}'".format(";
    "Fxn:__init__" -> "Fxn:self).__init__(mode,";
    "class:LSTM(RNNBase):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__('LSTM',";
    "class:GRU(RNNBase):" -> "Fxn:__init__";
    "Fxn:__init__" -> "Fxn:self).__init__('GRU',";
    "class:RNNCellBase(Module):" -> "Fxn:__repr__";
    "class:RNNCellBase(Module):" -> "Fxn:check_forward_input";
    "class:RNNCellBase(Module):" -> "Fxn:check_forward_hidden";
    "Fxn:__repr__" -> "Fxn:'{name}({input_size},";
    "Fxn:__repr__" -> "Fxn:s.format(name=self.__class__.__name__,";
    "Fxn:check_forward_input" -> "Fxn:input.size(1)";
    "Fxn:check_forward_input" -> "Fxn:RuntimeError(";
    "Fxn:check_forward_input" -> "Fxn:{}".format(";
    "Fxn:check_forward_input" -> "Fxn:input.size(1),";
    "Fxn:check_forward_hidden" -> "Fxn:input.size(0)";
    "Fxn:check_forward_hidden" -> "Fxn:hx.size(0):";
    "Fxn:check_forward_hidden" -> "Fxn:RuntimeError(";
    "Fxn:check_forward_hidden" -> "Fxn:{}".format(";
    "Fxn:check_forward_hidden" -> "Fxn:input.size(0),";
    "Fxn:check_forward_hidden" -> "Fxn:hx.size(0)))";
    "Fxn:check_forward_hidden" -> "Fxn:hx.size(1)";
    "Fxn:check_forward_hidden" -> "Fxn:RuntimeError(";
    "Fxn:check_forward_hidden" -> "Fxn:{}".format(";
    "Fxn:check_forward_hidden" -> "Fxn:hx.size(1),";
    "class:RNNCell(RNNCellBase):" -> "Fxn:__init__";
    "class:RNNCell(RNNCellBase):" -> "Fxn:reset_parameters";
    "class:RNNCell(RNNCellBase):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(hidden_size,";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(hidden_size,";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(hidden_size))";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(hidden_size))";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias_ih',";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias_hh',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:reset_parameters" -> "Fxn:self.parameters():";
    "Fxn:reset_parameters" -> "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:forward" -> "Fxn:self.check_forward_input(input)";
    "Fxn:forward" -> "Fxn:self.check_forward_hidden(input,";
    "Fxn:forward" -> "Fxn:RuntimeError(";
    "Fxn:forward" -> "Fxn:{}".format(self.nonlinearity))";
    "Fxn:forward" -> "Fxn:func(";
    "class:LSTMCell(RNNCellBase):" -> "Fxn:__init__";
    "class:LSTMCell(RNNCellBase):" -> "Fxn:reset_parameters";
    "class:LSTMCell(RNNCellBase):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(4";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(4";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(4";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(4";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias_ih',";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias_hh',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:reset_parameters" -> "Fxn:self.parameters():";
    "Fxn:reset_parameters" -> "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:forward" -> "Fxn:self.check_forward_input(input)";
    "Fxn:forward" -> "Fxn:self.check_forward_hidden(input,";
    "Fxn:forward" -> "Fxn:self.check_forward_hidden(input,";
    "Fxn:forward" -> "Fxn:self._backend.LSTMCell(";
    "class:GRUCell(RNNCellBase):" -> "Fxn:__init__";
    "class:GRUCell(RNNCellBase):" -> "Fxn:reset_parameters";
    "class:GRUCell(RNNCellBase):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(3";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(3";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(3";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(3";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias_ih',";
    "Fxn:__init__" -> "Fxn:self.register_parameter('bias_hh',";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:math.sqrt(self.hidden_size)";
    "Fxn:reset_parameters" -> "Fxn:self.parameters():";
    "Fxn:reset_parameters" -> "Fxn:weight.data.uniform_(-stdv,";
    "Fxn:forward" -> "Fxn:self.check_forward_input(input)";
    "Fxn:forward" -> "Fxn:self.check_forward_hidden(input,";
    "Fxn:forward" -> "Fxn:self._backend.GRUCell(";
    "/torch/nn/modules/sparse.py" -> "Import:torch";
    "/torch/nn/modules/sparse.py" -> "Import:Variable";
    "/torch/nn/modules/sparse.py" -> "Import:Parameter";
    "/torch/nn/modules/sparse.py" -> "Import:Module";
    "/torch/nn/modules/sparse.py" -> "Import:functional";
    "/torch/nn/modules/sparse.py" -> "class:Embedding(Module):";
    "/torch/nn/modules/sparse.py" -> "class:EmbeddingBag(Module):";
    "class:Embedding(Module):" -> "Fxn:__init__";
    "class:Embedding(Module):" -> "Fxn:reset_parameters";
    "class:Embedding(Module):" -> "Fxn:forward";
    "class:Embedding(Module):" -> "Fxn:__repr__";
    "class:Embedding(Module):" -> "Fxn:from_pretrained";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(num_embeddings,";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:__init__" -> "Fxn:Parameter(_weight)";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data.normal_(0,";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data[self.padding_idx].fill_(0)";
    "Fxn:forward" -> "Fxn:F.embedding(";
    "Fxn:__repr__" -> "Fxn:'{name}({num_embeddings},";
    "Fxn:__repr__" -> "Fxn:s.format(name=self.__class__.__name__,";
    "Fxn:from_pretrained" -> "Fxn:torch.FloatTensor([[1,";
    "Fxn:from_pretrained" -> "Fxn:nn.Embedding.from_pretrained(weight)";
    "Fxn:from_pretrained" -> "Fxn:torch.LongTensor([1])";
    "Fxn:from_pretrained" -> "Fxn:embedding(input)";
    "Fxn:from_pretrained" -> "Fxn:embeddings.dim()";
    "Fxn:from_pretrained" -> "Fxn:cls(num_embeddings=rows,";
    "class:EmbeddingBag(Module):" -> "Fxn:__init__";
    "class:EmbeddingBag(Module):" -> "Fxn:reset_parameters";
    "class:EmbeddingBag(Module):" -> "Fxn:forward";
    "class:EmbeddingBag(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:Parameter(torch.Tensor(num_embeddings,";
    "Fxn:__init__" -> "Fxn:self.reset_parameters()";
    "Fxn:reset_parameters" -> "Fxn:self.weight.data.normal_(0,";
    "Fxn:forward" -> "Fxn:F.embedding_bag(self.weight,";
    "Fxn:__repr__" -> "Fxn:'{name}({num_embeddings},";
    "Fxn:__repr__" -> "Fxn:s.format(name=self.__class__.__name__,";
    "/torch/nn/modules/upsampling.py" -> "Import:Integral";
    "/torch/nn/modules/upsampling.py" -> "Import:warnings";
    "/torch/nn/modules/upsampling.py" -> "Import:Module";
    "/torch/nn/modules/upsampling.py" -> "Import:functional";
    "/torch/nn/modules/upsampling.py" -> "class:Upsample(Module):";
    "/torch/nn/modules/upsampling.py" -> "class:UpsamplingNearest2d(Upsample):";
    "/torch/nn/modules/upsampling.py" -> "class:UpsamplingBilinear2d(Upsample):";
    "class:Upsample(Module):" -> "Fxn:__init__";
    "class:Upsample(Module):" -> "Fxn:forward";
    "class:Upsample(Module):" -> "Fxn:__repr__";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:F.upsample(input,";
    "Fxn:__repr__" -> "Fxn:'('";
    "class:UpsamplingNearest2d(Upsample):" -> "Fxn:__init__";
    "class:UpsamplingNearest2d(Upsample):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size,";
    "Fxn:forward" -> "Fxn:warnings.warn("nn.UpsamplingNearest2d";
    "Fxn:forward" -> "Fxn:self).forward(input)";
    "class:UpsamplingBilinear2d(Upsample):" -> "Fxn:__init__";
    "class:UpsamplingBilinear2d(Upsample):" -> "Fxn:forward";
    "Fxn:__init__" -> "Fxn:self).__init__(size,";
    "Fxn:forward" -> "Fxn:warnings.warn("nn.UpsamplingBilinear2d";
    "Fxn:forward" -> "Fxn:self).forward(input)";
    "/torch/nn/modules/utils.py" -> "Import:collections";
    "/torch/nn/modules/utils.py" -> "Import:repeat";
    "/torch/nn/modules/utils.py" -> "Fxn:_ntuple";
    "/torch/nn/modules/utils.py" -> "Fxn:parse";
    "/torch/nn/modules/__init__.py" -> "Import:Module";
    "/torch/nn/modules/__init__.py" -> "Import:Linear,";
    "/torch/nn/modules/__init__.py" -> "Import:Conv1d,";
    "/torch/nn/modules/__init__.py" -> "Import:Threshold,";
    "/torch/nn/modules/__init__.py" -> "Import:L1Loss,";
    "/torch/nn/modules/__init__.py" -> "Import:Container,";
    "/torch/nn/modules/__init__.py" -> "Import:AvgPool1d,";
    "/torch/nn/modules/__init__.py" -> "Import:BatchNorm1d,";
    "/torch/nn/modules/__init__.py" -> "Import:InstanceNorm1d,";
    "/torch/nn/modules/__init__.py" -> "Import:LocalResponseNorm,";
    "/torch/nn/modules/__init__.py" -> "Import:Dropout,";
    "/torch/nn/modules/__init__.py" -> "Import:ReflectionPad1d,";
    "/torch/nn/modules/__init__.py" -> "Import:Embedding,";
    "/torch/nn/modules/__init__.py" -> "Import:RNNBase,";
    "/torch/nn/modules/__init__.py" -> "Import:PixelShuffle";
    "/torch/nn/modules/__init__.py" -> "Import:UpsamplingNearest2d,";
    "/torch/nn/modules/__init__.py" -> "Import:PairwiseDistance,";
    "/torch/nn/modules/__init__.py" -> "Import:Fold,";
    "/torch/nn/parallel/data_parallel.py" -> "Import:operator";
    "/torch/nn/parallel/data_parallel.py" -> "Import:torch";
    "/torch/nn/parallel/data_parallel.py" -> "Import:warnings";
    "/torch/nn/parallel/data_parallel.py" -> "Import:Module";
    "/torch/nn/parallel/data_parallel.py" -> "Import:scatter_kwargs,";
    "/torch/nn/parallel/data_parallel.py" -> "Import:replicate";
    "/torch/nn/parallel/data_parallel.py" -> "Import:parallel_apply";
    "/torch/nn/parallel/data_parallel.py" -> "Fxn:_check_balance";
    "/torch/nn/parallel/data_parallel.py" -> "Fxn:warn_imbalance";
    "/torch/nn/parallel/data_parallel.py" -> "class:DataParallel(Module):";
    "class:DataParallel(Module):" -> "Fxn:__init__";
    "class:DataParallel(Module):" -> "Fxn:forward";
    "class:DataParallel(Module):" -> "Fxn:replicate";
    "class:DataParallel(Module):" -> "Fxn:scatter";
    "class:DataParallel(Module):" -> "Fxn:parallel_apply";
    "class:DataParallel(Module):" -> "Fxn:gather";
    "class:DataParallel(Module):" -> "Fxn:data_parallel";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:torch.cuda.is_available():";
    "Fxn:__init__" -> "Fxn:_check_balance(self.device_ids)";
    "Fxn:__init__" -> "Fxn:self.module.cuda(device_ids[0])";
    "Fxn:forward" -> "Fxn:self.module(*inputs,";
    "Fxn:forward" -> "Fxn:self.scatter(inputs,";
    "Fxn:forward" -> "Fxn:self.module(*inputs[0],";
    "Fxn:forward" -> "Fxn:self.replicate(self.module,";
    "Fxn:forward" -> "Fxn:self.device_ids[:len(inputs)])";
    "Fxn:forward" -> "Fxn:self.parallel_apply(replicas,";
    "Fxn:forward" -> "Fxn:self.gather(outputs,";
    "Fxn:replicate" -> "Fxn:replicate(module,";
    "Fxn:scatter" -> "Fxn:scatter_kwargs(inputs,";
    "Fxn:parallel_apply" -> "Fxn:parallel_apply(replicas,";
    "Fxn:parallel_apply" -> "Fxn:self.device_ids[:len(replicas)])";
    "Fxn:gather" -> "Fxn:gather(outputs,";
    "Fxn:data_parallel" -> "Fxn:module(input)";
    "Fxn:data_parallel" -> "Fxn:module(input)";
    "Fxn:data_parallel" -> "Fxn:scatter_kwargs(inputs,";
    "Fxn:data_parallel" -> "Fxn:module(*inputs[0],";
    "Fxn:data_parallel" -> "Fxn:device_ids[:len(inputs)]";
    "Fxn:data_parallel" -> "Fxn:replicate(module,";
    "Fxn:data_parallel" -> "Fxn:parallel_apply(replicas,";
    "Fxn:data_parallel" -> "Fxn:gather(outputs,";
    "/torch/nn/parallel/distributed.py" -> "Import:sys";
    "/torch/nn/parallel/distributed.py" -> "Import:math";
    "/torch/nn/parallel/distributed.py" -> "Import:threading";
    "/torch/nn/parallel/distributed.py" -> "Import:copy";
    "/torch/nn/parallel/distributed.py" -> "Import:torch";
    "/torch/nn/parallel/distributed.py" -> "Import:Variable";
    "/torch/nn/parallel/distributed.py" -> "Import:_flatten_dense_tensors,";
    "/torch/nn/parallel/distributed.py" -> "Import:broadcast_coalesced";
    "/torch/nn/parallel/distributed.py" -> "Import:nccl";
    "/torch/nn/parallel/distributed.py" -> "Import:torch.distributed";
    "/torch/nn/parallel/distributed.py" -> "Import:Module";
    "/torch/nn/parallel/distributed.py" -> "Import:replicate";
    "/torch/nn/parallel/distributed.py" -> "Import:scatter_kwargs,";
    "/torch/nn/parallel/distributed.py" -> "Import:parallel_apply";
    "/torch/nn/parallel/distributed.py" -> "Import:queue";
    "/torch/nn/parallel/distributed.py" -> "Import:Queue";
    "/torch/nn/parallel/distributed.py" -> "class:DistributedDataParallel(Module):";
    "class:DistributedDataParallel(Module):" -> "Fxn:__init__";
    "class:DistributedDataParallel(Module):" -> "Fxn:__getstate__";
    "class:DistributedDataParallel(Module):" -> "Fxn:__setstate__";
    "class:DistributedDataParallel(Module):" -> "Fxn:forward";
    "class:DistributedDataParallel(Module):" -> "Fxn:scatter";
    "class:DistributedDataParallel(Module):" -> "Fxn:parallel_apply";
    "class:DistributedDataParallel(Module):" -> "Fxn:gather";
    "class:DistributedDataParallel(Module):" -> "Fxn:train";
    "class:DistributedDataParallel(Module):" -> "Fxn:_dist_broadcast_coalesced";
    "class:DistributedDataParallel(Module):" -> "Fxn:_sync_params";
    "class:DistributedDataParallel(Module):" -> "Fxn:_register_grad_hooks";
    "class:DistributedDataParallel(Module):" -> "Fxn:_register_nccl_grad_hook";
    "class:DistributedDataParallel(Module):" -> "Fxn:reduction_fn_nccl";
    "class:DistributedDataParallel(Module):" -> "Fxn:allreduce_hook";
    "class:DistributedDataParallel(Module):" -> "Fxn:_make_param_hook";
    "class:DistributedDataParallel(Module):" -> "Fxn:distributed_data_parallel_hook";
    "class:DistributedDataParallel(Module):" -> "Fxn:_queue_reduction";
    "class:DistributedDataParallel(Module):" -> "Fxn:sync_reduction_streams";
    "class:DistributedDataParallel(Module):" -> "Fxn:_start_reduction_threads";
    "class:DistributedDataParallel(Module):" -> "Fxn:_reduction_thread_fn";
    "class:DistributedDataParallel(Module):" -> "Fxn:_process_batch";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:self._dist_broadcast_coalesced(module_states,";
    "Fxn:__init__" -> "Fxn:replicate(self.module,";
    "Fxn:__init__" -> "Fxn:module_copy.parameters()):";
    "Fxn:__init__" -> "Fxn:self._register_nccl_grad_hook()";
    "Fxn:__init__" -> "Fxn:param_buckets.append(list(_take_tensors(module.parameters(),";
    "Fxn:__init__" -> "Fxn:self.bucket_sizes.append(0)";
    "Fxn:__init__" -> "Fxn:param_tuple[0].type()";
    "Fxn:__init__" -> "Fxn:RuntimeError("DistributedDataParallel";
    "Fxn:__init__" -> "Fxn:self._register_grad_hooks()";
    "Fxn:__init__" -> "Fxn:threading.Lock()";
    "Fxn:__init__" -> "Fxn:self._start_reduction_threads()";
    "Fxn:__getstate__" -> "Fxn:copy.copy(self.__dict__)";
    "Fxn:__setstate__" -> "Fxn:self).__setstate__(state)";
    "Fxn:__setstate__" -> "Fxn:self._register_nccl_grad_hook()";
    "Fxn:__setstate__" -> "Fxn:self._register_grad_hooks()";
    "Fxn:__setstate__" -> "Fxn:self._start_reduction_threads()";
    "Fxn:forward" -> "Fxn:self.scatter(inputs,";
    "Fxn:forward" -> "Fxn:self._sync_params()";
    "Fxn:forward" -> "Fxn:self.module(*inputs[0],";
    "Fxn:forward" -> "Fxn:self.parallel_apply(self._module_copies,";
    "Fxn:forward" -> "Fxn:self.gather(outputs,";
    "Fxn:scatter" -> "Fxn:scatter_kwargs(inputs,";
    "Fxn:parallel_apply" -> "Fxn:parallel_apply(replicas,";
    "Fxn:parallel_apply" -> "Fxn:self.device_ids[:len(replicas)])";
    "Fxn:gather" -> "Fxn:gather(outputs,";
    "Fxn:train" -> "Fxn:self).train(mode)";
    "Fxn:train" -> "Fxn:module.train(mode)";
    "Fxn:_dist_broadcast_coalesced" -> "Fxn:_take_tensors(tensors,";
    "Fxn:_dist_broadcast_coalesced" -> "Fxn:_flatten_dense_tensors(tensors)";
    "Fxn:_dist_broadcast_coalesced" -> "Fxn:dist.broadcast(flat_tensors,";
    "Fxn:_dist_broadcast_coalesced" -> "Fxn:_unflatten_dense_tensors(flat_tensors,";
    "Fxn:_dist_broadcast_coalesced" -> "Fxn:tensor.copy_(synced)";
    "Fxn:_sync_params" -> "Fxn:self.module.parameters()]";
    "Fxn:_sync_params" -> "Fxn:broadcast_coalesced(params,";
    "Fxn:_sync_params" -> "Fxn:module.parameters()):";
    "Fxn:_sync_params" -> "Fxn:param.data.set_(tensor)";
    "Fxn:_sync_params" -> "Fxn:self._dist_broadcast_coalesced(buffers,";
    "Fxn:_sync_params" -> "Fxn:broadcast_coalesced(buffers,";
    "Fxn:_sync_params" -> "Fxn:module._all_buffers()):";
    "Fxn:_sync_params" -> "Fxn:buf.set_(tensor)";
    "Fxn:_register_grad_hooks" -> "Fxn:module.parameters():";
    "Fxn:_register_grad_hooks" -> "Fxn:p.expand_as(p)";
    "Fxn:_register_grad_hooks" -> "Fxn:grad_acc.register_hook(self._make_param_hook(p,";
    "Fxn:_register_grad_hooks" -> "Fxn:self._grad_accs.append(grad_acc)";
    "Fxn:_register_nccl_grad_hook" -> "Fxn:dist.new_group()";
    "Fxn:reduction_fn_nccl" -> "Fxn:module.parameters():";
    "Fxn:reduction_fn_nccl" -> "Fxn:RuntimeError("DistributedDataParallel";
    "Fxn:reduction_fn_nccl" -> "Fxn:all_grads[dev_idx].append(param.grad.data)";
    "Fxn:reduction_fn_nccl" -> "Fxn:_take_tensors(all_grads[dev_idx],";
    "Fxn:reduction_fn_nccl" -> "Fxn:all_grads_buckets_iters.append(dev_grads_buckets)";
    "Fxn:reduction_fn_nccl" -> "Fxn:torch.cuda.device(dev_id):";
    "Fxn:reduction_fn_nccl" -> "Fxn:_flatten_dense_tensors(dev_grads_batch)";
    "Fxn:reduction_fn_nccl" -> "Fxn:grads_batch_coalesced.append(dev_grads_batch_coalesced)";
    "Fxn:reduction_fn_nccl" -> "Fxn:dist.all_reduce_multigpu(grads_batch_coalesced,";
    "Fxn:reduction_fn_nccl" -> "Fxn:dist.get_world_size()";
    "Fxn:reduction_fn_nccl" -> "Fxn:_unflatten_dense_tensors(grads_batch_coalesced[0],";
    "Fxn:reduction_fn_nccl" -> "Fxn:grad.copy_(reduced)";
    "Fxn:reduction_fn_nccl" -> "Fxn:module.parameters():";
    "Fxn:reduction_fn_nccl" -> "Fxn:param.data.set_()";
    "Fxn:reduction_fn_nccl" -> "Fxn:self.module.parameters():";
    "Fxn:allreduce_hook" -> "Fxn:Variable._execution_engine.queue_callback(reduction_fn_nccl)";
    "Fxn:allreduce_hook" -> "Fxn:p.register_hook(allreduce_hook)";
    "Fxn:distributed_data_parallel_hook" -> "Fxn:RuntimeError("DistributedDataParallel";
    "Fxn:distributed_data_parallel_hook" -> "Fxn:bucket.append(param.grad.data)";
    "Fxn:distributed_data_parallel_hook" -> "Fxn:param.data.set_()";
    "Fxn:distributed_data_parallel_hook" -> "Fxn:torch.cuda.device(self.device_ids[device_idx]):";
    "Fxn:distributed_data_parallel_hook" -> "Fxn:torch.cuda.Event()";
    "Fxn:distributed_data_parallel_hook" -> "Fxn:event.record()";
    "Fxn:distributed_data_parallel_hook" -> "Fxn:self._queue_reduction(bucket_idx)";
    "Fxn:_queue_reduction" -> "Fxn:threading.Event()";
    "Fxn:_queue_reduction" -> "Fxn:self._reduction_queues[bucket_idx].put((dev_buckets,";
    "Fxn:_queue_reduction" -> "Fxn:Variable._execution_engine.queue_callback(lambda:";
    "Fxn:_queue_reduction" -> "Fxn:event.wait())";
    "Fxn:sync_reduction_streams" -> "Fxn:torch.cuda.device(dev_id):";
    "Fxn:sync_reduction_streams" -> "Fxn:default_stream.wait_stream(reduction_stream)";
    "Fxn:sync_reduction_streams" -> "Fxn:Variable._execution_engine.queue_callback(sync_reduction_streams)";
    "Fxn:_start_reduction_threads" -> "Fxn:[queue.Queue()";
    "Fxn:_start_reduction_threads" -> "Fxn:torch.cuda.device(dev_id):";
    "Fxn:_start_reduction_threads" -> "Fxn:self._default_streams.append(torch.cuda.current_stream())";
    "Fxn:_start_reduction_threads" -> "Fxn:self._nccl_streams.append(torch.cuda.Stream())";
    "Fxn:_start_reduction_threads" -> "Fxn:torch.cuda.device(dev_id):";
    "Fxn:_start_reduction_threads" -> "Fxn:reduction_streams.append(torch.cuda.Stream())";
    "Fxn:_start_reduction_threads" -> "Fxn:dist._register_stream(reduction_streams[0])";
    "Fxn:_start_reduction_threads" -> "Fxn:dist.new_group()";
    "Fxn:_start_reduction_threads" -> "Fxn:self._reduction_threads.append(threading.Thread(";
    "Fxn:_start_reduction_threads" -> "Fxn:args=(reduction_queue,";
    "Fxn:_start_reduction_threads" -> "Fxn:self._reduction_threads[-1].start()";
    "Fxn:_process_batch" -> "Fxn:queue.get()";
    "Fxn:_process_batch" -> "Fxn:torch.cuda.device(dev_id),";
    "Fxn:_process_batch" -> "Fxn:torch.cuda.stream(stream):";
    "Fxn:_process_batch" -> "Fxn:stream.wait_event(event)";
    "Fxn:_process_batch" -> "Fxn:_flatten_dense_tensors(grad_batch)";
    "Fxn:_process_batch" -> "Fxn:dev_coalesced.append(coalesced)";
    "Fxn:_process_batch" -> "Fxn:stream.synchronize()";
    "Fxn:_process_batch" -> "Fxn:nccl.reduce(dev_coalesced,";
    "Fxn:_process_batch" -> "Fxn:torch.cuda.stream(reduce_stream):";
    "Fxn:_process_batch" -> "Fxn:reduce_stream.wait_stream(nccl_streams[0])";
    "Fxn:_process_batch" -> "Fxn:dist.get_world_size()";
    "Fxn:_process_batch" -> "Fxn:dist.all_reduce(coalesced,";
    "Fxn:_process_batch" -> "Fxn:_unflatten_dense_tensors(coalesced,";
    "Fxn:_process_batch" -> "Fxn:grad.copy_(reduced)";
    "Fxn:_process_batch" -> "Fxn:job_event.set()";
    "Fxn:_process_batch" -> "Fxn:torch.cuda.device(device_ids[0]):";
    "Fxn:_process_batch" -> "Fxn:_process_batch()";
    "/torch/nn/parallel/parallel_apply.py" -> "Import:threading";
    "/torch/nn/parallel/parallel_apply.py" -> "Import:torch";
    "/torch/nn/parallel/parallel_apply.py" -> "Import:Variable";
    "/torch/nn/parallel/parallel_apply.py" -> "Fxn:get_a_var";
    "/torch/nn/parallel/parallel_apply.py" -> "Fxn:parallel_apply";
    "/torch/nn/parallel/parallel_apply.py" -> "Fxn:_worker";
    "/torch/nn/parallel/replicate.py" -> "Import:torch.cuda.comm";
    "/torch/nn/parallel/replicate.py" -> "Fxn:replicate";
    "/torch/nn/parallel/replicate.py" -> "Import:Broadcast";
    "/torch/nn/parallel/scatter_gather.py" -> "Import:torch";
    "/torch/nn/parallel/scatter_gather.py" -> "Import:Variable";
    "/torch/nn/parallel/scatter_gather.py" -> "Import:Scatter,";
    "/torch/nn/parallel/scatter_gather.py" -> "Fxn:scatter";
    "/torch/nn/parallel/scatter_gather.py" -> "Fxn:scatter_map";
    "/torch/nn/parallel/scatter_gather.py" -> "Fxn:scatter_kwargs";
    "/torch/nn/parallel/scatter_gather.py" -> "Fxn:gather";
    "/torch/nn/parallel/scatter_gather.py" -> "Fxn:gather_map";
    "/torch/nn/parallel/_functions.py" -> "Import:torch";
    "/torch/nn/parallel/_functions.py" -> "Import:torch.cuda.comm";
    "/torch/nn/parallel/_functions.py" -> "Import:Function";
    "/torch/nn/parallel/_functions.py" -> "class:Broadcast(Function):";
    "/torch/nn/parallel/_functions.py" -> "class:ReduceAddCoalesced(Function):";
    "/torch/nn/parallel/_functions.py" -> "class:Gather(Function):";
    "/torch/nn/parallel/_functions.py" -> "class:Scatter(Function):";
    "class:Broadcast(Function):" -> "Fxn:forward";
    "class:Broadcast(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:TypeError('Broadcast";
    "Fxn:forward" -> "Fxn:inputs[0].get_device()";
    "Fxn:forward" -> "Fxn:comm.broadcast_coalesced(inputs,";
    "Fxn:forward" -> "Fxn:non_differentiables.append(output[idx])";
    "Fxn:forward" -> "Fxn:ctx.mark_non_differentiable(*non_differentiables)";
    "Fxn:backward" -> "Fxn:ReduceAddCoalesced.apply(ctx.input_device,";
    "class:ReduceAddCoalesced(Function):" -> "Fxn:forward";
    "class:ReduceAddCoalesced(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:[grads[i].get_device()";
    "Fxn:forward" -> "Fxn:comm.reduce_add_coalesced(grads,";
    "Fxn:backward" -> "Fxn:Broadcast.apply(ctx.target_gpus,";
    "class:Gather(Function):" -> "Fxn:forward";
    "class:Gather(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:i.get_device(),";
    "Fxn:forward" -> "Fxn:i.size(ctx.dim),";
    "Fxn:forward" -> "Fxn:comm.gather(inputs,";
    "Fxn:backward" -> "Fxn:Scatter.apply(ctx.input_gpus,";
    "class:Scatter(Function):" -> "Fxn:forward";
    "class:Scatter(Function):" -> "Fxn:backward";
    "class:Scatter(Function):" -> "Fxn:_get_stream";
    "Fxn:forward" -> "Fxn:input.get_device()";
    "Fxn:forward" -> "Fxn:[_get_stream(device)";
    "Fxn:forward" -> "Fxn:comm.scatter(input,";
    "Fxn:forward" -> "Fxn:torch.cuda.device(ctx.target_gpus[i]):";
    "Fxn:forward" -> "Fxn:torch.cuda.current_stream()";
    "Fxn:forward" -> "Fxn:main_stream.wait_stream(streams[i])";
    "Fxn:forward" -> "Fxn:output.record_stream(main_stream)";
    "Fxn:backward" -> "Fxn:Gather.apply(ctx.input_device,";
    "Fxn:_get_stream" -> "Fxn:torch.cuda.device_count()";
    "Fxn:_get_stream" -> "Fxn:torch.cuda.Stream(device)";
    "/torch/nn/parallel/__init__.py" -> "Import:parallel_apply";
    "/torch/nn/parallel/__init__.py" -> "Import:replicate";
    "/torch/nn/parallel/__init__.py" -> "Import:DataParallel,";
    "/torch/nn/parallel/__init__.py" -> "Import:scatter,";
    "/torch/nn/parallel/__init__.py" -> "Import:DistributedDataParallel";
    "/torch/nn/utils/clip_grad.py" -> "Fxn:clip_grad_norm";
    "/torch/nn/utils/convert_parameters.py" -> "Import:torch";
    "/torch/nn/utils/convert_parameters.py" -> "Import:Variable";
    "/torch/nn/utils/convert_parameters.py" -> "Fxn:parameters_to_vector";
    "/torch/nn/utils/convert_parameters.py" -> "Fxn:vector_to_parameters";
    "/torch/nn/utils/convert_parameters.py" -> "Fxn:_check_param_device";
    "/torch/nn/utils/rnn.py" -> "Import:namedtuple";
    "/torch/nn/utils/rnn.py" -> "Import:torch";
    "/torch/nn/utils/rnn.py" -> "Import:Variable";
    "/torch/nn/utils/rnn.py" -> "Import:torch.onnx";
    "/torch/nn/utils/rnn.py" -> "Import:PackPadded";
    "/torch/nn/utils/rnn.py" -> "class:PackedSequence(PackedSequence_):";
    "/torch/nn/utils/rnn.py" -> "Import:pad_sequence";
    "/torch/nn/utils/rnn.py" -> "Import:pack_sequence";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:__new__";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:cuda";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:cpu";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:double";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:float";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:half";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:long";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:int";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:short";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:char";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:byte";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:is_cuda";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:_symbolic_pack_padded_sequence";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:pack_padded_sequence";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:_symbolic_pad_packed_sequence";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:pad_packed_sequence";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:pad_sequence";
    "class:PackedSequence(PackedSequence_):" -> "Fxn:pack_sequence";
    "Fxn:__new__" -> "Fxn:`PackedSequence(data,";
    "Fxn:__new__" -> "Fxn:cls).__new__(cls,";
    "Fxn:__new__" -> "Fxn:`PackedSequence((data,";
    "Fxn:__new__" -> "Fxn:cls).__new__(cls,";
    "Fxn:_symbolic_pack_padded_sequence" -> "Fxn:g.op('Transpose',";
    "Fxn:_symbolic_pack_padded_sequence" -> "Fxn:g.op("PackPadded",";
    "Fxn:_symbolic_pack_padded_sequence" -> "Fxn:@torch.onnx.symbolic_override_first_arg_based(_symbolic_pack_padded_sequence)";
    "Fxn:pack_padded_sequence" -> "Fxn:Variable(torch.LongTensor(lengths))";
    "Fxn:pack_padded_sequence" -> "Fxn:PackPadded.apply(input,";
    "Fxn:pack_padded_sequence" -> "Fxn:PackedSequence(data,";
    "Fxn:_symbolic_pad_packed_sequence" -> "Fxn:g.op("PadPacked",";
    "Fxn:_symbolic_pad_packed_sequence" -> "Fxn:g.op('Transpose',";
    "Fxn:_symbolic_pad_packed_sequence" -> "Fxn:@torch.onnx.symbolic_override_packed_sequence_based(_symbolic_pad_packed_sequence)";
    "Fxn:pad_packed_sequence" -> "Fxn:var_data.data.new(len(batch_sizes),";
    "Fxn:pad_packed_sequence" -> "Fxn:*var_data.size()[1:]).fill_(padding_value)";
    "Fxn:pad_packed_sequence" -> "Fxn:Variable(output)";
    "Fxn:pad_packed_sequence" -> "Fxn:tmp.view(i";
    "Fxn:pad_packed_sequence" -> "Fxn:*tmp.size()[1:])";
    "Fxn:pad_packed_sequence" -> "Fxn:lengths.extend((i,)";
    "Fxn:pad_packed_sequence" -> "Fxn:lengths.reverse()";
    "Fxn:pad_packed_sequence" -> "Fxn:output.transpose(0,";
    "Fxn:pad_packed_sequence" -> "Fxn:Variable(torch.LongTensor(lengths))";
    "Fxn:pad_sequence" -> "Fxn:Variable(torch.ones(25,";
    "Fxn:pad_sequence" -> "Fxn:Variable(torch.ones(22,";
    "Fxn:pad_sequence" -> "Fxn:Variable(torch.ones(15,";
    "Fxn:pad_sequence" -> "Fxn:pad_sequence([a,";
    "Fxn:pad_sequence" -> "Fxn:c]).size()";
    "Fxn:pad_sequence" -> "Fxn:torch.Size([25,";
    "Fxn:pad_sequence" -> "Fxn:sequences[0].size()";
    "Fxn:pad_sequence" -> "Fxn:Variable(sequences[0].data.new(*out_dims).fill_(padding_value))";
    "Fxn:pad_sequence" -> "Fxn:variable.size(0)";
    "Fxn:pad_sequence" -> "Fxn:ValueError("lengths";
    "Fxn:pack_sequence" -> "Fxn:Variable(torch.Tensor([1,2,3]))";
    "Fxn:pack_sequence" -> "Fxn:Variable(torch.Tensor([4,5]))";
    "Fxn:pack_sequence" -> "Fxn:Variable(torch.Tensor([6]))";
    "Fxn:pack_sequence" -> "Fxn:pack_sequence([a,";
    "Fxn:pack_sequence" -> "Fxn:PackedSequence(data=";
    "Fxn:pack_sequence" -> "Fxn:pack_padded_sequence(pad_sequence(sequences),";
    "Fxn:pack_sequence" -> "Fxn:[v.size(0)";
    "/torch/nn/utils/weight_norm.py" -> "Import:Parameter";
    "/torch/nn/utils/weight_norm.py" -> "Fxn:_norm";
    "/torch/nn/utils/weight_norm.py" -> "class:WeightNorm(object):";
    "class:WeightNorm(object):" -> "Fxn:__init__";
    "class:WeightNorm(object):" -> "Fxn:compute_weight";
    "class:WeightNorm(object):" -> "Fxn:apply";
    "class:WeightNorm(object):" -> "Fxn:remove";
    "class:WeightNorm(object):" -> "Fxn:__call__";
    "class:WeightNorm(object):" -> "Fxn:weight_norm";
    "class:WeightNorm(object):" -> "Fxn:remove_weight_norm";
    "Fxn:compute_weight" -> "Fxn:_norm(v,";
    "Fxn:apply" -> "Fxn:WeightNorm(name,";
    "Fxn:apply" -> "Fxn:module.register_parameter(name";
    "Fxn:apply" -> "Fxn:Parameter(_norm(weight,";
    "Fxn:apply" -> "Fxn:module.register_parameter(name";
    "Fxn:apply" -> "Fxn:Parameter(weight.data))";
    "Fxn:apply" -> "Fxn:fn.compute_weight(module))";
    "Fxn:apply" -> "Fxn:forward()";
    "Fxn:apply" -> "Fxn:module.register_forward_pre_hook(fn)";
    "Fxn:remove" -> "Fxn:self.compute_weight(module)";
    "Fxn:remove" -> "Fxn:module.register_parameter(self.name,";
    "Fxn:remove" -> "Fxn:Parameter(weight.data))";
    "Fxn:__call__" -> "Fxn:self.compute_weight(module))";
    "Fxn:weight_norm" -> "Fxn:weight_norm(nn.Linear(20,";
    "Fxn:weight_norm" -> "Fxn:m.weight_g.size()";
    "Fxn:weight_norm" -> "Fxn:torch.Size([40,";
    "Fxn:weight_norm" -> "Fxn:m.weight_v.size()";
    "Fxn:weight_norm" -> "Fxn:torch.Size([40,";
    "Fxn:weight_norm" -> "Fxn:WeightNorm.apply(module,";
    "Fxn:remove_weight_norm" -> "Fxn:weight_norm(nn.Linear(20,";
    "Fxn:remove_weight_norm" -> "Fxn:remove_weight_norm(m)";
    "Fxn:remove_weight_norm" -> "Fxn:module._forward_pre_hooks.items():";
    "Fxn:remove_weight_norm" -> "Fxn:hook.remove(module)";
    "Fxn:remove_weight_norm" -> "Fxn:ValueError("weight_norm";
    "Fxn:remove_weight_norm" -> "Fxn:.format(name,";
    "/torch/nn/utils/__init__.py" -> "Import:rnn";
    "/torch/nn/utils/__init__.py" -> "Import:clip_grad_norm";
    "/torch/nn/utils/__init__.py" -> "Import:weight_norm,";
    "/torch/nn/utils/__init__.py" -> "Import:parameters_to_vector,";
    "/torch/nn/_functions/dropout.py" -> "Import:torch";
    "/torch/nn/_functions/dropout.py" -> "Import:InplaceFunction";
    "/torch/nn/_functions/dropout.py" -> "Import:Variable";
    "/torch/nn/_functions/dropout.py" -> "Import:repeat";
    "/torch/nn/_functions/dropout.py" -> "class:Dropout(InplaceFunction):";
    "/torch/nn/_functions/dropout.py" -> "class:FeatureDropout(Dropout):";
    "/torch/nn/_functions/dropout.py" -> "Import:_unimplemented";
    "class:Dropout(InplaceFunction):" -> "Fxn:_make_noise";
    "class:Dropout(InplaceFunction):" -> "Fxn:symbolic";
    "class:Dropout(InplaceFunction):" -> "Fxn:forward";
    "class:Dropout(InplaceFunction):" -> "Fxn:backward";
    "Fxn:_make_noise" -> "Fxn:input.new().resize_as_(input)";
    "Fxn:symbolic" -> "Fxn:g.op("Dropout",";
    "Fxn:forward" -> "Fxn:ValueError("dropout";
    "Fxn:forward" -> "Fxn:{}".format(p))";
    "Fxn:forward" -> "Fxn:ctx.mark_dirty(input)";
    "Fxn:forward" -> "Fxn:input.clone()";
    "Fxn:forward" -> "Fxn:cls._make_noise(input)";
    "Fxn:forward" -> "Fxn:ctx.noise.fill_(0)";
    "Fxn:forward" -> "Fxn:ctx.noise.bernoulli_(1";
    "Fxn:forward" -> "Fxn:ctx.p).div_(1";
    "Fxn:forward" -> "Fxn:ctx.noise.expand_as(input)";
    "Fxn:forward" -> "Fxn:output.mul_(ctx.noise)";
    "class:FeatureDropout(Dropout):" -> "Fxn:symbolic";
    "class:FeatureDropout(Dropout):" -> "Fxn:_make_noise";
    "Fxn:symbolic" -> "Fxn:_unimplemented("FeatureDropout",";
    "Fxn:_make_noise" -> "Fxn:input.new().resize_(input.size(0),";
    "Fxn:_make_noise" -> "Fxn:input.size(1),";
    "Fxn:_make_noise" -> "Fxn:*repeat(1,";
    "Fxn:_make_noise" -> "Fxn:input.dim()";
    "/torch/nn/_functions/linear.py" -> "Import:torch";
    "/torch/nn/_functions/linear.py" -> "Import:Function,";
    "/torch/nn/_functions/linear.py" -> "class:Bilinear(Function):";
    "class:Bilinear(Function):" -> "Fxn:forward";
    "class:Bilinear(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(input1,";
    "Fxn:forward" -> "Fxn:input1.new(input1.size(0),";
    "Fxn:forward" -> "Fxn:weight.size(0))";
    "Fxn:forward" -> "Fxn:input1.new()";
    "Fxn:forward" -> "Fxn:torch.mm(input1,";
    "Fxn:forward" -> "Fxn:buff.mul_(input2)";
    "Fxn:forward" -> "Fxn:torch.sum(buff,";
    "Fxn:forward" -> "Fxn:out=output.narrow(1,";
    "Fxn:forward" -> "Fxn:output.add_(bias.expand_as(output))";
    "Fxn:backward" -> "Fxn:Variable(input1.data.new())";
    "Fxn:backward" -> "Fxn:torch.mm(input2,";
    "Fxn:backward" -> "Fxn:weight[0].t())";
    "Fxn:backward" -> "Fxn:grad_input1.mul(grad_output.narrow(1,";
    "Fxn:backward" -> "Fxn:1).expand(grad_input1.size()))";
    "Fxn:backward" -> "Fxn:torch.mm(input1,";
    "Fxn:backward" -> "Fxn:grad_input2.mul(grad_output.narrow(1,";
    "Fxn:backward" -> "Fxn:1).expand(grad_input2.size()))";
    "Fxn:backward" -> "Fxn:weight.size(0)):";
    "Fxn:backward" -> "Fxn:input2.mm(weight[k].t())";
    "Fxn:backward" -> "Fxn:buff.mul(grad_output.narrow(1,";
    "Fxn:backward" -> "Fxn:1).expand(grad_input1.size()))";
    "Fxn:backward" -> "Fxn:grad_input1.add_(buff)";
    "Fxn:backward" -> "Fxn:input1.mm(weight[k])";
    "Fxn:backward" -> "Fxn:buff.mul(grad_output.narrow(1,";
    "Fxn:backward" -> "Fxn:1).expand(grad_input2.size()))";
    "Fxn:backward" -> "Fxn:grad_input2.add_(buff)";
    "Fxn:backward" -> "Fxn:Variable(weight.data.new(weight.size()))";
    "Fxn:backward" -> "Fxn:input1.mul(grad_output.narrow(1,";
    "Fxn:backward" -> "Fxn:1).expand_as(input1))";
    "Fxn:backward" -> "Fxn:torch.mm(buff.t(),";
    "Fxn:backward" -> "Fxn:grad_output.sum(0,";
    "/torch/nn/_functions/loss.py" -> "Import:torch";
    "/torch/nn/_functions/loss.py" -> "Import:Function,";
    "/torch/nn/_functions/loss.py" -> "Import:once_differentiable";
    "/torch/nn/_functions/loss.py" -> "class:MarginRankingLoss(Function):";
    "class:MarginRankingLoss(Function):" -> "Fxn:forward";
    "class:MarginRankingLoss(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:input1.clone()";
    "Fxn:forward" -> "Fxn:_output.add_(-1,";
    "Fxn:forward" -> "Fxn:_output.mul_(-1).mul_(y)";
    "Fxn:forward" -> "Fxn:_output.add_(ctx.margin)";
    "Fxn:forward" -> "Fxn:_output.clamp_(min=0)";
    "Fxn:forward" -> "Fxn:_output.sum()";
    "Fxn:forward" -> "Fxn:y.size(0)";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(input1,";
    "Fxn:backward" -> "Fxn:Variable(input1.data.new(input1.size()).zero_())";
    "Fxn:backward" -> "Fxn:Variable(input1.data.new(input1.size()).zero_())";
    "Fxn:backward" -> "Fxn:input2).mul_(-1)";
    "Fxn:backward" -> "Fxn:y).add_(ctx.margin)";
    "Fxn:backward" -> "Fxn:dist.ge(0)";
    "Fxn:backward" -> "Fxn:grad_input1.masked_fill_(mask,";
    "Fxn:backward" -> "Fxn:grad_input1.mul_(-1)";
    "Fxn:backward" -> "Fxn:grad_input2.masked_fill_(mask,";
    "Fxn:backward" -> "Fxn:grad_input1.div_(y.size(0))";
    "Fxn:backward" -> "Fxn:grad_input2.div_(y.size(0))";
    "/torch/nn/_functions/packing.py" -> "Import:torch";
    "/torch/nn/_functions/packing.py" -> "Import:Function";
    "/torch/nn/_functions/packing.py" -> "class:PackPadded(Function):";
    "class:PackPadded(Function):" -> "Fxn:forward";
    "class:PackPadded(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:input.transpose(0,";
    "Fxn:forward" -> "Fxn:ValueError("Length";
    "Fxn:forward" -> "Fxn:input.size(1)";
    "Fxn:forward" -> "Fxn:ValueError("Expected";
    "Fxn:forward" -> "Fxn:`len(lengths)`";
    "Fxn:forward" -> "Fxn:steps.append(input[prev_l:l,";
    "Fxn:forward" -> "Fxn::c_batch_size].contiguous().view(-1,";
    "Fxn:forward" -> "Fxn:*input.size()[2:]))";
    "Fxn:forward" -> "Fxn:batch_sizes.extend([c_batch_size]";
    "Fxn:forward" -> "Fxn:ValueError("'lengths'";
    "Fxn:forward" -> "Fxn:input.size()";
    "Fxn:forward" -> "Fxn:torch.cat(steps),";
    "Fxn:forward" -> "Fxn:torch.LongTensor(batch_sizes)";
    "Fxn:backward" -> "Fxn:grad_steps.new(*ctx.input_size).zero_()";
    "Fxn:backward" -> "Fxn:grad_input.transpose(0,";
    "/torch/nn/_functions/padding.py" -> "Import:Function,";
    "/torch/nn/_functions/padding.py" -> "Import:prepare_onnx_paddings";
    "/torch/nn/_functions/padding.py" -> "class:ConstantPadNd(Function):";
    "class:ConstantPadNd(Function):" -> "Fxn:symbolic";
    "class:ConstantPadNd(Function):" -> "Fxn:forward";
    "class:ConstantPadNd(Function):" -> "Fxn:backward";
    "class:ConstantPadNd(Function):" -> "Fxn:narrow_slice";
    "class:ConstantPadNd(Function):" -> "Fxn:slice_length";
    "Fxn:symbolic" -> "Fxn:prepare_onnx_paddings(len(input.type().sizes()),";
    "Fxn:symbolic" -> "Fxn:g.op("Pad",";
    "Fxn:forward" -> "Fxn:input.size()";
    "Fxn:forward" -> "Fxn:input.new(input.size()[:(ctx.l_diff)]";
    "Fxn:forward" -> "Fxn:new_dim).fill_(ctx.value)";
    "Fxn:forward" -> "Fxn:c_input.narrow(i,";
    "Fxn:forward" -> "Fxn:c_input.size(i)";
    "Fxn:forward" -> "Fxn:c_input.narrow(i,";
    "Fxn:forward" -> "Fxn:c_input.size(i)";
    "Fxn:forward" -> "Fxn:c_output.narrow(i,";
    "Fxn:forward" -> "Fxn:c_output.size(i)";
    "Fxn:forward" -> "Fxn:c_output.narrow(i,";
    "Fxn:forward" -> "Fxn:c_output.size(i)";
    "Fxn:forward" -> "Fxn:c_output.copy_(c_input)";
    "Fxn:backward" -> "Fxn:Variable(grad_output.data.new(ctx.input_size).zero_())";
    "Fxn:backward" -> "Fxn:[slice(0,";
    "Fxn:slice_length" -> "Fxn:narrow_slice(i,";
    "Fxn:slice_length" -> "Fxn:slice_length(i)";
    "Fxn:slice_length" -> "Fxn:narrow_slice(i,";
    "Fxn:slice_length" -> "Fxn:slice_length(i)";
    "Fxn:slice_length" -> "Fxn:cg_output.narrow(i_s,";
    "Fxn:slice_length" -> "Fxn:cg_output.size(i_s)";
    "Fxn:slice_length" -> "Fxn:cg_output.narrow(i_s,";
    "Fxn:slice_length" -> "Fxn:cg_output.size(i_s)";
    "/torch/nn/_functions/rnn.py" -> "Import:warnings";
    "/torch/nn/_functions/rnn.py" -> "Import:NestedIOFunction,";
    "/torch/nn/_functions/rnn.py" -> "Import:torch.backends.cudnn";
    "/torch/nn/_functions/rnn.py" -> "Import:functional";
    "/torch/nn/_functions/rnn.py" -> "Import:rnnFusedPointwise";
    "/torch/nn/_functions/rnn.py" -> "Import:itertools";
    "/torch/nn/_functions/rnn.py" -> "Import:torch.backends.cudnn.rnn";
    "/torch/nn/_functions/rnn.py" -> "Fxn:RNNReLUCell";
    "/torch/nn/_functions/rnn.py" -> "Fxn:RNNTanhCell";
    "/torch/nn/_functions/rnn.py" -> "Fxn:LSTMCell";
    "/torch/nn/_functions/rnn.py" -> "Fxn:GRUCell";
    "/torch/nn/_functions/rnn.py" -> "Fxn:StackedRNN";
    "/torch/nn/_functions/rnn.py" -> "Fxn:forward";
    "/torch/nn/_functions/rnn.py" -> "Fxn:Recurrent";
    "/torch/nn/_functions/rnn.py" -> "Fxn:forward";
    "/torch/nn/_functions/rnn.py" -> "Fxn:variable_recurrent_factory";
    "/torch/nn/_functions/rnn.py" -> "Fxn:VariableRecurrent";
    "/torch/nn/_functions/rnn.py" -> "Fxn:forward";
    "/torch/nn/_functions/rnn.py" -> "Fxn:VariableRecurrentReverse";
    "/torch/nn/_functions/rnn.py" -> "Fxn:forward";
    "/torch/nn/_functions/rnn.py" -> "Fxn:AutogradRNN";
    "/torch/nn/_functions/rnn.py" -> "Fxn:forward";
    "/torch/nn/_functions/rnn.py" -> "Fxn:CudnnRNN";
    "/torch/nn/_functions/rnn.py" -> "Fxn:forward";
    "/torch/nn/_functions/rnn.py" -> "Fxn:RNN";
    "/torch/nn/_functions/rnn.py" -> "Fxn:forward";
    "/torch/nn/_functions/rnn.py" -> "Import:torch";
    "/torch/nn/_functions/rnn.py" -> "Import:torch.onnx.symbolic";
    "/torch/nn/_functions/vision.py" -> "Import:torch";
    "/torch/nn/_functions/vision.py" -> "Import:Function";
    "/torch/nn/_functions/vision.py" -> "Import:once_differentiable";
    "/torch/nn/_functions/vision.py" -> "Import:type2backend";
    "/torch/nn/_functions/vision.py" -> "Import:function_by_name";
    "/torch/nn/_functions/vision.py" -> "Import:torch.backends.cudnn";
    "/torch/nn/_functions/vision.py" -> "Fxn:grid_sampler";
    "/torch/nn/_functions/vision.py" -> "Fxn:affine_grid_generator";
    "/torch/nn/_functions/vision.py" -> "class:GridSampler(Function):";
    "/torch/nn/_functions/vision.py" -> "class:AffineGridGenerator(Function):";
    "class:GridSampler(Function):" -> "Fxn:forward";
    "class:GridSampler(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(input,";
    "Fxn:forward" -> "Fxn:ValueError("padding_mode";
    "Fxn:forward" -> "Fxn:{}".format(padding_mode))";
    "Fxn:forward" -> "Fxn:grid.size()";
    "Fxn:forward" -> "Fxn:type2backend[input.type()]";
    "Fxn:forward" -> "Fxn:input.dim()";
    "Fxn:forward" -> "Fxn:input.new(grid_sz[0],";
    "Fxn:forward" -> "Fxn:input.size(1),";
    "Fxn:forward" -> "Fxn:backend.SpatialGridSamplerBilinear_updateOutput(backend.library_state,";
    "Fxn:forward" -> "Fxn:input.dim()";
    "Fxn:forward" -> "Fxn:input.new(grid_sz[0],";
    "Fxn:forward" -> "Fxn:input.size(1),";
    "Fxn:forward" -> "Fxn:backend.VolumetricGridSamplerBilinear_updateOutput(backend.library_state,";
    "Fxn:forward" -> "Fxn:ValueError("input";
    "Fxn:forward" -> "Fxn:{}".format(input.shape))";
    "Fxn:backward" -> "Fxn:type2backend[input.type()]";
    "Fxn:backward" -> "Fxn:input.new(input.size())";
    "Fxn:backward" -> "Fxn:grid.new(grid.size())";
    "Fxn:backward" -> "Fxn:input.dim()";
    "Fxn:backward" -> "Fxn:backend.SpatialGridSamplerBilinear_updateGradInput(";
    "Fxn:backward" -> "Fxn:input.dim()";
    "Fxn:backward" -> "Fxn:backend.VolumetricGridSamplerBilinear_updateGradInput(";
    "Fxn:backward" -> "Fxn:ValueError("input";
    "Fxn:backward" -> "Fxn:{}".format(input.shape))";
    "class:AffineGridGenerator(Function):" -> "Fxn:_enforce_cudnn";
    "class:AffineGridGenerator(Function):" -> "Fxn:forward";
    "class:AffineGridGenerator(Function):" -> "Fxn:backward";
    "Fxn:_enforce_cudnn" -> "Fxn:RuntimeError("AffineGridGenerator";
    "Fxn:_enforce_cudnn" -> "Fxn:cudnn.is_acceptable(input)";
    "Fxn:forward" -> "Fxn:AffineGridGenerator._enforce_cudnn(theta)";
    "Fxn:forward" -> "Fxn:theta.new(N,";
    "Fxn:forward" -> "Fxn:torch.linspace(-1,";
    "Fxn:forward" -> "Fxn:torch.Tensor([-1])";
    "Fxn:forward" -> "Fxn:torch.ger(torch.ones(H),";
    "Fxn:forward" -> "Fxn:linear_points).expand_as(base_grid[:,";
    "Fxn:forward" -> "Fxn:torch.linspace(-1,";
    "Fxn:forward" -> "Fxn:torch.Tensor([-1])";
    "Fxn:forward" -> "Fxn:torch.ger(linear_points,";
    "Fxn:forward" -> "Fxn:torch.ones(W)).expand_as(base_grid[:,";
    "Fxn:forward" -> "Fxn:torch.bmm(base_grid.view(N,";
    "Fxn:forward" -> "Fxn:theta.transpose(1,";
    "Fxn:forward" -> "Fxn:grid.view(N,";
    "Fxn:backward" -> "Fxn:grad_grid.size()";
    "Fxn:backward" -> "Fxn:torch.Size([N,";
    "Fxn:backward" -> "Fxn:AffineGridGenerator._enforce_cudnn(grad_grid)";
    "Fxn:backward" -> "Fxn:torch.bmm(";
    "Fxn:backward" -> "Fxn:base_grid.view(N,";
    "Fxn:backward" -> "Fxn:3).transpose(1,";
    "Fxn:backward" -> "Fxn:grad_grid.view(N,";
    "Fxn:backward" -> "Fxn:grad_theta.transpose(1,";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:repeat";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:defaultdict";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:torch";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:parse_header,";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:Variable";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:Function,";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:type2backend";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:double_backwards_fns";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:symbolic_fns";
    "/torch/nn/_functions/thnn/auto.py" -> "Import:_all_functions";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:_make_function_class_criterion";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:symbolic";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:forward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:backward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:backward_cls_forward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:backward_cls_backward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:_find_buffers";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:_make_function_class";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:has_argument";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:_initialize_buffers";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:symbolic";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:forward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:backward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:backward_cls_forward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:backward_cls_backward";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:_generate_function_classes";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:make_default_double_backwards_fn";
    "/torch/nn/_functions/thnn/auto.py" -> "Fxn:default_double_backwards_fn";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Import:Variable";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Import:torch";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:elu_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:gatedlinear_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:hardshrink_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:hardtanh_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:leakyrelu_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:logsigmoid_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:softplus_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:softshrink_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:threshold_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:klddivloss_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:l1loss_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:mseloss_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:nllloss_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:smoothl1loss_double_backwards";
    "/torch/nn/_functions/thnn/auto_double_backwards.py" -> "Fxn:softmarginloss_double_backwards";
    "/torch/nn/_functions/thnn/auto_symbolic.py" -> "Import:prepare_onnx_paddings";
    "/torch/nn/_functions/thnn/auto_symbolic.py" -> "Fxn:reflectionpad_symbolic";
    "/torch/nn/_functions/thnn/auto_symbolic.py" -> "Fxn:replicationpad_symbolic";
    "/torch/nn/_functions/thnn/fold.py" -> "Import:Function,";
    "/torch/nn/_functions/thnn/fold.py" -> "Import:type2backend";
    "/torch/nn/_functions/thnn/fold.py" -> "Import:_all_functions";
    "/torch/nn/_functions/thnn/fold.py" -> "class:Col2Im(Function):";
    "/torch/nn/_functions/thnn/fold.py" -> "class:Im2Col(Function):";
    "class:Col2Im(Function):" -> "Fxn:forward";
    "class:Col2Im(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:type2backend[input.type()]";
    "Fxn:forward" -> "Fxn:input.new()";
    "Fxn:forward" -> "Fxn:ctx._backend.Col2Im_updateOutput(ctx._backend.library_state,";
    "Fxn:backward" -> "Fxn:grad_output.new()";
    "Fxn:backward" -> "Fxn:ctx._backend.Col2Im_updateGradInput(ctx._backend.library_state,";
    "class:Im2Col(Function):" -> "Fxn:forward";
    "class:Im2Col(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:input.dim()";
    "Fxn:forward" -> "Fxn:input.size(3))";
    "Fxn:forward" -> "Fxn:type2backend[input.type()]";
    "Fxn:forward" -> "Fxn:input.new()";
    "Fxn:forward" -> "Fxn:ctx._backend.Im2Col_updateOutput(ctx._backend.library_state,";
    "Fxn:backward" -> "Fxn:grad_output.new()";
    "Fxn:backward" -> "Fxn:ctx._backend.Im2Col_updateGradInput(ctx._backend.library_state,";
    "/torch/nn/_functions/thnn/normalization.py" -> "Import:torch";
    "/torch/nn/_functions/thnn/normalization.py" -> "Import:Function";
    "/torch/nn/_functions/thnn/normalization.py" -> "Import:type2backend";
    "/torch/nn/_functions/thnn/normalization.py" -> "Import:_all_functions";
    "/torch/nn/_functions/thnn/normalization.py" -> "class:CrossMapLRN2d(Function):";
    "class:CrossMapLRN2d(Function):" -> "Fxn:__init__";
    "class:CrossMapLRN2d(Function):" -> "Fxn:forward";
    "class:CrossMapLRN2d(Function):" -> "Fxn:backward";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:forward" -> "Fxn:input.dim()";
    "Fxn:forward" -> "Fxn:input.new()";
    "Fxn:forward" -> "Fxn:input.new()";
    "Fxn:forward" -> "Fxn:type2backend[input.type()]";
    "Fxn:forward" -> "Fxn:self._backend.SpatialCrossMapLRN_updateOutput(";
    "Fxn:forward" -> "Fxn:input.size(0)";
    "Fxn:forward" -> "Fxn:input.size(1)";
    "Fxn:forward" -> "Fxn:input.size(2)";
    "Fxn:forward" -> "Fxn:input.size(3)";
    "Fxn:forward" -> "Fxn:output.resize_as_(input)";
    "Fxn:forward" -> "Fxn:self.scale.resize_as_(input)";
    "Fxn:forward" -> "Fxn:torch.pow(input,";
    "Fxn:forward" -> "Fxn:self.scale.select(1,";
    "Fxn:forward" -> "Fxn:scale_first.zero_()";
    "Fxn:forward" -> "Fxn:scale_first.add_(input_square.select(1,";
    "Fxn:forward" -> "Fxn:self.scale.select(1,";
    "Fxn:forward" -> "Fxn:self.scale.select(1,";
    "Fxn:forward" -> "Fxn:scale_current.copy_(scale_previous)";
    "Fxn:forward" -> "Fxn:input_square.select(1,";
    "Fxn:forward" -> "Fxn:scale_current.add_(1,";
    "Fxn:forward" -> "Fxn:input_square.select(1,";
    "Fxn:forward" -> "Fxn:scale_current.add_(-1,";
    "Fxn:forward" -> "Fxn:self.scale.mul_(self.alpha";
    "Fxn:forward" -> "Fxn:self.size).add_(self.k)";
    "Fxn:forward" -> "Fxn:torch.pow(self.scale,";
    "Fxn:forward" -> "Fxn:output.mul_(input)";
    "Fxn:forward" -> "Fxn:self.save_for_backward(input,";
    "Fxn:backward" -> "Fxn:grad_output.new()";
    "Fxn:backward" -> "Fxn:self._backend.SpatialCrossMapLRN_updateGradInput(";
    "Fxn:backward" -> "Fxn:input.size(0)";
    "Fxn:backward" -> "Fxn:input.size(1)";
    "Fxn:backward" -> "Fxn:input.size(2)";
    "Fxn:backward" -> "Fxn:input.size(3)";
    "Fxn:backward" -> "Fxn:input.new(channels";
    "Fxn:backward" -> "Fxn:input.new(input_height,";
    "Fxn:backward" -> "Fxn:grad_input.resize_as_(input)";
    "Fxn:backward" -> "Fxn:torch.pow(self.scale,";
    "Fxn:backward" -> "Fxn:out=grad_input).mul_(grad_output)";
    "Fxn:backward" -> "Fxn:paddded_ratio.zero_()";
    "Fxn:backward" -> "Fxn:paddded_ratio.narrow(0,";
    "Fxn:backward" -> "Fxn:torch.mul(grad_output[n],";
    "Fxn:backward" -> "Fxn:padded_ratio_center.div_(self.scale[n])";
    "Fxn:backward" -> "Fxn:torch.sum(";
    "Fxn:backward" -> "Fxn:paddded_ratio.narrow(0,";
    "Fxn:backward" -> "Fxn:accum_ratio.add_(paddded_ratio[c";
    "Fxn:backward" -> "Fxn:grad_input[n][c].addcmul_(-cache_ratio_value,";
    "Fxn:backward" -> "Fxn:accum_ratio.add_(-1,";
    "Fxn:backward" -> "Fxn:_all_functions.append(CrossMapLRN2d)";
    "/torch/nn/_functions/thnn/rnnFusedPointwise.py" -> "Import:torch";
    "/torch/nn/_functions/thnn/rnnFusedPointwise.py" -> "Import:Function,";
    "/torch/nn/_functions/thnn/rnnFusedPointwise.py" -> "Import:type2backend";
    "/torch/nn/_functions/thnn/rnnFusedPointwise.py" -> "class:GRUFused(Function):";
    "/torch/nn/_functions/thnn/rnnFusedPointwise.py" -> "class:LSTMFused(Function):";
    "class:GRUFused(Function):" -> "Fxn:forward";
    "class:GRUFused(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:type2backend[input_gate.type()]";
    "Fxn:forward" -> "Fxn:input_gate.new()";
    "Fxn:forward" -> "Fxn:input_gate.new(hx.numel()";
    "Fxn:forward" -> "Fxn:ibias.dim()";
    "Fxn:forward" -> "Fxn:ibias.unsqueeze(0)";
    "Fxn:forward" -> "Fxn:hbias.dim()";
    "Fxn:forward" -> "Fxn:hbias.unsqueeze(0)";
    "Fxn:forward" -> "Fxn:ctx.backend.GRUFused_updateOutput(";
    "Fxn:forward" -> "Fxn:input_gate.size()";
    "Fxn:forward" -> "Fxn:hidden_gate.size()";
    "Fxn:backward" -> "Fxn:type2backend[gradOutput.type()]";
    "Fxn:backward" -> "Fxn:gradOutput.new()";
    "Fxn:backward" -> "Fxn:gradOutput.new(*ctx.igate_size)";
    "Fxn:backward" -> "Fxn:gradOutput.new(*ctx.hgate_size)";
    "Fxn:backward" -> "Fxn:ctx.backend.GRUFused_updateGradInput(";
    "Fxn:backward" -> "Fxn:gradInInput.sum(0,";
    "Fxn:backward" -> "Fxn:gradInHidden.sum(0,";
    "class:LSTMFused(Function):" -> "Fxn:forward";
    "class:LSTMFused(Function):" -> "Fxn:backward";
    "Fxn:forward" -> "Fxn:type2backend[input_gate.type()]";
    "Fxn:forward" -> "Fxn:input_gate.new()";
    "Fxn:forward" -> "Fxn:input_gate.new()";
    "Fxn:forward" -> "Fxn:ibias.dim()";
    "Fxn:forward" -> "Fxn:ibias.unsqueeze(0)";
    "Fxn:forward" -> "Fxn:hbias.dim()";
    "Fxn:forward" -> "Fxn:hbias.unsqueeze(0)";
    "Fxn:forward" -> "Fxn:ctx.backend.LSTMFused_updateOutput(";
    "Fxn:forward" -> "Fxn:hidden_gate.size()";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(input_gate,";
    "Fxn:backward" -> "Fxn:type2backend[gradOutput[0].type()]";
    "Fxn:backward" -> "Fxn:gradOutput[0].new()";
    "Fxn:backward" -> "Fxn:gradOutput[0].new(*ctx.hgate_size)";
    "Fxn:backward" -> "Fxn:ctx.backend.LSTMFused_updateGradInput(";
    "Fxn:backward" -> "Fxn:gradInGates.sum(0,";
    "Fxn:backward" -> "Fxn:gradInGates.sum(0,";
    "/torch/nn/_functions/thnn/sparse.py" -> "Import:torch";
    "/torch/nn/_functions/thnn/sparse.py" -> "Import:Function";
    "/torch/nn/_functions/thnn/sparse.py" -> "Import:type2backend";
    "/torch/nn/_functions/thnn/sparse.py" -> "Import:once_differentiable";
    "/torch/nn/_functions/thnn/sparse.py" -> "Import:_all_functions";
    "/torch/nn/_functions/thnn/sparse.py" -> "class:EmbeddingBag(Function):";
    "class:EmbeddingBag(Function):" -> "Fxn:_renorm";
    "class:EmbeddingBag(Function):" -> "Fxn:forward";
    "class:EmbeddingBag(Function):" -> "Fxn:backward";
    "Fxn:_renorm" -> "Fxn:ctx._backend.LookupTable_renorm(";
    "Fxn:_renorm" -> "Fxn:indices.clone().view(-1),";
    "Fxn:forward" -> "Fxn:ValueError("mode";
    "Fxn:forward" -> "Fxn:.format(mode))";
    "Fxn:forward" -> "Fxn:indices.dim()";
    "Fxn:forward" -> "Fxn:offsets.dim()";
    "Fxn:forward" -> "Fxn:ValueError("offsets";
    "Fxn:forward" -> "Fxn:ValueError("offsets[0]";
    "Fxn:forward" -> "Fxn:{}".format(offsets[0]))";
    "Fxn:forward" -> "Fxn:indices.size(0):";
    "Fxn:forward" -> "Fxn:ValueError("offsets[-1]";
    "Fxn:forward" -> "Fxn:.format(indices.size(0),";
    "Fxn:forward" -> "Fxn:type2backend[weight.type()]";
    "Fxn:forward" -> "Fxn:weight.size()";
    "Fxn:forward" -> "Fxn:offsets.new()";
    "Fxn:forward" -> "Fxn:ctx.save_for_backward(indices)";
    "Fxn:forward" -> "Fxn:indices.contiguous().view(-1)";
    "Fxn:forward" -> "Fxn:weight.new()";
    "Fxn:forward" -> "Fxn:cls._renorm(ctx,";
    "Fxn:forward" -> "Fxn:offsets.new().resize_(offsets.size())";
    "Fxn:forward" -> "Fxn:ctx._backend.LookupTableBag_updateOutput(";
    "Fxn:forward" -> "Fxn:torch.index_select(weight,";
    "Fxn:forward" -> "Fxn:ctx._offset2bag.resize_(indices.size(0)).zero_()";
    "Fxn:forward" -> "Fxn:ctx._offset2bag.index_fill_(0,";
    "Fxn:forward" -> "Fxn:ctx._offset2bag.cumsum(0)";
    "Fxn:forward" -> "Fxn:output.resize_(offsets.size(0),";
    "Fxn:forward" -> "Fxn:weight.size(1)).zero_()";
    "Fxn:forward" -> "Fxn:output.index_add_(0,";
    "Fxn:forward" -> "Fxn:offsets.size(0)";
    "Fxn:forward" -> "Fxn:indices.size(0)";
    "Fxn:forward" -> "Fxn:weight.new().resize_(offsets.size())";
    "Fxn:forward" -> "Fxn:indices.size(0)";
    "Fxn:forward" -> "Fxn:None].expand_as(output)";
    "Fxn:backward" -> "Fxn:indices.contiguous().view(-1)";
    "Fxn:backward" -> "Fxn:grad_output.contiguous()";
    "Fxn:backward" -> "Fxn:torch.cuda.device_of(grad_output):";
    "Fxn:backward" -> "Fxn:torch.cuda.LongTensor()";
    "Fxn:backward" -> "Fxn:torch.cuda.LongTensor()";
    "Fxn:backward" -> "Fxn:torch.cuda.LongTensor()";
    "Fxn:backward" -> "Fxn:torch.IntTensor()";
    "Fxn:backward" -> "Fxn:grad_output.new(ctx._weight_size).zero_()";
    "Fxn:backward" -> "Fxn:ctx._backend.LookupTableBag_accGradParameters(";
    "Fxn:backward" -> "Fxn:grad_output.index_select(0,";
    "Fxn:backward" -> "Fxn:ctx._backend.LookupTable_accGradParameters(";
    "Fxn:backward" -> "Fxn:_all_functions.append(EmbeddingBag)";
    "/torch/nn/_functions/thnn/__init__.py" -> "Import:.normalization";
    "/torch/nn/_functions/thnn/__init__.py" -> "Import:.fold";
    "/torch/nn/_functions/thnn/__init__.py" -> "Import:.sparse";
    "/torch/nn/_functions/thnn/__init__.py" -> "Import:.rnnFusedPointwise";
    "/torch/onnx/symbolic.py" -> "Import:torch";
    "/torch/onnx/symbolic.py" -> "Import:_single,";
    "/torch/onnx/symbolic.py" -> "Import:PackedSequence";
    "/torch/onnx/symbolic.py" -> "Import:warnings";
    "/torch/onnx/symbolic.py" -> "Import:torch.onnx";
    "/torch/onnx/symbolic.py" -> "Import:partial";
    "/torch/onnx/symbolic.py" -> "Fxn:_scalar";
    "/torch/onnx/symbolic.py" -> "Fxn:_if_scalar_type_as";
    "/torch/onnx/symbolic.py" -> "Fxn:_broadcast_if_scalar";
    "/torch/onnx/symbolic.py" -> "Fxn:_unimplemented";
    "/torch/onnx/symbolic.py" -> "Fxn:unused";
    "/torch/onnx/symbolic.py" -> "Fxn:Constant";
    "/torch/onnx/symbolic.py" -> "Fxn:add";
    "/torch/onnx/symbolic.py" -> "Fxn:sub";
    "/torch/onnx/symbolic.py" -> "Fxn:mul";
    "/torch/onnx/symbolic.py" -> "Fxn:div";
    "/torch/onnx/symbolic.py" -> "Fxn:cat";
    "/torch/onnx/symbolic.py" -> "Fxn:mm";
    "/torch/onnx/symbolic.py" -> "Fxn:bmm";
    "/torch/onnx/symbolic.py" -> "Fxn:matmul";
    "/torch/onnx/symbolic.py" -> "Fxn:addmm";
    "/torch/onnx/symbolic.py" -> "Fxn:neg";
    "/torch/onnx/symbolic.py" -> "Fxn:sqrt";
    "/torch/onnx/symbolic.py" -> "Fxn:tanh";
    "/torch/onnx/symbolic.py" -> "Fxn:sigmoid";
    "/torch/onnx/symbolic.py" -> "Fxn:mean";
    "/torch/onnx/symbolic.py" -> "Fxn:sum";
    "/torch/onnx/symbolic.py" -> "Fxn:cumsum";
    "/torch/onnx/symbolic.py" -> "Fxn:prod";
    "/torch/onnx/symbolic.py" -> "Fxn:t";
    "/torch/onnx/symbolic.py" -> "Fxn:expand";
    "/torch/onnx/symbolic.py" -> "Fxn:embedding";
    "/torch/onnx/symbolic.py" -> "Fxn:embedding_bag";
    "/torch/onnx/symbolic.py" -> "Fxn:transpose";
    "/torch/onnx/symbolic.py" -> "Fxn:permute";
    "/torch/onnx/symbolic.py" -> "Fxn:view";
    "/torch/onnx/symbolic.py" -> "Fxn:split";
    "/torch/onnx/symbolic.py" -> "Fxn:chunk";
    "/torch/onnx/symbolic.py" -> "Fxn:select";
    "/torch/onnx/symbolic.py" -> "Fxn:squeeze";
    "/torch/onnx/symbolic.py" -> "Fxn:prelu";
    "/torch/onnx/symbolic.py" -> "Fxn:relu";
    "/torch/onnx/symbolic.py" -> "Fxn:threshold";
    "/torch/onnx/symbolic.py" -> "Fxn:leaky_relu";
    "/torch/onnx/symbolic.py" -> "Fxn:glu";
    "/torch/onnx/symbolic.py" -> "Fxn:softmax";
    "/torch/onnx/symbolic.py" -> "Fxn:softplus";
    "/torch/onnx/symbolic.py" -> "Fxn:max_pool1d";
    "/torch/onnx/symbolic.py" -> "Fxn:max_pool2d";
    "/torch/onnx/symbolic.py" -> "Fxn:avg_pool2d";
    "/torch/onnx/symbolic.py" -> "Fxn:avg_pool3d";
    "/torch/onnx/symbolic.py" -> "Fxn:reflection_pad";
    "/torch/onnx/symbolic.py" -> "Import:prepare_onnx_paddings";
    "/torch/onnx/symbolic.py" -> "Fxn:replication_pad";
    "/torch/onnx/symbolic.py" -> "Import:prepare_onnx_paddings";
    "/torch/onnx/symbolic.py" -> "Fxn:upsample_nearest2d";
    "/torch/onnx/symbolic.py" -> "Fxn:upsample_bilinear2d";
    "/torch/onnx/symbolic.py" -> "Fxn:gt";
    "/torch/onnx/symbolic.py" -> "Fxn:lt";
    "/torch/onnx/symbolic.py" -> "Fxn:log_softmax";
    "/torch/onnx/symbolic.py" -> "Fxn:_convolution";
    "/torch/onnx/symbolic.py" -> "Fxn:batch_norm";
    "/torch/onnx/symbolic.py" -> "Fxn:unfold";
    "/torch/onnx/symbolic.py" -> "Fxn:elu";
    "/torch/onnx/symbolic.py" -> "Fxn:selu";
    "/torch/onnx/symbolic.py" -> "Fxn:index_select";
    "/torch/onnx/symbolic.py" -> "Fxn:type_as";
    "/torch/onnx/symbolic.py" -> "Fxn:clone";
    "/torch/onnx/symbolic.py" -> "Fxn:abs";
    "/torch/onnx/symbolic.py" -> "Fxn:pow";
    "/torch/onnx/symbolic.py" -> "Fxn:clamp";
    "/torch/onnx/symbolic.py" -> "Fxn:max";
    "/torch/onnx/symbolic.py" -> "Fxn:min";
    "/torch/onnx/symbolic.py" -> "Fxn:eq";
    "/torch/onnx/symbolic.py" -> "Fxn:exp";
    "/torch/onnx/symbolic.py" -> "Fxn:conv_tbc";
    "/torch/onnx/symbolic.py" -> "Fxn:_cast_func_template";
    "/torch/onnx/symbolic.py" -> "Fxn:slice";
    "/torch/onnx/symbolic.py" -> "Fxn:alias";
    "/torch/onnx/symbolic.py" -> "Fxn:unsqueeze";
    "/torch/onnx/symbolic.py" -> "Fxn:topk";
    "/torch/onnx/symbolic.py" -> "Fxn:instance_norm";
    "/torch/onnx/symbolic.py" -> "Fxn:RNN_symbolic_builder";
    "/torch/onnx/symbolic.py" -> "Fxn:reform_weights";
    "/torch/onnx/symbolic.py" -> "Fxn:Elman_RNN_symbolic_builder";
    "/torch/onnx/symbolic.py" -> "Fxn:symbolic";
    "/torch/onnx/symbolic.py" -> "Fxn:LSTM_symbolic_builder";
    "/torch/onnx/symbolic.py" -> "Fxn:symbolic";
    "/torch/onnx/symbolic.py" -> "Fxn:GRU_symbolic_builder";
    "/torch/onnx/symbolic.py" -> "Fxn:symbolic";
    "/torch/onnx/utils.py" -> "Import:torch";
    "/torch/onnx/utils.py" -> "Import:torch.jit";
    "/torch/onnx/utils.py" -> "Import:torch.autograd";
    "/torch/onnx/utils.py" -> "Import:torch.serialization";
    "/torch/onnx/utils.py" -> "Import:import";
    "/torch/onnx/utils.py" -> "Import:collections";
    "/torch/onnx/utils.py" -> "Import:contextlib";
    "/torch/onnx/utils.py" -> "Import:numbers";
    "/torch/onnx/utils.py" -> "Import:warnings";
    "/torch/onnx/utils.py" -> "Import:functools";
    "/torch/onnx/utils.py" -> "Import:types";
    "/torch/onnx/utils.py" -> "Import:string_classes";
    "/torch/onnx/utils.py" -> "Import:Function,";
    "/torch/onnx/utils.py" -> "Import:_unique_state_dict";
    "/torch/onnx/utils.py" -> "Fxn:set_training";
    "/torch/onnx/utils.py" -> "Fxn:export";
    "/torch/onnx/utils.py" -> "Fxn:_optimize_trace";
    "/torch/onnx/utils.py" -> "Fxn:_trace";
    "/torch/onnx/utils.py" -> "Fxn:_export";
    "/torch/onnx/utils.py" -> "Import:_onnx_opset_version";
    "/torch/onnx/utils.py" -> "Fxn:_set_input_and_output_names";
    "/torch/onnx/utils.py" -> "Fxn:set_names";
    "/torch/onnx/utils.py" -> "Fxn:_run_symbolic_method";
    "/torch/onnx/utils.py" -> "Fxn:_is_onnx_list";
    "/torch/onnx/utils.py" -> "Fxn:_add_attribute";
    "/torch/onnx/utils.py" -> "Fxn:_scalar";
    "/torch/onnx/utils.py" -> "Fxn:_newNode";
    "/torch/onnx/utils.py" -> "Fxn:_graph_op";
    "/torch/onnx/utils.py" -> "Fxn:const_if_tensor";
    "/torch/onnx/utils.py" -> "Fxn:_run_symbolic_function";
    "/torch/onnx/utils.py" -> "Import:torch.onnx.symbolic";
    "/torch/onnx/utils.py" -> "Fxn:_graph_at";
    "/torch/onnx/utils.py" -> "Fxn:_graph_constant";
    "/torch/onnx/utils.py" -> "Fxn:_node_getitem";
    "/torch/onnx/__init__.py" -> "Import:functools";
    "/torch/onnx/__init__.py" -> "Import:types";
    "/torch/onnx/__init__.py" -> "Fxn:_export";
    "/torch/onnx/__init__.py" -> "Import:utils";
    "/torch/onnx/__init__.py" -> "Fxn:export";
    "/torch/onnx/__init__.py" -> "Import:utils";
    "/torch/onnx/__init__.py" -> "Fxn:_optimize_trace";
    "/torch/onnx/__init__.py" -> "Import:utils";
    "/torch/onnx/__init__.py" -> "Fxn:set_training";
    "/torch/onnx/__init__.py" -> "Import:utils";
    "/torch/onnx/__init__.py" -> "Fxn:_run_symbolic_function";
    "/torch/onnx/__init__.py" -> "Import:utils";
    "/torch/onnx/__init__.py" -> "Fxn:_run_symbolic_method";
    "/torch/onnx/__init__.py" -> "Import:utils";
    "/torch/onnx/__init__.py" -> "Fxn:_symbolic_override_wrapper_maker";
    "/torch/onnx/__init__.py" -> "Fxn:wrapper";
    "/torch/onnx/__init__.py" -> "Import:torch";
    "/torch/onnx/__init__.py" -> "Import:torch.jit";
    "/torch/onnx/__init__.py" -> "Import:Function,";
    "/torch/onnx/__init__.py" -> "Fxn:symbolic_override";
    "/torch/onnx/__init__.py" -> "Fxn:symb";
    "/torch/onnx/__init__.py" -> "Fxn:foo";
    "/torch/onnx/__init__.py" -> "Fxn:symbolic_override_first_arg_based";
    "/torch/onnx/__init__.py" -> "Fxn:might_trace";
    "/torch/onnx/__init__.py" -> "Import:torch";
    "/torch/onnx/__init__.py" -> "Fxn:symbolic_override_packed_sequence_based";
    "/torch/onnx/__init__.py" -> "Fxn:might_trace";
    "/torch/onnx/__init__.py" -> "Import:torch";
    "/torch/optim/adadelta.py" -> "Import:torch";
    "/torch/optim/adadelta.py" -> "Import:Optimizer";
    "/torch/optim/adadelta.py" -> "class:Adadelta(Optimizer):";
    "class:Adadelta(Optimizer):" -> "Fxn:__init__";
    "class:Adadelta(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError('Adadelta";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:grad.add(group['weight_decay'],";
    "Fxn:step" -> "Fxn:square_avg.mul_(rho).addcmul_(1";
    "Fxn:step" -> "Fxn:square_avg.add(eps).sqrt_()";
    "Fxn:step" -> "Fxn:acc_delta.add(eps).sqrt_().div_(std).mul_(grad)";
    "Fxn:step" -> "Fxn:p.data.add_(-group['lr'],";
    "Fxn:step" -> "Fxn:acc_delta.mul_(rho).addcmul_(1";
    "/torch/optim/adagrad.py" -> "Import:torch";
    "/torch/optim/adagrad.py" -> "Import:Optimizer";
    "/torch/optim/adagrad.py" -> "class:Adagrad(Optimizer):";
    "class:Adagrad(Optimizer):" -> "Fxn:__init__";
    "class:Adagrad(Optimizer):" -> "Fxn:share_memory";
    "class:Adagrad(Optimizer):" -> "Fxn:step";
    "class:Adagrad(Optimizer):" -> "Fxn:make_sparse";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:__init__" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:share_memory" -> "Fxn:state['sum'].share_memory_()";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError("weight_decay";
    "Fxn:step" -> "Fxn:grad.add(group['weight_decay'],";
    "Fxn:step" -> "Fxn:grad.coalesce()";
    "Fxn:step" -> "Fxn:grad._indices()";
    "Fxn:step" -> "Fxn:grad._values()";
    "Fxn:step" -> "Fxn:grad.size()";
    "Fxn:make_sparse" -> "Fxn:grad_indices.dim()";
    "Fxn:make_sparse" -> "Fxn:values.dim()";
    "Fxn:make_sparse" -> "Fxn:constructor().resize_as_(grad)";
    "Fxn:make_sparse" -> "Fxn:constructor(grad_indices,";
    "Fxn:make_sparse" -> "Fxn:state['sum'].add_(make_sparse(grad_values.pow(2)))";
    "Fxn:make_sparse" -> "Fxn:state['sum']._sparse_mask(grad)";
    "Fxn:make_sparse" -> "Fxn:std._values().sqrt_().add_(1e-10)";
    "Fxn:make_sparse" -> "Fxn:p.data.add_(-clr,";
    "Fxn:make_sparse" -> "Fxn:make_sparse(grad_values";
    "Fxn:make_sparse" -> "Fxn:state['sum'].addcmul_(1,";
    "Fxn:make_sparse" -> "Fxn:state['sum'].sqrt().add_(1e-10)";
    "Fxn:make_sparse" -> "Fxn:p.data.addcdiv_(-clr,";
    "/torch/optim/adam.py" -> "Import:math";
    "/torch/optim/adam.py" -> "Import:torch";
    "/torch/optim/adam.py" -> "Import:Optimizer";
    "/torch/optim/adam.py" -> "class:Adam(Optimizer):";
    "class:Adam(Optimizer):" -> "Fxn:__init__";
    "class:Adam(Optimizer):" -> "Fxn:__setstate__";
    "class:Adam(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:betas=(0.9,";
    "Fxn:__init__" -> "Fxn:ValueError("Invalid";
    "Fxn:__init__" -> "Fxn:{}".format(betas[0]))";
    "Fxn:__init__" -> "Fxn:ValueError("Invalid";
    "Fxn:__init__" -> "Fxn:{}".format(betas[1]))";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:__setstate__" -> "Fxn:self).__setstate__(state)";
    "Fxn:__setstate__" -> "Fxn:group.setdefault('amsgrad',";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError('Adam";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:grad.add(group['weight_decay'],";
    "Fxn:step" -> "Fxn:exp_avg.mul_(beta1).add_(1";
    "Fxn:step" -> "Fxn:exp_avg_sq.mul_(beta2).addcmul_(1";
    "Fxn:step" -> "Fxn:torch.max(max_exp_avg_sq,";
    "Fxn:step" -> "Fxn:max_exp_avg_sq.sqrt().add_(group['eps'])";
    "Fxn:step" -> "Fxn:exp_avg_sq.sqrt().add_(group['eps'])";
    "Fxn:step" -> "Fxn:math.sqrt(bias_correction2)";
    "Fxn:step" -> "Fxn:p.data.addcdiv_(-step_size,";
    "/torch/optim/adamax.py" -> "Import:torch";
    "/torch/optim/adamax.py" -> "Import:Optimizer";
    "/torch/optim/adamax.py" -> "class:Adamax(Optimizer):";
    "class:Adamax(Optimizer):" -> "Fxn:__init__";
    "class:Adamax(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:betas=(0.9,";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError('Adamax";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:grad.add(group['weight_decay'],";
    "Fxn:step" -> "Fxn:exp_avg.mul_(beta1).add_(1";
    "Fxn:step" -> "Fxn:torch.cat([";
    "Fxn:step" -> "Fxn:exp_inf.mul_(beta2).unsqueeze(0),";
    "Fxn:step" -> "Fxn:grad.abs().add_(eps).unsqueeze_(0)";
    "Fxn:step" -> "Fxn:torch.max(norm_buf,";
    "Fxn:step" -> "Fxn:out=(exp_inf,";
    "Fxn:step" -> "Fxn:exp_inf.new().long()))";
    "Fxn:step" -> "Fxn:p.data.addcdiv_(-clr,";
    "/torch/optim/asgd.py" -> "Import:math";
    "/torch/optim/asgd.py" -> "Import:torch";
    "/torch/optim/asgd.py" -> "Import:Optimizer";
    "/torch/optim/asgd.py" -> "class:ASGD(Optimizer):";
    "class:ASGD(Optimizer):" -> "Fxn:__init__";
    "class:ASGD(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError('ASGD";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:grad.add(group['weight_decay'],";
    "Fxn:step" -> "Fxn:p.data.mul_(1";
    "Fxn:step" -> "Fxn:p.data.add_(-state['eta'],";
    "Fxn:step" -> "Fxn:state['ax'].add_(p.data.sub(state['ax']).mul(state['mu']))";
    "Fxn:step" -> "Fxn:state['ax'].copy_(p.data)";
    "Fxn:step" -> "Fxn:math.pow((1";
    "/torch/optim/lbfgs.py" -> "Import:torch";
    "/torch/optim/lbfgs.py" -> "Import:reduce";
    "/torch/optim/lbfgs.py" -> "Import:Optimizer";
    "/torch/optim/lbfgs.py" -> "class:LBFGS(Optimizer):";
    "class:LBFGS(Optimizer):" -> "Fxn:__init__";
    "class:LBFGS(Optimizer):" -> "Fxn:_numel";
    "class:LBFGS(Optimizer):" -> "Fxn:_gather_flat_grad";
    "class:LBFGS(Optimizer):" -> "Fxn:_add_grad";
    "class:LBFGS(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:__init__" -> "Fxn:ValueError("LBFGS";
    "Fxn:__init__" -> "Fxn:"(parameter";
    "Fxn:_numel" -> "Fxn:reduce(lambda";
    "Fxn:_numel" -> "Fxn:p.numel(),";
    "Fxn:_gather_flat_grad" -> "Fxn:p.data.new(p.data.numel()).zero_()";
    "Fxn:_gather_flat_grad" -> "Fxn:p.grad.data.to_dense().view(-1)";
    "Fxn:_gather_flat_grad" -> "Fxn:p.grad.data.view(-1)";
    "Fxn:_gather_flat_grad" -> "Fxn:views.append(view)";
    "Fxn:_gather_flat_grad" -> "Fxn:torch.cat(views,";
    "Fxn:_add_grad" -> "Fxn:p.numel()";
    "Fxn:_add_grad" -> "Fxn:p.data.add_(step_size,";
    "Fxn:_add_grad" -> "Fxn:numel].view_as(p.data))";
    "Fxn:_add_grad" -> "Fxn:self._numel()";
    "Fxn:step" -> "Fxn:state.setdefault('func_evals',";
    "Fxn:step" -> "Fxn:state.setdefault('n_iter',";
    "Fxn:step" -> "Fxn:f(x)";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:self._gather_flat_grad()";
    "Fxn:step" -> "Fxn:flat_grad.abs().sum()";
    "Fxn:step" -> "Fxn:state.get('d')";
    "Fxn:step" -> "Fxn:state.get('t')";
    "Fxn:step" -> "Fxn:state.get('old_dirs')";
    "Fxn:step" -> "Fxn:state.get('old_stps')";
    "Fxn:step" -> "Fxn:state.get('H_diag')";
    "Fxn:step" -> "Fxn:state.get('prev_flat_grad')";
    "Fxn:step" -> "Fxn:state.get('prev_loss')";
    "Fxn:step" -> "Fxn:flat_grad.neg()";
    "Fxn:step" -> "Fxn:flat_grad.sub(prev_flat_grad)";
    "Fxn:step" -> "Fxn:d.mul(t)";
    "Fxn:step" -> "Fxn:y.dot(s)";
    "Fxn:step" -> "Fxn:old_dirs.pop(0)";
    "Fxn:step" -> "Fxn:old_stps.pop(0)";
    "Fxn:step" -> "Fxn:old_dirs.append(s)";
    "Fxn:step" -> "Fxn:old_stps.append(y)";
    "Fxn:step" -> "Fxn:y.dot(y)";
    "Fxn:step" -> "Fxn:old_stps[i].dot(old_dirs[i])";
    "Fxn:step" -> "Fxn:flat_grad.neg()";
    "Fxn:step" -> "Fxn:old_dirs[i].dot(q)";
    "Fxn:step" -> "Fxn:q.add_(-al[i],";
    "Fxn:step" -> "Fxn:torch.mul(q,";
    "Fxn:step" -> "Fxn:old_stps[i].dot(r)";
    "Fxn:step" -> "Fxn:r.add_(al[i]";
    "Fxn:step" -> "Fxn:flat_grad.clone()";
    "Fxn:step" -> "Fxn:prev_flat_grad.copy_(flat_grad)";
    "Fxn:step" -> "Fxn:flat_grad.dot(d)";
    "Fxn:step" -> "Fxn:RuntimeError("line";
    "Fxn:step" -> "Fxn:self._add_grad(t,";
    "Fxn:step" -> "Fxn:self._gather_flat_grad()";
    "Fxn:step" -> "Fxn:flat_grad.abs().sum()";
    "Fxn:step" -> "Fxn:d.mul(t).abs_().sum()";
    "/torch/optim/lr_scheduler.py" -> "Import:math";
    "/torch/optim/lr_scheduler.py" -> "Import:bisect_right";
    "/torch/optim/lr_scheduler.py" -> "Import:partial";
    "/torch/optim/lr_scheduler.py" -> "Import:Optimizer";
    "/torch/optim/lr_scheduler.py" -> "class:_LRScheduler(object):";
    "/torch/optim/lr_scheduler.py" -> "class:LambdaLR(_LRScheduler):";
    "/torch/optim/lr_scheduler.py" -> "class:StepLR(_LRScheduler):";
    "/torch/optim/lr_scheduler.py" -> "class:MultiStepLR(_LRScheduler):";
    "/torch/optim/lr_scheduler.py" -> "class:ExponentialLR(_LRScheduler):";
    "/torch/optim/lr_scheduler.py" -> "class:CosineAnnealingLR(_LRScheduler):";
    "/torch/optim/lr_scheduler.py" -> "class:ReduceLROnPlateau(object):";
    "class:_LRScheduler(object):" -> "Fxn:__init__";
    "class:_LRScheduler(object):" -> "Fxn:get_lr";
    "class:_LRScheduler(object):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:TypeError('{}";
    "Fxn:__init__" -> "Fxn:Optimizer'.format(";
    "Fxn:__init__" -> "Fxn:group.setdefault('initial_lr',";
    "Fxn:__init__" -> "Fxn:KeyError("param";
    "Fxn:__init__" -> "Fxn:optimizer".format(i))";
    "Fxn:__init__" -> "Fxn:self.step(last_epoch";
    "Fxn:step" -> "Fxn:self.get_lr()):";
    "class:LambdaLR(_LRScheduler):" -> "Fxn:__init__";
    "class:LambdaLR(_LRScheduler):" -> "Fxn:get_lr";
    "Fxn:__init__" -> "Fxn:ValueError("Expected";
    "Fxn:__init__" -> "Fxn:{}".format(";
    "Fxn:__init__" -> "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr" -> "Fxn:lmbda(self.last_epoch)";
    "class:StepLR(_LRScheduler):" -> "Fxn:__init__";
    "class:StepLR(_LRScheduler):" -> "Fxn:get_lr";
    "Fxn:__init__" -> "Fxn:self).__init__(optimizer,";
    "class:MultiStepLR(_LRScheduler):" -> "Fxn:__init__";
    "class:MultiStepLR(_LRScheduler):" -> "Fxn:get_lr";
    "Fxn:__init__" -> "Fxn:ValueError('Milestones";
    "Fxn:__init__" -> "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr" -> "Fxn:bisect_right(self.milestones,";
    "class:ExponentialLR(_LRScheduler):" -> "Fxn:__init__";
    "class:ExponentialLR(_LRScheduler):" -> "Fxn:get_lr";
    "Fxn:__init__" -> "Fxn:self).__init__(optimizer,";
    "class:CosineAnnealingLR(_LRScheduler):" -> "Fxn:__init__";
    "class:CosineAnnealingLR(_LRScheduler):" -> "Fxn:get_lr";
    "Fxn:__init__" -> "Fxn:self).__init__(optimizer,";
    "Fxn:get_lr" -> "Fxn:math.cos(math.pi";
    "class:ReduceLROnPlateau(object):" -> "Fxn:__init__";
    "class:ReduceLROnPlateau(object):" -> "Fxn:_reset";
    "class:ReduceLROnPlateau(object):" -> "Fxn:step";
    "class:ReduceLROnPlateau(object):" -> "Fxn:_reduce_lr";
    "class:ReduceLROnPlateau(object):" -> "Fxn:in_cooldown";
    "class:ReduceLROnPlateau(object):" -> "Fxn:_cmp";
    "class:ReduceLROnPlateau(object):" -> "Fxn:_init_is_better";
    "Fxn:__init__" -> "Fxn:ValueError('Factor";
    "Fxn:__init__" -> "Fxn:TypeError('{}";
    "Fxn:__init__" -> "Fxn:Optimizer'.format(";
    "Fxn:__init__" -> "Fxn:ValueError("expected";
    "Fxn:__init__" -> "Fxn:{}".format(";
    "Fxn:__init__" -> "Fxn:self._init_is_better(mode=mode,";
    "Fxn:__init__" -> "Fxn:self._reset()";
    "Fxn:step" -> "Fxn:self.is_better(current,";
    "Fxn:step" -> "Fxn:self._reduce_lr(epoch)";
    "Fxn:_reduce_lr" -> "Fxn:{:.4e}.'.format(epoch,";
    "Fxn:_init_is_better" -> "Fxn:ValueError('mode";
    "Fxn:_init_is_better" -> "Fxn:ValueError('threshold";
    "Fxn:_init_is_better" -> "Fxn:partial(self._cmp,";
    "/torch/optim/optimizer.py" -> "Import:defaultdict,";
    "/torch/optim/optimizer.py" -> "Import:torch";
    "/torch/optim/optimizer.py" -> "Import:deepcopy";
    "/torch/optim/optimizer.py" -> "Import:chain";
    "/torch/optim/optimizer.py" -> "Import:Variable";
    "/torch/optim/optimizer.py" -> "class:Optimizer(object):";
    "class:Optimizer(object):" -> "Fxn:__init__";
    "class:Optimizer(object):" -> "Fxn:__getstate__";
    "class:Optimizer(object):" -> "Fxn:__setstate__";
    "class:Optimizer(object):" -> "Fxn:__repr__";
    "class:Optimizer(object):" -> "Fxn:state_dict";
    "class:Optimizer(object):" -> "Fxn:pack_group";
    "class:Optimizer(object):" -> "Fxn:load_state_dict";
    "class:Optimizer(object):" -> "Fxn:cast";
    "class:Optimizer(object):" -> "Fxn:update_group";
    "class:Optimizer(object):" -> "Fxn:zero_grad";
    "class:Optimizer(object):" -> "Fxn:step";
    "class:Optimizer(object):" -> "Fxn:add_param_group";
    "Fxn:__init__" -> "Fxn:torch.is_tensor(params):";
    "Fxn:__init__" -> "Fxn:TypeError("params";
    "Fxn:__init__" -> "Fxn:torch.typename(params))";
    "Fxn:__init__" -> "Fxn:defaultdict(dict)";
    "Fxn:__init__" -> "Fxn:ValueError("optimizer";
    "Fxn:__init__" -> "Fxn:self.add_param_group(param_group)";
    "Fxn:__setstate__" -> "Fxn:self.__dict__.update(state)";
    "Fxn:__repr__" -> "Fxn:{0}\n'.format(i)";
    "Fxn:__repr__" -> "Fxn:{1}\n'.format(key,";
    "Fxn:pack_group" -> "Fxn:group.items()";
    "Fxn:pack_group" -> "Fxn:[id(p)";
    "Fxn:pack_group" -> "Fxn:[pack_group(g)";
    "Fxn:pack_group" -> "Fxn:{(id(k)";
    "Fxn:pack_group" -> "Fxn:self.state.items()}";
    "Fxn:load_state_dict" -> "Fxn:deepcopy(state_dict)";
    "Fxn:load_state_dict" -> "Fxn:ValueError("loaded";
    "Fxn:load_state_dict" -> "Fxn:ValueError("loaded";
    "Fxn:load_state_dict" -> "Fxn:chain(*(g['params']";
    "Fxn:cast" -> "Fxn:torch.is_tensor(value):";
    "Fxn:cast" -> "Fxn:param.is_floating_point():";
    "Fxn:cast" -> "Fxn:value.type_as(param)";
    "Fxn:cast" -> "Fxn:value.cuda(param.get_device())";
    "Fxn:cast" -> "Fxn:value.cpu()";
    "Fxn:cast" -> "Fxn:cast(param,";
    "Fxn:cast" -> "Fxn:value.items()}";
    "Fxn:cast" -> "Fxn:defaultdict(dict)";
    "Fxn:cast" -> "Fxn:state_dict['state'].items():";
    "Fxn:cast" -> "Fxn:cast(param,";
    "Fxn:update_group" -> "Fxn:update_group(g,";
    "Fxn:update_group" -> "Fxn:self.__setstate__({'state':";
    "Fxn:zero_grad" -> "Fxn:p.grad.detach_()";
    "Fxn:zero_grad" -> "Fxn:p.grad.zero_()";
    "Fxn:add_param_group" -> "Fxn:TypeError("optimizer";
    "Fxn:add_param_group" -> "Fxn:torch.typename(param))";
    "Fxn:add_param_group" -> "Fxn:ValueError("optimizing";
    "Fxn:add_param_group" -> "Fxn:ValueError("can't";
    "Fxn:add_param_group" -> "Fxn:self.defaults.items():";
    "Fxn:add_param_group" -> "Fxn:ValueError("parameter";
    "Fxn:add_param_group" -> "Fxn:param_group.setdefault(name,";
    "Fxn:add_param_group" -> "Fxn:param_set.update(set(group['params']))";
    "Fxn:add_param_group" -> "Fxn:param_set.isdisjoint(set(param_group['params'])):";
    "Fxn:add_param_group" -> "Fxn:ValueError("some";
    "Fxn:add_param_group" -> "Fxn:self.param_groups.append(param_group)";
    "/torch/optim/rmsprop.py" -> "Import:torch";
    "/torch/optim/rmsprop.py" -> "Import:Optimizer";
    "/torch/optim/rmsprop.py" -> "class:RMSprop(Optimizer):";
    "class:RMSprop(Optimizer):" -> "Fxn:__init__";
    "class:RMSprop(Optimizer):" -> "Fxn:__setstate__";
    "class:RMSprop(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:__setstate__" -> "Fxn:self).__setstate__(state)";
    "Fxn:__setstate__" -> "Fxn:group.setdefault('momentum',";
    "Fxn:__setstate__" -> "Fxn:group.setdefault('centered',";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError('RMSprop";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:grad.add(group['weight_decay'],";
    "Fxn:step" -> "Fxn:square_avg.mul_(alpha).addcmul_(1";
    "Fxn:step" -> "Fxn:grad_avg.mul_(alpha).add_(1";
    "Fxn:step" -> "Fxn:square_avg.addcmul(-1,";
    "Fxn:step" -> "Fxn:grad_avg).sqrt().add_(group['eps'])";
    "Fxn:step" -> "Fxn:square_avg.sqrt().add_(group['eps'])";
    "Fxn:step" -> "Fxn:buf.mul_(group['momentum']).addcdiv_(grad,";
    "Fxn:step" -> "Fxn:p.data.add_(-group['lr'],";
    "Fxn:step" -> "Fxn:p.data.addcdiv_(-group['lr'],";
    "/torch/optim/rprop.py" -> "Import:math";
    "/torch/optim/rprop.py" -> "Import:torch";
    "/torch/optim/rprop.py" -> "Import:Optimizer";
    "/torch/optim/rprop.py" -> "class:Rprop(Optimizer):";
    "class:Rprop(Optimizer):" -> "Fxn:__init__";
    "class:Rprop(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:etas=(0.5,";
    "Fxn:__init__" -> "Fxn:step_sizes=(1e-6,";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError('Rprop";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:grad.new().resize_as_(grad).fill_(group['lr'])";
    "Fxn:step" -> "Fxn:grad.mul(state['prev']).sign()";
    "Fxn:step" -> "Fxn:sign[sign.gt(0)]";
    "Fxn:step" -> "Fxn:sign[sign.lt(0)]";
    "Fxn:step" -> "Fxn:sign[sign.eq(0)]";
    "Fxn:step" -> "Fxn:step_size.mul_(sign).clamp_(step_size_min,";
    "Fxn:step" -> "Fxn:grad.clone()";
    "Fxn:step" -> "Fxn:grad[sign.eq(etaminus)]";
    "Fxn:step" -> "Fxn:p.data.addcmul_(-1,";
    "Fxn:step" -> "Fxn:grad.sign(),";
    "Fxn:step" -> "Fxn:state['prev'].copy_(grad)";
    "/torch/optim/sgd.py" -> "Import:torch";
    "/torch/optim/sgd.py" -> "Import:Optimizer,";
    "/torch/optim/sgd.py" -> "class:SGD(Optimizer):";
    "class:SGD(Optimizer):" -> "Fxn:__init__";
    "class:SGD(Optimizer):" -> "Fxn:__setstate__";
    "class:SGD(Optimizer):" -> "Fxn:step";
    "Fxn:__init__" -> "Fxn:ValueError("Nesterov";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:__setstate__" -> "Fxn:self).__setstate__(state)";
    "Fxn:__setstate__" -> "Fxn:group.setdefault('nesterov',";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:d_p.add_(weight_decay,";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:buf.mul_(momentum).add_(d_p)";
    "Fxn:step" -> "Fxn:buf.mul_(momentum).add_(1";
    "Fxn:step" -> "Fxn:d_p.add(momentum,";
    "Fxn:step" -> "Fxn:p.data.add_(-group['lr'],";
    "/torch/optim/sparse_adam.py" -> "Import:math";
    "/torch/optim/sparse_adam.py" -> "Import:torch";
    "/torch/optim/sparse_adam.py" -> "Import:Optimizer";
    "/torch/optim/sparse_adam.py" -> "class:SparseAdam(Optimizer):";
    "class:SparseAdam(Optimizer):" -> "Fxn:__init__";
    "class:SparseAdam(Optimizer):" -> "Fxn:step";
    "class:SparseAdam(Optimizer):" -> "Fxn:make_sparse";
    "Fxn:__init__" -> "Fxn:betas=(0.9,";
    "Fxn:__init__" -> "Fxn:self).__init__(params,";
    "Fxn:step" -> "Fxn:closure()";
    "Fxn:step" -> "Fxn:RuntimeError('SparseAdam";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:torch.zeros_like(p.data)";
    "Fxn:step" -> "Fxn:grad.coalesce()";
    "Fxn:step" -> "Fxn:grad._indices()";
    "Fxn:step" -> "Fxn:grad._values()";
    "Fxn:step" -> "Fxn:grad.size()";
    "Fxn:make_sparse" -> "Fxn:grad_indices.dim()";
    "Fxn:make_sparse" -> "Fxn:values.dim()";
    "Fxn:make_sparse" -> "Fxn:constructor().resize_as_(grad)";
    "Fxn:make_sparse" -> "Fxn:constructor(grad_indices,";
    "Fxn:make_sparse" -> "Fxn:exp_avg._sparse_mask(grad)._values()";
    "Fxn:make_sparse" -> "Fxn:grad_values.sub(old_exp_avg_values).mul_(1";
    "Fxn:make_sparse" -> "Fxn:exp_avg.add_(make_sparse(exp_avg_update_values))";
    "Fxn:make_sparse" -> "Fxn:exp_avg_sq._sparse_mask(grad)._values()";
    "Fxn:make_sparse" -> "Fxn:grad_values.pow(2).sub_(old_exp_avg_sq_values).mul_(1";
    "Fxn:make_sparse" -> "Fxn:exp_avg_sq.add_(make_sparse(exp_avg_sq_update_values))";
    "Fxn:make_sparse" -> "Fxn:exp_avg_update_values.add_(old_exp_avg_values)";
    "Fxn:make_sparse" -> "Fxn:exp_avg_sq_update_values.add_(old_exp_avg_sq_values)";
    "Fxn:make_sparse" -> "Fxn:exp_avg_sq_update_values.sqrt_().add_(group['eps'])";
    "Fxn:make_sparse" -> "Fxn:math.sqrt(bias_correction2)";
    "Fxn:make_sparse" -> "Fxn:p.data.add_(make_sparse(-step_size";
    "Fxn:make_sparse" -> "Fxn:numer.div_(denom)))";
    "/torch/optim/__init__.py" -> "Import:Adadelta";
    "/torch/optim/__init__.py" -> "Import:Adagrad";
    "/torch/optim/__init__.py" -> "Import:Adam";
    "/torch/optim/__init__.py" -> "Import:SparseAdam";
    "/torch/optim/__init__.py" -> "Import:Adamax";
    "/torch/optim/__init__.py" -> "Import:ASGD";
    "/torch/optim/__init__.py" -> "Import:SGD";
    "/torch/optim/__init__.py" -> "Import:Rprop";
    "/torch/optim/__init__.py" -> "Import:RMSprop";
    "/torch/optim/__init__.py" -> "Import:Optimizer";
    "/torch/optim/__init__.py" -> "Import:LBFGS";
    "/torch/optim/__init__.py" -> "Import:lr_scheduler";
    "/torch/testing/__init__.py" -> "Import:torch";
    "/torch/testing/__init__.py" -> "Import:random";
    "/torch/testing/__init__.py" -> "Fxn:make_non_contiguous";
    "/torch/testing/__init__.py" -> "Fxn:get_all_dtypes";
    "/torch/utils/cpp_extension.py" -> "Import:copy";
    "/torch/utils/cpp_extension.py" -> "Import:glob";
    "/torch/utils/cpp_extension.py" -> "Import:imp";
    "/torch/utils/cpp_extension.py" -> "Import:import";
    "/torch/utils/cpp_extension.py" -> "Import:import";
    "/torch/utils/cpp_extension.py" -> "Import:setuptools";
    "/torch/utils/cpp_extension.py" -> "Import:subprocess";
    "/torch/utils/cpp_extension.py" -> "Import:sys";
    "/torch/utils/cpp_extension.py" -> "Import:sysconfig";
    "/torch/utils/cpp_extension.py" -> "Import:tempfile";
    "/torch/utils/cpp_extension.py" -> "Import:warnings";
    "/torch/utils/cpp_extension.py" -> "Import:torch";
    "/torch/utils/cpp_extension.py" -> "Import:build_ext";
    "/torch/utils/cpp_extension.py" -> "Fxn:_find_cuda_home";
    "/torch/utils/cpp_extension.py" -> "Fxn:check_compiler_abi_compatibility";
    "/torch/utils/cpp_extension.py" -> "class:BuildExtension(build_ext):";
    "/torch/utils/cpp_extension.py" -> "Import:setup";
    "/torch/utils/cpp_extension.py" -> "Import:BuildExtension,";
    "/torch/utils/cpp_extension.py" -> "Import:setup";
    "/torch/utils/cpp_extension.py" -> "Import:BuildExtension,";
    "/torch/utils/cpp_extension.py" -> "Import:load";
    "class:BuildExtension(build_ext):" -> "Fxn:build_extensions";
    "class:BuildExtension(build_ext):" -> "Fxn:wrap_compile";
    "class:BuildExtension(build_ext):" -> "Fxn:_check_abi";
    "class:BuildExtension(build_ext):" -> "Fxn:_define_torch_extension_name";
    "class:BuildExtension(build_ext):" -> "Fxn:CppExtension";
    "class:BuildExtension(build_ext):" -> "Fxn:CUDAExtension";
    "class:BuildExtension(build_ext):" -> "Fxn:include_paths";
    "class:BuildExtension(build_ext):" -> "Fxn:load";
    "class:BuildExtension(build_ext):" -> "Fxn:verify_ninja_availability";
    "class:BuildExtension(build_ext):" -> "Fxn:_get_build_directory";
    "class:BuildExtension(build_ext):" -> "Fxn:_build_extension_module";
    "class:BuildExtension(build_ext):" -> "Fxn:_import_module_from_library";
    "class:BuildExtension(build_ext):" -> "Fxn:_write_ninja_file";
    "class:BuildExtension(build_ext):" -> "Fxn:_join_cuda_home";
    "class:BuildExtension(build_ext):" -> "Fxn:_is_cuda_file";
    "Fxn:build_extensions" -> "Fxn:self._check_abi()";
    "Fxn:build_extensions" -> "Fxn:self._define_torch_extension_name(extension)";
    "Fxn:wrap_compile" -> "Fxn:copy.deepcopy(extra_postargs)";
    "Fxn:wrap_compile" -> "Fxn:_is_cuda_file(src):";
    "Fxn:wrap_compile" -> "Fxn:_join_cuda_home('bin',";
    "Fxn:wrap_compile" -> "Fxn:self.compiler.set_executable('compiler_so',";
    "Fxn:wrap_compile" -> "Fxn:cflags.append('-std=c++11')";
    "Fxn:wrap_compile" -> "Fxn:original_compile(obj,";
    "Fxn:wrap_compile" -> "Fxn:self.compiler.set_executable('compiler_so',";
    "Fxn:wrap_compile" -> "Fxn:build_ext.build_extensions(self)";
    "Fxn:_check_abi" -> "Fxn:os.environ.get('CXX',";
    "Fxn:_check_abi" -> "Fxn:check_compiler_abi_compatibility(compiler)";
    "Fxn:_define_torch_extension_name" -> "Fxn:'-DTORCH_EXTENSION_NAME={}'.format(extension.name)";
    "Fxn:_define_torch_extension_name" -> "Fxn:extension.extra_compile_args.values():";
    "Fxn:_define_torch_extension_name" -> "Fxn:args.append(define)";
    "Fxn:_define_torch_extension_name" -> "Fxn:extension.extra_compile_args.append(define)";
    "Fxn:CppExtension" -> "Fxn:setup(";
    "Fxn:CppExtension" -> "Fxn:CppExtension(";
    "Fxn:CppExtension" -> "Fxn:kwargs.get('include_dirs',";
    "Fxn:CppExtension" -> "Fxn:include_paths()";
    "Fxn:CppExtension" -> "Fxn:setuptools.Extension(name,";
    "Fxn:CUDAExtension" -> "Fxn:setup(";
    "Fxn:CUDAExtension" -> "Fxn:CUDAExtension(";
    "Fxn:CUDAExtension" -> "Fxn:kwargs.get('library_dirs',";
    "Fxn:CUDAExtension" -> "Fxn:library_dirs.append(_join_cuda_home('lib64'))";
    "Fxn:CUDAExtension" -> "Fxn:kwargs.get('libraries',";
    "Fxn:CUDAExtension" -> "Fxn:libraries.append('cudart')";
    "Fxn:CUDAExtension" -> "Fxn:kwargs.get('include_dirs',";
    "Fxn:CUDAExtension" -> "Fxn:include_paths(cuda=True)";
    "Fxn:CUDAExtension" -> "Fxn:setuptools.Extension(name,";
    "Fxn:include_paths" -> "Fxn:os.path.abspath(__file__)";
    "Fxn:include_paths" -> "Fxn:os.path.dirname(os.path.dirname(here))";
    "Fxn:include_paths" -> "Fxn:os.path.join(torch_path,";
    "Fxn:include_paths" -> "Fxn:os.path.join(lib_include,";
    "Fxn:include_paths" -> "Fxn:os.path.join(lib_include,";
    "Fxn:include_paths" -> "Fxn:paths.append(_join_cuda_home('include'))";
    "Fxn:load" -> "Fxn:load(";
    "Fxn:load" -> "Fxn:verify_ninja_availability()";
    "Fxn:load" -> "Fxn:_get_build_directory(name,";
    "Fxn:load" -> "Fxn:extra_ldflags.append('-L{}'.format(_join_cuda_home('lib64')))";
    "Fxn:load" -> "Fxn:extra_ldflags.append('-lcudart')";
    "Fxn:load" -> "Fxn:os.path.join(build_directory,";
    "Fxn:load" -> "Fxn:{}...'.format(build_file_path))";
    "Fxn:load" -> "Fxn:_write_ninja_file(";
    "Fxn:load" -> "Fxn:{}...'.format(name))";
    "Fxn:load" -> "Fxn:_build_extension_module(name,";
    "Fxn:load" -> "Fxn:{}...'.format(name))";
    "Fxn:load" -> "Fxn:_import_module_from_library(name,";
    "Fxn:verify_ninja_availability" -> "Fxn:subprocess.check_call('ninja";
    "Fxn:verify_ninja_availability" -> "Fxn:--version'.split(),";
    "Fxn:verify_ninja_availability" -> "Fxn:RuntimeError("Ninja";
    "Fxn:_get_build_directory" -> "Fxn:os.environ.get('TORCH_EXTENSIONS_DIR')";
    "Fxn:_get_build_directory" -> "Fxn:tempfile.gettempdir()";
    "Fxn:_get_build_directory" -> "Fxn:os.path.join(tempfile.gettempdir(),";
    "Fxn:_get_build_directory" -> "Fxn:root...'.format(";
    "Fxn:_get_build_directory" -> "Fxn:os.path.join(root_extensions_directory,";
    "Fxn:_get_build_directory" -> "Fxn:os.path.exists(build_directory):";
    "Fxn:_get_build_directory" -> "Fxn:{}...'.format(build_directory))";
    "Fxn:_get_build_directory" -> "Fxn:os.makedirs(build_directory)";
    "Fxn:_build_extension_module" -> "Fxn:subprocess.check_output(";
    "Fxn:_build_extension_module" -> "Fxn:sys.exc_info()";
    "Fxn:_build_extension_module" -> "Fxn:RuntimeError("Error";
    "Fxn:_build_extension_module" -> "Fxn:{}".format(";
    "Fxn:_build_extension_module" -> "Fxn:error.output.decode()))";
    "Fxn:_import_module_from_library" -> "Fxn:imp.find_module(module_name,";
    "Fxn:_import_module_from_library" -> "Fxn:imp.load_module(module_name,";
    "Fxn:_write_ninja_file" -> "Fxn:config.append('cxx";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format(os.environ.get('CXX',";
    "Fxn:_write_ninja_file" -> "Fxn:config.append('nvcc";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format(_join_cuda_home('bin',";
    "Fxn:_write_ninja_file" -> "Fxn:[os.path.abspath(file)";
    "Fxn:_write_ninja_file" -> "Fxn:[os.path.abspath(file)";
    "Fxn:_write_ninja_file" -> "Fxn:include_paths()";
    "Fxn:_write_ninja_file" -> "Fxn:include_paths(with_cuda)";
    "Fxn:_write_ninja_file" -> "Fxn:sysconfig.get_paths()['include']";
    "Fxn:_write_ninja_file" -> "Fxn:includes.append(sysconfig.get_paths()['include'])";
    "Fxn:_write_ninja_file" -> "Fxn:['-DTORCH_EXTENSION_NAME={}'.format(name)]";
    "Fxn:_write_ninja_file" -> "Fxn:['-I{}'.format(include)";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format('";
    "Fxn:_write_ninja_file" -> "Fxn:'.join(cflags))]";
    "Fxn:_write_ninja_file" -> "Fxn:cuda_flags.append('-std=c++11')";
    "Fxn:_write_ninja_file" -> "Fxn:flags.append('cuda_flags";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format('";
    "Fxn:_write_ninja_file" -> "Fxn:'.join(cuda_flags)))";
    "Fxn:_write_ninja_file" -> "Fxn:ldflags.append('-undefined";
    "Fxn:_write_ninja_file" -> "Fxn:flags.append('ldflags";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format('";
    "Fxn:_write_ninja_file" -> "Fxn:'.join(ldflags)))";
    "Fxn:_write_ninja_file" -> "Fxn:compile_rule.append(";
    "Fxn:_write_ninja_file" -> "Fxn:compile_rule.append('";
    "Fxn:_write_ninja_file" -> "Fxn:compile_rule.append('";
    "Fxn:_write_ninja_file" -> "Fxn:cuda_compile_rule.append(";
    "Fxn:_write_ninja_file" -> "Fxn:link_rule.append('";
    "Fxn:_write_ninja_file" -> "Fxn:os.path.splitext(os.path.basename(source_file))[0]";
    "Fxn:_write_ninja_file" -> "Fxn:_is_cuda_file(source_file):";
    "Fxn:_write_ninja_file" -> "Fxn:'{}.cuda.o'.format(file_name)";
    "Fxn:_write_ninja_file" -> "Fxn:'{}.o'.format(file_name)";
    "Fxn:_write_ninja_file" -> "Fxn:object_files.append(target)";
    "Fxn:_write_ninja_file" -> "Fxn:build.append('build";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format(target,";
    "Fxn:_write_ninja_file" -> "Fxn:'{}.so'.format(name)";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format(library_target,";
    "Fxn:_write_ninja_file" -> "Fxn:'.join(object_files))]";
    "Fxn:_write_ninja_file" -> "Fxn:{}'.format(library_target)]";
    "Fxn:_write_ninja_file" -> "Fxn:blocks.append(cuda_compile_rule)";
    "Fxn:_write_ninja_file" -> "Fxn:'\n'.join(block)";
    "Fxn:_write_ninja_file" -> "Fxn:build_file.write('{}\n\n'.format(lines))";
    "Fxn:_join_cuda_home" -> "Fxn:EnvironmentError('CUDA_HOME";
    "Fxn:_join_cuda_home" -> "Fxn:os.path.join(CUDA_HOME,";
    "Fxn:_is_cuda_file" -> "Fxn:os.path.splitext(path)[1]";
    "/torch/utils/dlpack.py" -> "Import:torch";
    "/torch/utils/dlpack.py" -> "Import:_from_dlpack";
    "/torch/utils/dlpack.py" -> "Import:_to_dlpack";
    "/torch/utils/hooks.py" -> "Import:collections";
    "/torch/utils/hooks.py" -> "Import:weakref";
    "/torch/utils/hooks.py" -> "class:RemovableHandle(object):";
    "class:RemovableHandle(object):" -> "Fxn:__init__";
    "class:RemovableHandle(object):" -> "Fxn:remove";
    "class:RemovableHandle(object):" -> "Fxn:__getstate__";
    "class:RemovableHandle(object):" -> "Fxn:__setstate__";
    "class:RemovableHandle(object):" -> "Fxn:__enter__";
    "class:RemovableHandle(object):" -> "Fxn:__exit__";
    "Fxn:__init__" -> "Fxn:weakref.ref(hooks_dict)";
    "Fxn:remove" -> "Fxn:self.hooks_dict_ref()";
    "Fxn:__setstate__" -> "Fxn:weakref.ref(collections.OrderedDict())";
    "Fxn:__setstate__" -> "Fxn:weakref.ref(state[0])";
    "Fxn:__exit__" -> "Fxn:self.remove()";
    "/torch/utils/model_zoo.py" -> "Import:torch";
    "/torch/utils/model_zoo.py" -> "Import:hashlib";
    "/torch/utils/model_zoo.py" -> "Import:import";
    "/torch/utils/model_zoo.py" -> "Import:import";
    "/torch/utils/model_zoo.py" -> "Import:shutil";
    "/torch/utils/model_zoo.py" -> "Import:sys";
    "/torch/utils/model_zoo.py" -> "Import:tempfile";
    "/torch/utils/model_zoo.py" -> "Import:urlparse";
    "/torch/utils/model_zoo.py" -> "Import:requests.get";
    "/torch/utils/model_zoo.py" -> "Import:urlparse";
    "/torch/utils/model_zoo.py" -> "Import:urlopen";
    "/torch/utils/model_zoo.py" -> "Import:urlopen";
    "/torch/utils/model_zoo.py" -> "Import:urlparse";
    "/torch/utils/model_zoo.py" -> "Import:tqdm";
    "/torch/utils/model_zoo.py" -> "Fxn:load_url";
    "/torch/utils/model_zoo.py" -> "Fxn:_download_url_to_file";
    "/torch/utils/model_zoo.py" -> "class:tqdm(object):";
    "class:tqdm(object):" -> "Fxn:__init__";
    "class:tqdm(object):" -> "Fxn:update";
    "class:tqdm(object):" -> "Fxn:__enter__";
    "class:tqdm(object):" -> "Fxn:__exit__";
    "Fxn:update" -> "Fxn:sys.stderr.write("\r{0:.1f}%".format(100";
    "Fxn:update" -> "Fxn:sys.stderr.flush()";
    "Fxn:__exit__" -> "Fxn:sys.stderr.write('\n')";
    "/torch/utils/backcompat/__init__.py" -> "Import:_set_backcompat_broadcast_warn";
    "/torch/utils/backcompat/__init__.py" -> "Import:_get_backcompat_broadcast_warn";
    "/torch/utils/backcompat/__init__.py" -> "Import:_set_backcompat_keepdim_warn";
    "/torch/utils/backcompat/__init__.py" -> "Import:_get_backcompat_keepdim_warn";
    "/torch/utils/backcompat/__init__.py" -> "class:Warning(object):";
    "class:Warning(object):" -> "Fxn:__init__";
    "class:Warning(object):" -> "Fxn:set_enabled";
    "class:Warning(object):" -> "Fxn:get_enabled";
    "Fxn:set_enabled" -> "Fxn:self.setter(value)";
    "Fxn:get_enabled" -> "Fxn:self.getter()";
    "Fxn:get_enabled" -> "Fxn:Warning(_set_backcompat_broadcast_warn,";
    "Fxn:get_enabled" -> "Fxn:Warning(_set_backcompat_keepdim_warn,";
    "/torch/utils/data/dataloader.py" -> "Import:random";
    "/torch/utils/data/dataloader.py" -> "Import:torch";
    "/torch/utils/data/dataloader.py" -> "Import:torch.multiprocessing";
    "/torch/utils/data/dataloader.py" -> "Import:_set_worker_signal_handlers,";
    "/torch/utils/data/dataloader.py" -> "Import:SequentialSampler,";
    "/torch/utils/data/dataloader.py" -> "Import:signal";
    "/torch/utils/data/dataloader.py" -> "Import:functools";
    "/torch/utils/data/dataloader.py" -> "Import:collections";
    "/torch/utils/data/dataloader.py" -> "Import:import";
    "/torch/utils/data/dataloader.py" -> "Import:sys";
    "/torch/utils/data/dataloader.py" -> "Import:threading";
    "/torch/utils/data/dataloader.py" -> "Import:traceback";
    "/torch/utils/data/dataloader.py" -> "Import:string_classes,";
    "/torch/utils/data/dataloader.py" -> "Import:Queue";
    "/torch/utils/data/dataloader.py" -> "Import:queue";
    "/torch/utils/data/dataloader.py" -> "class:ExceptionWrapper(object):";
    "/torch/utils/data/dataloader.py" -> "class:_DataLoaderIter(object):";
    "/torch/utils/data/dataloader.py" -> "class:DataLoader(object):";
    "class:ExceptionWrapper(object):" -> "Fxn:__init__";
    "class:ExceptionWrapper(object):" -> "Fxn:_worker_loop";
    "class:ExceptionWrapper(object):" -> "Fxn:_worker_manager_loop";
    "class:ExceptionWrapper(object):" -> "Fxn:default_collate";
    "class:ExceptionWrapper(object):" -> "Fxn:pin_memory_batch";
    "class:ExceptionWrapper(object):" -> "Fxn:_set_SIGCHLD_handler";
    "class:ExceptionWrapper(object):" -> "Fxn:handler";
    "Fxn:__init__" -> "Fxn:"".join(traceback.format_exception(*exc_info))";
    "Fxn:_worker_loop" -> "Fxn:_set_worker_signal_handlers()";
    "Fxn:_worker_loop" -> "Fxn:torch.set_num_threads(1)";
    "Fxn:_worker_loop" -> "Fxn:random.seed(seed)";
    "Fxn:_worker_loop" -> "Fxn:torch.manual_seed(seed)";
    "Fxn:_worker_loop" -> "Fxn:init_fn(worker_id)";
    "Fxn:_worker_loop" -> "Fxn:index_queue.get()";
    "Fxn:_worker_loop" -> "Fxn:collate_fn([dataset[i]";
    "Fxn:_worker_loop" -> "Fxn:data_queue.put((idx,";
    "Fxn:_worker_loop" -> "Fxn:ExceptionWrapper(sys.exc_info())))";
    "Fxn:_worker_loop" -> "Fxn:data_queue.put((idx,";
    "Fxn:_worker_manager_loop" -> "Fxn:torch.cuda.set_device(device_id)";
    "Fxn:_worker_manager_loop" -> "Fxn:in_queue.get()";
    "Fxn:_worker_manager_loop" -> "Fxn:done_event.is_set():";
    "Fxn:_worker_manager_loop" -> "Fxn:out_queue.put(r)";
    "Fxn:_worker_manager_loop" -> "Fxn:pin_memory_batch(batch)";
    "Fxn:_worker_manager_loop" -> "Fxn:out_queue.put((idx,";
    "Fxn:_worker_manager_loop" -> "Fxn:ExceptionWrapper(sys.exc_info())))";
    "Fxn:_worker_manager_loop" -> "Fxn:out_queue.put((idx,";
    "Fxn:default_collate" -> "Fxn:torch.is_tensor(batch[0]):";
    "Fxn:default_collate" -> "Fxn:batch[0].storage()._new_shared(numel)";
    "Fxn:default_collate" -> "Fxn:batch[0].new(storage)";
    "Fxn:default_collate" -> "Fxn:torch.stack(batch,";
    "Fxn:default_collate" -> "Fxn:re.search('[SaUO]',";
    "Fxn:default_collate" -> "Fxn:TypeError(error_msg.format(elem.dtype))";
    "Fxn:default_collate" -> "Fxn:torch.stack([torch.from_numpy(b)";
    "Fxn:default_collate" -> "Fxn:elem.dtype.name.startswith('float')";
    "Fxn:default_collate" -> "Fxn:numpy_type_map[elem.dtype.name](list(map(py_type,";
    "Fxn:default_collate" -> "Fxn:torch.LongTensor(batch)";
    "Fxn:default_collate" -> "Fxn:torch.DoubleTensor(batch)";
    "Fxn:default_collate" -> "Fxn:default_collate([d[key]";
    "Fxn:default_collate" -> "Fxn:[default_collate(samples)";
    "Fxn:default_collate" -> "Fxn:TypeError((error_msg.format(type(batch[0]))))";
    "Fxn:pin_memory_batch" -> "Fxn:torch.is_tensor(batch):";
    "Fxn:pin_memory_batch" -> "Fxn:batch.pin_memory()";
    "Fxn:pin_memory_batch" -> "Fxn:pin_memory_batch(sample)";
    "Fxn:pin_memory_batch" -> "Fxn:batch.items()}";
    "Fxn:pin_memory_batch" -> "Fxn:[pin_memory_batch(sample)";
    "Fxn:_set_SIGCHLD_handler" -> "Fxn:signal.getsignal(signal.SIGCHLD)";
    "Fxn:handler" -> "Fxn:_error_if_any_worker_fails()";
    "Fxn:handler" -> "Fxn:previous_handler(signum,";
    "Fxn:handler" -> "Fxn:signal.signal(signal.SIGCHLD,";
    "class:_DataLoaderIter(object):" -> "Fxn:__init__";
    "class:_DataLoaderIter(object):" -> "Fxn:__len__";
    "class:_DataLoaderIter(object):" -> "Fxn:_get_batch";
    "class:_DataLoaderIter(object):" -> "Fxn:__next__";
    "class:_DataLoaderIter(object):" -> "Fxn:__iter__";
    "class:_DataLoaderIter(object):" -> "Fxn:_put_indices";
    "class:_DataLoaderIter(object):" -> "Fxn:_process_next_batch";
    "class:_DataLoaderIter(object):" -> "Fxn:__getstate__";
    "class:_DataLoaderIter(object):" -> "Fxn:_shutdown_workers";
    "class:_DataLoaderIter(object):" -> "Fxn:__del__";
    "Fxn:__init__" -> "Fxn:torch.cuda.is_available()";
    "Fxn:__init__" -> "Fxn:threading.Event()";
    "Fxn:__init__" -> "Fxn:multiprocessing.SimpleQueue()";
    "Fxn:__init__" -> "Fxn:multiprocessing.SimpleQueue()";
    "Fxn:__init__" -> "Fxn:torch.LongTensor(1).random_()[0]";
    "Fxn:__init__" -> "Fxn:multiprocessing.Process(";
    "Fxn:__init__" -> "Fxn:args=(self.dataset,";
    "Fxn:__init__" -> "Fxn:queue.Queue()";
    "Fxn:__init__" -> "Fxn:torch.cuda.current_device()";
    "Fxn:__init__" -> "Fxn:threading.Thread(";
    "Fxn:__init__" -> "Fxn:args=(self.worker_result_queue,";
    "Fxn:__init__" -> "Fxn:self.worker_manager_thread.start()";
    "Fxn:__init__" -> "Fxn:w.start()";
    "Fxn:__init__" -> "Fxn:_update_worker_pids(id(self),";
    "Fxn:__init__" -> "Fxn:_set_SIGCHLD_handler()";
    "Fxn:__init__" -> "Fxn:self._put_indices()";
    "Fxn:_get_batch" -> "Fxn:self.data_queue.get(timeout=self.timeout)";
    "Fxn:_get_batch" -> "Fxn:RuntimeError('DataLoader";
    "Fxn:_get_batch" -> "Fxn:seconds'.format(self.timeout))";
    "Fxn:_get_batch" -> "Fxn:self.data_queue.get()";
    "Fxn:__next__" -> "Fxn:self.collate_fn([self.dataset[i]";
    "Fxn:__next__" -> "Fxn:pin_memory_batch(batch)";
    "Fxn:__next__" -> "Fxn:self.reorder_dict.pop(self.rcvd_idx)";
    "Fxn:__next__" -> "Fxn:self._process_next_batch(batch)";
    "Fxn:__next__" -> "Fxn:self._shutdown_workers()";
    "Fxn:__next__" -> "Fxn:self._get_batch()";
    "Fxn:__next__" -> "Fxn:self._process_next_batch(batch)";
    "Fxn:_put_indices" -> "Fxn:self.index_queue.put((self.send_idx,";
    "Fxn:_process_next_batch" -> "Fxn:self._put_indices()";
    "Fxn:_process_next_batch" -> "Fxn:batch.exc_type(batch.exc_msg)";
    "Fxn:__getstate__" -> "Fxn:NotImplementedError("_DataLoaderIter";
    "Fxn:_shutdown_workers" -> "Fxn:self.done_event.set()";
    "Fxn:_shutdown_workers" -> "Fxn:self.data_queue.empty():";
    "Fxn:_shutdown_workers" -> "Fxn:self.data_queue.get()";
    "Fxn:_shutdown_workers" -> "Fxn:self.index_queue.put(None)";
    "Fxn:_shutdown_workers" -> "Fxn:self.worker_result_queue.put(None)";
    "Fxn:_shutdown_workers" -> "Fxn:_remove_worker_pids(id(self))";
    "Fxn:__del__" -> "Fxn:self._shutdown_workers()";
    "class:DataLoader(object):" -> "Fxn:__init__";
    "class:DataLoader(object):" -> "Fxn:__iter__";
    "class:DataLoader(object):" -> "Fxn:__len__";
    "Fxn:__init__" -> "Fxn:ValueError('timeout";
    "Fxn:__init__" -> "Fxn:ValueError('batch_sampler";
    "Fxn:__init__" -> "Fxn:ValueError('sampler";
    "Fxn:__init__" -> "Fxn:ValueError('num_workers";
    "Fxn:__init__" -> "Fxn:ValueError('num_workers";
    "Fxn:__init__" -> "Fxn:RandomSampler(dataset)";
    "Fxn:__init__" -> "Fxn:SequentialSampler(dataset)";
    "Fxn:__init__" -> "Fxn:BatchSampler(sampler,";
    "Fxn:__iter__" -> "Fxn:_DataLoaderIter(self)";
    "/torch/utils/data/dataset.py" -> "Import:bisect";
    "/torch/utils/data/dataset.py" -> "Import:warnings";
    "/torch/utils/data/dataset.py" -> "Import:_accumulate";
    "/torch/utils/data/dataset.py" -> "Import:randperm";
    "/torch/utils/data/dataset.py" -> "class:Dataset(object):";
    "/torch/utils/data/dataset.py" -> "class:TensorDataset(Dataset):";
    "/torch/utils/data/dataset.py" -> "class:ConcatDataset(Dataset):";
    "/torch/utils/data/dataset.py" -> "class:Subset(Dataset):";
    "class:Dataset(object):" -> "Fxn:__getitem__";
    "class:Dataset(object):" -> "Fxn:__len__";
    "class:Dataset(object):" -> "Fxn:__add__";
    "Fxn:__add__" -> "Fxn:ConcatDataset([self,";
    "class:TensorDataset(Dataset):" -> "Fxn:__init__";
    "class:TensorDataset(Dataset):" -> "Fxn:__getitem__";
    "class:TensorDataset(Dataset):" -> "Fxn:__len__";
    "Fxn:__init__" -> "Fxn:data_tensor.size(0)";
    "Fxn:__init__" -> "Fxn:target_tensor.size(0)";
    "Fxn:__len__" -> "Fxn:self.data_tensor.size(0)";
    "class:ConcatDataset(Dataset):" -> "Fxn:cumsum";
    "class:ConcatDataset(Dataset):" -> "Fxn:__init__";
    "class:ConcatDataset(Dataset):" -> "Fxn:__len__";
    "class:ConcatDataset(Dataset):" -> "Fxn:__getitem__";
    "class:ConcatDataset(Dataset):" -> "Fxn:cummulative_sizes";
    "Fxn:cumsum" -> "Fxn:r.append(l";
    "Fxn:__init__" -> "Fxn:self).__init__()";
    "Fxn:__init__" -> "Fxn:self.cumsum(self.datasets)";
    "Fxn:__getitem__" -> "Fxn:bisect.bisect_right(self.cumulative_sizes,";
    "Fxn:cummulative_sizes" -> "Fxn:warnings.warn("cummulative_sizes";
    "class:Subset(Dataset):" -> "Fxn:__init__";
    "class:Subset(Dataset):" -> "Fxn:__getitem__";
    "class:Subset(Dataset):" -> "Fxn:__len__";
    "class:Subset(Dataset):" -> "Fxn:random_split";
    "Fxn:random_split" -> "Fxn:ValueError("Sum";
    "Fxn:random_split" -> "Fxn:randperm(sum(lengths))";
    "Fxn:random_split" -> "Fxn:[Subset(dataset,";
    "/torch/utils/data/distributed.py" -> "Import:math";
    "/torch/utils/data/distributed.py" -> "Import:torch";
    "/torch/utils/data/distributed.py" -> "Import:Sampler";
    "/torch/utils/data/distributed.py" -> "Import:get_world_size,";
    "/torch/utils/data/distributed.py" -> "class:DistributedSampler(Sampler):";
    "class:DistributedSampler(Sampler):" -> "Fxn:__init__";
    "class:DistributedSampler(Sampler):" -> "Fxn:__iter__";
    "class:DistributedSampler(Sampler):" -> "Fxn:__len__";
    "class:DistributedSampler(Sampler):" -> "Fxn:set_epoch";
    "Fxn:__init__" -> "Fxn:get_world_size()";
    "Fxn:__init__" -> "Fxn:get_rank()";
    "Fxn:__iter__" -> "Fxn:torch.Generator()";
    "Fxn:__iter__" -> "Fxn:g.manual_seed(self.epoch)";
    "Fxn:__iter__" -> "Fxn:indices[:(self.total_size";
    "/torch/utils/data/sampler.py" -> "Import:torch";
    "/torch/utils/data/sampler.py" -> "class:Sampler(object):";
    "/torch/utils/data/sampler.py" -> "class:SequentialSampler(Sampler):";
    "/torch/utils/data/sampler.py" -> "class:RandomSampler(Sampler):";
    "/torch/utils/data/sampler.py" -> "class:SubsetRandomSampler(Sampler):";
    "/torch/utils/data/sampler.py" -> "class:WeightedRandomSampler(Sampler):";
    "/torch/utils/data/sampler.py" -> "class:BatchSampler(object):";
    "class:Sampler(object):" -> "Fxn:__init__";
    "class:Sampler(object):" -> "Fxn:__iter__";
    "class:Sampler(object):" -> "Fxn:__len__";
    "class:SequentialSampler(Sampler):" -> "Fxn:__init__";
    "class:SequentialSampler(Sampler):" -> "Fxn:__iter__";
    "class:SequentialSampler(Sampler):" -> "Fxn:__len__";
    "class:RandomSampler(Sampler):" -> "Fxn:__init__";
    "class:RandomSampler(Sampler):" -> "Fxn:__iter__";
    "class:RandomSampler(Sampler):" -> "Fxn:__len__";
    "class:SubsetRandomSampler(Sampler):" -> "Fxn:__init__";
    "class:SubsetRandomSampler(Sampler):" -> "Fxn:__iter__";
    "class:SubsetRandomSampler(Sampler):" -> "Fxn:__len__";
    "Fxn:__iter__" -> "Fxn:torch.randperm(len(self.indices)))";
    "class:WeightedRandomSampler(Sampler):" -> "Fxn:__init__";
    "class:WeightedRandomSampler(Sampler):" -> "Fxn:__iter__";
    "class:WeightedRandomSampler(Sampler):" -> "Fxn:__len__";
    "Fxn:__init__" -> "Fxn:torch.DoubleTensor(weights)";
    "class:BatchSampler(object):" -> "Fxn:__init__";
    "class:BatchSampler(object):" -> "Fxn:__iter__";
    "class:BatchSampler(object):" -> "Fxn:__len__";
    "Fxn:__iter__" -> "Fxn:batch.append(int(idx))";
    "/torch/utils/data/__init__.py" -> "Import:Dataset,";
    "/torch/utils/data/__init__.py" -> "Import:DataLoader";
    "/torch/utils/ffi/__init__.py" -> "Import:import";
    "/torch/utils/ffi/__init__.py" -> "Import:glob";
    "/torch/utils/ffi/__init__.py" -> "Import:tempfile";
    "/torch/utils/ffi/__init__.py" -> "Import:shutil";
    "/torch/utils/ffi/__init__.py" -> "Import:wraps,";
    "/torch/utils/ffi/__init__.py" -> "Import:Template";
    "/torch/utils/ffi/__init__.py" -> "Import:torch";
    "/torch/utils/ffi/__init__.py" -> "Import:torch.cuda";
    "/torch/utils/ffi/__init__.py" -> "Import:Variable";
    "/torch/utils/ffi/__init__.py" -> "Import:_accumulate";
    "/torch/utils/ffi/__init__.py" -> "Import:cffi";
    "/torch/utils/ffi/__init__.py" -> "Fxn:_generate_typedefs";
    "/torch/utils/ffi/__init__.py" -> "Import:_wrap_function";
    "/torch/utils/ffi/__init__.py" -> "Import:lib";
    "/torch/utils/ffi/__init__.py" -> "Fxn:_import_symbols";
    "/torch/utils/ffi/__init__.py" -> "Fxn:_setup_wrapper";
    "/torch/utils/ffi/__init__.py" -> "Import:torch.cuda";
    "/torch/utils/ffi/__init__.py" -> "Fxn:_create_module_dir";
    "/torch/utils/ffi/__init__.py" -> "Fxn:_build_extension";
    "/torch/utils/ffi/__init__.py" -> "Fxn:_make_python_wrapper";
    "/torch/utils/ffi/__init__.py" -> "Fxn:create_extension";
    "/torch/utils/ffi/__init__.py" -> "Fxn:build";
    "/torch/utils/ffi/__init__.py" -> "Fxn:_wrap_function";
    "/torch/utils/ffi/__init__.py" -> "Fxn:safe_call";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:sys";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:struct";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:array";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:namedtuple";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:wraps";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:torch";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:torch.legacy.nn";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:torch.cuda";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:type2backend";
    "/torch/utils/serialization/read_lua_file.py" -> "Import:_import_dotted_name";
    "/torch/utils/serialization/read_lua_file.py" -> "class:hashable_uniq_dict(dict):";
    "/torch/utils/serialization/read_lua_file.py" -> "class:TorchObject(object):";
    "/torch/utils/serialization/read_lua_file.py" -> "class:T7ReaderException(Exception):";
    "class:hashable_uniq_dict(dict):" -> "Fxn:__hash__";
    "class:hashable_uniq_dict(dict):" -> "Fxn:__getattr__";
    "class:hashable_uniq_dict(dict):" -> "Fxn:__eq__";
    "Fxn:__getattr__" -> "Fxn:self.get(key)";
    "class:TorchObject(object):" -> "Fxn:__init__";
    "class:TorchObject(object):" -> "Fxn:__getattr__";
    "class:TorchObject(object):" -> "Fxn:__getitem__";
    "class:TorchObject(object):" -> "Fxn:torch_typename";
    "class:TorchObject(object):" -> "Fxn:__repr__";
    "class:TorchObject(object):" -> "Fxn:__str__";
    "class:TorchObject(object):" -> "Fxn:__dir__";
    "class:TorchObject(object):" -> "Fxn:get_python_class";
    "class:TorchObject(object):" -> "Fxn:make_tensor_reader";
    "class:TorchObject(object):" -> "Fxn:read_tensor";
    "class:TorchObject(object):" -> "Fxn:make_storage_reader";
    "class:TorchObject(object):" -> "Fxn:read_storage";
    "class:TorchObject(object):" -> "Fxn:register_torch_class";
    "class:TorchObject(object):" -> "Fxn:tds_Vec_reader";
    "class:TorchObject(object):" -> "Fxn:tds_Hash_reader";
    "class:TorchObject(object):" -> "Fxn:_load_backend";
    "class:TorchObject(object):" -> "Fxn:updateOutput_patch";
    "class:TorchObject(object):" -> "Fxn:nn_reader";
    "class:TorchObject(object):" -> "Fxn:read_nn_class";
    "class:TorchObject(object):" -> "Fxn:custom_reader";
    "class:TorchObject(object):" -> "Fxn:reader_factory";
    "class:TorchObject(object):" -> "Fxn:wrapper";
    "class:TorchObject(object):" -> "Fxn:BatchNorm_reader";
    "class:TorchObject(object):" -> "Fxn:Transpose_reader";
    "class:TorchObject(object):" -> "Fxn:SpatialDivisiveNormalization_reader";
    "class:TorchObject(object):" -> "Fxn:SpatialContrastiveNormalization_reader";
    "class:TorchObject(object):" -> "Fxn:GradientReversal_reader";
    "class:TorchObject(object):" -> "Fxn:VolumetricAveragePooling_reader";
    "class:TorchObject(object):" -> "Fxn:registry_addon";
    "class:TorchObject(object):" -> "Fxn:wrapper_factory";
    "class:TorchObject(object):" -> "Fxn:wrapper";
    "class:TorchObject(object):" -> "Fxn:attr_map";
    "class:TorchObject(object):" -> "Fxn:ensure_attr";
    "class:TorchObject(object):" -> "Fxn:make_none_attr";
    "class:TorchObject(object):" -> "Fxn:decrement";
    "class:TorchObject(object):" -> "Fxn:decrement_positive";
    "class:TorchObject(object):" -> "Fxn:storage_to_size";
    "class:TorchObject(object):" -> "Fxn:ensure_type";
    "Fxn:__getattr__" -> "Fxn:self._obj.get(k)";
    "Fxn:__getitem__" -> "Fxn:self._obj.get(k)";
    "Fxn:__repr__" -> "Fxn:"TorchObject(%s,";
    "Fxn:__dir__" -> "Fxn:keys.append('torch_typename')";
    "Fxn:get_python_class" -> "Fxn:typename.rpartition('.')";
    "Fxn:get_python_class" -> "Fxn:cls_name.startswith('Cuda'):";
    "Fxn:get_python_class" -> "Fxn:_import_dotted_name(module";
    "Fxn:make_tensor_reader" -> "Fxn:get_python_class(typename)";
    "Fxn:read_tensor" -> "Fxn:reader.read_int()";
    "Fxn:read_tensor" -> "Fxn:torch.LongStorage(reader.read_long_array(ndim))";
    "Fxn:read_tensor" -> "Fxn:torch.LongStorage(reader.read_long_array(ndim))";
    "Fxn:read_tensor" -> "Fxn:reader.read_long()";
    "Fxn:read_tensor" -> "Fxn:reader.read()";
    "Fxn:read_tensor" -> "Fxn:python_class()";
    "Fxn:read_tensor" -> "Fxn:python_class().set_(storage,";
    "Fxn:read_tensor" -> "Fxn:torch.Size(size),";
    "Fxn:make_storage_reader" -> "Fxn:get_python_class(typename)";
    "Fxn:make_storage_reader" -> "Fxn:python_class().element_size()";
    "Fxn:read_storage" -> "Fxn:reader.read_long()";
    "Fxn:read_storage" -> "Fxn:python_class.from_buffer(reader.f.read(size),";
    "Fxn:register_torch_class" -> "Fxn:reader_factory(cls_name)";
    "Fxn:register_torch_class" -> "Fxn:register_torch_class('Storage',";
    "Fxn:register_torch_class" -> "Fxn:register_torch_class('Tensor',";
    "Fxn:tds_Vec_reader" -> "Fxn:reader.read_long()";
    "Fxn:tds_Vec_reader" -> "Fxn:[reader.read()";
    "Fxn:tds_Hash_reader" -> "Fxn:reader.read_long()";
    "Fxn:tds_Hash_reader" -> "Fxn:reader.read()";
    "Fxn:tds_Hash_reader" -> "Fxn:reader.read()";
    "Fxn:_load_backend" -> "Fxn:torch.is_tensor(attr):";
    "Fxn:_load_backend" -> "Fxn:type2backend[attr.type()]";
    "Fxn:updateOutput_patch" -> "Fxn:torch.is_tensor(input):";
    "Fxn:updateOutput_patch" -> "Fxn:type2backend[input.type()]";
    "Fxn:updateOutput_patch" -> "Fxn:obj.updateOutput(*args)";
    "Fxn:read_nn_class" -> "Fxn:cls.__new__(cls)";
    "Fxn:read_nn_class" -> "Fxn:reader.read()";
    "Fxn:read_nn_class" -> "Fxn:obj.__dict__.update(attributes)";
    "Fxn:read_nn_class" -> "Fxn:_load_backend(obj)";
    "Fxn:read_nn_class" -> "Fxn:reader_registry.update({('nn.'";
    "Fxn:read_nn_class" -> "Fxn:nn_reader(module)";
    "Fxn:read_nn_class" -> "Fxn:nn.__dict__.items()";
    "Fxn:read_nn_class" -> "Fxn:name[0].upper()";
    "Fxn:reader_factory" -> "Fxn:nn_reader(cls)";
    "Fxn:wrapper" -> "Fxn:base(reader,";
    "Fxn:wrapper" -> "Fxn:fn(reader,";
    "Fxn:BatchNorm_reader" -> "Fxn:obj.running_var.pow(-2).add(-obj.eps)";
    "Fxn:BatchNorm_reader" -> "Fxn:custom_reader(getattr(nn,";
    "Fxn:BatchNorm_reader" -> "Fxn:name))(BatchNorm_reader)";
    "Fxn:BatchNorm_reader" -> "Fxn:@custom_reader(nn.Transpose)";
    "Fxn:Transpose_reader" -> "Fxn:@custom_reader(nn.SpatialDivisiveNormalization)";
    "Fxn:SpatialDivisiveNormalization_reader" -> "Fxn:@custom_reader(nn.SpatialContrastiveNormalization)";
    "Fxn:SpatialContrastiveNormalization_reader" -> "Fxn:RuntimeError("loading";
    "Fxn:SpatialContrastiveNormalization_reader" -> "Fxn:@custom_reader(nn.GradientReversal)";
    "Fxn:GradientReversal_reader" -> "Fxn:@custom_reader(nn.VolumetricAveragePooling)";
    "Fxn:wrapper" -> "Fxn:build_fn(reader,";
    "Fxn:wrapper" -> "Fxn:fn(obj,";
    "Fxn:attr_map" -> "Fxn:attribute_map.items():";
    "Fxn:storage_to_size" -> "Fxn:torch.Size(value))";
    "Fxn:ensure_type" -> "Fxn:type_map.items():";
    "Fxn:ensure_type" -> "Fxn:converter)())";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('Linear',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('CAddTable',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('SpatialFractionalMaxPooling',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('BatchNormalization',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('SpatialBatchNormalization',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('VolumetricBatchNormalization',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('LookupTable',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('MixtureTable',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('WeightedEuclidean',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('VolumetricMaxPooling',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('BCECriterion',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('SpatialClassNLLCriterion',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('ClassNLLCriterion',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('ParallelCriterion',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('MultiMarginCriterion',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('SpatialConvolution',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('SpatialCrossMapLRN',";
    "Fxn:ensure_type" -> "Fxn:ensure_attr('Dropout',";
    "Fxn:ensure_type" -> "Fxn:make_none_attr('SpatialConvolution',";
    "Fxn:ensure_type" -> "Fxn:attr_map('ReLU',";
    "Fxn:ensure_type" -> "Fxn:attr_map('Threshold',";
    "Fxn:ensure_type" -> "Fxn:attr_map('Unsqueeze',";
    "Fxn:ensure_type" -> "Fxn:attr_map('HardShrink',";
    "Fxn:ensure_type" -> "Fxn:attr_map('SoftShrink',";
    "Fxn:ensure_type" -> "Fxn:attr_map('GradientReversal',";
    "Fxn:ensure_type" -> "Fxn:attr_map('SpatialAdaptiveMaxPooling',";
    "Fxn:ensure_type" -> "Fxn:decrement('Index',";
    "Fxn:ensure_type" -> "Fxn:decrement('SelectTable',";
    "Fxn:ensure_type" -> "Fxn:decrement('SplitTable',";
    "Fxn:ensure_type" -> "Fxn:decrement_positive('JoinTable',";
    "Fxn:ensure_type" -> "Fxn:decrement('Parallel',";
    "Fxn:ensure_type" -> "Fxn:decrement('Concat',";
    "Fxn:ensure_type" -> "Fxn:decrement('DepthConcat',";
    "Fxn:ensure_type" -> "Fxn:decrement('Squeeze',";
    "Fxn:ensure_type" -> "Fxn:decrement('Unsqueeze',";
    "Fxn:ensure_type" -> "Fxn:decrement('Replicate',";
    "Fxn:ensure_type" -> "Fxn:decrement('MixtureTable',";
    "Fxn:ensure_type" -> "Fxn:decrement('Narrow',";
    "Fxn:ensure_type" -> "Fxn:decrement('NarrowTable',";
    "Fxn:ensure_type" -> "Fxn:decrement('LookupTable',";
    "Fxn:ensure_type" -> "Fxn:decrement('SpatialConvolutionMap',";
    "Fxn:ensure_type" -> "Fxn:decrement('SpatialFullConvolutionMap',";
    "Fxn:ensure_type" -> "Fxn:decrement('Select',";
    "Fxn:ensure_type" -> "Fxn:decrement('Padding',";
    "Fxn:ensure_type" -> "Fxn:decrement('PartialLinear',";
    "Fxn:ensure_type" -> "Fxn:decrement_positive('Sum',";
    "Fxn:ensure_type" -> "Fxn:decrement_positive('Max',";
    "Fxn:ensure_type" -> "Fxn:decrement_positive('Min',";
    "Fxn:ensure_type" -> "Fxn:decrement_positive('Mean',";
    "Fxn:ensure_type" -> "Fxn:storage_to_size('View',";
    "Fxn:ensure_type" -> "Fxn:storage_to_size('DepthConcat',";
    "Fxn:ensure_type" -> "Fxn:storage_to_size('MixtureTable',";
    "Fxn:ensure_type" -> "Fxn:ensure_type('PartialLinear',";
    "class:T7ReaderException(Exception):" -> "Fxn:__init__";
    "class:T7ReaderException(Exception):" -> "Fxn:_read";
    "class:T7ReaderException(Exception):" -> "Fxn:read_boolean";
    "class:T7ReaderException(Exception):" -> "Fxn:read_int";
    "class:T7ReaderException(Exception):" -> "Fxn:read_long";
    "class:T7ReaderException(Exception):" -> "Fxn:read_long_array";
    "class:T7ReaderException(Exception):" -> "Fxn:read_float";
    "class:T7ReaderException(Exception):" -> "Fxn:read_double";
    "class:T7ReaderException(Exception):" -> "Fxn:read_string";
    "class:T7ReaderException(Exception):" -> "Fxn:read_number";
    "class:T7ReaderException(Exception):" -> "Fxn:memoize_index";
    "class:T7ReaderException(Exception):" -> "Fxn:wrapper";
    "class:T7ReaderException(Exception):" -> "Fxn:read_function";
    "class:T7ReaderException(Exception):" -> "Fxn:read_object";
    "class:T7ReaderException(Exception):" -> "Fxn:_can_be_list";
    "class:T7ReaderException(Exception):" -> "Fxn:is_natural";
    "class:T7ReaderException(Exception):" -> "Fxn:read_table";
    "class:T7ReaderException(Exception):" -> "Fxn:read";
    "class:T7ReaderException(Exception):" -> "Fxn:load_lua";
    "Fxn:_read" -> "Fxn:struct.calcsize(fmt)";
    "Fxn:_read" -> "Fxn:struct.unpack(fmt,";
    "Fxn:_read" -> "Fxn:self.f.read(sz))";
    "Fxn:read_boolean" -> "Fxn:self.read_int()";
    "Fxn:read_int" -> "Fxn:self._read('i')";
    "Fxn:read_long" -> "Fxn:self._read('l')";
    "Fxn:read_long" -> "Fxn:self._read('q')";
    "Fxn:read_long" -> "Fxn:self._read('i')";
    "Fxn:read_long_array" -> "Fxn:lst.append(self.read_long())";
    "Fxn:read_long_array" -> "Fxn:array(LONG_SIZE_ARR)";
    "Fxn:read_long_array" -> "Fxn:arr.fromfile(self.f,";
    "Fxn:read_long_array" -> "Fxn:arr.tolist()";
    "Fxn:read_float" -> "Fxn:self._read('f')";
    "Fxn:read_double" -> "Fxn:self._read('d')";
    "Fxn:read_string" -> "Fxn:self.read_int()";
    "Fxn:read_string" -> "Fxn:self.f.read(size)";
    "Fxn:read_number" -> "Fxn:self.read_double()";
    "Fxn:read_number" -> "Fxn:x.is_integer():";
    "Fxn:memoize_index" -> "Fxn:@wraps(fn)";
    "Fxn:wrapper" -> "Fxn:self.read_int()";
    "Fxn:wrapper" -> "Fxn:fn(self,";
    "Fxn:read_function" -> "Fxn:self.read_int()";
    "Fxn:read_function" -> "Fxn:self.f.read(size)";
    "Fxn:read_function" -> "Fxn:self.read()";
    "Fxn:read_function" -> "Fxn:LuaFunction(size,";
    "Fxn:read_object" -> "Fxn:self.read_string()";
    "Fxn:read_object" -> "Fxn:version_str.startswith('V";
    "Fxn:read_object" -> "Fxn:self.read_string()";
    "Fxn:read_object" -> "Fxn:reader_registry[cls_name](self,";
    "Fxn:read_object" -> "Fxn:TorchObject(cls_name,";
    "Fxn:read_object" -> "Fxn:self.read())";
    "Fxn:read_object" -> "Fxn:T7ReaderException(("don't";
    "Fxn:is_natural" -> "Fxn:key.is_integer())";
    "Fxn:is_natural" -> "Fxn:table.keys()))";
    "Fxn:read_table" -> "Fxn:self.read_int()";
    "Fxn:read_table" -> "Fxn:hashable_uniq_dict()";
    "Fxn:read_table" -> "Fxn:self.read()";
    "Fxn:read_table" -> "Fxn:self.read()";
    "Fxn:read_table" -> "Fxn:self._can_be_list(table):";
    "Fxn:read" -> "Fxn:self.read_int()";
    "Fxn:read" -> "Fxn:self.read_number()";
    "Fxn:read" -> "Fxn:self.read_boolean()";
    "Fxn:read" -> "Fxn:self.read_string()";
    "Fxn:read" -> "Fxn:self.read_function()";
    "Fxn:read" -> "Fxn:self.read_object()";
    "Fxn:read" -> "Fxn:self.read_table()";
    "Fxn:read" -> "Fxn:T7ReaderException("unknown";
    "Fxn:read" -> "Fxn:"corrupted.".format(typeidx))";
    "Fxn:load_lua" -> "Fxn:T7Reader(f,";
    "Fxn:load_lua" -> "Fxn:reader.read()";
    "/torch/utils/serialization/__init__.py" -> "Import:load_lua,";
    "/torch/utils/trainer/trainer.py" -> "Import:heapq";
    "/torch/utils/trainer/trainer.py" -> "Import:Variable";
    "/torch/utils/trainer/trainer.py" -> "class:Trainer(object):";
    "class:Trainer(object):" -> "Fxn:__init__";
    "class:Trainer(object):" -> "Fxn:register_plugin";
    "class:Trainer(object):" -> "Fxn:call_plugins";
    "class:Trainer(object):" -> "Fxn:run";
    "class:Trainer(object):" -> "Fxn:train";
    "class:Trainer(object):" -> "Fxn:closure";
    "Fxn:register_plugin" -> "Fxn:plugin.register(self)";
    "Fxn:register_plugin" -> "Fxn:queue.append((duration,";
    "Fxn:call_plugins" -> "Fxn:queue_name)(*args)";
    "Fxn:call_plugins" -> "Fxn:heapq.heappushpop(queue,";
    "Fxn:run" -> "Fxn:self.plugin_queues.values():";
    "Fxn:run" -> "Fxn:heapq.heapify(q)";
    "Fxn:run" -> "Fxn:self.train()";
    "Fxn:run" -> "Fxn:self.call_plugins('epoch',";
    "Fxn:train" -> "Fxn:self.call_plugins('batch',";
    "Fxn:train" -> "Fxn:Variable(batch_input)";
    "Fxn:train" -> "Fxn:Variable(batch_target)";
    "Fxn:closure" -> "Fxn:self.model(input_var)";
    "Fxn:closure" -> "Fxn:self.criterion(batch_output,";
    "Fxn:closure" -> "Fxn:loss.backward()";
    "Fxn:closure" -> "Fxn:self.optimizer.zero_grad()";
    "Fxn:closure" -> "Fxn:self.optimizer.step(closure)";
    "Fxn:closure" -> "Fxn:self.call_plugins('iteration',";
    "Fxn:closure" -> "Fxn:self.call_plugins('update',";
    "/torch/utils/trainer/__init__.py" -> "Import:Trainer";
    "/torch/utils/trainer/plugins/accuracy.py" -> "Import:Monitor";
    "/torch/utils/trainer/plugins/accuracy.py" -> "class:AccuracyMonitor(Monitor):";
    "class:AccuracyMonitor(Monitor):" -> "Fxn:__init__";
    "class:AccuracyMonitor(Monitor):" -> "Fxn:_get_value";
    "Fxn:__init__" -> "Fxn:kwargs.setdefault('unit',";
    "Fxn:__init__" -> "Fxn:kwargs.setdefault('precision',";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:_get_value" -> "Fxn:input.size(0)";
    "Fxn:_get_value" -> "Fxn:output.max(1)[1].type_as(target)";
    "Fxn:_get_value" -> "Fxn:predictions.eq(target)";
    "Fxn:_get_value" -> "Fxn:correct.cpu()";
    "Fxn:_get_value" -> "Fxn:correct.sum()";
    "/torch/utils/trainer/plugins/logger.py" -> "Import:defaultdict";
    "/torch/utils/trainer/plugins/logger.py" -> "Import:Plugin";
    "/torch/utils/trainer/plugins/logger.py" -> "class:Logger(Plugin):";
    "class:Logger(Plugin):" -> "Fxn:__init__";
    "class:Logger(Plugin):" -> "Fxn:_join_results";
    "class:Logger(Plugin):" -> "Fxn:log";
    "class:Logger(Plugin):" -> "Fxn:register";
    "class:Logger(Plugin):" -> "Fxn:gather_stats";
    "class:Logger(Plugin):" -> "Fxn:_align_output";
    "class:Logger(Plugin):" -> "Fxn:_gather_outputs";
    "class:Logger(Plugin):" -> "Fxn:_log_all";
    "class:Logger(Plugin):" -> "Fxn:iteration";
    "class:Logger(Plugin):" -> "Fxn:epoch";
    "Fxn:__init__" -> "Fxn:[(1,";
    "Fxn:__init__" -> "Fxn:self).__init__(interval)";
    "Fxn:__init__" -> "Fxn:defaultdict(lambda:";
    "Fxn:__init__" -> "Fxn:defaultdict(int))";
    "Fxn:__init__" -> "Fxn:f.split('.'),";
    "Fxn:_join_results" -> "Fxn:'.join(i[1])),";
    "Fxn:_join_results" -> "Fxn:{}'.format(i[0],";
    "Fxn:_join_results" -> "Fxn:'\t'.join(joined_fields)";
    "Fxn:_gather_outputs" -> "Fxn:stat.get(log_fields,";
    "Fxn:_gather_outputs" -> "Fxn:stat.get('log_name',";
    "Fxn:_gather_outputs" -> "Fxn:'.'.join(field))";
    "Fxn:_gather_outputs" -> "Fxn:output.append(f.format(**stat))";
    "Fxn:_gather_outputs" -> "Fxn:'.'.join(field)";
    "Fxn:_gather_outputs" -> "Fxn:stat_parent.get('log_format',";
    "Fxn:_gather_outputs" -> "Fxn:stat_parent.get('log_unit',";
    "Fxn:_gather_outputs" -> "Fxn:output.append(fmt.format(stat))";
    "Fxn:_log_all" -> "Fxn:self._gather_outputs(field,";
    "Fxn:_log_all" -> "Fxn:self._align_output(field_idx,";
    "Fxn:_log_all" -> "Fxn:results.append((name,";
    "Fxn:_log_all" -> "Fxn:self._join_results(results)";
    "Fxn:_log_all" -> "Fxn:self.log(prefix)";
    "Fxn:_log_all" -> "Fxn:self.log(output)";
    "Fxn:_log_all" -> "Fxn:self.log(suffix)";
    "Fxn:iteration" -> "Fxn:self._log_all('log_iter_fields')";
    "Fxn:epoch" -> "Fxn:self._log_all('log_epoch_fields',";
    "/torch/utils/trainer/plugins/loss.py" -> "Import:Monitor";
    "/torch/utils/trainer/plugins/loss.py" -> "class:LossMonitor(Monitor):";
    "class:LossMonitor(Monitor):" -> "Fxn:_get_value";
    "/torch/utils/trainer/plugins/monitor.py" -> "Import:Plugin";
    "/torch/utils/trainer/plugins/monitor.py" -> "class:Monitor(Plugin):";
    "class:Monitor(Plugin):" -> "Fxn:__init__";
    "class:Monitor(Plugin):" -> "Fxn:register";
    "class:Monitor(Plugin):" -> "Fxn:iteration";
    "class:Monitor(Plugin):" -> "Fxn:epoch";
    "Fxn:__init__" -> "Fxn:'.{}f'.format(precision)";
    "Fxn:__init__" -> "Fxn:self).__init__([(1,";
    "Fxn:register" -> "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:iteration" -> "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:iteration" -> "Fxn:self._get_value(*args)";
    "Fxn:iteration" -> "Fxn:stats.get('running_avg',";
    "Fxn:epoch" -> "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "/torch/utils/trainer/plugins/plugin.py" -> "class:Plugin(object):";
    "class:Plugin(object):" -> "Fxn:__init__";
    "class:Plugin(object):" -> "Fxn:register";
    "/torch/utils/trainer/plugins/progress.py" -> "Import:Plugin";
    "/torch/utils/trainer/plugins/progress.py" -> "class:ProgressMonitor(Plugin):";
    "class:ProgressMonitor(Plugin):" -> "Fxn:__init__";
    "class:ProgressMonitor(Plugin):" -> "Fxn:register";
    "class:ProgressMonitor(Plugin):" -> "Fxn:iteration";
    "class:ProgressMonitor(Plugin):" -> "Fxn:epoch";
    "Fxn:__init__" -> "Fxn:self).__init__([(1,";
    "Fxn:register" -> "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:register" -> "Fxn:'({percent:.2f}%)'";
    "Fxn:iteration" -> "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "Fxn:epoch" -> "Fxn:self.trainer.stats.setdefault(self.stat_name,";
    "/torch/utils/trainer/plugins/time.py" -> "Import:absolute_import";
    "/torch/utils/trainer/plugins/time.py" -> "Import:time";
    "/torch/utils/trainer/plugins/time.py" -> "Import:Monitor";
    "/torch/utils/trainer/plugins/time.py" -> "class:TimeMonitor(Monitor):";
    "class:TimeMonitor(Monitor):" -> "Fxn:__init__";
    "class:TimeMonitor(Monitor):" -> "Fxn:_get_value";
    "Fxn:__init__" -> "Fxn:kwargs.setdefault('unit',";
    "Fxn:__init__" -> "Fxn:kwargs.setdefault('precision',";
    "Fxn:__init__" -> "Fxn:self).__init__(*args,";
    "Fxn:_get_value" -> "Fxn:time.time()";
    "Fxn:_get_value" -> "Fxn:time.time()";
    "/torch/utils/trainer/plugins/__init__.py" -> "Import:ProgressMonitor";
    "/torch/utils/trainer/plugins/__init__.py" -> "Import:AccuracyMonitor";
    "/torch/utils/trainer/plugins/__init__.py" -> "Import:TimeMonitor";
    "/torch/utils/trainer/plugins/__init__.py" -> "Import:LossMonitor";
    "/torch/utils/trainer/plugins/__init__.py" -> "Import:Logger";
    "/torch/_thnn/utils.py" -> "Import:import";
    "/torch/_thnn/utils.py" -> "Import:itertools";
    "/torch/_thnn/utils.py" -> "Import:importlib";
    "/torch/_thnn/utils.py" -> "Fxn:_unpickle_backend";
    "/torch/_thnn/utils.py" -> "Import:torch._thnn";
    "/torch/_thnn/utils.py" -> "class:THNNBackendBase(object):";
    "/torch/_thnn/utils.py" -> "class:Function(object):";
    "/torch/_thnn/utils.py" -> "class:Argument(object):";
    "class:THNNBackendBase(object):" -> "Fxn:__init__";
    "class:THNNBackendBase(object):" -> "Fxn:__getattr__";
    "class:THNNBackendBase(object):" -> "Fxn:register_method";
    "class:THNNBackendBase(object):" -> "Fxn:library_state";
    "class:THNNBackendBase(object):" -> "Fxn:__reduce__";
    "Fxn:__getattr__" -> "Fxn:self.methods.get(name,";
    "class:Function(object):" -> "Fxn:__init__";
    "class:Function(object):" -> "Fxn:add_argument";
    "class:Function(object):" -> "Fxn:__repr__";
    "Fxn:add_argument" -> "Fxn:self.arguments.append(arg)";
    "Fxn:__repr__" -> "Fxn:'('";
    "Fxn:__repr__" -> "Fxn:'.join(map(lambda";
    "Fxn:__repr__" -> "Fxn:a.__repr__(),";
    "class:Argument(object):" -> "Fxn:__init__";
    "class:Argument(object):" -> "Fxn:__repr__";
    "class:Argument(object):" -> "Fxn:parse_header";
    "class:Argument(object):" -> "Fxn:load_backend";
    "Fxn:parse_header" -> "Fxn:f.read().split('\n')";
    "Fxn:parse_header" -> "Fxn:l.startswith('#'),";
    "Fxn:parse_header" -> "Fxn:l.partition('//'),";
    "Fxn:parse_header" -> "Fxn:l[2].strip()),";
    "Fxn:parse_header" -> "Fxn:new_lines.append((split,";
    "Fxn:parse_header" -> "Fxn:l.startswith('TH_API";
    "Fxn:parse_header" -> "Fxn:l.lstrip('TH_API";
    "Fxn:parse_header" -> "Fxn:'('";
    "Fxn:parse_header" -> "Fxn:generic_functions.append(Function(fn_name))";
    "Fxn:parse_header" -> "Fxn:l.split()";
    "Fxn:parse_header" -> "Fxn:generic_functions[-1].add_argument(Argument(t,";
    "Fxn:load_backend" -> "Fxn:mixins=tuple()):";
    "Fxn:load_backend" -> "Fxn:'THNN{}Backend'.format(t)";
    "Fxn:load_backend" -> "Fxn:{})()";
    "Fxn:load_backend" -> "Fxn:'{}{}'.format(t,";
    "Fxn:load_backend" -> "Fxn:backend.register_method(function.name,";
    "/torch/_thnn/__init__.py" -> "Import:threading";
    "/torch/_thnn/__init__.py" -> "Import:torch.cuda";
    "/torch/_thnn/__init__.py" -> "Import:THNN_H_PATH,";
    "/torch/_thnn/__init__.py" -> "class:Backends(object):";
    "/torch/_thnn/__init__.py" -> "class:Backend(object):";
    "/torch/_thnn/__init__.py" -> "class:THNNCudaBackendStateMixin(object):";
    "class:Backends(object):" -> "Fxn:__init__";
    "class:Backends(object):" -> "Fxn:__getattr__";
    "class:Backends(object):" -> "Fxn:__getitem__";
    "Fxn:__getattr__" -> "Fxn:self.backends[name].load()";
    "Fxn:__getitem__" -> "Fxn:self.backends[name].load()";
    "class:Backend(object):" -> "Fxn:__init__";
    "class:Backend(object):" -> "Fxn:load";
    "Fxn:__init__" -> "Fxn:mixins=tuple()):";
    "Fxn:__init__" -> "Fxn:threading.Lock()";
    "Fxn:load" -> "Fxn:load_backend(self.lib_prefix,";
    "class:THNNCudaBackendStateMixin(object):" -> "Fxn:library_state";
    "Fxn:library_state" -> "Fxn:Backends()";
    "Fxn:library_state" -> "Fxn:parse_header(THNN_H_PATH)";
    "Fxn:library_state" -> "Fxn:parse_header(THCUNN_H_PATH)";
    "Fxn:library_state" -> "Fxn:Backend(t,";
    "Fxn:library_state" -> "Fxn:type2backend.backends['THNN{}Backend'.format(t)]";
    "Fxn:library_state" -> "Fxn:type2backend.backends['torch.{}Tensor'.format(t)]";
    "Fxn:library_state" -> "Fxn:type2backend.backends[getattr(torch,";
    "Fxn:library_state" -> "Fxn:'{}Tensor'.format(t))]";
    "Fxn:library_state" -> "Fxn:Backend('Cuda'";
    "Fxn:library_state" -> "Fxn:type2backend.backends['THNNCuda{}Backend'.format(t)]";
    "Fxn:library_state" -> "Fxn:type2backend.backends['torch.cuda.{}Tensor'.format(py_name)]";
    "Fxn:library_state" -> "Fxn:type2backend.backends[getattr(torch.cuda,";
    "Fxn:library_state" -> "Fxn:'{}Tensor'.format(py_name))]";
}
