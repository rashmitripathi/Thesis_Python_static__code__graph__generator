strict digraph "" {
__call__;
set_weights;
build;
reset_states;
compute_output_shape;
call;
run_internal_graph;
add_update;
_object_list_uid;
_to_list;
add_loss;
fit;
function;
ValueError;
_merge_function;
get_initial_state;
"axis=";
Input;
"K.floatx";
"K.sum";
"K.name_scope";
add_weight;
has_arg;
get_updates_for;
get_losses_for;
_fix_unknown_dimension;
_compute_elemwise_op_output_shape;
"np.zeros";
"K.epsilon";
predict_generator;
predict_on_batch;
__init__;
_generate_dropout_ones;
"K.backend";
"','.join";
recurrent_conv;
"strides=";
"K.image_data_format";
"K.sqrt";
"K.cast";
"K.abs";
TypeError;
"K.int_shape";
"keras.Input";
"model.compile";
get_layer;
compile;
"warnings.warn";
"model.fit";
predict;
count_params;
"K.zeros";
step;
Model;
"K.dtype";
"conv_utils.conv_output_length";
compute_mask;
"input_shapes.append";
"copy.copy";
"np.prod";
conv1d;
conv2d;
_preprocess_conv2d_input;
_has_nchw_support;
_is_current_explicit_device;
__call__ -> set_weights;
__call__ -> build;
__call__ -> compute_output_shape;
__call__ -> call;
__call__ -> compute_mask;
set_weights -> build;
set_weights -> ValueError;
build -> reset_states;
build -> add_weight;
build -> _compute_elemwise_op_output_shape;
build -> set_weights;
build -> ValueError;
build -> "np.zeros";
reset_states -> compute_output_shape;
reset_states -> ValueError;
reset_states -> "np.zeros";
compute_output_shape -> call;
compute_output_shape -> _fix_unknown_dimension;
compute_output_shape -> _compute_elemwise_op_output_shape;
compute_output_shape -> Input;
compute_output_shape -> ValueError;
compute_output_shape -> "warnings.warn";
compute_output_shape -> "model.fit";
compute_output_shape -> "K.sqrt";
compute_output_shape -> _to_list;
compute_output_shape -> "input_shapes.append";
compute_output_shape -> "copy.copy";
compute_output_shape -> "K.int_shape";
compute_output_shape -> "model.compile";
compute_output_shape -> "conv_utils.conv_output_length";
call -> run_internal_graph;
call -> add_update;
call -> function;
call -> _merge_function;
call -> get_initial_state;
call -> Input;
call -> build;
call -> ValueError;
call -> "np.zeros";
call -> "K.epsilon";
call -> _generate_dropout_ones;
call -> recurrent_conv;
call -> "K.sqrt";
call -> "K.cast";
call -> "K.floatx";
call -> "K.sum";
call -> "K.abs";
call -> TypeError;
call -> _to_list;
call -> has_arg;
call -> "K.int_shape";
call -> "keras.Input";
call -> "model.compile";
call -> "K.backend";
call -> "K.dtype";
call -> "','.join";
run_internal_graph -> add_update;
run_internal_graph -> add_loss;
run_internal_graph -> "K.name_scope";
run_internal_graph -> _to_list;
run_internal_graph -> has_arg;
run_internal_graph -> "','.join";
add_update -> _object_list_uid;
add_update -> _to_list;
_object_list_uid -> _to_list;
add_loss -> _object_list_uid;
add_loss -> _to_list;
fit -> __call__;
function -> ValueError;
function -> has_arg;
_merge_function -> ValueError;
get_initial_state -> "axis=";
get_initial_state -> "K.sum";
get_initial_state -> "K.image_data_format";
get_initial_state -> "K.zeros";
get_initial_state -> "conv_utils.conv_output_length";
get_initial_state -> call;
Input -> "K.floatx";
Input -> Model;
add_weight -> add_loss;
add_weight -> "K.floatx";
get_updates_for -> build;
get_losses_for -> build;
_fix_unknown_dimension -> ValueError;
_fix_unknown_dimension -> "np.prod";
_compute_elemwise_op_output_shape -> ValueError;
predict_generator -> predict_on_batch;
predict_generator -> build;
predict_on_batch -> build;
__init__ -> build;
_generate_dropout_ones -> "K.backend";
recurrent_conv -> "strides=";
get_layer -> build;
compile -> build;
predict -> build;
count_params -> build;
step -> compute_output_shape;
compute_mask -> run_internal_graph;
conv1d -> conv2d;
conv2d -> _preprocess_conv2d_input;
_preprocess_conv2d_input -> _has_nchw_support;
_has_nchw_support -> _is_current_explicit_device;
_is_current_explicit_device -> ValueError;
}
